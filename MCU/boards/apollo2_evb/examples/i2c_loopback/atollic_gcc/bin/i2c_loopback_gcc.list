
C:\jenkins\jobs\ambiqsuite-checkout\workspace\ambiqsuite-sdk\boards\apollo2_evb\examples\i2c_loopback\atollic_gcc\bin\i2c_loopback_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000054f8  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00030000  2**2
                  ALLOC
  2 .data         00000094  10001000  000054f8  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000680  10001094  0000558c  00021094  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00021094  2**0
                  CONTENTS, READONLY
  5 .debug_info   0000f765  00000000  00000000  000210cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000241d  00000000  00000000  00030830  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000b20  00000000  00000000  00032c4d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 00001f50  00000000  00000000  0003376d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000067e5  00000000  00000000  000356bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003d9c  00000000  00000000  0003bea2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007e  00000000  00000000  0003fc3e  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00002274  00000000  00000000  0003fcbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00011888  00000000  00000000  00041f30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <g_am_pfnVectors>:
       0:	00 10 00 10 29 05 00 00 91 05 00 00 99 05 00 00     ....)...........
      10:	99 05 00 00 99 05 00 00 99 05 00 00 00 00 00 00     ................
	...
      2c:	a1 05 00 00 a1 05 00 00 00 00 00 00 a1 05 00 00     ................
      3c:	a1 05 00 00 a1 05 00 00 a1 05 00 00 a1 05 00 00     ................
      4c:	a1 05 00 00 a1 05 00 00 a1 05 00 00 61 01 00 00     ............a...
      5c:	a1 05 00 00 a1 05 00 00 a1 05 00 00 a1 05 00 00     ................
      6c:	a1 05 00 00 a1 05 00 00 a1 05 00 00 a1 05 00 00     ................
      7c:	a1 05 00 00 a1 05 00 00 a1 05 00 00 a1 05 00 00     ................
      8c:	a1 05 00 00 a1 05 00 00 a1 05 00 00 a1 05 00 00     ................
      9c:	a1 05 00 00 a1 05 00 00 a1 05 00 00 a1 05 00 00     ................
      ac:	a1 05 00 00 a1 05 00 00 a1 05 00 00 a1 05 00 00     ................
      bc:	a1 05 00 00                                         ....

000000c0 <__aeabi_d2f>:
      c0:	ea4f 0241 	mov.w	r2, r1, lsl #1
      c4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
      c8:	bf24      	itt	cs
      ca:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
      ce:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
      d2:	d90d      	bls.n	f0 <__aeabi_d2f+0x30>
      d4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
      d8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
      dc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
      e0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
      e4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
      e8:	bf08      	it	eq
      ea:	f020 0001 	biceq.w	r0, r0, #1
      ee:	4770      	bx	lr
      f0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
      f4:	d121      	bne.n	13a <__aeabi_d2f+0x7a>
      f6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
      fa:	bfbc      	itt	lt
      fc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
     100:	4770      	bxlt	lr
     102:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     106:	ea4f 5252 	mov.w	r2, r2, lsr #21
     10a:	f1c2 0218 	rsb	r2, r2, #24
     10e:	f1c2 0c20 	rsb	ip, r2, #32
     112:	fa10 f30c 	lsls.w	r3, r0, ip
     116:	fa20 f002 	lsr.w	r0, r0, r2
     11a:	bf18      	it	ne
     11c:	f040 0001 	orrne.w	r0, r0, #1
     120:	ea4f 23c1 	mov.w	r3, r1, lsl #11
     124:	ea4f 23d3 	mov.w	r3, r3, lsr #11
     128:	fa03 fc0c 	lsl.w	ip, r3, ip
     12c:	ea40 000c 	orr.w	r0, r0, ip
     130:	fa23 f302 	lsr.w	r3, r3, r2
     134:	ea4f 0343 	mov.w	r3, r3, lsl #1
     138:	e7cc      	b.n	d4 <__aeabi_d2f+0x14>
     13a:	ea7f 5362 	mvns.w	r3, r2, asr #21
     13e:	d107      	bne.n	150 <__aeabi_d2f+0x90>
     140:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
     144:	bf1e      	ittt	ne
     146:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
     14a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
     14e:	4770      	bxne	lr
     150:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
     154:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     158:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     15c:	4770      	bx	lr
     15e:	bf00      	nop

00000160 <am_iomaster0_isr>:
//
//! Take over default ISR for IOM 0. (Queue mode service)
//
void
am_iomaster0_isr(void)
{
     160:	b580      	push	{r7, lr}
     162:	b082      	sub	sp, #8
     164:	af00      	add	r7, sp, #0
    uint32_t ui32Status;

    ui32Status = am_hal_iom_int_status_get(IOM_MODULE, true);
     166:	2101      	movs	r1, #1
     168:	2000      	movs	r0, #0
     16a:	f003 fb49 	bl	3800 <am_hal_iom_int_status_get>
     16e:	6078      	str	r0, [r7, #4]

    am_hal_iom_int_clear(IOM_MODULE, ui32Status);
     170:	6879      	ldr	r1, [r7, #4]
     172:	2000      	movs	r0, #0
     174:	f003 fb3a 	bl	37ec <am_hal_iom_int_clear>

    am_hal_iom_queue_service(IOM_MODULE, ui32Status);
     178:	6879      	ldr	r1, [r7, #4]
     17a:	2000      	movs	r0, #0
     17c:	f003 f816 	bl	31ac <am_hal_iom_queue_service>
}
     180:	bf00      	nop
     182:	3708      	adds	r7, #8
     184:	46bd      	mov	sp, r7
     186:	bd80      	pop	{r7, pc}

00000188 <itm_start>:
// Start up the ITM interface.
//
//*****************************************************************************
void
itm_start(void)
{
     188:	b580      	push	{r7, lr}
     18a:	b082      	sub	sp, #8
     18c:	af00      	add	r7, sp, #0
    //
    // Initialize the printf interface for ITM/SWO output.
    //
    am_util_stdio_printf_init((am_util_stdio_print_char_t) am_bsp_itm_string_print);
     18e:	4817      	ldr	r0, [pc, #92]	; (1ec <itm_start+0x64>)
     190:	f000 fa22 	bl	5d8 <am_util_stdio_printf_init>

    //
    // Initialize the SWO GPIO pin
    //
    am_bsp_pin_enable(ITM_SWO);
     194:	f3ef 8310 	mrs	r3, PRIMASK
     198:	607b      	str	r3, [r7, #4]
     19a:	b672      	cpsid	i
     19c:	4b14      	ldr	r3, [pc, #80]	; (1f0 <itm_start+0x68>)
     19e:	2273      	movs	r2, #115	; 0x73
     1a0:	601a      	str	r2, [r3, #0]
     1a2:	4a14      	ldr	r2, [pc, #80]	; (1f4 <itm_start+0x6c>)
     1a4:	4b13      	ldr	r3, [pc, #76]	; (1f4 <itm_start+0x6c>)
     1a6:	681b      	ldr	r3, [r3, #0]
     1a8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
     1ac:	6013      	str	r3, [r2, #0]
     1ae:	4a12      	ldr	r2, [pc, #72]	; (1f8 <itm_start+0x70>)
     1b0:	4b11      	ldr	r3, [pc, #68]	; (1f8 <itm_start+0x70>)
     1b2:	681b      	ldr	r3, [r3, #0]
     1b4:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     1b8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     1bc:	6013      	str	r3, [r2, #0]
     1be:	4a0f      	ldr	r2, [pc, #60]	; (1fc <itm_start+0x74>)
     1c0:	4b0e      	ldr	r3, [pc, #56]	; (1fc <itm_start+0x74>)
     1c2:	681b      	ldr	r3, [r3, #0]
     1c4:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     1c8:	6013      	str	r3, [r2, #0]
     1ca:	4b09      	ldr	r3, [pc, #36]	; (1f0 <itm_start+0x68>)
     1cc:	2200      	movs	r2, #0
     1ce:	601a      	str	r2, [r3, #0]
     1d0:	687b      	ldr	r3, [r7, #4]
     1d2:	f383 8810 	msr	PRIMASK, r3

    //
    // Enable the ITM.
    //
    am_hal_itm_enable();
     1d6:	f003 fb89 	bl	38ec <am_hal_itm_enable>

    //
    // Enable debug printf messages using ITM on SWO pin
    //
    am_bsp_debug_printf_enable();
     1da:	f001 f90d 	bl	13f8 <am_bsp_debug_printf_enable>

    //
    // Clear the terminal.
    //
    am_util_stdio_terminal_clear();
     1de:	f001 f88b 	bl	12f8 <am_util_stdio_terminal_clear>
}
     1e2:	bf00      	nop
     1e4:	3708      	adds	r7, #8
     1e6:	46bd      	mov	sp, r7
     1e8:	bd80      	pop	{r7, pc}
     1ea:	bf00      	nop
     1ec:	00001479 	.word	0x00001479
     1f0:	40010060 	.word	0x40010060
     1f4:	40010054 	.word	0x40010054
     1f8:	40010028 	.word	0x40010028
     1fc:	40010108 	.word	0x40010108

00000200 <ios_set_up>:
// Configure the IOS as I2C slave.
//
//*****************************************************************************
static void
ios_set_up(void)
{
     200:	b580      	push	{r7, lr}
     202:	b084      	sub	sp, #16
     204:	af00      	add	r7, sp, #0
  // Configure I2C interface
    am_hal_gpio_pin_config(0, AM_HAL_PIN_0_SLSCL);
     206:	f3ef 8310 	mrs	r3, PRIMASK
     20a:	60fb      	str	r3, [r7, #12]
     20c:	b672      	cpsid	i
     20e:	4b3b      	ldr	r3, [pc, #236]	; (2fc <ios_set_up+0xfc>)
     210:	2273      	movs	r2, #115	; 0x73
     212:	601a      	str	r2, [r3, #0]
     214:	4a3a      	ldr	r2, [pc, #232]	; (300 <ios_set_up+0x100>)
     216:	4b3a      	ldr	r3, [pc, #232]	; (300 <ios_set_up+0x100>)
     218:	681b      	ldr	r3, [r3, #0]
     21a:	f023 0307 	bic.w	r3, r3, #7
     21e:	6013      	str	r3, [r2, #0]
     220:	4a38      	ldr	r2, [pc, #224]	; (304 <ios_set_up+0x104>)
     222:	4b38      	ldr	r3, [pc, #224]	; (304 <ios_set_up+0x104>)
     224:	681b      	ldr	r3, [r3, #0]
     226:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     22a:	f043 0302 	orr.w	r3, r3, #2
     22e:	6013      	str	r3, [r2, #0]
     230:	4a35      	ldr	r2, [pc, #212]	; (308 <ios_set_up+0x108>)
     232:	4b35      	ldr	r3, [pc, #212]	; (308 <ios_set_up+0x108>)
     234:	681b      	ldr	r3, [r3, #0]
     236:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     23a:	6013      	str	r3, [r2, #0]
     23c:	4b2f      	ldr	r3, [pc, #188]	; (2fc <ios_set_up+0xfc>)
     23e:	2200      	movs	r2, #0
     240:	601a      	str	r2, [r3, #0]
     242:	68fb      	ldr	r3, [r7, #12]
     244:	f383 8810 	msr	PRIMASK, r3
    am_hal_gpio_pin_config(1, AM_HAL_PIN_1_SLSDA);
     248:	f3ef 8310 	mrs	r3, PRIMASK
     24c:	60bb      	str	r3, [r7, #8]
     24e:	b672      	cpsid	i
     250:	4b2a      	ldr	r3, [pc, #168]	; (2fc <ios_set_up+0xfc>)
     252:	2273      	movs	r2, #115	; 0x73
     254:	601a      	str	r2, [r3, #0]
     256:	4a2a      	ldr	r2, [pc, #168]	; (300 <ios_set_up+0x100>)
     258:	4b29      	ldr	r3, [pc, #164]	; (300 <ios_set_up+0x100>)
     25a:	681b      	ldr	r3, [r3, #0]
     25c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
     260:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     264:	6013      	str	r3, [r2, #0]
     266:	4a27      	ldr	r2, [pc, #156]	; (304 <ios_set_up+0x104>)
     268:	4b26      	ldr	r3, [pc, #152]	; (304 <ios_set_up+0x104>)
     26a:	681b      	ldr	r3, [r3, #0]
     26c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     270:	f443 7300 	orr.w	r3, r3, #512	; 0x200
     274:	6013      	str	r3, [r2, #0]
     276:	4a24      	ldr	r2, [pc, #144]	; (308 <ios_set_up+0x108>)
     278:	4b23      	ldr	r3, [pc, #140]	; (308 <ios_set_up+0x108>)
     27a:	681b      	ldr	r3, [r3, #0]
     27c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     280:	6013      	str	r3, [r2, #0]
     282:	4b1e      	ldr	r3, [pc, #120]	; (2fc <ios_set_up+0xfc>)
     284:	2200      	movs	r2, #0
     286:	601a      	str	r2, [r3, #0]
     288:	68bb      	ldr	r3, [r7, #8]
     28a:	f383 8810 	msr	PRIMASK, r3

    //
    // Configure the IOS interface and LRAM structure.
    //
    am_hal_ios_config(&g_sIOSI2cConfig);
     28e:	481f      	ldr	r0, [pc, #124]	; (30c <ios_set_up+0x10c>)
     290:	f003 faca 	bl	3828 <am_hal_ios_config>

    //
    // Clear out any IOS register-access interrupts that may be active, and
    // enable interrupts for the registers we're interested in.
    //
    am_hal_ios_access_int_clear(AM_HAL_IOS_ACCESS_INT_ALL);
     294:	f04f 30ff 	mov.w	r0, #4294967295
     298:	f003 fb18 	bl	38cc <am_hal_ios_access_int_clear>
    am_hal_ios_int_clear(AM_HAL_IOS_INT_ALL);
     29c:	f04f 30ff 	mov.w	r0, #4294967295
     2a0:	f003 fb1a 	bl	38d8 <am_hal_ios_int_clear>

    //
    // Set the bit in the NVIC to accept access interrupts from the IO Slave.
    //
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_IOSACC);
     2a4:	2015      	movs	r0, #21
     2a6:	f001 fa7b 	bl	17a0 <am_hal_interrupt_enable>
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_IOSLAVE);
     2aa:	2014      	movs	r0, #20
     2ac:	f001 fa78 	bl	17a0 <am_hal_interrupt_enable>

    // Set up the IOSINT interrupt pin
    am_hal_gpio_pin_config(4, AM_HAL_PIN_4_SLINT);
     2b0:	f3ef 8310 	mrs	r3, PRIMASK
     2b4:	607b      	str	r3, [r7, #4]
     2b6:	b672      	cpsid	i
     2b8:	4b10      	ldr	r3, [pc, #64]	; (2fc <ios_set_up+0xfc>)
     2ba:	2273      	movs	r2, #115	; 0x73
     2bc:	601a      	str	r2, [r3, #0]
     2be:	4a10      	ldr	r2, [pc, #64]	; (300 <ios_set_up+0x100>)
     2c0:	4b0f      	ldr	r3, [pc, #60]	; (300 <ios_set_up+0x100>)
     2c2:	681b      	ldr	r3, [r3, #0]
     2c4:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
     2c8:	6013      	str	r3, [r2, #0]
     2ca:	4a11      	ldr	r2, [pc, #68]	; (310 <ios_set_up+0x110>)
     2cc:	4b10      	ldr	r3, [pc, #64]	; (310 <ios_set_up+0x110>)
     2ce:	681b      	ldr	r3, [r3, #0]
     2d0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     2d4:	f043 0308 	orr.w	r3, r3, #8
     2d8:	6013      	str	r3, [r2, #0]
     2da:	4a0e      	ldr	r2, [pc, #56]	; (314 <ios_set_up+0x114>)
     2dc:	4b0d      	ldr	r3, [pc, #52]	; (314 <ios_set_up+0x114>)
     2de:	681b      	ldr	r3, [r3, #0]
     2e0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     2e4:	6013      	str	r3, [r2, #0]
     2e6:	4b05      	ldr	r3, [pc, #20]	; (2fc <ios_set_up+0xfc>)
     2e8:	2200      	movs	r2, #0
     2ea:	601a      	str	r2, [r3, #0]
     2ec:	687b      	ldr	r3, [r7, #4]
     2ee:	f383 8810 	msr	PRIMASK, r3
}
     2f2:	bf00      	nop
     2f4:	3710      	adds	r7, #16
     2f6:	46bd      	mov	sp, r7
     2f8:	bd80      	pop	{r7, pc}
     2fa:	bf00      	nop
     2fc:	40010060 	.word	0x40010060
     300:	40010040 	.word	0x40010040
     304:	40010000 	.word	0x40010000
     308:	400100e0 	.word	0x400100e0
     30c:	10001010 	.word	0x10001010
     310:	40010004 	.word	0x40010004
     314:	400100e4 	.word	0x400100e4

00000318 <iom_set_up>:
// Configure the IOM as I2C master.
//
//*****************************************************************************
static void
iom_set_up(void)
{
     318:	b580      	push	{r7, lr}
     31a:	b082      	sub	sp, #8
     31c:	af00      	add	r7, sp, #0
    //
    // Enable power to IOM.
    //
    am_hal_iom_pwrctrl_enable(IOM_MODULE);
     31e:	2000      	movs	r0, #0
     320:	f001 fc9e 	bl	1c60 <am_hal_iom_pwrctrl_enable>

    //
    // Set the required configuration settings for the IOM.
    //
    am_hal_iom_config(IOM_MODULE, &g_sIOMI2cConfig);
     324:	492e      	ldr	r1, [pc, #184]	; (3e0 <iom_set_up+0xc8>)
     326:	2000      	movs	r0, #0
     328:	f001 fcc4 	bl	1cb4 <am_hal_iom_config>

    //
    // Set pins high to prevent bus dips.
    //
    am_hal_gpio_out_bit_set(5);
     32c:	4b2d      	ldr	r3, [pc, #180]	; (3e4 <iom_set_up+0xcc>)
     32e:	2220      	movs	r2, #32
     330:	601a      	str	r2, [r3, #0]
    am_hal_gpio_out_bit_set(6);
     332:	4b2c      	ldr	r3, [pc, #176]	; (3e4 <iom_set_up+0xcc>)
     334:	2240      	movs	r2, #64	; 0x40
     336:	601a      	str	r2, [r3, #0]
#ifdef INTERNAL_LOOPBACK
    am_hal_gpio_pin_config(5, AM_HAL_PIN_5_M0SCLLB | AM_HAL_GPIO_PULLUP);
    am_hal_gpio_pin_config(6, AM_HAL_PIN_6_SLSDALB | AM_HAL_GPIO_PULLUP);
    AM_REG(GPIO, LOOPBACK) = IOM_MODULE;
#else
    am_hal_gpio_pin_config(5, AM_HAL_PIN_5_M0SCL | AM_HAL_GPIO_PULLUP);
     338:	f3ef 8310 	mrs	r3, PRIMASK
     33c:	607b      	str	r3, [r7, #4]
     33e:	b672      	cpsid	i
     340:	4b29      	ldr	r3, [pc, #164]	; (3e8 <iom_set_up+0xd0>)
     342:	2273      	movs	r2, #115	; 0x73
     344:	601a      	str	r2, [r3, #0]
     346:	4a29      	ldr	r2, [pc, #164]	; (3ec <iom_set_up+0xd4>)
     348:	4b28      	ldr	r3, [pc, #160]	; (3ec <iom_set_up+0xd4>)
     34a:	681b      	ldr	r3, [r3, #0]
     34c:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
     350:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
     354:	6013      	str	r3, [r2, #0]
     356:	4a26      	ldr	r2, [pc, #152]	; (3f0 <iom_set_up+0xd8>)
     358:	4b25      	ldr	r3, [pc, #148]	; (3f0 <iom_set_up+0xd8>)
     35a:	681b      	ldr	r3, [r3, #0]
     35c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     360:	f443 7340 	orr.w	r3, r3, #768	; 0x300
     364:	6013      	str	r3, [r2, #0]
     366:	4a23      	ldr	r2, [pc, #140]	; (3f4 <iom_set_up+0xdc>)
     368:	4b22      	ldr	r3, [pc, #136]	; (3f4 <iom_set_up+0xdc>)
     36a:	681b      	ldr	r3, [r3, #0]
     36c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     370:	6013      	str	r3, [r2, #0]
     372:	4b1d      	ldr	r3, [pc, #116]	; (3e8 <iom_set_up+0xd0>)
     374:	2200      	movs	r2, #0
     376:	601a      	str	r2, [r3, #0]
     378:	687b      	ldr	r3, [r7, #4]
     37a:	f383 8810 	msr	PRIMASK, r3
    am_hal_gpio_pin_config(6, AM_HAL_PIN_6_M0SDA | AM_HAL_GPIO_PULLUP);
     37e:	f3ef 8310 	mrs	r3, PRIMASK
     382:	603b      	str	r3, [r7, #0]
     384:	b672      	cpsid	i
     386:	4b18      	ldr	r3, [pc, #96]	; (3e8 <iom_set_up+0xd0>)
     388:	2273      	movs	r2, #115	; 0x73
     38a:	601a      	str	r2, [r3, #0]
     38c:	4a17      	ldr	r2, [pc, #92]	; (3ec <iom_set_up+0xd4>)
     38e:	4b17      	ldr	r3, [pc, #92]	; (3ec <iom_set_up+0xd4>)
     390:	681b      	ldr	r3, [r3, #0]
     392:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
     396:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
     39a:	6013      	str	r3, [r2, #0]
     39c:	4a14      	ldr	r2, [pc, #80]	; (3f0 <iom_set_up+0xd8>)
     39e:	4b14      	ldr	r3, [pc, #80]	; (3f0 <iom_set_up+0xd8>)
     3a0:	681b      	ldr	r3, [r3, #0]
     3a2:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     3a6:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
     3aa:	6013      	str	r3, [r2, #0]
     3ac:	4a11      	ldr	r2, [pc, #68]	; (3f4 <iom_set_up+0xdc>)
     3ae:	4b11      	ldr	r3, [pc, #68]	; (3f4 <iom_set_up+0xdc>)
     3b0:	681b      	ldr	r3, [r3, #0]
     3b2:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     3b6:	6013      	str	r3, [r2, #0]
     3b8:	4b0b      	ldr	r3, [pc, #44]	; (3e8 <iom_set_up+0xd0>)
     3ba:	2200      	movs	r2, #0
     3bc:	601a      	str	r2, [r3, #0]
     3be:	683b      	ldr	r3, [r7, #0]
     3c0:	f383 8810 	msr	PRIMASK, r3
#endif

    am_hal_iom_int_enable(IOM_MODULE, 0xFF);
     3c4:	21ff      	movs	r1, #255	; 0xff
     3c6:	2000      	movs	r0, #0
     3c8:	f003 fa04 	bl	37d4 <am_hal_iom_int_enable>
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_IOMASTER0);
     3cc:	2016      	movs	r0, #22
     3ce:	f001 f9e7 	bl	17a0 <am_hal_interrupt_enable>

    //
    // Turn on the IOM for this operation.
    //
    am_bsp_iom_enable(IOM_MODULE);
     3d2:	2000      	movs	r0, #0
     3d4:	f000 ff9a 	bl	130c <am_bsp_iom_enable>
}
     3d8:	bf00      	nop
     3da:	3708      	adds	r7, #8
     3dc:	46bd      	mov	sp, r7
     3de:	bd80      	pop	{r7, pc}
     3e0:	10001028 	.word	0x10001028
     3e4:	40010090 	.word	0x40010090
     3e8:	40010060 	.word	0x40010060
     3ec:	40010040 	.word	0x40010040
     3f0:	40010004 	.word	0x40010004
     3f4:	400100e4 	.word	0x400100e4

000003f8 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
     3f8:	b590      	push	{r4, r7, lr}
     3fa:	b087      	sub	sp, #28
     3fc:	af02      	add	r7, sp, #8
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
     3fe:	2000      	movs	r0, #0
     400:	f001 f8d2 	bl	15a8 <am_hal_clkgen_sysclk_select>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);
     404:	4840      	ldr	r0, [pc, #256]	; (508 <main+0x110>)
     406:	f001 f839 	bl	147c <am_hal_cachectrl_enable>

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
     40a:	f000 ffe3 	bl	13d4 <am_bsp_low_power_init>

    //
    //
    // Initialize the printf interface for ITM/SWO output.
    //
    itm_start();
     40e:	f7ff febb 	bl	188 <itm_start>

    //
    // Print the banner.
    //
    am_util_stdio_terminal_clear();
     412:	f000 ff71 	bl	12f8 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("I2C Loopback Example using IOMSTR #4 and IOSLAVE");
     416:	483d      	ldr	r0, [pc, #244]	; (50c <main+0x114>)
     418:	f000 ff50 	bl	12bc <am_util_stdio_printf>

    //
    // Allow time for all printing to finish.
    //
    am_util_delay_ms(10);
     41c:	200a      	movs	r0, #10
     41e:	f000 f8c3 	bl	5a8 <am_util_delay_ms>

    //
    // Enable Interrupts.
    //
    am_hal_interrupt_master_enable();
     422:	f001 f9e5 	bl	17f0 <am_hal_interrupt_master_enable>

    //
    // Set up the IOS
    //
    ios_set_up();
     426:	f7ff feeb 	bl	200 <ios_set_up>

    //
    // Set up the IOM
    //
    iom_set_up();
     42a:	f7ff ff75 	bl	318 <iom_set_up>

    //
    // Perform a 16-byte transfer as a blocking operation.
    //
    am_hal_iom_i2c_write(IOM_MODULE, GET_I2CADDR(g_sIOSI2cConfig.ui32InterfaceSelect),
     42e:	4b38      	ldr	r3, [pc, #224]	; (510 <main+0x118>)
     430:	681b      	ldr	r3, [r3, #0]
     432:	0a5b      	lsrs	r3, r3, #9
     434:	f3c3 010a 	ubfx	r1, r3, #0, #11
     438:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     43c:	9300      	str	r3, [sp, #0]
     43e:	2310      	movs	r3, #16
     440:	4a34      	ldr	r2, [pc, #208]	; (514 <main+0x11c>)
     442:	2000      	movs	r0, #0
     444:	f002 fc80 	bl	2d48 <am_hal_iom_i2c_write>
                       (uint32_t *)&g_testdata, 16, AM_HAL_IOM_OFFSET(0x80));
    am_util_stdio_printf("\nBlocking Transfer Complete\n");
     448:	4833      	ldr	r0, [pc, #204]	; (518 <main+0x120>)
     44a:	f000 ff37 	bl	12bc <am_util_stdio_printf>

    for ( uint32_t i = 0; i < 16; i++ )
     44e:	2300      	movs	r3, #0
     450:	60fb      	str	r3, [r7, #12]
     452:	e010      	b.n	476 <main+0x7e>
    {
        if ( g_testdata[i] != am_hal_ios_lram_read(i) )
     454:	4a2f      	ldr	r2, [pc, #188]	; (514 <main+0x11c>)
     456:	68fb      	ldr	r3, [r7, #12]
     458:	4413      	add	r3, r2
     45a:	781c      	ldrb	r4, [r3, #0]
     45c:	68f8      	ldr	r0, [r7, #12]
     45e:	f003 fa41 	bl	38e4 <am_hal_ios_lram_read>
     462:	4603      	mov	r3, r0
     464:	429c      	cmp	r4, r3
     466:	d003      	beq.n	470 <main+0x78>
        {
            am_util_stdio_printf("\nIOS Data did not match IOM data sent!!!\n");
     468:	482c      	ldr	r0, [pc, #176]	; (51c <main+0x124>)
     46a:	f000 ff27 	bl	12bc <am_util_stdio_printf>
            break;
     46e:	e005      	b.n	47c <main+0x84>
    //
    am_hal_iom_i2c_write(IOM_MODULE, GET_I2CADDR(g_sIOSI2cConfig.ui32InterfaceSelect),
                       (uint32_t *)&g_testdata, 16, AM_HAL_IOM_OFFSET(0x80));
    am_util_stdio_printf("\nBlocking Transfer Complete\n");

    for ( uint32_t i = 0; i < 16; i++ )
     470:	68fb      	ldr	r3, [r7, #12]
     472:	3301      	adds	r3, #1
     474:	60fb      	str	r3, [r7, #12]
     476:	68fb      	ldr	r3, [r7, #12]
     478:	2b0f      	cmp	r3, #15
     47a:	d9eb      	bls.n	454 <main+0x5c>
    }

    //
    // Set up the IOM transaction queue.
    //
    am_hal_iom_queue_init(IOM_MODULE, g_psQueueMemory, sizeof(g_psQueueMemory));
     47c:	f44f 7260 	mov.w	r2, #896	; 0x380
     480:	4927      	ldr	r1, [pc, #156]	; (520 <main+0x128>)
     482:	2000      	movs	r0, #0
     484:	f002 fe80 	bl	3188 <am_hal_iom_queue_init>

    //
    // Perform a 16-byte transfer as a blocking operation.
    //
    for ( uint32_t i = 0; i < sizeof(g_testdata); i++ )
     488:	2300      	movs	r3, #0
     48a:	60bb      	str	r3, [r7, #8]
     48c:	e014      	b.n	4b8 <main+0xc0>
    {
        am_hal_iom_i2c_write(IOM_MODULE, GET_I2CADDR(g_sIOSI2cConfig.ui32InterfaceSelect),
     48e:	4b20      	ldr	r3, [pc, #128]	; (510 <main+0x118>)
     490:	681b      	ldr	r3, [r3, #0]
     492:	0a5b      	lsrs	r3, r3, #9
     494:	f3c3 010a 	ubfx	r1, r3, #0, #11
                             (uint32_t *)&g_testdata[i], 1, AM_HAL_IOM_OFFSET(0x80 | i));
     498:	68bb      	ldr	r3, [r7, #8]
     49a:	4a1e      	ldr	r2, [pc, #120]	; (514 <main+0x11c>)
     49c:	441a      	add	r2, r3
     49e:	68bb      	ldr	r3, [r7, #8]
     4a0:	021b      	lsls	r3, r3, #8
     4a2:	b29b      	uxth	r3, r3
    //
    // Perform a 16-byte transfer as a blocking operation.
    //
    for ( uint32_t i = 0; i < sizeof(g_testdata); i++ )
    {
        am_hal_iom_i2c_write(IOM_MODULE, GET_I2CADDR(g_sIOSI2cConfig.ui32InterfaceSelect),
     4a4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
     4a8:	9300      	str	r3, [sp, #0]
     4aa:	2301      	movs	r3, #1
     4ac:	2000      	movs	r0, #0
     4ae:	f002 fc4b 	bl	2d48 <am_hal_iom_i2c_write>
    am_hal_iom_queue_init(IOM_MODULE, g_psQueueMemory, sizeof(g_psQueueMemory));

    //
    // Perform a 16-byte transfer as a blocking operation.
    //
    for ( uint32_t i = 0; i < sizeof(g_testdata); i++ )
     4b2:	68bb      	ldr	r3, [r7, #8]
     4b4:	3301      	adds	r3, #1
     4b6:	60bb      	str	r3, [r7, #8]
     4b8:	68bb      	ldr	r3, [r7, #8]
     4ba:	2b0f      	cmp	r3, #15
     4bc:	d9e7      	bls.n	48e <main+0x96>
    {
        am_hal_iom_i2c_write(IOM_MODULE, GET_I2CADDR(g_sIOSI2cConfig.ui32InterfaceSelect),
                             (uint32_t *)&g_testdata[i], 1, AM_HAL_IOM_OFFSET(0x80 | i));
    }

    am_util_delay_ms(10);
     4be:	200a      	movs	r0, #10
     4c0:	f000 f872 	bl	5a8 <am_util_delay_ms>
    am_util_stdio_printf("\nNon-Blocking Transfer Complete\n");
     4c4:	4817      	ldr	r0, [pc, #92]	; (524 <main+0x12c>)
     4c6:	f000 fef9 	bl	12bc <am_util_stdio_printf>

    for ( uint32_t i = 0; i < 16; i++ )
     4ca:	2300      	movs	r3, #0
     4cc:	607b      	str	r3, [r7, #4]
     4ce:	e010      	b.n	4f2 <main+0xfa>
    {
        if ( g_testdata[i] != am_hal_ios_lram_read(i) )
     4d0:	4a10      	ldr	r2, [pc, #64]	; (514 <main+0x11c>)
     4d2:	687b      	ldr	r3, [r7, #4]
     4d4:	4413      	add	r3, r2
     4d6:	781c      	ldrb	r4, [r3, #0]
     4d8:	6878      	ldr	r0, [r7, #4]
     4da:	f003 fa03 	bl	38e4 <am_hal_ios_lram_read>
     4de:	4603      	mov	r3, r0
     4e0:	429c      	cmp	r4, r3
     4e2:	d003      	beq.n	4ec <main+0xf4>
        {
            am_util_stdio_printf("\nIOS Data did not match IOM data sent!!!\n");
     4e4:	480d      	ldr	r0, [pc, #52]	; (51c <main+0x124>)
     4e6:	f000 fee9 	bl	12bc <am_util_stdio_printf>
            break;
     4ea:	e005      	b.n	4f8 <main+0x100>
    }

    am_util_delay_ms(10);
    am_util_stdio_printf("\nNon-Blocking Transfer Complete\n");

    for ( uint32_t i = 0; i < 16; i++ )
     4ec:	687b      	ldr	r3, [r7, #4]
     4ee:	3301      	adds	r3, #1
     4f0:	607b      	str	r3, [r7, #4]
     4f2:	687b      	ldr	r3, [r7, #4]
     4f4:	2b0f      	cmp	r3, #15
     4f6:	d9eb      	bls.n	4d0 <main+0xd8>
            break;
        }
    }

    // Make sure the print is complete
    am_util_delay_ms(100);
     4f8:	2064      	movs	r0, #100	; 0x64
     4fa:	f000 f855 	bl	5a8 <am_util_delay_ms>
    while (1)
    {
        //
        // Go to Deep Sleep.
        //
        am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
     4fe:	2001      	movs	r0, #1
     500:	f003 fd42 	bl	3f88 <am_hal_sysctrl_sleep>
    }
     504:	e7fb      	b.n	4fe <main+0x106>
     506:	bf00      	nop
     508:	00005304 	.word	0x00005304
     50c:	0000521c 	.word	0x0000521c
     510:	10001010 	.word	0x10001010
     514:	10001000 	.word	0x10001000
     518:	00005250 	.word	0x00005250
     51c:	00005270 	.word	0x00005270
     520:	100011e8 	.word	0x100011e8
     524:	0000529c 	.word	0x0000529c

00000528 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
     528:	4811      	ldr	r0, [pc, #68]	; (570 <zero_loop+0x12>)
     52a:	4912      	ldr	r1, [pc, #72]	; (574 <zero_loop+0x16>)
     52c:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
     52e:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
     532:	4811      	ldr	r0, [pc, #68]	; (578 <zero_loop+0x1a>)
     534:	6801      	ldr	r1, [r0, #0]
     536:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     53a:	6001      	str	r1, [r0, #0]
     53c:	f3bf 8f4f 	dsb	sy
     540:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
     544:	480d      	ldr	r0, [pc, #52]	; (57c <zero_loop+0x1e>)
     546:	490e      	ldr	r1, [pc, #56]	; (580 <zero_loop+0x22>)
     548:	4a0e      	ldr	r2, [pc, #56]	; (584 <zero_loop+0x26>)

0000054a <copy_loop>:
     54a:	f850 3b04 	ldr.w	r3, [r0], #4
     54e:	f841 3b04 	str.w	r3, [r1], #4
     552:	4291      	cmp	r1, r2
     554:	dbf9      	blt.n	54a <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
     556:	480c      	ldr	r0, [pc, #48]	; (588 <zero_loop+0x2a>)
     558:	490c      	ldr	r1, [pc, #48]	; (58c <zero_loop+0x2e>)
     55a:	f04f 0200 	mov.w	r2, #0

0000055e <zero_loop>:
     55e:	4288      	cmp	r0, r1
     560:	bfb8      	it	lt
     562:	f840 2b04 	strlt.w	r2, [r0], #4
     566:	dbfa      	blt.n	55e <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
     568:	f7ff ff46 	bl	3f8 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
     56c:	be00      	bkpt	0x0000
}
     56e:	bf00      	nop
     570:	e000ed08 	.word	0xe000ed08
     574:	00000000 	.word	0x00000000
     578:	e000ed88 	.word	0xe000ed88
     57c:	000054f8 	.word	0x000054f8
     580:	10001000 	.word	0x10001000
     584:	10001094 	.word	0x10001094
     588:	10001094 	.word	0x10001094
     58c:	10001714 	.word	0x10001714

00000590 <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
     590:	b480      	push	{r7}
     592:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     594:	e7fe      	b.n	594 <am_nmi_isr+0x4>
     596:	bf00      	nop

00000598 <am_busfault_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_fault_isr(void)
{
     598:	b480      	push	{r7}
     59a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     59c:	e7fe      	b.n	59c <am_busfault_isr+0x4>
     59e:	bf00      	nop

000005a0 <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
     5a0:	b480      	push	{r7}
     5a2:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     5a4:	e7fe      	b.n	5a4 <am_adc_isr+0x4>
     5a6:	bf00      	nop

000005a8 <am_util_delay_ms>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
     5a8:	b580      	push	{r7, lr}
     5aa:	b084      	sub	sp, #16
     5ac:	af00      	add	r7, sp, #0
     5ae:	6078      	str	r0, [r7, #4]
    uint32_t ui32Loops = ui32MilliSeconds *
                          (am_hal_clkgen_sysclk_get() / 3000);
     5b0:	f001 f812 	bl	15d8 <am_hal_clkgen_sysclk_get>
     5b4:	4602      	mov	r2, r0
     5b6:	4b07      	ldr	r3, [pc, #28]	; (5d4 <am_util_delay_ms+0x2c>)
     5b8:	fba3 2302 	umull	r2, r3, r3, r2
     5bc:	099b      	lsrs	r3, r3, #6
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
    uint32_t ui32Loops = ui32MilliSeconds *
     5be:	687a      	ldr	r2, [r7, #4]
     5c0:	fb02 f303 	mul.w	r3, r2, r3
     5c4:	60fb      	str	r3, [r7, #12]
                          (am_hal_clkgen_sysclk_get() / 3000);

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
     5c6:	68f8      	ldr	r0, [r7, #12]
     5c8:	f001 f822 	bl	1610 <am_hal_flash_delay>
}
     5cc:	bf00      	nop
     5ce:	3710      	adds	r7, #16
     5d0:	46bd      	mov	sp, r7
     5d2:	bd80      	pop	{r7, pc}
     5d4:	057619f1 	.word	0x057619f1

000005d8 <am_util_stdio_printf_init>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
{
     5d8:	b480      	push	{r7}
     5da:	b083      	sub	sp, #12
     5dc:	af00      	add	r7, sp, #0
     5de:	6078      	str	r0, [r7, #4]
    g_pfnCharPrint = pfnCharPrint;
     5e0:	4a04      	ldr	r2, [pc, #16]	; (5f4 <am_util_stdio_printf_init+0x1c>)
     5e2:	687b      	ldr	r3, [r7, #4]
     5e4:	6013      	str	r3, [r2, #0]
}
     5e6:	bf00      	nop
     5e8:	370c      	adds	r7, #12
     5ea:	46bd      	mov	sp, r7
     5ec:	f85d 7b04 	ldr.w	r7, [sp], #4
     5f0:	4770      	bx	lr
     5f2:	bf00      	nop
     5f4:	10001578 	.word	0x10001578

000005f8 <divu64_10>:
//  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
//
//*****************************************************************************
static uint64_t
divu64_10(uint64_t ui64Val)
{
     5f8:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
     5fc:	b096      	sub	sp, #88	; 0x58
     5fe:	af00      	add	r7, sp, #0
     600:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
     604:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
     608:	0025      	movs	r5, r4
     60a:	2600      	movs	r6, #0
     60c:	ea55 0306 	orrs.w	r3, r5, r6
     610:	f000 809e 	beq.w	750 <divu64_10+0x158>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
     614:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
     618:	0862      	lsrs	r2, r4, #1
     61a:	ea4f 0133 	mov.w	r1, r3, rrx
     61e:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
     622:	ea4f 0893 	mov.w	r8, r3, lsr #2
     626:	ea48 7884 	orr.w	r8, r8, r4, lsl #30
     62a:	ea4f 0994 	mov.w	r9, r4, lsr #2
     62e:	eb11 0308 	adds.w	r3, r1, r8
     632:	eb42 0409 	adc.w	r4, r2, r9
     636:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 4);
     63a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     63e:	ea4f 1a13 	mov.w	sl, r3, lsr #4
     642:	ea4a 7a04 	orr.w	sl, sl, r4, lsl #28
     646:	ea4f 1b14 	mov.w	fp, r4, lsr #4
     64a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     64e:	eb13 030a 	adds.w	r3, r3, sl
     652:	eb44 040b 	adc.w	r4, r4, fp
     656:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 8);
     65a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     65e:	0a1a      	lsrs	r2, r3, #8
     660:	62ba      	str	r2, [r7, #40]	; 0x28
     662:	6aba      	ldr	r2, [r7, #40]	; 0x28
     664:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
     668:	62ba      	str	r2, [r7, #40]	; 0x28
     66a:	0a23      	lsrs	r3, r4, #8
     66c:	62fb      	str	r3, [r7, #44]	; 0x2c
     66e:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     672:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
     676:	18c9      	adds	r1, r1, r3
     678:	eb42 0204 	adc.w	r2, r2, r4
     67c:	460b      	mov	r3, r1
     67e:	4614      	mov	r4, r2
     680:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 16);
     684:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     688:	0c1a      	lsrs	r2, r3, #16
     68a:	623a      	str	r2, [r7, #32]
     68c:	6a3a      	ldr	r2, [r7, #32]
     68e:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
     692:	623a      	str	r2, [r7, #32]
     694:	0c23      	lsrs	r3, r4, #16
     696:	627b      	str	r3, [r7, #36]	; 0x24
     698:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     69c:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
     6a0:	18c9      	adds	r1, r1, r3
     6a2:	eb42 0204 	adc.w	r2, r2, r4
     6a6:	460b      	mov	r3, r1
     6a8:	4614      	mov	r4, r2
     6aa:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 32);
     6ae:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     6b2:	0023      	movs	r3, r4
     6b4:	603b      	str	r3, [r7, #0]
     6b6:	2300      	movs	r3, #0
     6b8:	607b      	str	r3, [r7, #4]
     6ba:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     6be:	e897 0006 	ldmia.w	r7, {r1, r2}
     6c2:	18c9      	adds	r1, r1, r3
     6c4:	eb42 0204 	adc.w	r2, r2, r4
     6c8:	460b      	mov	r3, r1
     6ca:	4614      	mov	r4, r2
     6cc:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 >>= 3;
     6d0:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     6d4:	08da      	lsrs	r2, r3, #3
     6d6:	613a      	str	r2, [r7, #16]
     6d8:	693a      	ldr	r2, [r7, #16]
     6da:	ea42 7244 	orr.w	r2, r2, r4, lsl #29
     6de:	613a      	str	r2, [r7, #16]
     6e0:	08e3      	lsrs	r3, r4, #3
     6e2:	617b      	str	r3, [r7, #20]
     6e4:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
     6e8:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        r64 = ui64Val - q64*10;
     6ec:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     6f0:	18db      	adds	r3, r3, r3
     6f2:	eb44 0404 	adc.w	r4, r4, r4
     6f6:	00a2      	lsls	r2, r4, #2
     6f8:	60fa      	str	r2, [r7, #12]
     6fa:	68fa      	ldr	r2, [r7, #12]
     6fc:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
     700:	60fa      	str	r2, [r7, #12]
     702:	009a      	lsls	r2, r3, #2
     704:	60ba      	str	r2, [r7, #8]
     706:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
     70a:	18c9      	adds	r1, r1, r3
     70c:	eb42 0204 	adc.w	r2, r2, r4
     710:	460b      	mov	r3, r1
     712:	4614      	mov	r4, r2
     714:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
     718:	1acb      	subs	r3, r1, r3
     71a:	eb62 0404 	sbc.w	r4, r2, r4
     71e:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        return q64 + ((r64 + 6) >> 4);
     722:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
     726:	3306      	adds	r3, #6
     728:	f144 0400 	adc.w	r4, r4, #0
     72c:	091a      	lsrs	r2, r3, #4
     72e:	61ba      	str	r2, [r7, #24]
     730:	69ba      	ldr	r2, [r7, #24]
     732:	ea42 7204 	orr.w	r2, r2, r4, lsl #28
     736:	61ba      	str	r2, [r7, #24]
     738:	0923      	lsrs	r3, r4, #4
     73a:	61fb      	str	r3, [r7, #28]
     73c:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
     740:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
     744:	18c9      	adds	r1, r1, r3
     746:	eb42 0204 	adc.w	r2, r2, r4
     74a:	460b      	mov	r3, r1
     74c:	4614      	mov	r4, r2
     74e:	e029      	b.n	7a4 <divu64_10+0x1ac>
    }
    else
    {
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
     750:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     752:	647b      	str	r3, [r7, #68]	; 0x44
        q32 = (ui32Val>>1) + (ui32Val>>2);
     754:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     756:	085a      	lsrs	r2, r3, #1
     758:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     75a:	089b      	lsrs	r3, r3, #2
     75c:	4413      	add	r3, r2
     75e:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 4);
     760:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     762:	091b      	lsrs	r3, r3, #4
     764:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     766:	4413      	add	r3, r2
     768:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 8);
     76a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     76c:	0a1b      	lsrs	r3, r3, #8
     76e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     770:	4413      	add	r3, r2
     772:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 16);
     774:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     776:	0c1b      	lsrs	r3, r3, #16
     778:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     77a:	4413      	add	r3, r2
     77c:	643b      	str	r3, [r7, #64]	; 0x40
        q32 >>= 3;
     77e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     780:	08db      	lsrs	r3, r3, #3
     782:	643b      	str	r3, [r7, #64]	; 0x40
        r32 = ui32Val - q32*10;
     784:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     786:	4613      	mov	r3, r2
     788:	009b      	lsls	r3, r3, #2
     78a:	4413      	add	r3, r2
     78c:	005b      	lsls	r3, r3, #1
     78e:	461a      	mov	r2, r3
     790:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     792:	1a9b      	subs	r3, r3, r2
     794:	63fb      	str	r3, [r7, #60]	; 0x3c
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
     796:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     798:	3306      	adds	r3, #6
     79a:	091a      	lsrs	r2, r3, #4
     79c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     79e:	4413      	add	r3, r2
     7a0:	f04f 0400 	mov.w	r4, #0
    }
}
     7a4:	4618      	mov	r0, r3
     7a6:	4621      	mov	r1, r4
     7a8:	3758      	adds	r7, #88	; 0x58
     7aa:	46bd      	mov	sp, r7
     7ac:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
     7b0:	4770      	bx	lr
     7b2:	bf00      	nop

000007b4 <ndigits_in_u64>:
// example: 10000 return 5, 123 returns 3.
//
//*****************************************************************************
static int
ndigits_in_u64(uint64_t ui64Val)
{
     7b4:	b590      	push	{r4, r7, lr}
     7b6:	b085      	sub	sp, #20
     7b8:	af00      	add	r7, sp, #0
     7ba:	e9c7 0100 	strd	r0, r1, [r7]
    int iNDigits = ui64Val ? 0 : 1;
     7be:	683a      	ldr	r2, [r7, #0]
     7c0:	687b      	ldr	r3, [r7, #4]
     7c2:	4313      	orrs	r3, r2
     7c4:	2b00      	cmp	r3, #0
     7c6:	bf0c      	ite	eq
     7c8:	2301      	moveq	r3, #1
     7ca:	2300      	movne	r3, #0
     7cc:	b2db      	uxtb	r3, r3
     7ce:	60fb      	str	r3, [r7, #12]

    while ( ui64Val )
     7d0:	e008      	b.n	7e4 <ndigits_in_u64+0x30>
    {
        //
        // ui32Val /= 10;
        //
        ui64Val = divu64_10(ui64Val);
     7d2:	e9d7 0100 	ldrd	r0, r1, [r7]
     7d6:	f7ff ff0f 	bl	5f8 <divu64_10>
     7da:	e9c7 0100 	strd	r0, r1, [r7]
        ++iNDigits;
     7de:	68fb      	ldr	r3, [r7, #12]
     7e0:	3301      	adds	r3, #1
     7e2:	60fb      	str	r3, [r7, #12]
static int
ndigits_in_u64(uint64_t ui64Val)
{
    int iNDigits = ui64Val ? 0 : 1;

    while ( ui64Val )
     7e4:	e897 0018 	ldmia.w	r7, {r3, r4}
     7e8:	4323      	orrs	r3, r4
     7ea:	d1f2      	bne.n	7d2 <ndigits_in_u64+0x1e>
        //
        ui64Val = divu64_10(ui64Val);
        ++iNDigits;
    }

    return iNDigits;
     7ec:	68fb      	ldr	r3, [r7, #12]
}
     7ee:	4618      	mov	r0, r3
     7f0:	3714      	adds	r7, #20
     7f2:	46bd      	mov	sp, r7
     7f4:	bd90      	pop	{r4, r7, pc}
     7f6:	bf00      	nop

000007f8 <ndigits_in_i64>:
// example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
//
//*****************************************************************************
static int
ndigits_in_i64(int64_t i64Val)
{
     7f8:	b590      	push	{r4, r7, lr}
     7fa:	b083      	sub	sp, #12
     7fc:	af00      	add	r7, sp, #0
     7fe:	e9c7 0100 	strd	r0, r1, [r7]
    if ( i64Val < 0 )
     802:	e897 0018 	ldmia.w	r7, {r3, r4}
     806:	2b00      	cmp	r3, #0
     808:	f174 0300 	sbcs.w	r3, r4, #0
     80c:	da06      	bge.n	81c <ndigits_in_i64+0x24>
    {
        //
        // Get absolute value
        //
        i64Val = -i64Val;
     80e:	e897 0018 	ldmia.w	r7, {r3, r4}
     812:	425b      	negs	r3, r3
     814:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
     818:	e887 0018 	stmia.w	r7, {r3, r4}
    }

    return ndigits_in_u64((uint64_t) i64Val);
     81c:	e897 0018 	ldmia.w	r7, {r3, r4}
     820:	4618      	mov	r0, r3
     822:	4621      	mov	r1, r4
     824:	f7ff ffc6 	bl	7b4 <ndigits_in_u64>
     828:	4603      	mov	r3, r0
}
     82a:	4618      	mov	r0, r3
     82c:	370c      	adds	r7, #12
     82e:	46bd      	mov	sp, r7
     830:	bd90      	pop	{r4, r7, pc}
     832:	bf00      	nop

00000834 <ndigits_in_hex>:
// Return the number of hex digits in an uint64_t.
//
//*****************************************************************************
static int
ndigits_in_hex(uint64_t ui64Val)
{
     834:	b490      	push	{r4, r7}
     836:	b084      	sub	sp, #16
     838:	af00      	add	r7, sp, #0
     83a:	e9c7 0100 	strd	r0, r1, [r7]
    int iDigits = ui64Val ? 0 : 1;
     83e:	6839      	ldr	r1, [r7, #0]
     840:	687a      	ldr	r2, [r7, #4]
     842:	430a      	orrs	r2, r1
     844:	2a00      	cmp	r2, #0
     846:	bf0c      	ite	eq
     848:	2201      	moveq	r2, #1
     84a:	2200      	movne	r2, #0
     84c:	b2d2      	uxtb	r2, r2
     84e:	60fa      	str	r2, [r7, #12]

    while ( ui64Val )
     850:	e00a      	b.n	868 <ndigits_in_hex+0x34>
    {
        ui64Val >>= 4;
     852:	e897 0006 	ldmia.w	r7, {r1, r2}
     856:	090b      	lsrs	r3, r1, #4
     858:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
     85c:	0914      	lsrs	r4, r2, #4
     85e:	e887 0018 	stmia.w	r7, {r3, r4}
        ++iDigits;
     862:	68fa      	ldr	r2, [r7, #12]
     864:	3201      	adds	r2, #1
     866:	60fa      	str	r2, [r7, #12]
static int
ndigits_in_hex(uint64_t ui64Val)
{
    int iDigits = ui64Val ? 0 : 1;

    while ( ui64Val )
     868:	e897 0006 	ldmia.w	r7, {r1, r2}
     86c:	430a      	orrs	r2, r1
     86e:	d1f0      	bne.n	852 <ndigits_in_hex+0x1e>
    {
        ui64Val >>= 4;
        ++iDigits;
    }

    return iDigits;
     870:	68fb      	ldr	r3, [r7, #12]
}
     872:	4618      	mov	r0, r3
     874:	3710      	adds	r7, #16
     876:	46bd      	mov	sp, r7
     878:	bc90      	pop	{r4, r7}
     87a:	4770      	bx	lr

0000087c <decstr_to_int>:
// pui32CharCnt.
//
//*****************************************************************************
static uint32_t
decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
{
     87c:	b480      	push	{r7}
     87e:	b087      	sub	sp, #28
     880:	af00      	add	r7, sp, #0
     882:	6078      	str	r0, [r7, #4]
     884:	6039      	str	r1, [r7, #0]
    bool bNeg = false;
     886:	2300      	movs	r3, #0
     888:	75fb      	strb	r3, [r7, #23]
    uint32_t ui32Val = 0, uCnt = 0;
     88a:	2300      	movs	r3, #0
     88c:	613b      	str	r3, [r7, #16]
     88e:	2300      	movs	r3, #0
     890:	60fb      	str	r3, [r7, #12]

    if ( *pcStr == '-')
     892:	687b      	ldr	r3, [r7, #4]
     894:	781b      	ldrb	r3, [r3, #0]
     896:	2b2d      	cmp	r3, #45	; 0x2d
     898:	d11b      	bne.n	8d2 <decstr_to_int+0x56>
    {
        bNeg = true;
     89a:	2301      	movs	r3, #1
     89c:	75fb      	strb	r3, [r7, #23]
        pcStr++;
     89e:	687b      	ldr	r3, [r7, #4]
     8a0:	3301      	adds	r3, #1
     8a2:	607b      	str	r3, [r7, #4]
        uCnt++;
     8a4:	68fb      	ldr	r3, [r7, #12]
     8a6:	3301      	adds	r3, #1
     8a8:	60fb      	str	r3, [r7, #12]
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
     8aa:	e012      	b.n	8d2 <decstr_to_int+0x56>
    {
        ++uCnt;
     8ac:	68fb      	ldr	r3, [r7, #12]
     8ae:	3301      	adds	r3, #1
     8b0:	60fb      	str	r3, [r7, #12]

        //
        // Multiply accumulated value by 10.
        //
        ui32Val *= 10;
     8b2:	693a      	ldr	r2, [r7, #16]
     8b4:	4613      	mov	r3, r2
     8b6:	009b      	lsls	r3, r3, #2
     8b8:	4413      	add	r3, r2
     8ba:	005b      	lsls	r3, r3, #1
     8bc:	613b      	str	r3, [r7, #16]

        //
        // Add in the new low digit.
        //
        ui32Val += (*pcStr - '0');
     8be:	687b      	ldr	r3, [r7, #4]
     8c0:	781b      	ldrb	r3, [r3, #0]
     8c2:	461a      	mov	r2, r3
     8c4:	693b      	ldr	r3, [r7, #16]
     8c6:	4413      	add	r3, r2
     8c8:	3b30      	subs	r3, #48	; 0x30
     8ca:	613b      	str	r3, [r7, #16]
        pcStr++;
     8cc:	687b      	ldr	r3, [r7, #4]
     8ce:	3301      	adds	r3, #1
     8d0:	607b      	str	r3, [r7, #4]
        bNeg = true;
        pcStr++;
        uCnt++;
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
     8d2:	687b      	ldr	r3, [r7, #4]
     8d4:	781b      	ldrb	r3, [r3, #0]
     8d6:	2b2f      	cmp	r3, #47	; 0x2f
     8d8:	d903      	bls.n	8e2 <decstr_to_int+0x66>
     8da:	687b      	ldr	r3, [r7, #4]
     8dc:	781b      	ldrb	r3, [r3, #0]
     8de:	2b39      	cmp	r3, #57	; 0x39
     8e0:	d9e4      	bls.n	8ac <decstr_to_int+0x30>
        //
        ui32Val += (*pcStr - '0');
        pcStr++;
    }

    if ( pui32CharCnt )
     8e2:	683b      	ldr	r3, [r7, #0]
     8e4:	2b00      	cmp	r3, #0
     8e6:	d002      	beq.n	8ee <decstr_to_int+0x72>
    {
        *pui32CharCnt = uCnt;
     8e8:	683b      	ldr	r3, [r7, #0]
     8ea:	68fa      	ldr	r2, [r7, #12]
     8ec:	601a      	str	r2, [r3, #0]
    }

    return bNeg ? -ui32Val : ui32Val;
     8ee:	7dfb      	ldrb	r3, [r7, #23]
     8f0:	2b00      	cmp	r3, #0
     8f2:	d002      	beq.n	8fa <decstr_to_int+0x7e>
     8f4:	693b      	ldr	r3, [r7, #16]
     8f6:	425b      	negs	r3, r3
     8f8:	e000      	b.n	8fc <decstr_to_int+0x80>
     8fa:	693b      	ldr	r3, [r7, #16]
}
     8fc:	4618      	mov	r0, r3
     8fe:	371c      	adds	r7, #28
     900:	46bd      	mov	sp, r7
     902:	f85d 7b04 	ldr.w	r7, [sp], #4
     906:	4770      	bx	lr

00000908 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
     908:	b590      	push	{r4, r7, lr}
     90a:	b091      	sub	sp, #68	; 0x44
     90c:	af00      	add	r7, sp, #0
     90e:	e9c7 0102 	strd	r0, r1, [r7, #8]
     912:	607a      	str	r2, [r7, #4]
    char tbuf[25];
    int ix = 0, iNumDig = 0;
     914:	2300      	movs	r3, #0
     916:	63fb      	str	r3, [r7, #60]	; 0x3c
     918:	2300      	movs	r3, #0
     91a:	63bb      	str	r3, [r7, #56]	; 0x38
    do
    {
        //
        // Divide by 10
        //
        u64Tmp = divu64_10(ui64Val);
     91c:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
     920:	f7ff fe6a 	bl	5f8 <divu64_10>
     924:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);
     928:	68b9      	ldr	r1, [r7, #8]
     92a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
     92c:	4613      	mov	r3, r2
     92e:	009b      	lsls	r3, r3, #2
     930:	4413      	add	r3, r2
     932:	005b      	lsls	r3, r3, #1
     934:	1acb      	subs	r3, r1, r3
     936:	62fb      	str	r3, [r7, #44]	; 0x2c

        tbuf[ix++] = uMod + '0';
     938:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     93a:	1c5a      	adds	r2, r3, #1
     93c:	63fa      	str	r2, [r7, #60]	; 0x3c
     93e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     940:	b2d2      	uxtb	r2, r2
     942:	3230      	adds	r2, #48	; 0x30
     944:	b2d2      	uxtb	r2, r2
     946:	f107 0140 	add.w	r1, r7, #64	; 0x40
     94a:	440b      	add	r3, r1
     94c:	f803 2c30 	strb.w	r2, [r3, #-48]
        ui64Val = u64Tmp;
     950:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
     954:	e9c7 3402 	strd	r3, r4, [r7, #8]
    } while ( ui64Val );
     958:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
     95c:	4323      	orrs	r3, r4
     95e:	d1dd      	bne.n	91c <uint64_to_str+0x14>

    //
    // Save the total number of digits
    //
    iNumDig = ix;
     960:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     962:	63bb      	str	r3, [r7, #56]	; 0x38

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
     964:	687b      	ldr	r3, [r7, #4]
     966:	2b00      	cmp	r3, #0
     968:	d011      	beq.n	98e <uint64_to_str+0x86>
    {
        while ( ix-- )
     96a:	e008      	b.n	97e <uint64_to_str+0x76>
        {
            *pcBuf++ = tbuf[ix];
     96c:	687b      	ldr	r3, [r7, #4]
     96e:	1c5a      	adds	r2, r3, #1
     970:	607a      	str	r2, [r7, #4]
     972:	f107 0110 	add.w	r1, r7, #16
     976:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     978:	440a      	add	r2, r1
     97a:	7812      	ldrb	r2, [r2, #0]
     97c:	701a      	strb	r2, [r3, #0]
    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    {
        while ( ix-- )
     97e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     980:	1e5a      	subs	r2, r3, #1
     982:	63fa      	str	r2, [r7, #60]	; 0x3c
     984:	2b00      	cmp	r3, #0
     986:	d1f1      	bne.n	96c <uint64_to_str+0x64>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
     988:	687b      	ldr	r3, [r7, #4]
     98a:	2200      	movs	r2, #0
     98c:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
     98e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
     990:	4618      	mov	r0, r3
     992:	3744      	adds	r7, #68	; 0x44
     994:	46bd      	mov	sp, r7
     996:	bd90      	pop	{r4, r7, pc}

00000998 <uint64_to_hexstr>:
// written).
//
//*****************************************************************************
static int
uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
{
     998:	b4b0      	push	{r4, r5, r7}
     99a:	b08d      	sub	sp, #52	; 0x34
     99c:	af00      	add	r7, sp, #0
     99e:	e9c7 0102 	strd	r0, r1, [r7, #8]
     9a2:	607a      	str	r2, [r7, #4]
     9a4:	70fb      	strb	r3, [r7, #3]
    int iNumDig, ix = 0;
     9a6:	2300      	movs	r3, #0
     9a8:	62fb      	str	r3, [r7, #44]	; 0x2c
    char cCh, tbuf[20];

    if ( ui64Val == 0 )
     9aa:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
     9ae:	4313      	orrs	r3, r2
     9b0:	d131      	bne.n	a16 <uint64_to_hexstr+0x7e>
    {
        tbuf[ix++] = '0';   // Print a '0'
     9b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     9b4:	1c5a      	adds	r2, r3, #1
     9b6:	62fa      	str	r2, [r7, #44]	; 0x2c
     9b8:	f107 0230 	add.w	r2, r7, #48	; 0x30
     9bc:	4413      	add	r3, r2
     9be:	2230      	movs	r2, #48	; 0x30
     9c0:	f803 2c20 	strb.w	r2, [r3, #-32]
    }

    while ( ui64Val )
     9c4:	e027      	b.n	a16 <uint64_to_hexstr+0x7e>
    {
        cCh = ui64Val & 0xf;
     9c6:	7a3b      	ldrb	r3, [r7, #8]
     9c8:	f003 030f 	and.w	r3, r3, #15
     9cc:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

        //
        // Alpha character
        //
        if ( cCh > 9 )
     9d0:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
     9d4:	2b09      	cmp	r3, #9
     9d6:	d90a      	bls.n	9ee <uint64_to_hexstr+0x56>
        {
            cCh += bLower ? 0x27 : 0x7;
     9d8:	78fb      	ldrb	r3, [r7, #3]
     9da:	2b00      	cmp	r3, #0
     9dc:	d001      	beq.n	9e2 <uint64_to_hexstr+0x4a>
     9de:	2227      	movs	r2, #39	; 0x27
     9e0:	e000      	b.n	9e4 <uint64_to_hexstr+0x4c>
     9e2:	2207      	movs	r2, #7
     9e4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
     9e8:	4413      	add	r3, r2
     9ea:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        }

        tbuf[ix++] = cCh + '0';
     9ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     9f0:	1c5a      	adds	r2, r3, #1
     9f2:	62fa      	str	r2, [r7, #44]	; 0x2c
     9f4:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
     9f8:	3230      	adds	r2, #48	; 0x30
     9fa:	b2d2      	uxtb	r2, r2
     9fc:	f107 0130 	add.w	r1, r7, #48	; 0x30
     a00:	440b      	add	r3, r1
     a02:	f803 2c20 	strb.w	r2, [r3, #-32]
        ui64Val >>= 4;
     a06:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
     a0a:	0914      	lsrs	r4, r2, #4
     a0c:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
     a10:	091d      	lsrs	r5, r3, #4
     a12:	e9c7 4502 	strd	r4, r5, [r7, #8]
    if ( ui64Val == 0 )
    {
        tbuf[ix++] = '0';   // Print a '0'
    }

    while ( ui64Val )
     a16:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
     a1a:	4313      	orrs	r3, r2
     a1c:	d1d3      	bne.n	9c6 <uint64_to_hexstr+0x2e>
    }

    //
    // Save the total number of digits
    //
    iNumDig = ix;
     a1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     a20:	627b      	str	r3, [r7, #36]	; 0x24

    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
     a22:	687b      	ldr	r3, [r7, #4]
     a24:	2b00      	cmp	r3, #0
     a26:	d011      	beq.n	a4c <uint64_to_hexstr+0xb4>
    {
        while (ix--)
     a28:	e008      	b.n	a3c <uint64_to_hexstr+0xa4>
        {
            *pcBuf++ = tbuf[ix];
     a2a:	687b      	ldr	r3, [r7, #4]
     a2c:	1c5a      	adds	r2, r3, #1
     a2e:	607a      	str	r2, [r7, #4]
     a30:	f107 0110 	add.w	r1, r7, #16
     a34:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     a36:	440a      	add	r2, r1
     a38:	7812      	ldrb	r2, [r2, #0]
     a3a:	701a      	strb	r2, [r3, #0]
    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
    {
        while (ix--)
     a3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     a3e:	1e5a      	subs	r2, r3, #1
     a40:	62fa      	str	r2, [r7, #44]	; 0x2c
     a42:	2b00      	cmp	r3, #0
     a44:	d1f1      	bne.n	a2a <uint64_to_hexstr+0x92>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0;
     a46:	687b      	ldr	r3, [r7, #4]
     a48:	2200      	movs	r2, #0
     a4a:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
     a4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
     a4e:	4618      	mov	r0, r3
     a50:	3734      	adds	r7, #52	; 0x34
     a52:	46bd      	mov	sp, r7
     a54:	bcb0      	pop	{r4, r5, r7}
     a56:	4770      	bx	lr

00000a58 <simple_strlen>:
// Return length of the given string.
//
//*****************************************************************************
static uint32_t
simple_strlen(char *pcBuf)
{
     a58:	b480      	push	{r7}
     a5a:	b085      	sub	sp, #20
     a5c:	af00      	add	r7, sp, #0
     a5e:	6078      	str	r0, [r7, #4]
    uint32_t ui32RetVal = 0;
     a60:	2300      	movs	r3, #0
     a62:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
     a64:	687b      	ldr	r3, [r7, #4]
     a66:	2b00      	cmp	r3, #0
     a68:	d104      	bne.n	a74 <simple_strlen+0x1c>
    {
        return ui32RetVal;
     a6a:	68fb      	ldr	r3, [r7, #12]
     a6c:	e009      	b.n	a82 <simple_strlen+0x2a>
    }

    while ( *pcBuf++ )
    {
        ui32RetVal++;
     a6e:	68fb      	ldr	r3, [r7, #12]
     a70:	3301      	adds	r3, #1
     a72:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
    {
        return ui32RetVal;
    }

    while ( *pcBuf++ )
     a74:	687b      	ldr	r3, [r7, #4]
     a76:	1c5a      	adds	r2, r3, #1
     a78:	607a      	str	r2, [r7, #4]
     a7a:	781b      	ldrb	r3, [r3, #0]
     a7c:	2b00      	cmp	r3, #0
     a7e:	d1f6      	bne.n	a6e <simple_strlen+0x16>
    {
        ui32RetVal++;
    }
    return ui32RetVal;
     a80:	68fb      	ldr	r3, [r7, #12]
}
     a82:	4618      	mov	r0, r3
     a84:	3714      	adds	r7, #20
     a86:	46bd      	mov	sp, r7
     a88:	f85d 7b04 	ldr.w	r7, [sp], #4
     a8c:	4770      	bx	lr
     a8e:	bf00      	nop

00000a90 <padbuffer>:
// Pad a string buffer with pad characters.
//
//*****************************************************************************
static int32_t
padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
{
     a90:	b480      	push	{r7}
     a92:	b087      	sub	sp, #28
     a94:	af00      	add	r7, sp, #0
     a96:	60f8      	str	r0, [r7, #12]
     a98:	460b      	mov	r3, r1
     a9a:	607a      	str	r2, [r7, #4]
     a9c:	72fb      	strb	r3, [r7, #11]
    int32_t i32Cnt = 0;
     a9e:	2300      	movs	r3, #0
     aa0:	617b      	str	r3, [r7, #20]

    if ( i32NumChars <= 0 )
     aa2:	687b      	ldr	r3, [r7, #4]
     aa4:	2b00      	cmp	r3, #0
     aa6:	dc0c      	bgt.n	ac2 <padbuffer+0x32>
    {
        return i32Cnt;
     aa8:	697b      	ldr	r3, [r7, #20]
     aaa:	e010      	b.n	ace <padbuffer+0x3e>
    }

    while ( i32NumChars-- )
    {
        if ( pcBuf )
     aac:	68fb      	ldr	r3, [r7, #12]
     aae:	2b00      	cmp	r3, #0
     ab0:	d004      	beq.n	abc <padbuffer+0x2c>
        {
            *pcBuf++ = cPadChar;
     ab2:	68fb      	ldr	r3, [r7, #12]
     ab4:	1c5a      	adds	r2, r3, #1
     ab6:	60fa      	str	r2, [r7, #12]
     ab8:	7afa      	ldrb	r2, [r7, #11]
     aba:	701a      	strb	r2, [r3, #0]
        }
        i32Cnt++;
     abc:	697b      	ldr	r3, [r7, #20]
     abe:	3301      	adds	r3, #1
     ac0:	617b      	str	r3, [r7, #20]
    if ( i32NumChars <= 0 )
    {
        return i32Cnt;
    }

    while ( i32NumChars-- )
     ac2:	687b      	ldr	r3, [r7, #4]
     ac4:	1e5a      	subs	r2, r3, #1
     ac6:	607a      	str	r2, [r7, #4]
     ac8:	2b00      	cmp	r3, #0
     aca:	d1ef      	bne.n	aac <padbuffer+0x1c>
            *pcBuf++ = cPadChar;
        }
        i32Cnt++;
    }

    return i32Cnt;
     acc:	697b      	ldr	r3, [r7, #20]
}
     ace:	4618      	mov	r0, r3
     ad0:	371c      	adds	r7, #28
     ad2:	46bd      	mov	sp, r7
     ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
     ad8:	4770      	bx	lr
     ada:	bf00      	nop

00000adc <ftoa>:
    int32_t I32;
    float F;
} i32fl_t;

static int ftoa(float fValue, char *pcBuf, int iPrecision)
{
     adc:	b590      	push	{r4, r7, lr}
     ade:	b08f      	sub	sp, #60	; 0x3c
     ae0:	af00      	add	r7, sp, #0
     ae2:	60f8      	str	r0, [r7, #12]
     ae4:	60b9      	str	r1, [r7, #8]
     ae6:	607a      	str	r2, [r7, #4]
    i32fl_t unFloatValue;
    int iExp2, iBufSize;
    int32_t i32Mantissa, i32IntPart, i32FracPart;
    char *pcBufInitial;

    iBufSize = *(uint32_t*)pcBuf;
     ae8:	68bb      	ldr	r3, [r7, #8]
     aea:	681b      	ldr	r3, [r3, #0]
     aec:	62bb      	str	r3, [r7, #40]	; 0x28
    if (iBufSize < 4)
     aee:	6abb      	ldr	r3, [r7, #40]	; 0x28
     af0:	2b03      	cmp	r3, #3
     af2:	dc02      	bgt.n	afa <ftoa+0x1e>
    {
        return AM_FTOA_ERR_BUFSIZE;
     af4:	f06f 0302 	mvn.w	r3, #2
     af8:	e0d4      	b.n	ca4 <ftoa+0x1c8>
    }

    if (fValue == 0.0f)
     afa:	edd7 7a03 	vldr	s15, [r7, #12]
     afe:	eef5 7a40 	vcmp.f32	s15, #0.0
     b02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     b06:	d104      	bne.n	b12 <ftoa+0x36>
    {
        // "0.0"
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
     b08:	68bb      	ldr	r3, [r7, #8]
     b0a:	4a68      	ldr	r2, [pc, #416]	; (cac <ftoa+0x1d0>)
     b0c:	601a      	str	r2, [r3, #0]
        return 3;
     b0e:	2303      	movs	r3, #3
     b10:	e0c8      	b.n	ca4 <ftoa+0x1c8>
    }

    pcBufInitial = pcBuf;
     b12:	68bb      	ldr	r3, [r7, #8]
     b14:	627b      	str	r3, [r7, #36]	; 0x24

    unFloatValue.F = fValue;
     b16:	68fb      	ldr	r3, [r7, #12]
     b18:	617b      	str	r3, [r7, #20]

    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
     b1a:	697b      	ldr	r3, [r7, #20]
     b1c:	15db      	asrs	r3, r3, #23
     b1e:	b2db      	uxtb	r3, r3
     b20:	3b7f      	subs	r3, #127	; 0x7f
     b22:	623b      	str	r3, [r7, #32]
    i32Mantissa = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
     b24:	697b      	ldr	r3, [r7, #20]
     b26:	f3c3 0316 	ubfx	r3, r3, #0, #23
     b2a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
     b2e:	61fb      	str	r3, [r7, #28]
    i32FracPart = 0;
     b30:	2300      	movs	r3, #0
     b32:	633b      	str	r3, [r7, #48]	; 0x30
    i32IntPart = 0;
     b34:	2300      	movs	r3, #0
     b36:	637b      	str	r3, [r7, #52]	; 0x34

    if (iExp2 >= 31)
     b38:	6a3b      	ldr	r3, [r7, #32]
     b3a:	2b1e      	cmp	r3, #30
     b3c:	dd02      	ble.n	b44 <ftoa+0x68>
    {
        return AM_FTOA_ERR_VAL_TOO_LARGE;
     b3e:	f06f 0301 	mvn.w	r3, #1
     b42:	e0af      	b.n	ca4 <ftoa+0x1c8>
    }
    else if (iExp2 < -23)
     b44:	6a3b      	ldr	r3, [r7, #32]
     b46:	f113 0f17 	cmn.w	r3, #23
     b4a:	da02      	bge.n	b52 <ftoa+0x76>
    {
        return AM_FTOA_ERR_VAL_TOO_SMALL;
     b4c:	f04f 33ff 	mov.w	r3, #4294967295
     b50:	e0a8      	b.n	ca4 <ftoa+0x1c8>
    }
    else if (iExp2 >= 23)
     b52:	6a3b      	ldr	r3, [r7, #32]
     b54:	2b16      	cmp	r3, #22
     b56:	dd06      	ble.n	b66 <ftoa+0x8a>
    {
        i32IntPart = i32Mantissa << (iExp2 - 23);
     b58:	6a3b      	ldr	r3, [r7, #32]
     b5a:	3b17      	subs	r3, #23
     b5c:	69fa      	ldr	r2, [r7, #28]
     b5e:	fa02 f303 	lsl.w	r3, r2, r3
     b62:	637b      	str	r3, [r7, #52]	; 0x34
     b64:	e01a      	b.n	b9c <ftoa+0xc0>
    }
    else if (iExp2 >= 0)
     b66:	6a3b      	ldr	r3, [r7, #32]
     b68:	2b00      	cmp	r3, #0
     b6a:	db0f      	blt.n	b8c <ftoa+0xb0>
    {
        i32IntPart = i32Mantissa >> (23 - iExp2);
     b6c:	6a3b      	ldr	r3, [r7, #32]
     b6e:	f1c3 0317 	rsb	r3, r3, #23
     b72:	69fa      	ldr	r2, [r7, #28]
     b74:	fa42 f303 	asr.w	r3, r2, r3
     b78:	637b      	str	r3, [r7, #52]	; 0x34
        i32FracPart = (i32Mantissa << (iExp2 + 1)) & 0x00FFFFFF;
     b7a:	6a3b      	ldr	r3, [r7, #32]
     b7c:	3301      	adds	r3, #1
     b7e:	69fa      	ldr	r2, [r7, #28]
     b80:	fa02 f303 	lsl.w	r3, r2, r3
     b84:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     b88:	633b      	str	r3, [r7, #48]	; 0x30
     b8a:	e007      	b.n	b9c <ftoa+0xc0>
    }
    else // if (iExp2 < 0)
    {
        i32FracPart = (i32Mantissa & 0x00FFFFFF) >> -(iExp2 + 1);
     b8c:	69fb      	ldr	r3, [r7, #28]
     b8e:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
     b92:	6a3b      	ldr	r3, [r7, #32]
     b94:	43db      	mvns	r3, r3
     b96:	fa42 f303 	asr.w	r3, r2, r3
     b9a:	633b      	str	r3, [r7, #48]	; 0x30
    }

    if (unFloatValue.I32 < 0)
     b9c:	697b      	ldr	r3, [r7, #20]
     b9e:	2b00      	cmp	r3, #0
     ba0:	da04      	bge.n	bac <ftoa+0xd0>
    {
        *pcBuf++ = '-';
     ba2:	68bb      	ldr	r3, [r7, #8]
     ba4:	1c5a      	adds	r2, r3, #1
     ba6:	60ba      	str	r2, [r7, #8]
     ba8:	222d      	movs	r2, #45	; 0x2d
     baa:	701a      	strb	r2, [r3, #0]
    }

    if (i32IntPart == 0)
     bac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     bae:	2b00      	cmp	r3, #0
     bb0:	d105      	bne.n	bbe <ftoa+0xe2>
    {
        *pcBuf++ = '0';
     bb2:	68bb      	ldr	r3, [r7, #8]
     bb4:	1c5a      	adds	r2, r3, #1
     bb6:	60ba      	str	r2, [r7, #8]
     bb8:	2230      	movs	r2, #48	; 0x30
     bba:	701a      	strb	r2, [r3, #0]
     bbc:	e021      	b.n	c02 <ftoa+0x126>
    }
    else
    {
        if (i32IntPart > 0)
     bbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     bc0:	2b00      	cmp	r3, #0
     bc2:	dd08      	ble.n	bd6 <ftoa+0xfa>
        {
            uint64_to_str(i32IntPart, pcBuf);
     bc4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     bc6:	ea4f 74e3 	mov.w	r4, r3, asr #31
     bca:	68ba      	ldr	r2, [r7, #8]
     bcc:	4618      	mov	r0, r3
     bce:	4621      	mov	r1, r4
     bd0:	f7ff fe9a 	bl	908 <uint64_to_str>
     bd4:	e011      	b.n	bfa <ftoa+0x11e>
        }
        else
        {
            *pcBuf++ = '-';
     bd6:	68bb      	ldr	r3, [r7, #8]
     bd8:	1c5a      	adds	r2, r3, #1
     bda:	60ba      	str	r2, [r7, #8]
     bdc:	222d      	movs	r2, #45	; 0x2d
     bde:	701a      	strb	r2, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
     be0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     be2:	425b      	negs	r3, r3
     be4:	ea4f 74e3 	mov.w	r4, r3, asr #31
     be8:	68ba      	ldr	r2, [r7, #8]
     bea:	4618      	mov	r0, r3
     bec:	4621      	mov	r1, r4
     bee:	f7ff fe8b 	bl	908 <uint64_to_str>
        }
        while (*pcBuf)    // Get to end of new string
     bf2:	e002      	b.n	bfa <ftoa+0x11e>
        {
            pcBuf++;
     bf4:	68bb      	ldr	r3, [r7, #8]
     bf6:	3301      	adds	r3, #1
     bf8:	60bb      	str	r3, [r7, #8]
        else
        {
            *pcBuf++ = '-';
            uint64_to_str(-i32IntPart, pcBuf);
        }
        while (*pcBuf)    // Get to end of new string
     bfa:	68bb      	ldr	r3, [r7, #8]
     bfc:	781b      	ldrb	r3, [r3, #0]
     bfe:	2b00      	cmp	r3, #0
     c00:	d1f8      	bne.n	bf4 <ftoa+0x118>
    }

    //
    // Now, begin the fractional part
    //
    *pcBuf++ = '.';
     c02:	68bb      	ldr	r3, [r7, #8]
     c04:	1c5a      	adds	r2, r3, #1
     c06:	60ba      	str	r2, [r7, #8]
     c08:	222e      	movs	r2, #46	; 0x2e
     c0a:	701a      	strb	r2, [r3, #0]

    if (i32FracPart == 0)
     c0c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     c0e:	2b00      	cmp	r3, #0
     c10:	d105      	bne.n	c1e <ftoa+0x142>
    {
        *pcBuf++ = '0';
     c12:	68bb      	ldr	r3, [r7, #8]
     c14:	1c5a      	adds	r2, r3, #1
     c16:	60ba      	str	r2, [r7, #8]
     c18:	2230      	movs	r2, #48	; 0x30
     c1a:	701a      	strb	r2, [r3, #0]
     c1c:	e03c      	b.n	c98 <ftoa+0x1bc>
    }
    else
    {
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
     c1e:	68ba      	ldr	r2, [r7, #8]
     c20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     c22:	1ad3      	subs	r3, r2, r3
     c24:	6aba      	ldr	r2, [r7, #40]	; 0x28
     c26:	1ad3      	subs	r3, r2, r3
     c28:	3b01      	subs	r3, #1
     c2a:	61bb      	str	r3, [r7, #24]
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
     c2c:	69ba      	ldr	r2, [r7, #24]
     c2e:	687b      	ldr	r3, [r7, #4]
     c30:	4293      	cmp	r3, r2
     c32:	bfa8      	it	ge
     c34:	4613      	movge	r3, r2
     c36:	61bb      	str	r3, [r7, #24]

        for (jx = 0; jx < iMax; jx++)
     c38:	2300      	movs	r3, #0
     c3a:	62fb      	str	r3, [r7, #44]	; 0x2c
     c3c:	e015      	b.n	c6a <ftoa+0x18e>
        {
            i32FracPart *= 10;
     c3e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
     c40:	4613      	mov	r3, r2
     c42:	009b      	lsls	r3, r3, #2
     c44:	4413      	add	r3, r2
     c46:	005b      	lsls	r3, r3, #1
     c48:	633b      	str	r3, [r7, #48]	; 0x30
            *pcBuf++ = (i32FracPart >> 24) + '0';
     c4a:	68bb      	ldr	r3, [r7, #8]
     c4c:	1c5a      	adds	r2, r3, #1
     c4e:	60ba      	str	r2, [r7, #8]
     c50:	6b3a      	ldr	r2, [r7, #48]	; 0x30
     c52:	1612      	asrs	r2, r2, #24
     c54:	b2d2      	uxtb	r2, r2
     c56:	3230      	adds	r2, #48	; 0x30
     c58:	b2d2      	uxtb	r2, r2
     c5a:	701a      	strb	r2, [r3, #0]
            i32FracPart &= 0x00FFFFFF;
     c5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     c5e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     c62:	633b      	str	r3, [r7, #48]	; 0x30
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
        iMax = (iMax > iPrecision) ? iPrecision : iMax;

        for (jx = 0; jx < iMax; jx++)
     c64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     c66:	3301      	adds	r3, #1
     c68:	62fb      	str	r3, [r7, #44]	; 0x2c
     c6a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     c6c:	69bb      	ldr	r3, [r7, #24]
     c6e:	429a      	cmp	r2, r3
     c70:	dbe5      	blt.n	c3e <ftoa+0x162>
        }

        //
        // Remove trailing zeros
        //
        --pcBuf;
     c72:	68bb      	ldr	r3, [r7, #8]
     c74:	3b01      	subs	r3, #1
     c76:	60bb      	str	r3, [r7, #8]
        while ((*pcBuf == '0')  &&  (*(pcBuf-1) != '.'))
     c78:	e002      	b.n	c80 <ftoa+0x1a4>
        {
            --pcBuf;
     c7a:	68bb      	ldr	r3, [r7, #8]
     c7c:	3b01      	subs	r3, #1
     c7e:	60bb      	str	r3, [r7, #8]

        //
        // Remove trailing zeros
        //
        --pcBuf;
        while ((*pcBuf == '0')  &&  (*(pcBuf-1) != '.'))
     c80:	68bb      	ldr	r3, [r7, #8]
     c82:	781b      	ldrb	r3, [r3, #0]
     c84:	2b30      	cmp	r3, #48	; 0x30
     c86:	d104      	bne.n	c92 <ftoa+0x1b6>
     c88:	68bb      	ldr	r3, [r7, #8]
     c8a:	3b01      	subs	r3, #1
     c8c:	781b      	ldrb	r3, [r3, #0]
     c8e:	2b2e      	cmp	r3, #46	; 0x2e
     c90:	d1f3      	bne.n	c7a <ftoa+0x19e>
        {
            --pcBuf;
        }
        ++pcBuf;
     c92:	68bb      	ldr	r3, [r7, #8]
     c94:	3301      	adds	r3, #1
     c96:	60bb      	str	r3, [r7, #8]
    }

    //
    // Terminate the string and we're done
    //
    *pcBuf = 0x00;
     c98:	68bb      	ldr	r3, [r7, #8]
     c9a:	2200      	movs	r2, #0
     c9c:	701a      	strb	r2, [r3, #0]

    return (pcBuf - pcBufInitial);
     c9e:	68ba      	ldr	r2, [r7, #8]
     ca0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     ca2:	1ad3      	subs	r3, r2, r3
} // ftoa()
     ca4:	4618      	mov	r0, r3
     ca6:	373c      	adds	r7, #60	; 0x3c
     ca8:	46bd      	mov	sp, r7
     caa:	bd90      	pop	{r4, r7, pc}
     cac:	00302e30 	.word	0x00302e30

00000cb0 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
     cb0:	b590      	push	{r4, r7, lr}
     cb2:	b095      	sub	sp, #84	; 0x54
     cb4:	af00      	add	r7, sp, #0
     cb6:	60f8      	str	r0, [r7, #12]
     cb8:	60b9      	str	r1, [r7, #8]
     cba:	607a      	str	r2, [r7, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
     cbc:	2300      	movs	r3, #0
     cbe:	63fb      	str	r3, [r7, #60]	; 0x3c
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;
     cc0:	2300      	movs	r3, #0
     cc2:	627b      	str	r3, [r7, #36]	; 0x24

    while ( *pcFmt != 0x0 )
     cc4:	e2e3      	b.n	128e <am_util_stdio_vsprintf+0x5de>
    {
        iPrecision = 6;             // printf() default precision for %f is 6
     cc6:	2306      	movs	r3, #6
     cc8:	633b      	str	r3, [r7, #48]	; 0x30

        if ( *pcFmt != '%' )
     cca:	68bb      	ldr	r3, [r7, #8]
     ccc:	781b      	ldrb	r3, [r3, #0]
     cce:	2b25      	cmp	r3, #37	; 0x25
     cd0:	d01f      	beq.n	d12 <am_util_stdio_vsprintf+0x62>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
     cd2:	68fb      	ldr	r3, [r7, #12]
     cd4:	2b00      	cmp	r3, #0
     cd6:	d015      	beq.n	d04 <am_util_stdio_vsprintf+0x54>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
     cd8:	68bb      	ldr	r3, [r7, #8]
     cda:	781b      	ldrb	r3, [r3, #0]
     cdc:	2b0a      	cmp	r3, #10
     cde:	d10b      	bne.n	cf8 <am_util_stdio_vsprintf+0x48>
     ce0:	4bb1      	ldr	r3, [pc, #708]	; (fa8 <am_util_stdio_vsprintf+0x2f8>)
     ce2:	781b      	ldrb	r3, [r3, #0]
     ce4:	2b00      	cmp	r3, #0
     ce6:	d007      	beq.n	cf8 <am_util_stdio_vsprintf+0x48>
                {
                    *pcBuf++ = '\r';
     ce8:	68fb      	ldr	r3, [r7, #12]
     cea:	1c5a      	adds	r2, r3, #1
     cec:	60fa      	str	r2, [r7, #12]
     cee:	220d      	movs	r2, #13
     cf0:	701a      	strb	r2, [r3, #0]
                    ++ui32CharCnt;
     cf2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     cf4:	3301      	adds	r3, #1
     cf6:	63fb      	str	r3, [r7, #60]	; 0x3c
                }
                *pcBuf++ = *pcFmt;
     cf8:	68fb      	ldr	r3, [r7, #12]
     cfa:	1c5a      	adds	r2, r3, #1
     cfc:	60fa      	str	r2, [r7, #12]
     cfe:	68ba      	ldr	r2, [r7, #8]
     d00:	7812      	ldrb	r2, [r2, #0]
     d02:	701a      	strb	r2, [r3, #0]
            }

            ++pcFmt;
     d04:	68bb      	ldr	r3, [r7, #8]
     d06:	3301      	adds	r3, #1
     d08:	60bb      	str	r3, [r7, #8]
            ++ui32CharCnt;
     d0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     d0c:	3301      	adds	r3, #1
     d0e:	63fb      	str	r3, [r7, #60]	; 0x3c
            continue;
     d10:	e2bd      	b.n	128e <am_util_stdio_vsprintf+0x5de>
        }

        //
        // Handle the specifier.
        //
        ++pcFmt;
     d12:	68bb      	ldr	r3, [r7, #8]
     d14:	3301      	adds	r3, #1
     d16:	60bb      	str	r3, [r7, #8]
        bLower = bLongLong = false;
     d18:	2300      	movs	r3, #0
     d1a:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
     d1e:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
     d22:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';
     d26:	2320      	movs	r3, #32
     d28:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        if ( *pcFmt == '0' )
     d2c:	68bb      	ldr	r3, [r7, #8]
     d2e:	781b      	ldrb	r3, [r3, #0]
     d30:	2b30      	cmp	r3, #48	; 0x30
     d32:	d105      	bne.n	d40 <am_util_stdio_vsprintf+0x90>
        {
            ui8PadChar = '0';
     d34:	2330      	movs	r3, #48	; 0x30
     d36:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            ++pcFmt;
     d3a:	68bb      	ldr	r3, [r7, #8]
     d3c:	3301      	adds	r3, #1
     d3e:	60bb      	str	r3, [r7, #8]
        }

        //
        // Width specifier
        //
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
     d40:	f107 0310 	add.w	r3, r7, #16
     d44:	4619      	mov	r1, r3
     d46:	68b8      	ldr	r0, [r7, #8]
     d48:	f7ff fd98 	bl	87c <decstr_to_int>
     d4c:	4603      	mov	r3, r0
     d4e:	63bb      	str	r3, [r7, #56]	; 0x38
        pcFmt += ui32NumChars;
     d50:	693b      	ldr	r3, [r7, #16]
     d52:	68ba      	ldr	r2, [r7, #8]
     d54:	4413      	add	r3, r2
     d56:	60bb      	str	r3, [r7, #8]

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
     d58:	68bb      	ldr	r3, [r7, #8]
     d5a:	781b      	ldrb	r3, [r3, #0]
     d5c:	2b73      	cmp	r3, #115	; 0x73
     d5e:	d005      	beq.n	d6c <am_util_stdio_vsprintf+0xbc>
     d60:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     d62:	2b00      	cmp	r3, #0
     d64:	da02      	bge.n	d6c <am_util_stdio_vsprintf+0xbc>
        {
            iWidth = -iWidth;
     d66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     d68:	425b      	negs	r3, r3
     d6a:	63bb      	str	r3, [r7, #56]	; 0x38
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
     d6c:	68bb      	ldr	r3, [r7, #8]
     d6e:	781b      	ldrb	r3, [r3, #0]
     d70:	2b2e      	cmp	r3, #46	; 0x2e
     d72:	d10e      	bne.n	d92 <am_util_stdio_vsprintf+0xe2>
        {
            ++pcFmt;
     d74:	68bb      	ldr	r3, [r7, #8]
     d76:	3301      	adds	r3, #1
     d78:	60bb      	str	r3, [r7, #8]
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
     d7a:	f107 0310 	add.w	r3, r7, #16
     d7e:	4619      	mov	r1, r3
     d80:	68b8      	ldr	r0, [r7, #8]
     d82:	f7ff fd7b 	bl	87c <decstr_to_int>
     d86:	4603      	mov	r3, r0
     d88:	633b      	str	r3, [r7, #48]	; 0x30
            pcFmt += ui32NumChars;
     d8a:	693b      	ldr	r3, [r7, #16]
     d8c:	68ba      	ldr	r2, [r7, #8]
     d8e:	4413      	add	r3, r2
     d90:	60bb      	str	r3, [r7, #8]
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
     d92:	68bb      	ldr	r3, [r7, #8]
     d94:	781b      	ldrb	r3, [r3, #0]
     d96:	2b6c      	cmp	r3, #108	; 0x6c
     d98:	d10c      	bne.n	db4 <am_util_stdio_vsprintf+0x104>
        {
            pcFmt++;
     d9a:	68bb      	ldr	r3, [r7, #8]
     d9c:	3301      	adds	r3, #1
     d9e:	60bb      	str	r3, [r7, #8]
            if ( *pcFmt == 'l' )    // "ll" (long long)
     da0:	68bb      	ldr	r3, [r7, #8]
     da2:	781b      	ldrb	r3, [r3, #0]
     da4:	2b6c      	cmp	r3, #108	; 0x6c
     da6:	d105      	bne.n	db4 <am_util_stdio_vsprintf+0x104>
            {
                pcFmt++;
     da8:	68bb      	ldr	r3, [r7, #8]
     daa:	3301      	adds	r3, #1
     dac:	60bb      	str	r3, [r7, #8]
                bLongLong = true;
     dae:	2301      	movs	r3, #1
     db0:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
            }
        }

        switch ( *pcFmt )
     db4:	68bb      	ldr	r3, [r7, #8]
     db6:	781b      	ldrb	r3, [r3, #0]
     db8:	3b46      	subs	r3, #70	; 0x46
     dba:	2b32      	cmp	r3, #50	; 0x32
     dbc:	f200 8254 	bhi.w	1268 <am_util_stdio_vsprintf+0x5b8>
     dc0:	a201      	add	r2, pc, #4	; (adr r2, dc8 <am_util_stdio_vsprintf+0x118>)
     dc2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     dc6:	bf00      	nop
     dc8:	000011f3 	.word	0x000011f3
     dcc:	00001269 	.word	0x00001269
     dd0:	00001269 	.word	0x00001269
     dd4:	00001269 	.word	0x00001269
     dd8:	00001269 	.word	0x00001269
     ddc:	00001269 	.word	0x00001269
     de0:	00001269 	.word	0x00001269
     de4:	00001269 	.word	0x00001269
     de8:	00001269 	.word	0x00001269
     dec:	00001269 	.word	0x00001269
     df0:	00001269 	.word	0x00001269
     df4:	00001269 	.word	0x00001269
     df8:	00001269 	.word	0x00001269
     dfc:	00001269 	.word	0x00001269
     e00:	00001269 	.word	0x00001269
     e04:	00001269 	.word	0x00001269
     e08:	00001269 	.word	0x00001269
     e0c:	00001269 	.word	0x00001269
     e10:	00000f8f 	.word	0x00000f8f
     e14:	00001269 	.word	0x00001269
     e18:	00001269 	.word	0x00001269
     e1c:	00001269 	.word	0x00001269
     e20:	00001269 	.word	0x00001269
     e24:	00001269 	.word	0x00001269
     e28:	00001269 	.word	0x00001269
     e2c:	00001269 	.word	0x00001269
     e30:	00001269 	.word	0x00001269
     e34:	00001269 	.word	0x00001269
     e38:	00001269 	.word	0x00001269
     e3c:	00000e95 	.word	0x00000e95
     e40:	000010bb 	.word	0x000010bb
     e44:	00001269 	.word	0x00001269
     e48:	000011f3 	.word	0x000011f3
     e4c:	00001269 	.word	0x00001269
     e50:	00001269 	.word	0x00001269
     e54:	000010bb 	.word	0x000010bb
     e58:	00001269 	.word	0x00001269
     e5c:	00001269 	.word	0x00001269
     e60:	00001269 	.word	0x00001269
     e64:	00001269 	.word	0x00001269
     e68:	00001269 	.word	0x00001269
     e6c:	00001269 	.word	0x00001269
     e70:	00001269 	.word	0x00001269
     e74:	00001269 	.word	0x00001269
     e78:	00001269 	.word	0x00001269
     e7c:	00000ebb 	.word	0x00000ebb
     e80:	00001269 	.word	0x00001269
     e84:	00001029 	.word	0x00001029
     e88:	00001269 	.word	0x00001269
     e8c:	00001269 	.word	0x00001269
     e90:	00000f89 	.word	0x00000f89
        {
            case 'c':
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
     e94:	687b      	ldr	r3, [r7, #4]
     e96:	1d1a      	adds	r2, r3, #4
     e98:	607a      	str	r2, [r7, #4]
     e9a:	681b      	ldr	r3, [r3, #0]
     e9c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

                if ( pcBuf )
     ea0:	68fb      	ldr	r3, [r7, #12]
     ea2:	2b00      	cmp	r3, #0
     ea4:	d005      	beq.n	eb2 <am_util_stdio_vsprintf+0x202>
                {
                    *pcBuf++ = ui8CharSpecifier;
     ea6:	68fb      	ldr	r3, [r7, #12]
     ea8:	1c5a      	adds	r2, r3, #1
     eaa:	60fa      	str	r2, [r7, #12]
     eac:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
     eb0:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
     eb2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     eb4:	3301      	adds	r3, #1
     eb6:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
     eb8:	e1e6      	b.n	1288 <am_util_stdio_vsprintf+0x5d8>

            case 's':
                pcStr = va_arg(pArgs, char *);
     eba:	687b      	ldr	r3, [r7, #4]
     ebc:	1d1a      	adds	r2, r3, #4
     ebe:	607a      	str	r2, [r7, #4]
     ec0:	681b      	ldr	r3, [r3, #0]
     ec2:	64fb      	str	r3, [r7, #76]	; 0x4c
                //
                // For %s, we support the width specifier. If iWidth is negative
                // the string is left-aligned (padding on the right).  Otherwise
                // the string is padded at the beginning with spaces.
                //
                ui32strlen = simple_strlen(pcStr);
     ec4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
     ec6:	f7ff fdc7 	bl	a58 <simple_strlen>
     eca:	6278      	str	r0, [r7, #36]	; 0x24
                if ( iWidth > 0 )
     ecc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     ece:	2b00      	cmp	r3, #0
     ed0:	dd2e      	ble.n	f30 <am_util_stdio_vsprintf+0x280>
                {
                    // Pad the beginning of the string (right-aligned).
                    if ( ui32strlen < iWidth )
     ed2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     ed4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     ed6:	429a      	cmp	r2, r3
     ed8:	d22a      	bcs.n	f30 <am_util_stdio_vsprintf+0x280>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
     eda:	6bba      	ldr	r2, [r7, #56]	; 0x38
     edc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     ede:	1ad3      	subs	r3, r2, r3
     ee0:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
     ee2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
     ee6:	6bba      	ldr	r2, [r7, #56]	; 0x38
     ee8:	4619      	mov	r1, r3
     eea:	68f8      	ldr	r0, [r7, #12]
     eec:	f7ff fdd0 	bl	a90 <padbuffer>
     ef0:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
     ef2:	68fb      	ldr	r3, [r7, #12]
     ef4:	2b00      	cmp	r3, #0
     ef6:	d001      	beq.n	efc <am_util_stdio_vsprintf+0x24c>
     ef8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     efa:	e000      	b.n	efe <am_util_stdio_vsprintf+0x24e>
     efc:	2300      	movs	r3, #0
     efe:	68fa      	ldr	r2, [r7, #12]
     f00:	4413      	add	r3, r2
     f02:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
     f04:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     f06:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     f08:	4413      	add	r3, r2
     f0a:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
     f0c:	2300      	movs	r3, #0
     f0e:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }

                while (*pcStr != 0x0)
     f10:	e00e      	b.n	f30 <am_util_stdio_vsprintf+0x280>
                {
                    if ( pcBuf )
     f12:	68fb      	ldr	r3, [r7, #12]
     f14:	2b00      	cmp	r3, #0
     f16:	d005      	beq.n	f24 <am_util_stdio_vsprintf+0x274>
                    {
                        *pcBuf++ = *pcStr;
     f18:	68fb      	ldr	r3, [r7, #12]
     f1a:	1c5a      	adds	r2, r3, #1
     f1c:	60fa      	str	r2, [r7, #12]
     f1e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
     f20:	7812      	ldrb	r2, [r2, #0]
     f22:	701a      	strb	r2, [r3, #0]
                    }

                    ++pcStr;
     f24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     f26:	3301      	adds	r3, #1
     f28:	64fb      	str	r3, [r7, #76]	; 0x4c
                    ++ui32CharCnt;
     f2a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     f2c:	3301      	adds	r3, #1
     f2e:	63fb      	str	r3, [r7, #60]	; 0x3c
                        ui32CharCnt += iWidth;
                        iWidth = 0;
                    }
                }

                while (*pcStr != 0x0)
     f30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     f32:	781b      	ldrb	r3, [r3, #0]
     f34:	2b00      	cmp	r3, #0
     f36:	d1ec      	bne.n	f12 <am_util_stdio_vsprintf+0x262>

                    ++pcStr;
                    ++ui32CharCnt;
                }

                if ( iWidth )
     f38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     f3a:	2b00      	cmp	r3, #0
     f3c:	f000 81a1 	beq.w	1282 <am_util_stdio_vsprintf+0x5d2>
                {
                    iWidth = -iWidth;
     f40:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     f42:	425b      	negs	r3, r3
     f44:	63bb      	str	r3, [r7, #56]	; 0x38

                    // Pad the end of the string (left-aligned).
                    if ( ui32strlen < iWidth )
     f46:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     f48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     f4a:	429a      	cmp	r2, r3
     f4c:	f080 8199 	bcs.w	1282 <am_util_stdio_vsprintf+0x5d2>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
     f50:	6bba      	ldr	r2, [r7, #56]	; 0x38
     f52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     f54:	1ad3      	subs	r3, r2, r3
     f56:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
     f58:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
     f5c:	6bba      	ldr	r2, [r7, #56]	; 0x38
     f5e:	4619      	mov	r1, r3
     f60:	68f8      	ldr	r0, [r7, #12]
     f62:	f7ff fd95 	bl	a90 <padbuffer>
     f66:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
     f68:	68fb      	ldr	r3, [r7, #12]
     f6a:	2b00      	cmp	r3, #0
     f6c:	d001      	beq.n	f72 <am_util_stdio_vsprintf+0x2c2>
     f6e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     f70:	e000      	b.n	f74 <am_util_stdio_vsprintf+0x2c4>
     f72:	2300      	movs	r3, #0
     f74:	68fa      	ldr	r2, [r7, #12]
     f76:	4413      	add	r3, r2
     f78:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
     f7a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     f7c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     f7e:	4413      	add	r3, r2
     f80:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
     f82:	2300      	movs	r3, #0
     f84:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }
                break;
     f86:	e17c      	b.n	1282 <am_util_stdio_vsprintf+0x5d2>

            case 'x':
                bLower = true;
     f88:	2301      	movs	r3, #1
     f8a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
     f8e:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
     f92:	2b00      	cmp	r3, #0
     f94:	d00a      	beq.n	fac <am_util_stdio_vsprintf+0x2fc>
     f96:	687b      	ldr	r3, [r7, #4]
     f98:	3307      	adds	r3, #7
     f9a:	f023 0307 	bic.w	r3, r3, #7
     f9e:	f103 0208 	add.w	r2, r3, #8
     fa2:	607a      	str	r2, [r7, #4]
     fa4:	cb18      	ldmia	r3, {r3, r4}
     fa6:	e007      	b.n	fb8 <am_util_stdio_vsprintf+0x308>
     fa8:	10001194 	.word	0x10001194
                                      va_arg(pArgs, uint32_t);
     fac:	687b      	ldr	r3, [r7, #4]
     fae:	1d1a      	adds	r2, r3, #4
     fb0:	607a      	str	r2, [r7, #4]
     fb2:	681b      	ldr	r3, [r3, #0]
                break;

            case 'x':
                bLower = true;
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
     fb4:	f04f 0400 	mov.w	r4, #0
     fb8:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                                      va_arg(pArgs, uint32_t);

                if ( iWidth )
     fbc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     fbe:	2b00      	cmp	r3, #0
     fc0:	d01e      	beq.n	1000 <am_util_stdio_vsprintf+0x350>
                {
                    //
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_hex(ui64Val);
     fc2:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
     fc6:	f7ff fc35 	bl	834 <ndigits_in_hex>
     fca:	4602      	mov	r2, r0
     fcc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     fce:	1a9b      	subs	r3, r3, r2
     fd0:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
     fd2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
     fd6:	6bba      	ldr	r2, [r7, #56]	; 0x38
     fd8:	4619      	mov	r1, r3
     fda:	68f8      	ldr	r0, [r7, #12]
     fdc:	f7ff fd58 	bl	a90 <padbuffer>
     fe0:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
     fe2:	68fb      	ldr	r3, [r7, #12]
     fe4:	2b00      	cmp	r3, #0
     fe6:	d001      	beq.n	fec <am_util_stdio_vsprintf+0x33c>
     fe8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     fea:	e000      	b.n	fee <am_util_stdio_vsprintf+0x33e>
     fec:	2300      	movs	r3, #0
     fee:	68fa      	ldr	r2, [r7, #12]
     ff0:	4413      	add	r3, r2
     ff2:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
     ff4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     ff6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     ff8:	4413      	add	r3, r2
     ffa:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
     ffc:	2300      	movs	r3, #0
     ffe:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
    1000:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    1004:	68fa      	ldr	r2, [r7, #12]
    1006:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    100a:	f7ff fcc5 	bl	998 <uint64_to_hexstr>
    100e:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    1010:	68fb      	ldr	r3, [r7, #12]
    1012:	2b00      	cmp	r3, #0
    1014:	d003      	beq.n	101e <am_util_stdio_vsprintf+0x36e>
                {
                    pcBuf += iVal;
    1016:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    1018:	68fa      	ldr	r2, [r7, #12]
    101a:	4413      	add	r3, r2
    101c:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    101e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    1020:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    1022:	4413      	add	r3, r2
    1024:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    1026:	e12f      	b.n	1288 <am_util_stdio_vsprintf+0x5d8>

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    1028:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    102c:	2b00      	cmp	r3, #0
    102e:	d008      	beq.n	1042 <am_util_stdio_vsprintf+0x392>
    1030:	687b      	ldr	r3, [r7, #4]
    1032:	3307      	adds	r3, #7
    1034:	f023 0307 	bic.w	r3, r3, #7
    1038:	f103 0208 	add.w	r2, r3, #8
    103c:	607a      	str	r2, [r7, #4]
    103e:	cb18      	ldmia	r3, {r3, r4}
    1040:	e005      	b.n	104e <am_util_stdio_vsprintf+0x39e>
                                      va_arg(pArgs, uint32_t);
    1042:	687b      	ldr	r3, [r7, #4]
    1044:	1d1a      	adds	r2, r3, #4
    1046:	607a      	str	r2, [r7, #4]
    1048:	681b      	ldr	r3, [r3, #0]

                ui32CharCnt += iVal;
                break;

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    104a:	f04f 0400 	mov.w	r4, #0
    104e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                                      va_arg(pArgs, uint32_t);

                if ( iWidth )
    1052:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1054:	2b00      	cmp	r3, #0
    1056:	d01e      	beq.n	1096 <am_util_stdio_vsprintf+0x3e6>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_u64(ui64Val);
    1058:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    105c:	f7ff fbaa 	bl	7b4 <ndigits_in_u64>
    1060:	4602      	mov	r2, r0
    1062:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1064:	1a9b      	subs	r3, r3, r2
    1066:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    1068:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    106c:	6bba      	ldr	r2, [r7, #56]	; 0x38
    106e:	4619      	mov	r1, r3
    1070:	68f8      	ldr	r0, [r7, #12]
    1072:	f7ff fd0d 	bl	a90 <padbuffer>
    1076:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    1078:	68fb      	ldr	r3, [r7, #12]
    107a:	2b00      	cmp	r3, #0
    107c:	d001      	beq.n	1082 <am_util_stdio_vsprintf+0x3d2>
    107e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1080:	e000      	b.n	1084 <am_util_stdio_vsprintf+0x3d4>
    1082:	2300      	movs	r3, #0
    1084:	68fa      	ldr	r2, [r7, #12]
    1086:	4413      	add	r3, r2
    1088:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    108a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    108c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    108e:	4413      	add	r3, r2
    1090:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    1092:	2300      	movs	r3, #0
    1094:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    1096:	68fa      	ldr	r2, [r7, #12]
    1098:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    109c:	f7ff fc34 	bl	908 <uint64_to_str>
    10a0:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    10a2:	68fb      	ldr	r3, [r7, #12]
    10a4:	2b00      	cmp	r3, #0
    10a6:	d003      	beq.n	10b0 <am_util_stdio_vsprintf+0x400>
                {
                    pcBuf += iVal;
    10a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    10aa:	68fa      	ldr	r2, [r7, #12]
    10ac:	4413      	add	r3, r2
    10ae:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    10b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    10b2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    10b4:	4413      	add	r3, r2
    10b6:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    10b8:	e0e6      	b.n	1288 <am_util_stdio_vsprintf+0x5d8>
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    10ba:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    10be:	2b00      	cmp	r3, #0
    10c0:	d008      	beq.n	10d4 <am_util_stdio_vsprintf+0x424>
    10c2:	687b      	ldr	r3, [r7, #4]
    10c4:	3307      	adds	r3, #7
    10c6:	f023 0307 	bic.w	r3, r3, #7
    10ca:	f103 0208 	add.w	r2, r3, #8
    10ce:	607a      	str	r2, [r7, #4]
    10d0:	cb18      	ldmia	r3, {r3, r4}
    10d2:	e005      	b.n	10e0 <am_util_stdio_vsprintf+0x430>
                                     va_arg(pArgs, int32_t);
    10d4:	687b      	ldr	r3, [r7, #4]
    10d6:	1d1a      	adds	r2, r3, #4
    10d8:	607a      	str	r2, [r7, #4]
    10da:	681b      	ldr	r3, [r3, #0]
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    10dc:	ea4f 74e3 	mov.w	r4, r3, asr #31
    10e0:	e9c7 3406 	strd	r3, r4, [r7, #24]
                                     va_arg(pArgs, int32_t);

                //
                // Get absolute value
                //
                if ( i64Val < 0 )
    10e4:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    10e8:	2b00      	cmp	r3, #0
    10ea:	f174 0300 	sbcs.w	r3, r4, #0
    10ee:	da0a      	bge.n	1106 <am_util_stdio_vsprintf+0x456>
                {
                    ui64Val = -i64Val;          // Get absolute value
    10f0:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    10f4:	425b      	negs	r3, r3
    10f6:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    10fa:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = true;
    10fe:	2301      	movs	r3, #1
    1100:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    1104:	e006      	b.n	1114 <am_util_stdio_vsprintf+0x464>
                }
                else
                {
                    ui64Val = i64Val;
    1106:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    110a:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = false;
    110e:	2300      	movs	r3, #0
    1110:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
                }

                if ( iWidth )
    1114:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1116:	2b00      	cmp	r3, #0
    1118:	d04a      	beq.n	11b0 <am_util_stdio_vsprintf+0x500>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_i64(ui64Val);
    111a:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
    111e:	4618      	mov	r0, r3
    1120:	4621      	mov	r1, r4
    1122:	f7ff fb69 	bl	7f8 <ndigits_in_i64>
    1126:	4602      	mov	r2, r0
    1128:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    112a:	1a9b      	subs	r3, r3, r2
    112c:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg )
    112e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    1132:	2b00      	cmp	r3, #0
    1134:	d011      	beq.n	115a <am_util_stdio_vsprintf+0x4aa>
                    {
                        --iWidth;
    1136:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1138:	3b01      	subs	r3, #1
    113a:	63bb      	str	r3, [r7, #56]	; 0x38

                        //
                        // Allow for the negative sign
                        //
                        if ( ui8PadChar == '0' )
    113c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    1140:	2b30      	cmp	r3, #48	; 0x30
    1142:	d10a      	bne.n	115a <am_util_stdio_vsprintf+0x4aa>
                        {
                            //
                            // Print the neg sign BEFORE the leading zeros
                            //
                            if ( pcBuf )
    1144:	68fb      	ldr	r3, [r7, #12]
    1146:	2b00      	cmp	r3, #0
    1148:	d004      	beq.n	1154 <am_util_stdio_vsprintf+0x4a4>
                            {
                                *pcBuf++ = '-';
    114a:	68fb      	ldr	r3, [r7, #12]
    114c:	1c5a      	adds	r2, r3, #1
    114e:	60fa      	str	r2, [r7, #12]
    1150:	222d      	movs	r2, #45	; 0x2d
    1152:	701a      	strb	r2, [r3, #0]
                            }

                            ++ui32CharCnt;
    1154:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    1156:	3301      	adds	r3, #1
    1158:	63fb      	str	r3, [r7, #60]	; 0x3c
                        }
                    }

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    115a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    115e:	6bba      	ldr	r2, [r7, #56]	; 0x38
    1160:	4619      	mov	r1, r3
    1162:	68f8      	ldr	r0, [r7, #12]
    1164:	f7ff fc94 	bl	a90 <padbuffer>
    1168:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    116a:	68fb      	ldr	r3, [r7, #12]
    116c:	2b00      	cmp	r3, #0
    116e:	d001      	beq.n	1174 <am_util_stdio_vsprintf+0x4c4>
    1170:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1172:	e000      	b.n	1176 <am_util_stdio_vsprintf+0x4c6>
    1174:	2300      	movs	r3, #0
    1176:	68fa      	ldr	r2, [r7, #12]
    1178:	4413      	add	r3, r2
    117a:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    117c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    117e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    1180:	4413      	add	r3, r2
    1182:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    1184:	2300      	movs	r3, #0
    1186:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg  &&  (ui8PadChar == ' ') )
    1188:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    118c:	2b00      	cmp	r3, #0
    118e:	d01e      	beq.n	11ce <am_util_stdio_vsprintf+0x51e>
    1190:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    1194:	2b20      	cmp	r3, #32
    1196:	d11a      	bne.n	11ce <am_util_stdio_vsprintf+0x51e>
                    {
                        //
                        // Print the neg sign AFTER the leading blanks
                        //
                        if ( pcBuf )
    1198:	68fb      	ldr	r3, [r7, #12]
    119a:	2b00      	cmp	r3, #0
    119c:	d004      	beq.n	11a8 <am_util_stdio_vsprintf+0x4f8>
                        {
                            *pcBuf++ = '-';
    119e:	68fb      	ldr	r3, [r7, #12]
    11a0:	1c5a      	adds	r2, r3, #1
    11a2:	60fa      	str	r2, [r7, #12]
    11a4:	222d      	movs	r2, #45	; 0x2d
    11a6:	701a      	strb	r2, [r3, #0]
                        }

                        ++ui32CharCnt;
    11a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    11aa:	3301      	adds	r3, #1
    11ac:	63fb      	str	r3, [r7, #60]	; 0x3c
    11ae:	e00e      	b.n	11ce <am_util_stdio_vsprintf+0x51e>
                    }
                }
                else
                {
                    if ( bNeg )
    11b0:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    11b4:	2b00      	cmp	r3, #0
    11b6:	d00a      	beq.n	11ce <am_util_stdio_vsprintf+0x51e>
                    {
                        if ( pcBuf )
    11b8:	68fb      	ldr	r3, [r7, #12]
    11ba:	2b00      	cmp	r3, #0
    11bc:	d004      	beq.n	11c8 <am_util_stdio_vsprintf+0x518>
                        {
                            *pcBuf++ = '-';
    11be:	68fb      	ldr	r3, [r7, #12]
    11c0:	1c5a      	adds	r2, r3, #1
    11c2:	60fa      	str	r2, [r7, #12]
    11c4:	222d      	movs	r2, #45	; 0x2d
    11c6:	701a      	strb	r2, [r3, #0]
                        }
                        ++ui32CharCnt;
    11c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    11ca:	3301      	adds	r3, #1
    11cc:	63fb      	str	r3, [r7, #60]	; 0x3c
                    }
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    11ce:	68fa      	ldr	r2, [r7, #12]
    11d0:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    11d4:	f7ff fb98 	bl	908 <uint64_to_str>
    11d8:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    11da:	68fb      	ldr	r3, [r7, #12]
    11dc:	2b00      	cmp	r3, #0
    11de:	d003      	beq.n	11e8 <am_util_stdio_vsprintf+0x538>
                {
                    pcBuf += iVal;
    11e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    11e2:	68fa      	ldr	r2, [r7, #12]
    11e4:	4413      	add	r3, r2
    11e6:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    11e8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    11ea:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    11ec:	4413      	add	r3, r2
    11ee:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    11f0:	e04a      	b.n	1288 <am_util_stdio_vsprintf+0x5d8>


            case 'f':
            case 'F':
                if ( pcBuf )
    11f2:	68fb      	ldr	r3, [r7, #12]
    11f4:	2b00      	cmp	r3, #0
    11f6:	d046      	beq.n	1286 <am_util_stdio_vsprintf+0x5d6>
                {
                    float fValue = va_arg(pArgs, double);
    11f8:	687b      	ldr	r3, [r7, #4]
    11fa:	3307      	adds	r3, #7
    11fc:	f023 0307 	bic.w	r3, r3, #7
    1200:	f103 0208 	add.w	r2, r3, #8
    1204:	607a      	str	r2, [r7, #4]
    1206:	cb18      	ldmia	r3, {r3, r4}
    1208:	4618      	mov	r0, r3
    120a:	4621      	mov	r1, r4
    120c:	f7fe ff58 	bl	c0 <__aeabi_d2f>
    1210:	4603      	mov	r3, r0
    1212:	617b      	str	r3, [r7, #20]

                    //
                    // pcBuf is an input (size of buffer) and also an output of ftoa()
                    //
                    *(uint32_t*)pcBuf = 20;
    1214:	68fb      	ldr	r3, [r7, #12]
    1216:	2214      	movs	r2, #20
    1218:	601a      	str	r2, [r3, #0]

                    iVal = ftoa(fValue, pcBuf, iPrecision);
    121a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    121c:	68f9      	ldr	r1, [r7, #12]
    121e:	6978      	ldr	r0, [r7, #20]
    1220:	f7ff fc5c 	bl	adc <ftoa>
    1224:	6378      	str	r0, [r7, #52]	; 0x34
                    if ( iVal < 0 )
    1226:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    1228:	2b00      	cmp	r3, #0
    122a:	da14      	bge.n	1256 <am_util_stdio_vsprintf+0x5a6>
                    {
                        uint32_t u32PrntErrVal;
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    122c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    122e:	f1b3 3fff 	cmp.w	r3, #4294967295
    1232:	d102      	bne.n	123a <am_util_stdio_vsprintf+0x58a>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    1234:	4b1e      	ldr	r3, [pc, #120]	; (12b0 <am_util_stdio_vsprintf+0x600>)
    1236:	62bb      	str	r3, [r7, #40]	; 0x28
    1238:	e008      	b.n	124c <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('0' << 0);  // "0.0"
                        }
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    123a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    123c:	f113 0f02 	cmn.w	r3, #2
    1240:	d102      	bne.n	1248 <am_util_stdio_vsprintf+0x598>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    1242:	4b1c      	ldr	r3, [pc, #112]	; (12b4 <am_util_stdio_vsprintf+0x604>)
    1244:	62bb      	str	r3, [r7, #40]	; 0x28
    1246:	e001      	b.n	124c <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('#' << 0);  // "#.#"
                        }
                        else
                        {
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    1248:	4b1b      	ldr	r3, [pc, #108]	; (12b8 <am_util_stdio_vsprintf+0x608>)
    124a:	62bb      	str	r3, [r7, #40]	; 0x28
                                            ('.' << 8)   | ('?' << 0);  // "?.?"
                        }
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    124c:	68fb      	ldr	r3, [r7, #12]
    124e:	6aba      	ldr	r2, [r7, #40]	; 0x28
    1250:	601a      	str	r2, [r3, #0]
                        iVal = 3;
    1252:	2303      	movs	r3, #3
    1254:	637b      	str	r3, [r7, #52]	; 0x34
                    }
                    ui32CharCnt += iVal;
    1256:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    1258:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    125a:	4413      	add	r3, r2
    125c:	63fb      	str	r3, [r7, #60]	; 0x3c
                    pcBuf += iVal;
    125e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    1260:	68fa      	ldr	r2, [r7, #12]
    1262:	4413      	add	r3, r2
    1264:	60fb      	str	r3, [r7, #12]
                }
                break;
    1266:	e00e      	b.n	1286 <am_util_stdio_vsprintf+0x5d6>
            // For non-handled specifiers, we'll just print the character.
            // e.g. this will allow the normal printing of a '%' using
            // "%%".
            //
            default:
                if ( pcBuf )
    1268:	68fb      	ldr	r3, [r7, #12]
    126a:	2b00      	cmp	r3, #0
    126c:	d005      	beq.n	127a <am_util_stdio_vsprintf+0x5ca>
                {
                    *pcBuf++ = *pcFmt;
    126e:	68fb      	ldr	r3, [r7, #12]
    1270:	1c5a      	adds	r2, r3, #1
    1272:	60fa      	str	r2, [r7, #12]
    1274:	68ba      	ldr	r2, [r7, #8]
    1276:	7812      	ldrb	r2, [r2, #0]
    1278:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    127a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    127c:	3301      	adds	r3, #1
    127e:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    1280:	e002      	b.n	1288 <am_util_stdio_vsprintf+0x5d8>
                        pcBuf += pcBuf ? iWidth : 0;
                        ui32CharCnt += iWidth;
                        iWidth = 0;
                    }
                }
                break;
    1282:	bf00      	nop
    1284:	e000      	b.n	1288 <am_util_stdio_vsprintf+0x5d8>
                        iVal = 3;
                    }
                    ui32CharCnt += iVal;
                    pcBuf += iVal;
                }
                break;
    1286:	bf00      	nop
        } // switch()

        //
        // Bump the format specification to the next character
        //
        ++pcFmt;
    1288:	68bb      	ldr	r3, [r7, #8]
    128a:	3301      	adds	r3, #1
    128c:	60bb      	str	r3, [r7, #8]
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    128e:	68bb      	ldr	r3, [r7, #8]
    1290:	781b      	ldrb	r3, [r3, #0]
    1292:	2b00      	cmp	r3, #0
    1294:	f47f ad17 	bne.w	cc6 <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    1298:	68fb      	ldr	r3, [r7, #12]
    129a:	2b00      	cmp	r3, #0
    129c:	d002      	beq.n	12a4 <am_util_stdio_vsprintf+0x5f4>
    {
        *pcBuf = 0x0;
    129e:	68fb      	ldr	r3, [r7, #12]
    12a0:	2200      	movs	r2, #0
    12a2:	701a      	strb	r2, [r3, #0]
    }

    return (ui32CharCnt);
    12a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    12a6:	4618      	mov	r0, r3
    12a8:	3754      	adds	r7, #84	; 0x54
    12aa:	46bd      	mov	sp, r7
    12ac:	bd90      	pop	{r4, r7, pc}
    12ae:	bf00      	nop
    12b0:	00302e30 	.word	0x00302e30
    12b4:	00232e23 	.word	0x00232e23
    12b8:	003f2e3f 	.word	0x003f2e3f

000012bc <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    12bc:	b40f      	push	{r0, r1, r2, r3}
    12be:	b580      	push	{r7, lr}
    12c0:	b082      	sub	sp, #8
    12c2:	af00      	add	r7, sp, #0

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    12c4:	f107 0314 	add.w	r3, r7, #20
    12c8:	603b      	str	r3, [r7, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    12ca:	683a      	ldr	r2, [r7, #0]
    12cc:	6939      	ldr	r1, [r7, #16]
    12ce:	4808      	ldr	r0, [pc, #32]	; (12f0 <am_util_stdio_printf+0x34>)
    12d0:	f7ff fcee 	bl	cb0 <am_util_stdio_vsprintf>
    12d4:	6078      	str	r0, [r7, #4]
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    12d6:	4b07      	ldr	r3, [pc, #28]	; (12f4 <am_util_stdio_printf+0x38>)
    12d8:	681b      	ldr	r3, [r3, #0]
    12da:	4805      	ldr	r0, [pc, #20]	; (12f0 <am_util_stdio_printf+0x34>)
    12dc:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
    12de:	687b      	ldr	r3, [r7, #4]
}
    12e0:	4618      	mov	r0, r3
    12e2:	3708      	adds	r7, #8
    12e4:	46bd      	mov	sp, r7
    12e6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    12ea:	b004      	add	sp, #16
    12ec:	4770      	bx	lr
    12ee:	bf00      	nop
    12f0:	10001094 	.word	0x10001094
    12f4:	10001578 	.word	0x10001578

000012f8 <am_util_stdio_terminal_clear>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_terminal_clear(void)
{
    12f8:	b580      	push	{r7, lr}
    12fa:	af00      	add	r7, sp, #0
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    12fc:	4802      	ldr	r0, [pc, #8]	; (1308 <am_util_stdio_terminal_clear+0x10>)
    12fe:	f7ff ffdd 	bl	12bc <am_util_stdio_printf>
}
    1302:	bf00      	nop
    1304:	bd80      	pop	{r7, pc}
    1306:	bf00      	nop
    1308:	000052c0 	.word	0x000052c0

0000130c <am_bsp_iom_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_iom_enable(uint32_t ui32Module)
{
    130c:	b5f0      	push	{r4, r5, r6, r7, lr}
    130e:	b083      	sub	sp, #12
    1310:	4604      	mov	r4, r0
    am_hal_iom_enable(ui32Module);
    1312:	f000 fcb9 	bl	1c88 <am_hal_iom_enable>

    //
    // Check that the MISO pin is defined in BSP and we are in SPI mode.
    //
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
    1316:	492a      	ldr	r1, [pc, #168]	; (13c0 <am_bsp_iom_enable+0xb4>)
    1318:	4a2a      	ldr	r2, [pc, #168]	; (13c4 <am_bsp_iom_enable+0xb8>)
    131a:	f851 3034 	ldr.w	r3, [r1, r4, lsl #3]
    131e:	4293      	cmp	r3, r2
    1320:	d04c      	beq.n	13bc <am_bsp_iom_enable+0xb0>
         (1 == AM_BFRn(IOMSTR, ui32Module, CFG, IFCSEL) ) )
    1322:	f504 20a0 	add.w	r0, r4, #327680	; 0x50000
    1326:	3004      	adds	r0, #4
    1328:	0305      	lsls	r5, r0, #12
    132a:	f8d5 611c 	ldr.w	r6, [r5, #284]	; 0x11c
    am_hal_iom_enable(ui32Module);

    //
    // Check that the MISO pin is defined in BSP and we are in SPI mode.
    //
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
    132e:	07f2      	lsls	r2, r6, #31
    1330:	d544      	bpl.n	13bc <am_bsp_iom_enable+0xb0>
         (1 == AM_BFRn(IOMSTR, ui32Module, CFG, IFCSEL) ) )
    {
        am_hal_gpio_pin_config(g_SPIpins[ui32Module][0],
    1332:	2b31      	cmp	r3, #49	; 0x31
    1334:	d842      	bhi.n	13bc <am_bsp_iom_enable+0xb0>
    1336:	f3ef 8710 	mrs	r7, PRIMASK
    133a:	9701      	str	r7, [sp, #4]
    133c:	b672      	cpsid	i
    133e:	eb01 0ec4 	add.w	lr, r1, r4, lsl #3
    1342:	4821      	ldr	r0, [pc, #132]	; (13c8 <am_bsp_iom_enable+0xbc>)
    1344:	f8de 2004 	ldr.w	r2, [lr, #4]
    1348:	f8df c084 	ldr.w	ip, [pc, #132]	; 13d0 <am_bsp_iom_enable+0xc4>
    134c:	4d1f      	ldr	r5, [pc, #124]	; (13cc <am_bsp_iom_enable+0xc0>)
    134e:	085c      	lsrs	r4, r3, #1
    1350:	f004 077c 	and.w	r7, r4, #124	; 0x7c
    1354:	009e      	lsls	r6, r3, #2
    1356:	2173      	movs	r1, #115	; 0x73
    1358:	6001      	str	r1, [r0, #0]
    135a:	f006 041c 	and.w	r4, r6, #28
    135e:	f3c2 2102 	ubfx	r1, r2, #8, #3
    1362:	2607      	movs	r6, #7
    1364:	fa01 fe04 	lsl.w	lr, r1, r4
    1368:	40a6      	lsls	r6, r4
    136a:	f857 400c 	ldr.w	r4, [r7, ip]
    136e:	ea24 0106 	bic.w	r1, r4, r6
    1372:	f003 06fc 	and.w	r6, r3, #252	; 0xfc
    1376:	ea4e 0401 	orr.w	r4, lr, r1
    137a:	f106 4e80 	add.w	lr, r6, #1073741824	; 0x40000000
    137e:	f847 400c 	str.w	r4, [r7, ip]
    1382:	f50e 3e80 	add.w	lr, lr, #65536	; 0x10000
    1386:	00db      	lsls	r3, r3, #3
    1388:	f003 0318 	and.w	r3, r3, #24
    138c:	21ff      	movs	r1, #255	; 0xff
    138e:	f8de 7000 	ldr.w	r7, [lr]
    1392:	4099      	lsls	r1, r3
    1394:	43c9      	mvns	r1, r1
    1396:	b2d4      	uxtb	r4, r2
    1398:	400f      	ands	r7, r1
    139a:	409c      	lsls	r4, r3
    139c:	433c      	orrs	r4, r7
    139e:	f8ce 4000 	str.w	r4, [lr]
    13a2:	5977      	ldr	r7, [r6, r5]
    13a4:	f3c2 4c07 	ubfx	ip, r2, #16, #8
    13a8:	fa0c f303 	lsl.w	r3, ip, r3
    13ac:	4039      	ands	r1, r7
    13ae:	430b      	orrs	r3, r1
    13b0:	2200      	movs	r2, #0
    13b2:	5173      	str	r3, [r6, r5]
    13b4:	6002      	str	r2, [r0, #0]
    13b6:	9801      	ldr	r0, [sp, #4]
    13b8:	f380 8810 	msr	PRIMASK, r0
                               g_SPIpins[ui32Module][1]);
    }
}
    13bc:	b003      	add	sp, #12
    13be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    13c0:	000052d4 	.word	0x000052d4
    13c4:	deadbeef 	.word	0xdeadbeef
    13c8:	40010060 	.word	0x40010060
    13cc:	400100e0 	.word	0x400100e0
    13d0:	40010040 	.word	0x40010040

000013d4 <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
    13d4:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_pwrctrl_bucks_init();
    13d6:	f002 fc1b 	bl	3c10 <am_hal_pwrctrl_bucks_init>

    //
    // Initialize for low power in the power control block
    //
    am_hal_pwrctrl_low_power_init();
    13da:	f002 fc87 	bl	3cec <am_hal_pwrctrl_low_power_init>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
    13de:	f002 fec3 	bl	4168 <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
    13e2:	2001      	movs	r0, #1
    13e4:	f002 fdba 	bl	3f5c <am_hal_rtc_osc_select>

    //
    // Stop the XT and LFRC.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
    13e8:	2001      	movs	r0, #1
    13ea:	f000 f905 	bl	15f8 <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
}
    13ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_LFRC);

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
    13f2:	f002 bdc1 	b.w	3f78 <am_hal_rtc_osc_disable>
    13f6:	bf00      	nop

000013f8 <am_bsp_debug_printf_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_enable(void)
{
    13f8:	b530      	push	{r4, r5, lr}
    am_hal_tpiu_config_t TPIUcfg;

    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    13fa:	4b17      	ldr	r3, [pc, #92]	; (1458 <am_bsp_debug_printf_enable+0x60>)
    13fc:	6818      	ldr	r0, [r3, #0]
    13fe:	f010 0401 	ands.w	r4, r0, #1
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_enable(void)
{
    1402:	b087      	sub	sp, #28
    am_hal_tpiu_config_t TPIUcfg;

    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    1404:	d001      	beq.n	140a <am_bsp_debug_printf_enable+0x12>
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    am_hal_tpiu_enable(&TPIUcfg);
    am_bsp_pin_enable(ITM_SWO);
}
    1406:	b007      	add	sp, #28
    1408:	bd30      	pop	{r4, r5, pc}
    }

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    140a:	4a14      	ldr	r2, [pc, #80]	; (145c <am_bsp_debug_printf_enable+0x64>)
    140c:	4914      	ldr	r1, [pc, #80]	; (1460 <am_bsp_debug_printf_enable+0x68>)
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

    //
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    140e:	4d15      	ldr	r5, [pc, #84]	; (1464 <am_bsp_debug_printf_enable+0x6c>)
    }

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    1410:	6011      	str	r1, [r2, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

    //
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    1412:	a806      	add	r0, sp, #24
    1414:	f840 5d14 	str.w	r5, [r0, #-20]!
    am_hal_tpiu_enable(&TPIUcfg);
    1418:	f002 fe50 	bl	40bc <am_hal_tpiu_enable>
    am_bsp_pin_enable(ITM_SWO);
    141c:	f3ef 8310 	mrs	r3, PRIMASK
    1420:	9300      	str	r3, [sp, #0]
    1422:	b672      	cpsid	i
    1424:	4a10      	ldr	r2, [pc, #64]	; (1468 <am_bsp_debug_printf_enable+0x70>)
    1426:	4d11      	ldr	r5, [pc, #68]	; (146c <am_bsp_debug_printf_enable+0x74>)
    1428:	4811      	ldr	r0, [pc, #68]	; (1470 <am_bsp_debug_printf_enable+0x78>)
    142a:	4912      	ldr	r1, [pc, #72]	; (1474 <am_bsp_debug_printf_enable+0x7c>)
    142c:	2373      	movs	r3, #115	; 0x73
    142e:	6013      	str	r3, [r2, #0]
    1430:	682b      	ldr	r3, [r5, #0]
    1432:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    1436:	602b      	str	r3, [r5, #0]
    1438:	6805      	ldr	r5, [r0, #0]
    143a:	f425 4c7f 	bic.w	ip, r5, #65280	; 0xff00
    143e:	f44c 5380 	orr.w	r3, ip, #4096	; 0x1000
    1442:	6003      	str	r3, [r0, #0]
    1444:	6808      	ldr	r0, [r1, #0]
    1446:	f420 457f 	bic.w	r5, r0, #65280	; 0xff00
    144a:	600d      	str	r5, [r1, #0]
    144c:	6014      	str	r4, [r2, #0]
    144e:	9c00      	ldr	r4, [sp, #0]
    1450:	f384 8810 	msr	PRIMASK, r4
}
    1454:	b007      	add	sp, #28
    1456:	bd30      	pop	{r4, r5, pc}
    1458:	10001198 	.word	0x10001198
    145c:	e0000e80 	.word	0xe0000e80
    1460:	00150511 	.word	0x00150511
    1464:	000f4240 	.word	0x000f4240
    1468:	40010060 	.word	0x40010060
    146c:	40010054 	.word	0x40010054
    1470:	40010028 	.word	0x40010028
    1474:	40010108 	.word	0x40010108

00001478 <am_bsp_itm_string_print>:
//
//*****************************************************************************
void
am_bsp_itm_string_print(char *pcString)
{
    am_hal_itm_print(pcString);
    1478:	f002 ba64 	b.w	3944 <am_hal_itm_print>

0000147c <am_hal_cachectrl_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_cachectrl_enable(const am_hal_cachectrl_config_t *psConfig)
{
    147c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    147e:	4604      	mov	r4, r0
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
    1480:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
                       AM_REG_CACHECTRL_CACHECFG_LRU( psConfig->ui32LRU )                                   |
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC0( (psConfig->ui32EnableNCregions & 0x1) >> 0 )   |
    1484:	78a7      	ldrb	r7, [r4, #2]
    // workaround for a timing issue with early versions of Apollo2 that caused
    // the cache to incorrectly mark itself valid during the startup sequence.
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    1486:	7863      	ldrb	r3, [r4, #1]
    1488:	78e2      	ldrb	r2, [r4, #3]
    148a:	7925      	ldrb	r5, [r4, #4]
    148c:	79a1      	ldrb	r1, [r4, #6]
    148e:	00be      	lsls	r6, r7, #2
    1490:	ea4f 0e43 	mov.w	lr, r3, lsl #1
    1494:	f006 0304 	and.w	r3, r6, #4
    1498:	f00e 0602 	and.w	r6, lr, #2
    149c:	431e      	orrs	r6, r3
    149e:	f042 0201 	orr.w	r2, r2, #1
    14a2:	79e3      	ldrb	r3, [r4, #7]
    14a4:	01ed      	lsls	r5, r5, #7
    14a6:	4316      	orrs	r6, r2
    14a8:	b2ed      	uxtb	r5, r5
    14aa:	7a22      	ldrb	r2, [r4, #8]
    14ac:	0289      	lsls	r1, r1, #10
    14ae:	432e      	orrs	r6, r5
    14b0:	f401 6180 	and.w	r1, r1, #1024	; 0x400
    14b4:	7a65      	ldrb	r5, [r4, #9]
    14b6:	02db      	lsls	r3, r3, #11
    14b8:	430e      	orrs	r6, r1
    14ba:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    14be:	0312      	lsls	r2, r2, #12
    14c0:	7aa1      	ldrb	r1, [r4, #10]
    14c2:	431e      	orrs	r6, r3
    14c4:	042d      	lsls	r5, r5, #16
    14c6:	b293      	uxth	r3, r2
    14c8:	7ae2      	ldrb	r2, [r4, #11]
    14ca:	431e      	orrs	r6, r3
    14cc:	0509      	lsls	r1, r1, #20
    14ce:	f405 2370 	and.w	r3, r5, #983040	; 0xf0000
    14d2:	0612      	lsls	r2, r2, #24
    14d4:	4333      	orrs	r3, r6
    14d6:	f401 1680 	and.w	r6, r1, #1048576	; 0x100000
    14da:	00bf      	lsls	r7, r7, #2
    14dc:	f002 7180 	and.w	r1, r2, #16777216	; 0x1000000
    14e0:	4333      	orrs	r3, r6
    14e2:	430b      	orrs	r3, r1
    14e4:	f007 0508 	and.w	r5, r7, #8
    14e8:	431d      	orrs	r5, r3
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
    14ea:	f002 fa89 	bl	3a00 <am_hal_pwrctrl_memory_enable>

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    14ee:	482c      	ldr	r0, [pc, #176]	; (15a0 <am_hal_cachectrl_enable+0x124>)
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    14f0:	4b2c      	ldr	r3, [pc, #176]	; (15a4 <am_hal_cachectrl_enable+0x128>)
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    14f2:	6005      	str	r5, [r0, #0]
    14f4:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    14f6:	681e      	ldr	r6, [r3, #0]
    14f8:	0777      	lsls	r7, r6, #29
    14fa:	d41e      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    14fc:	681f      	ldr	r7, [r3, #0]
    14fe:	077e      	lsls	r6, r7, #29
    1500:	f102 32ff 	add.w	r2, r2, #4294967295
    1504:	d419      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    1506:	6819      	ldr	r1, [r3, #0]
    1508:	074f      	lsls	r7, r1, #29
    150a:	d416      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    150c:	6818      	ldr	r0, [r3, #0]
    150e:	0746      	lsls	r6, r0, #29
    1510:	d413      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    1512:	681e      	ldr	r6, [r3, #0]
    1514:	0770      	lsls	r0, r6, #29
    1516:	d410      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    1518:	681f      	ldr	r7, [r3, #0]
    151a:	0779      	lsls	r1, r7, #29
    151c:	d40d      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    151e:	6819      	ldr	r1, [r3, #0]
    1520:	074f      	lsls	r7, r1, #29
    1522:	d40a      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    1524:	6818      	ldr	r0, [r3, #0]
    1526:	0746      	lsls	r6, r0, #29
    1528:	d407      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    152a:	681e      	ldr	r6, [r3, #0]
    152c:	0770      	lsls	r0, r6, #29
    152e:	d404      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    1530:	681f      	ldr	r7, [r3, #0]
    1532:	0779      	lsls	r1, r7, #29
    1534:	d401      	bmi.n	153a <am_hal_cachectrl_enable+0xbe>
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;

    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    1536:	3a09      	subs	r2, #9
    1538:	d1dd      	bne.n	14f6 <am_hal_cachectrl_enable+0x7a>
    }

    //
    // Manually invalidate the cache (workaround for the issue described above.)
    //
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);
    153a:	4b1a      	ldr	r3, [pc, #104]	; (15a4 <am_hal_cachectrl_enable+0x128>)
    153c:	681a      	ldr	r2, [r3, #0]
    153e:	f042 0101 	orr.w	r1, r2, #1
    1542:	6019      	str	r1, [r3, #0]
    1544:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    1546:	6818      	ldr	r0, [r3, #0]
    1548:	0740      	lsls	r0, r0, #29
    154a:	d41e      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    154c:	681e      	ldr	r6, [r3, #0]
    154e:	0771      	lsls	r1, r6, #29
    1550:	f102 32ff 	add.w	r2, r2, #4294967295
    1554:	d419      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    1556:	681f      	ldr	r7, [r3, #0]
    1558:	077f      	lsls	r7, r7, #29
    155a:	d416      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    155c:	6819      	ldr	r1, [r3, #0]
    155e:	074e      	lsls	r6, r1, #29
    1560:	d413      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    1562:	6818      	ldr	r0, [r3, #0]
    1564:	0740      	lsls	r0, r0, #29
    1566:	d410      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    1568:	681e      	ldr	r6, [r3, #0]
    156a:	0771      	lsls	r1, r6, #29
    156c:	d40d      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    156e:	681f      	ldr	r7, [r3, #0]
    1570:	077f      	lsls	r7, r7, #29
    1572:	d40a      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    1574:	6819      	ldr	r1, [r3, #0]
    1576:	074e      	lsls	r6, r1, #29
    1578:	d407      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    157a:	6818      	ldr	r0, [r3, #0]
    157c:	0740      	lsls	r0, r0, #29
    157e:	d404      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    1580:	681e      	ldr	r6, [r3, #0]
    1582:	0771      	lsls	r1, r6, #29
    1584:	d401      	bmi.n	158a <am_hal_cachectrl_enable+0x10e>
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);

    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    1586:	3a09      	subs	r2, #9
    1588:	d1dd      	bne.n	1546 <am_hal_cachectrl_enable+0xca>

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
    158a:	7964      	ldrb	r4, [r4, #5]
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    158c:	4f04      	ldr	r7, [pc, #16]	; (15a0 <am_hal_cachectrl_enable+0x124>)

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
    158e:	0223      	lsls	r3, r4, #8
    1590:	f403 7100 	and.w	r1, r3, #512	; 0x200
    1594:	f403 7280 	and.w	r2, r3, #256	; 0x100
    1598:	4311      	orrs	r1, r2
    159a:	4329      	orrs	r1, r5
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    159c:	6039      	str	r1, [r7, #0]
    159e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    15a0:	40018000 	.word	0x40018000
    15a4:	40018008 	.word	0x40018008

000015a8 <am_hal_clkgen_sysclk_select>:
//! @return None.
//
//*****************************************************************************
void
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
    15a8:	b510      	push	{r4, lr}
    am_hal_debug_assert_msg(ui32ClockSetting == AM_HAL_CLKGEN_SYSCLK_48MHZ,
    15aa:	4604      	mov	r4, r0
    15ac:	b120      	cbz	r0, 15b8 <am_hal_clkgen_sysclk_select+0x10>
    15ae:	4a06      	ldr	r2, [pc, #24]	; (15c8 <am_hal_clkgen_sysclk_select+0x20>)
    15b0:	4806      	ldr	r0, [pc, #24]	; (15cc <am_hal_clkgen_sysclk_select+0x24>)
    15b2:	2150      	movs	r1, #80	; 0x50
    15b4:	f000 f82a 	bl	160c <am_hal_debug_error>
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    15b8:	4b05      	ldr	r3, [pc, #20]	; (15d0 <am_hal_clkgen_sysclk_select+0x28>)

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    15ba:	4906      	ldr	r1, [pc, #24]	; (15d4 <am_hal_clkgen_sysclk_select+0x2c>)
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    15bc:	2047      	movs	r0, #71	; 0x47
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
    15be:	2200      	movs	r2, #0
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    15c0:	6018      	str	r0, [r3, #0]

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    15c2:	600c      	str	r4, [r1, #0]

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
    15c4:	601a      	str	r2, [r3, #0]
    15c6:	bd10      	pop	{r4, pc}
    15c8:	00005310 	.word	0x00005310
    15cc:	00005348 	.word	0x00005348
    15d0:	40004014 	.word	0x40004014
    15d4:	40004018 	.word	0x40004018

000015d8 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
    15d8:	4b04      	ldr	r3, [pc, #16]	; (15ec <am_hal_clkgen_sysclk_get+0x14>)

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
    15da:	4905      	ldr	r1, [pc, #20]	; (15f0 <am_hal_clkgen_sysclk_get+0x18>)
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
    15dc:	681a      	ldr	r2, [r3, #0]

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
    15de:	4805      	ldr	r0, [pc, #20]	; (15f4 <am_hal_clkgen_sysclk_get+0x1c>)
    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;

    switch ( ui32ClockSetting )
    15e0:	f012 0f01 	tst.w	r2, #1
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC_DIV2:
            return 24000000;
        default:
            return 0xFFFFFFFF;
    }
}
    15e4:	bf08      	it	eq
    15e6:	4608      	moveq	r0, r1
    15e8:	4770      	bx	lr
    15ea:	bf00      	nop
    15ec:	40004018 	.word	0x40004018
    15f0:	02dc6c00 	.word	0x02dc6c00
    15f4:	016e3600 	.word	0x016e3600

000015f8 <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    15f8:	0783      	lsls	r3, r0, #30
    15fa:	d003      	beq.n	1604 <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
    15fc:	4a02      	ldr	r2, [pc, #8]	; (1608 <am_hal_clkgen_osc_stop+0x10>)
    15fe:	6813      	ldr	r3, [r2, #0]
    1600:	4318      	orrs	r0, r3
    1602:	6010      	str	r0, [r2, #0]
    1604:	4770      	bx	lr
    1606:	bf00      	nop
    1608:	4000400c 	.word	0x4000400c

0000160c <am_hal_debug_error>:
__weak void
#else
void __attribute__((weak))
#endif
am_hal_debug_error(const char *pcFile, uint32_t ui32Line, const char *pcMessage)
{
    160c:	e7fe      	b.n	160c <am_hal_debug_error>
    160e:	bf00      	nop

00001610 <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1610:	4b01      	ldr	r3, [pc, #4]	; (1618 <am_hal_flash_delay+0x8>)
    1612:	6b59      	ldr	r1, [r3, #52]	; 0x34
    1614:	4708      	bx	r1
    1616:	bf00      	nop
    1618:	10001034 	.word	0x10001034

0000161c <am_hal_flash_delay_status_change>:
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
    161c:	2800      	cmp	r0, #0
    161e:	f000 80bb 	beq.w	1798 <am_hal_flash_delay_status_change+0x17c>
//
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    1622:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1626:	f100 3aff 	add.w	sl, r0, #4294967295
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    162a:	6808      	ldr	r0, [r1, #0]
    162c:	4010      	ands	r0, r2
    162e:	4283      	cmp	r3, r0
    1630:	f000 80ac 	beq.w	178c <am_hal_flash_delay_status_change+0x170>
    1634:	f01a 0907 	ands.w	r9, sl, #7
    1638:	461c      	mov	r4, r3
    163a:	4615      	mov	r5, r2
    163c:	460e      	mov	r6, r1
    163e:	f04f 0700 	mov.w	r7, #0
    1642:	f8df 8158 	ldr.w	r8, [pc, #344]	; 179c <am_hal_flash_delay_status_change+0x180>
    1646:	d056      	beq.n	16f6 <am_hal_flash_delay_status_change+0xda>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1648:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
    164c:	200c      	movs	r0, #12
    164e:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1650:	6831      	ldr	r1, [r6, #0]
    1652:	4029      	ands	r1, r5
    1654:	42a1      	cmp	r1, r4
    1656:	f04f 0701 	mov.w	r7, #1
    165a:	f000 8097 	beq.w	178c <am_hal_flash_delay_status_change+0x170>
    165e:	45b9      	cmp	r9, r7
    1660:	d049      	beq.n	16f6 <am_hal_flash_delay_status_change+0xda>
    1662:	f1b9 0f02 	cmp.w	r9, #2
    1666:	d03c      	beq.n	16e2 <am_hal_flash_delay_status_change+0xc6>
    1668:	f1b9 0f03 	cmp.w	r9, #3
    166c:	d02f      	beq.n	16ce <am_hal_flash_delay_status_change+0xb2>
    166e:	f1b9 0f04 	cmp.w	r9, #4
    1672:	d022      	beq.n	16ba <am_hal_flash_delay_status_change+0x9e>
    1674:	f1b9 0f05 	cmp.w	r9, #5
    1678:	d015      	beq.n	16a6 <am_hal_flash_delay_status_change+0x8a>
    167a:	f1b9 0f06 	cmp.w	r9, #6
    167e:	d008      	beq.n	1692 <am_hal_flash_delay_status_change+0x76>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1680:	200c      	movs	r0, #12
    1682:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
    1686:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1688:	6830      	ldr	r0, [r6, #0]
    168a:	4028      	ands	r0, r5
    168c:	42a0      	cmp	r0, r4
    168e:	443f      	add	r7, r7
    1690:	d07c      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1692:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
    1696:	200c      	movs	r0, #12
    1698:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    169a:	6831      	ldr	r1, [r6, #0]
    169c:	4029      	ands	r1, r5
    169e:	42a1      	cmp	r1, r4
    16a0:	f107 0701 	add.w	r7, r7, #1
    16a4:	d072      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    16a6:	200c      	movs	r0, #12
    16a8:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
    16ac:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    16ae:	6830      	ldr	r0, [r6, #0]
    16b0:	4028      	ands	r0, r5
    16b2:	42a0      	cmp	r0, r4
    16b4:	f107 0701 	add.w	r7, r7, #1
    16b8:	d068      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    16ba:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
    16be:	200c      	movs	r0, #12
    16c0:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    16c2:	6831      	ldr	r1, [r6, #0]
    16c4:	4029      	ands	r1, r5
    16c6:	42a1      	cmp	r1, r4
    16c8:	f107 0701 	add.w	r7, r7, #1
    16cc:	d05e      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    16ce:	200c      	movs	r0, #12
    16d0:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
    16d4:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    16d6:	6830      	ldr	r0, [r6, #0]
    16d8:	4028      	ands	r0, r5
    16da:	42a0      	cmp	r0, r4
    16dc:	f107 0701 	add.w	r7, r7, #1
    16e0:	d054      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    16e2:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
    16e6:	200c      	movs	r0, #12
    16e8:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    16ea:	6831      	ldr	r1, [r6, #0]
    16ec:	4029      	ands	r1, r5
    16ee:	42a1      	cmp	r1, r4
    16f0:	f107 0701 	add.w	r7, r7, #1
    16f4:	d04a      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    16f6:	200c      	movs	r0, #12
    16f8:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
    16fc:	4790      	blx	r2
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
    16fe:	4557      	cmp	r7, sl
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1700:	f04f 000c 	mov.w	r0, #12
    1704:	f107 0708 	add.w	r7, r7, #8
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
    1708:	d043      	beq.n	1792 <am_hal_flash_delay_status_change+0x176>
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    170a:	6833      	ldr	r3, [r6, #0]
    170c:	402b      	ands	r3, r5
    170e:	42a3      	cmp	r3, r4
    1710:	d03c      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1712:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
    1716:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1718:	6832      	ldr	r2, [r6, #0]
    171a:	402a      	ands	r2, r5
    171c:	42a2      	cmp	r2, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    171e:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1722:	d033      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1724:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
    1728:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    172a:	6831      	ldr	r1, [r6, #0]
    172c:	4029      	ands	r1, r5
    172e:	42a1      	cmp	r1, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1730:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1734:	d02a      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1736:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
    173a:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    173c:	6833      	ldr	r3, [r6, #0]
    173e:	402b      	ands	r3, r5
    1740:	42a3      	cmp	r3, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1742:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1746:	d021      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1748:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
    174c:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    174e:	6832      	ldr	r2, [r6, #0]
    1750:	402a      	ands	r2, r5
    1752:	42a2      	cmp	r2, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1754:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1758:	d018      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    175a:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
    175e:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1760:	6831      	ldr	r1, [r6, #0]
    1762:	4029      	ands	r1, r5
    1764:	42a1      	cmp	r1, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1766:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    176a:	d00f      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    176c:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
    1770:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1772:	6833      	ldr	r3, [r6, #0]
    1774:	402b      	ands	r3, r5
    1776:	42a3      	cmp	r3, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    1778:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    177c:	d006      	beq.n	178c <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    177e:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
    1782:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    1784:	6830      	ldr	r0, [r6, #0]
    1786:	4028      	ands	r0, r5
    1788:	42a0      	cmp	r0, r4
    178a:	d1b4      	bne.n	16f6 <am_hal_flash_delay_status_change+0xda>
        {
            return 1;
    178c:	2001      	movs	r0, #1
    178e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        // Call the BOOTROM cycle function to delay for about 1 microsecond.
        //
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
    }

    return 0;
    1792:	2000      	movs	r0, #0
    1794:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1798:	2000      	movs	r0, #0
} // am_hal_flash_delay_status_change()
    179a:	4770      	bx	lr
    179c:	10001034 	.word	0x10001034

000017a0 <am_hal_interrupt_enable>:
am_hal_interrupt_enable(uint32_t ui32Interrupt)
{
    //
    // Check to see what type of interrupt this is.
    //
    if ( ui32Interrupt > 15 )
    17a0:	280f      	cmp	r0, #15
    17a2:	d80b      	bhi.n	17bc <am_hal_interrupt_enable+0x1c>
    {
        //
        // If this is an ARM internal interrupt number, route it to the
        // appropriate enable register.
        //
        switch(ui32Interrupt)
    17a4:	2805      	cmp	r0, #5
    17a6:	d013      	beq.n	17d0 <am_hal_interrupt_enable+0x30>
    17a8:	2806      	cmp	r0, #6
    17aa:	d017      	beq.n	17dc <am_hal_interrupt_enable+0x3c>
    17ac:	2804      	cmp	r0, #4
    17ae:	d104      	bne.n	17ba <am_hal_interrupt_enable+0x1a>
            case AM_HAL_INTERRUPT_USAGEFAULT:
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
            break;

            case AM_HAL_INTERRUPT_MPUFAULT:
                AM_BFW(SYSCTRL, SHCSR, MEMFAULTENA, 1);
    17b0:	4a0d      	ldr	r2, [pc, #52]	; (17e8 <am_hal_interrupt_enable+0x48>)
    17b2:	6813      	ldr	r3, [r2, #0]
    17b4:	f443 3080 	orr.w	r0, r3, #65536	; 0x10000
    17b8:	6010      	str	r0, [r2, #0]
    17ba:	4770      	bx	lr
    {
        //
        // If this ISR number corresponds to a "normal" peripheral interrupt,
        // enable it using the NVIC register.
        //
        AM_REG(NVIC, ISER0) = 0x1 << ((ui32Interrupt - 16) & 0x1F);
    17bc:	f1a0 0310 	sub.w	r3, r0, #16
    17c0:	f003 0c1f 	and.w	ip, r3, #31
    17c4:	2001      	movs	r0, #1
    17c6:	4909      	ldr	r1, [pc, #36]	; (17ec <am_hal_interrupt_enable+0x4c>)
    17c8:	fa00 f20c 	lsl.w	r2, r0, ip
    17cc:	600a      	str	r2, [r1, #0]
    17ce:	4770      	bx	lr
        // appropriate enable register.
        //
        switch(ui32Interrupt)
        {
            case AM_HAL_INTERRUPT_BUSFAULT:
                AM_BFW(SYSCTRL, SHCSR, BUSFAULTENA, 1);
    17d0:	4805      	ldr	r0, [pc, #20]	; (17e8 <am_hal_interrupt_enable+0x48>)
    17d2:	6801      	ldr	r1, [r0, #0]
    17d4:	f441 3200 	orr.w	r2, r1, #131072	; 0x20000
    17d8:	6002      	str	r2, [r0, #0]
            break;
    17da:	4770      	bx	lr

            case AM_HAL_INTERRUPT_USAGEFAULT:
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
    17dc:	4902      	ldr	r1, [pc, #8]	; (17e8 <am_hal_interrupt_enable+0x48>)
    17de:	680a      	ldr	r2, [r1, #0]
    17e0:	f442 2380 	orr.w	r3, r2, #262144	; 0x40000
    17e4:	600b      	str	r3, [r1, #0]
            break;
    17e6:	4770      	bx	lr
    17e8:	e000ed24 	.word	0xe000ed24
    17ec:	e000e100 	.word	0xe000e100

000017f0 <am_hal_interrupt_master_enable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_enable(void)
{
    __asm("    mrs     r0, PRIMASK");
    17f0:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsie i");
    17f4:	b662      	cpsie	i
    __asm("    bx lr");
    17f6:	4770      	bx	lr

000017f8 <am_hal_interrupt_master_disable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
    17f8:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
    17fc:	b672      	cpsid	i
    __asm("    bx lr");
    17fe:	4770      	bx	lr

00001800 <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
    1800:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
    1804:	4770      	bx	lr
    1806:	bf00      	nop

00001808 <iom_workaround_loop>:
                    bool bRising)
{
    //
    // Check to see if this is a "rising edge" or "falling edge" detector.
    //
    __asm("    cbz      r2, falling_edge");
    1808:	b132      	cbz	r2, 1818 <falling_edge>

0000180a <rising_edge>:

    //
    // Read GPIO pin 44, and loop until it's HIGH.
    //
    __asm("rising_edge:");
    __asm("    ldr      r2, =0x40010084");
    180a:	4a07      	ldr	r2, [pc, #28]	; (1828 <falling_check_mosi+0xe>)

0000180c <rising_check_mosi>:
    __asm("rising_check_mosi:");
    __asm("    ldr      r3, [r2]");
    180c:	6813      	ldr	r3, [r2, #0]
    __asm("    ands     r3, r3, #0x1000");
    180e:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
    __asm("    beq      rising_check_mosi");
    1812:	d0fb      	beq.n	180c <rising_check_mosi>

    //
    // Write the PADREG Value to the PADREG register.
    //
    __asm("    str     r0, [r1]");
    1814:	6008      	str	r0, [r1, #0]
    __asm("    bx      lr");
    1816:	4770      	bx	lr

00001818 <falling_edge>:

    //
    // Read GPIO pin 44, and loop until it's LOW.
    //
    __asm("falling_edge:");
    __asm("    ldr      r2, =0x40010084");
    1818:	4a03      	ldr	r2, [pc, #12]	; (1828 <falling_check_mosi+0xe>)

0000181a <falling_check_mosi>:
    __asm("falling_check_mosi:");
    __asm("    ldr      r3, [r2]");
    181a:	6813      	ldr	r3, [r2, #0]
    __asm("    ands     r3, r3, #0x1000");
    181c:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
    __asm("    bne      falling_check_mosi");
    1820:	d1fb      	bne.n	181a <falling_check_mosi>

    //
    // Write the PADREG Value to the PADREG register.
    //
    __asm("    str     r0, [r1]");
    1822:	6008      	str	r0, [r1, #0]
    __asm("    bx      lr");
    1824:	4770      	bx	lr
    1826:	0000      	.short	0x0000
    1828:	40010084 	.word	0x40010084

0000182c <am_hal_iom_sleeping_queue_flush>:
    uint32_t ui32Critical;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    182c:	2805      	cmp	r0, #5
    182e:	d819      	bhi.n	1864 <am_hal_iom_sleeping_queue_flush+0x38>
//! implementations expect to control sleep behavior).
//
//*****************************************************************************
void
am_hal_iom_sleeping_queue_flush(uint32_t ui32Module)
{
    1830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1832:	4b0d      	ldr	r3, [pc, #52]	; (1868 <am_hal_iom_sleeping_queue_flush+0x3c>)
    1834:	4e0d      	ldr	r6, [pc, #52]	; (186c <am_hal_iom_sleeping_queue_flush+0x40>)

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
            am_hal_queue_empty(&g_psIOMQueue[ui32Module]) )
    1836:	eb00 0740 	add.w	r7, r0, r0, lsl #1
    183a:	4604      	mov	r4, r0
    183c:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
    while ( bWaiting )
    {
        //
        // Start a critical section.
        //
        ui32Critical = am_hal_interrupt_master_disable();
    1840:	f7ff ffda 	bl	17f8 <am_hal_interrupt_master_disable>

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
    1844:	5d31      	ldrb	r1, [r6, r4]
    while ( bWaiting )
    {
        //
        // Start a critical section.
        //
        ui32Critical = am_hal_interrupt_master_disable();
    1846:	4605      	mov	r5, r0

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
    1848:	b929      	cbnz	r1, 1856 <am_hal_iom_sleeping_queue_flush+0x2a>
    184a:	68ba      	ldr	r2, [r7, #8]
    184c:	b91a      	cbnz	r2, 1856 <am_hal_iom_sleeping_queue_flush+0x2a>
        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
    }
}
    184e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        }

        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
    1852:	f7ff bfd5 	b.w	1800 <am_hal_interrupt_master_set>
        else
        {
            //
            // Otherwise, we should sleep until the interface is actually free.
            //
            am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_NORMAL);
    1856:	2000      	movs	r0, #0
    1858:	f002 fb96 	bl	3f88 <am_hal_sysctrl_sleep>
        }

        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
    185c:	4628      	mov	r0, r5
    185e:	f7ff ffcf 	bl	1800 <am_hal_interrupt_master_set>
    1862:	e7ed      	b.n	1840 <am_hal_iom_sleeping_queue_flush+0x14>
    1864:	4770      	bx	lr
    1866:	bf00      	nop
    1868:	1000160c 	.word	0x1000160c
    186c:	100011a4 	.word	0x100011a4

00001870 <am_hal_iom_i2c_cmd_run.part.1>:
//!
//! @return 0 on success
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_cmd_run(uint32_t ui32Operation, uint32_t ui32Module,
    1870:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1874:	b089      	sub	sp, #36	; 0x24
    for ( index = 0; index < (sizeof(g_I2CPads) / sizeof(I2CPad_t)); index++ )
    {
        //
        //  Is this for the IOM that we are using?
        //
        if ( g_I2CPads[index].module == ui32Module )
    1876:	2900      	cmp	r1, #0
    1878:	d06a      	beq.n	1950 <am_hal_iom_i2c_cmd_run.part.1+0xe0>
    187a:	2901      	cmp	r1, #1
    187c:	d00d      	beq.n	189a <am_hal_iom_i2c_cmd_run.part.1+0x2a>
    187e:	2902      	cmp	r1, #2
    1880:	d01a      	beq.n	18b8 <am_hal_iom_i2c_cmd_run.part.1+0x48>
    1882:	2903      	cmp	r1, #3
    1884:	d030      	beq.n	18e8 <am_hal_iom_i2c_cmd_run.part.1+0x78>
    1886:	2904      	cmp	r1, #4
    1888:	d040      	beq.n	190c <am_hal_iom_i2c_cmd_run.part.1+0x9c>
    188a:	2905      	cmp	r1, #5
    188c:	d050      	beq.n	1930 <am_hal_iom_i2c_cmd_run.part.1+0xc0>
    188e:	2902      	cmp	r1, #2
    1890:	d019      	beq.n	18c6 <am_hal_iom_i2c_cmd_run.part.1+0x56>
        }
    }
    if (0xDEADBEEF == ui32IOMGPIO)
    {
        // SCL has not been configured
        return AM_HAL_IOM_ERR_INVALID_CFG;
    1892:	2004      	movs	r0, #4
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    }
    return ui32Status;
}
    1894:	b009      	add	sp, #36	; 0x24
    1896:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    189a:	4d6f      	ldr	r5, [pc, #444]	; (1a58 <am_hal_iom_i2c_cmd_run.part.1+0x1e8>)
    189c:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
    189e:	f3c7 04c2 	ubfx	r4, r7, #3, #3
    18a2:	2c00      	cmp	r4, #0
    18a4:	d1f5      	bne.n	1892 <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    18a6:	f04f 0e08 	mov.w	lr, #8
    18aa:	26ff      	movs	r6, #255	; 0xff
    18ac:	9403      	str	r4, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    18ae:	46f3      	mov	fp, lr
    18b0:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    18b4:	9604      	str	r6, [sp, #16]
    18b6:	e05b      	b.n	1970 <am_hal_iom_i2c_cmd_run.part.1+0x100>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    18b8:	4d68      	ldr	r5, [pc, #416]	; (1a5c <am_hal_iom_i2c_cmd_run.part.1+0x1ec>)
    18ba:	682c      	ldr	r4, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
    18bc:	f3c4 06c2 	ubfx	r6, r4, #3, #3
    18c0:	2e07      	cmp	r6, #7
    18c2:	f000 80c1 	beq.w	1a48 <am_hal_iom_i2c_cmd_run.part.1+0x1d8>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    18c6:	4d66      	ldr	r5, [pc, #408]	; (1a60 <am_hal_iom_i2c_cmd_run.part.1+0x1f0>)
    18c8:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
    18ca:	f3c7 64c2 	ubfx	r4, r7, #27, #3
    18ce:	2c04      	cmp	r4, #4
    18d0:	d1df      	bne.n	1892 <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    18d2:	2618      	movs	r6, #24
    18d4:	f04f 0e1b 	mov.w	lr, #27
    18d8:	f04f 477f 	mov.w	r7, #4278190080	; 0xff000000
    18dc:	9603      	str	r6, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    18de:	46b3      	mov	fp, r6
    18e0:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    18e4:	9704      	str	r7, [sp, #16]
    18e6:	e043      	b.n	1970 <am_hal_iom_i2c_cmd_run.part.1+0x100>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    18e8:	4d5e      	ldr	r5, [pc, #376]	; (1a64 <am_hal_iom_i2c_cmd_run.part.1+0x1f4>)
    18ea:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
    18ec:	f3c7 44c2 	ubfx	r4, r7, #19, #3
    18f0:	2c04      	cmp	r4, #4
    18f2:	d1ce      	bne.n	1892 <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    18f4:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
    18f8:	f44f 067f 	mov.w	r6, #16711680	; 0xff0000
    18fc:	2710      	movs	r7, #16
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    18fe:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    1902:	9604      	str	r6, [sp, #16]
    1904:	9703      	str	r7, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    1906:	f04f 0b28 	mov.w	fp, #40	; 0x28
    190a:	e031      	b.n	1970 <am_hal_iom_i2c_cmd_run.part.1+0x100>
    190c:	4d56      	ldr	r5, [pc, #344]	; (1a68 <am_hal_iom_i2c_cmd_run.part.1+0x1f8>)
    190e:	682e      	ldr	r6, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
    1910:	f3c6 67c2 	ubfx	r7, r6, #27, #3
    1914:	2f04      	cmp	r7, #4
    1916:	d1bc      	bne.n	1892 <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    1918:	f04f 0e27 	mov.w	lr, #39	; 0x27
    191c:	f04f 447f 	mov.w	r4, #4278190080	; 0xff000000
    1920:	2618      	movs	r6, #24
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    1922:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    1926:	9404      	str	r4, [sp, #16]
    1928:	9603      	str	r6, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    192a:	f04f 0b24 	mov.w	fp, #36	; 0x24
    192e:	e01f      	b.n	1970 <am_hal_iom_i2c_cmd_run.part.1+0x100>
    1930:	4d4e      	ldr	r5, [pc, #312]	; (1a6c <am_hal_iom_i2c_cmd_run.part.1+0x1fc>)
    1932:	682c      	ldr	r4, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
    1934:	f3c4 06c2 	ubfx	r6, r4, #3, #3
    1938:	2e04      	cmp	r6, #4
    193a:	d1aa      	bne.n	1892 <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    193c:	f04f 0e30 	mov.w	lr, #48	; 0x30
    1940:	27ff      	movs	r7, #255	; 0xff
    1942:	2400      	movs	r4, #0
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    1944:	46f3      	mov	fp, lr
    1946:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    194a:	9704      	str	r7, [sp, #16]
    194c:	9403      	str	r4, [sp, #12]
    194e:	e00f      	b.n	1970 <am_hal_iom_i2c_cmd_run.part.1+0x100>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    1950:	4d47      	ldr	r5, [pc, #284]	; (1a70 <am_hal_iom_i2c_cmd_run.part.1+0x200>)
    1952:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
    1954:	f417 5f60 	tst.w	r7, #14336	; 0x3800
    1958:	d19b      	bne.n	1892 <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    195a:	f04f 0e05 	mov.w	lr, #5
    195e:	f44f 447f 	mov.w	r4, #65280	; 0xff00
    1962:	2608      	movs	r6, #8
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    1964:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    1968:	9404      	str	r4, [sp, #16]
    196a:	9603      	str	r6, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    196c:	f04f 0b04 	mov.w	fp, #4
    1970:	461e      	mov	r6, r3
    //
    // Save the locations and values of the SCL pin configuration
    // information.
    //
    pui32SCLPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32SCLPadregVal = *pui32SCLPadreg;
    1972:	682b      	ldr	r3, [r5, #0]
    1974:	9001      	str	r0, [sp, #4]
    1976:	460c      	mov	r4, r1
    //
    // Temporarily configure the override pin as an input.
    //
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_PIN_INPUT);
    1978:	f3ef 8010 	mrs	r0, PRIMASK
    197c:	4690      	mov	r8, r2
    //
    // Save the locations and values of the SCL pin configuration
    // information.
    //
    pui32SCLPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32SCLPadregVal = *pui32SCLPadreg;
    197e:	9302      	str	r3, [sp, #8]
    //
    // Temporarily configure the override pin as an input.
    //
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_PIN_INPUT);
    1980:	9007      	str	r0, [sp, #28]
    1982:	b672      	cpsid	i
    1984:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 1a84 <am_hal_iom_i2c_cmd_run.part.1+0x214>
    1988:	4f3a      	ldr	r7, [pc, #232]	; (1a74 <am_hal_iom_i2c_cmd_run.part.1+0x204>)
    198a:	f8df c0fc 	ldr.w	ip, [pc, #252]	; 1a88 <am_hal_iom_i2c_cmd_run.part.1+0x218>
    198e:	ea4f 015e 	mov.w	r1, lr, lsr #1
    1992:	f001 037c 	and.w	r3, r1, #124	; 0x7c
    1996:	f04f 0a73 	mov.w	sl, #115	; 0x73
    199a:	f8c9 a000 	str.w	sl, [r9]
    199e:	ea4f 008e 	mov.w	r0, lr, lsl #2
    19a2:	59da      	ldr	r2, [r3, r7]
    19a4:	f000 001c 	and.w	r0, r0, #28
    19a8:	2107      	movs	r1, #7
    19aa:	4081      	lsls	r1, r0
    19ac:	ea22 0201 	bic.w	r2, r2, r1
    19b0:	51da      	str	r2, [r3, r7]
    19b2:	9b04      	ldr	r3, [sp, #16]
    19b4:	682f      	ldr	r7, [r5, #0]
    19b6:	9803      	ldr	r0, [sp, #12]
    19b8:	43da      	mvns	r2, r3
    19ba:	211a      	movs	r1, #26
    19bc:	4017      	ands	r7, r2
    19be:	4081      	lsls	r1, r0
    19c0:	4339      	orrs	r1, r7
    19c2:	6029      	str	r1, [r5, #0]
    19c4:	f85b 300c 	ldr.w	r3, [fp, ip]
    19c8:	2700      	movs	r7, #0
    19ca:	401a      	ands	r2, r3
    19cc:	f84b 200c 	str.w	r2, [fp, ip]
    19d0:	f8c9 7000 	str.w	r7, [r9]
    19d4:	9a07      	ldr	r2, [sp, #28]
    19d6:	f382 8810 	msr	PRIMASK, r2

    //
    // Make sure SCL is high within standard timeout
    //
    waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    19da:	9b05      	ldr	r3, [sp, #20]
    19dc:	4926      	ldr	r1, [pc, #152]	; (1a78 <am_hal_iom_i2c_cmd_run.part.1+0x208>)
    19de:	4827      	ldr	r0, [pc, #156]	; (1a7c <am_hal_iom_i2c_cmd_run.part.1+0x20c>)
    19e0:	f003 021f 	and.w	r2, r3, #31
    19e4:	f04f 0b01 	mov.w	fp, #1
    19e8:	ea4f 03de 	mov.w	r3, lr, lsr #3
    19ec:	f003 0e04 	and.w	lr, r3, #4
    19f0:	fa0b f302 	lsl.w	r3, fp, r2
    19f4:	4471      	add	r1, lr
    19f6:	461a      	mov	r2, r3
    19f8:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
    19fc:	f7ff fe0e 	bl	161c <am_hal_flash_delay_status_change>
    //
    // Write the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    // Revert back the original settings
    *pui32SCLPadreg = ui32SCLPadregVal;
    1a00:	9902      	ldr	r1, [sp, #8]
                 AM_HAL_GPIO_RD_M(ui32IOMGPIO));

    //
    // Write the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    1a02:	f8c9 a000 	str.w	sl, [r9]
    //
    // Re-lock the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = 0;

    if (waitStatus != 1)
    1a06:	4558      	cmp	r0, fp
    //
    // Write the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    // Revert back the original settings
    *pui32SCLPadreg = ui32SCLPadregVal;
    1a08:	6029      	str	r1, [r5, #0]
    //
    // Re-lock the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = 0;
    1a0a:	f8c9 7000 	str.w	r7, [r9]

    if (waitStatus != 1)
    1a0e:	d003      	beq.n	1a18 <am_hal_iom_i2c_cmd_run.part.1+0x1a8>
    {
        return AM_HAL_IOM_ERR_TIMEOUT;
    1a10:	4658      	mov	r0, fp
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    }
    return ui32Status;
}
    1a12:	b009      	add	sp, #36	; 0x24
    1a14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= (ui32Options & 0x5C00FF00);
    1a18:	9812      	ldr	r0, [sp, #72]	; 0x48
    1a1a:	4d19      	ldr	r5, [pc, #100]	; (1a80 <am_hal_iom_i2c_cmd_run.part.1+0x210>)
    1a1c:	f020 4223 	bic.w	r2, r0, #2734686208	; 0xa3000000
    1a20:	9801      	ldr	r0, [sp, #4]
    1a22:	ea4f 4308 	mov.w	r3, r8, lsl #16
    1a26:	f002 21ff 	and.w	r1, r2, #4278255360	; 0xff00ff00
    if (ui32Status == AM_HAL_IOM_SUCCESS)
    {
        //
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    1a2a:	f504 24a0 	add.w	r4, r4, #327680	; 0x50000
    1a2e:	3404      	adds	r4, #4
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= (ui32Options & 0x5C00FF00);
    1a30:	401d      	ands	r5, r3
    1a32:	4301      	orrs	r1, r0
    if (ui32Status == AM_HAL_IOM_SUCCESS)
    {
        //
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    1a34:	0322      	lsls	r2, r4, #12
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= (ui32Options & 0x5C00FF00);
    1a36:	4329      	orrs	r1, r5
    1a38:	b2f6      	uxtb	r6, r6
    1a3a:	430e      	orrs	r6, r1
    if (ui32Status == AM_HAL_IOM_SUCCESS)
    {
        //
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    1a3c:	4638      	mov	r0, r7
    1a3e:	f8c2 6110 	str.w	r6, [r2, #272]	; 0x110
    }
    return ui32Status;
}
    1a42:	b009      	add	sp, #36	; 0x24
    1a44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    1a48:	2400      	movs	r4, #0
    1a4a:	26ff      	movs	r6, #255	; 0xff
    1a4c:	9403      	str	r4, [sp, #12]
    1a4e:	46a6      	mov	lr, r4
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
    1a50:	46a3      	mov	fp, r4
    1a52:	9405      	str	r4, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
    1a54:	9604      	str	r6, [sp, #16]
    1a56:	e78b      	b.n	1970 <am_hal_iom_i2c_cmd_run.part.1+0x100>
    1a58:	40010008 	.word	0x40010008
    1a5c:	40010000 	.word	0x40010000
    1a60:	40010018 	.word	0x40010018
    1a64:	40010028 	.word	0x40010028
    1a68:	40010024 	.word	0x40010024
    1a6c:	40010030 	.word	0x40010030
    1a70:	40010004 	.word	0x40010004
    1a74:	40010040 	.word	0x40010040
    1a78:	40010080 	.word	0x40010080
    1a7c:	1000157c 	.word	0x1000157c
    1a80:	03ff0000 	.word	0x03ff0000
    1a84:	40010060 	.word	0x40010060
    1a88:	400100e0 	.word	0x400100e0

00001a8c <am_hal_iom_i2c_write_nb.part.8>:
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
    1a8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    //
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    1a90:	2806      	cmp	r0, #6
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
    1a92:	b084      	sub	sp, #16
    1a94:	460e      	mov	r6, r1

    //
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    1a96:	d024      	beq.n	1ae2 <am_hal_iom_i2c_write_nb.part.8+0x56>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    1a98:	2bff      	cmp	r3, #255	; 0xff
    1a9a:	4604      	mov	r4, r0
    1a9c:	d905      	bls.n	1aaa <am_hal_iom_i2c_write_nb.part.8+0x1e>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    1a9e:	4e6a      	ldr	r6, [pc, #424]	; (1c48 <am_hal_iom_i2c_write_nb.part.8+0x1bc>)
    1aa0:	2003      	movs	r0, #3
    1aa2:	5530      	strb	r0, [r6, r4]
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
    1aa4:	b004      	add	sp, #16
    1aa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1aaa:	f500 25a0 	add.w	r5, r0, #327680	; 0x50000
    1aae:	3504      	adds	r5, #4
    1ab0:	032d      	lsls	r5, r5, #12
    1ab2:	4617      	mov	r7, r2
    1ab4:	f8d5 211c 	ldr.w	r2, [r5, #284]	; 0x11c
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
    1ab8:	4964      	ldr	r1, [pc, #400]	; (1c4c <am_hal_iom_i2c_write_nb.part.8+0x1c0>)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1aba:	f012 0f08 	tst.w	r2, #8
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
    1abe:	f04f 0001 	mov.w	r0, #1

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1ac2:	f240 72ff 	movw	r2, #2047	; 0x7ff
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1ac6:	bf0c      	ite	eq
    1ac8:	f04f 0880 	moveq.w	r8, #128	; 0x80
    1acc:	f04f 0840 	movne.w	r8, #64	; 0x40
    uint32_t ui32Index;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1ad0:	2c05      	cmp	r4, #5
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
    1ad2:	5508      	strb	r0, [r1, r4]

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1ad4:	f8c5 2208 	str.w	r2, [r5, #520]	; 0x208
    uint32_t ui32Index;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1ad8:	d92b      	bls.n	1b32 <am_hal_iom_i2c_write_nb.part.8+0xa6>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1ada:	2000      	movs	r0, #0
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
    1adc:	b004      	add	sp, #16
    1ade:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
    1ae2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    1ae4:	0048      	lsls	r0, r1, #1
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
    1ae6:	0061      	lsls	r1, r4, #1
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    1ae8:	f3c4 7500 	ubfx	r5, r4, #28, #1
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
    1aec:	d415      	bmi.n	1b1a <am_hal_iom_i2c_write_nb.part.8+0x8e>
                                     (uint8_t *)pui32Data, 0, false,
                                     (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    1aee:	2401      	movs	r4, #1
    1af0:	e88d 0030 	stmia.w	sp, {r4, r5}
    1af4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    1af6:	4619      	mov	r1, r3
    1af8:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    1afc:	f3c5 2307 	ubfx	r3, r5, #8, #8
    1b00:	f003 f802 	bl	4b08 <am_hal_i2c_bit_bang_send>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    1b04:	4952      	ldr	r1, [pc, #328]	; (1c50 <am_hal_iom_i2c_write_nb.part.8+0x1c4>)
    1b06:	4a50      	ldr	r2, [pc, #320]	; (1c48 <am_hal_iom_i2c_write_nb.part.8+0x1bc>)
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
    1b08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    1b0a:	5c0f      	ldrb	r7, [r1, r0]
    1b0c:	7197      	strb	r7, [r2, #6]
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
    1b0e:	b173      	cbz	r3, 1b2e <am_hal_iom_i2c_write_nb.part.8+0xa2>
        {
            pfnCallback();
    1b10:	4798      	blx	r3
        }
        return ui32Status;
    1b12:	4638      	mov	r0, r7
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
    1b14:	b004      	add	sp, #16
    1b16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    1b1a:	2400      	movs	r4, #0
    1b1c:	4619      	mov	r1, r3
    1b1e:	e88d 0030 	stmia.w	sp, {r4, r5}
    1b22:	4623      	mov	r3, r4
    1b24:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    1b28:	f002 ffee 	bl	4b08 <am_hal_i2c_bit_bang_send>
    1b2c:	e7ea      	b.n	1b04 <am_hal_iom_i2c_write_nb.part.8+0x78>
        //
        if ( pfnCallback )
        {
            pfnCallback();
        }
        return ui32Status;
    1b2e:	4638      	mov	r0, r7
    1b30:	e7b8      	b.n	1aa4 <am_hal_iom_i2c_write_nb.part.8+0x18>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1b32:	f8d5 011c 	ldr.w	r0, [r5, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    1b36:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1b3a:	f010 0f08 	tst.w	r0, #8
    1b3e:	bf14      	ite	ne
    1b40:	2040      	movne	r0, #64	; 0x40
    1b42:	2080      	moveq	r0, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1b44:	1a42      	subs	r2, r0, r1
                       AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);

    //
    // Figure out how many bytes we can write to the FIFO immediately.
    //
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    1b46:	4598      	cmp	r8, r3
    1b48:	bf28      	it	cs
    1b4a:	4698      	movcs	r8, r3
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1b4c:	f002 00fc 	and.w	r0, r2, #252	; 0xfc
    1b50:	4540      	cmp	r0, r8
    1b52:	d370      	bcc.n	1c36 <am_hal_iom_i2c_write_nb.part.8+0x1aa>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1b54:	f1b8 0f00 	cmp.w	r8, #0
    1b58:	d0bf      	beq.n	1ada <am_hal_iom_i2c_write_nb.part.8+0x4e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1b5a:	463a      	mov	r2, r7
    1b5c:	43f9      	mvns	r1, r7
    1b5e:	f852 0b04 	ldr.w	r0, [r2], #4
    1b62:	6028      	str	r0, [r5, #0]
    1b64:	4439      	add	r1, r7

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1b66:	1bd0      	subs	r0, r2, r7
    1b68:	4441      	add	r1, r8
    1b6a:	4540      	cmp	r0, r8
    1b6c:	f3c1 0182 	ubfx	r1, r1, #2, #3
    1b70:	d241      	bcs.n	1bf6 <am_hal_iom_i2c_write_nb.part.8+0x16a>
    1b72:	b319      	cbz	r1, 1bbc <am_hal_iom_i2c_write_nb.part.8+0x130>
    1b74:	2901      	cmp	r1, #1
    1b76:	d01b      	beq.n	1bb0 <am_hal_iom_i2c_write_nb.part.8+0x124>
    1b78:	2902      	cmp	r1, #2
    1b7a:	d016      	beq.n	1baa <am_hal_iom_i2c_write_nb.part.8+0x11e>
    1b7c:	2903      	cmp	r1, #3
    1b7e:	d011      	beq.n	1ba4 <am_hal_iom_i2c_write_nb.part.8+0x118>
    1b80:	2904      	cmp	r1, #4
    1b82:	d00c      	beq.n	1b9e <am_hal_iom_i2c_write_nb.part.8+0x112>
    1b84:	2905      	cmp	r1, #5
    1b86:	d007      	beq.n	1b98 <am_hal_iom_i2c_write_nb.part.8+0x10c>
    1b88:	2906      	cmp	r1, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1b8a:	bf1c      	itt	ne
    1b8c:	f852 1b04 	ldrne.w	r1, [r2], #4
    1b90:	6029      	strne	r1, [r5, #0]
    1b92:	f852 0b04 	ldr.w	r0, [r2], #4
    1b96:	6028      	str	r0, [r5, #0]
    1b98:	f852 1b04 	ldr.w	r1, [r2], #4
    1b9c:	6029      	str	r1, [r5, #0]
    1b9e:	f852 0b04 	ldr.w	r0, [r2], #4
    1ba2:	6028      	str	r0, [r5, #0]
    1ba4:	f852 1b04 	ldr.w	r1, [r2], #4
    1ba8:	6029      	str	r1, [r5, #0]
    1baa:	f852 0b04 	ldr.w	r0, [r2], #4
    1bae:	6028      	str	r0, [r5, #0]
    1bb0:	f852 1b04 	ldr.w	r1, [r2], #4
    1bb4:	6029      	str	r1, [r5, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1bb6:	1bd0      	subs	r0, r2, r7
    1bb8:	4540      	cmp	r0, r8
    1bba:	d21c      	bcs.n	1bf6 <am_hal_iom_i2c_write_nb.part.8+0x16a>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1bbc:	4694      	mov	ip, r2
    1bbe:	3220      	adds	r2, #32
    1bc0:	f85c 1b04 	ldr.w	r1, [ip], #4
    1bc4:	6029      	str	r1, [r5, #0]
    1bc6:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    1bca:	6028      	str	r0, [r5, #0]
    1bcc:	f8dc 1004 	ldr.w	r1, [ip, #4]
    1bd0:	6029      	str	r1, [r5, #0]
    1bd2:	f852 0c14 	ldr.w	r0, [r2, #-20]
    1bd6:	6028      	str	r0, [r5, #0]
    1bd8:	f852 1c10 	ldr.w	r1, [r2, #-16]
    1bdc:	6029      	str	r1, [r5, #0]
    1bde:	f852 0c0c 	ldr.w	r0, [r2, #-12]
    1be2:	6028      	str	r0, [r5, #0]
    1be4:	f852 1c08 	ldr.w	r1, [r2, #-8]
    1be8:	6029      	str	r1, [r5, #0]
    1bea:	f852 0c04 	ldr.w	r0, [r2, #-4]
    1bee:	6028      	str	r0, [r5, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1bf0:	1bd1      	subs	r1, r2, r7
    1bf2:	4541      	cmp	r1, r8
    1bf4:	d3e2      	bcc.n	1bbc <am_hal_iom_i2c_write_nb.part.8+0x130>
    if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
    {
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    1bf6:	4817      	ldr	r0, [pc, #92]	; (1c54 <am_hal_iom_i2c_write_nb.part.8+0x1c8>)
    1bf8:	eb04 0584 	add.w	r5, r4, r4, lsl #2
    1bfc:	00aa      	lsls	r2, r5, #2
    1bfe:	1881      	adds	r1, r0, r2
    1c00:	2501      	movs	r5, #1
        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    1c02:	f028 0c03 	bic.w	ip, r8, #3
    if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
    {
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    1c06:	5085      	str	r5, [r0, r2]
        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    1c08:	4467      	add	r7, ip

        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    1c0a:	ebc8 0003 	rsb	r0, r8, r3
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    1c0e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    1c10:	610a      	str	r2, [r1, #16]

        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    1c12:	6088      	str	r0, [r1, #8]
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    1c14:	604f      	str	r7, [r1, #4]
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    if (ui32NumBytes == 0)
    1c16:	b91b      	cbnz	r3, 1c20 <am_hal_iom_i2c_write_nb.part.8+0x194>
    1c18:	2003      	movs	r0, #3
        //
        ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                               ui32NumBytes, ui32Options);
        if (ui32Status != AM_HAL_IOM_SUCCESS)
        {
            g_iom_error_status[ui32Module] = ui32Status;
    1c1a:	4b0b      	ldr	r3, [pc, #44]	; (1c48 <am_hal_iom_i2c_write_nb.part.8+0x1bc>)
    1c1c:	5518      	strb	r0, [r3, r4]
    1c1e:	e741      	b.n	1aa4 <am_hal_iom_i2c_write_nb.part.8+0x18>
    1c20:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    1c22:	9700      	str	r7, [sp, #0]
    1c24:	4632      	mov	r2, r6
    1c26:	4621      	mov	r1, r4
    1c28:	2000      	movs	r0, #0
    1c2a:	f7ff fe21 	bl	1870 <am_hal_iom_i2c_cmd_run.part.1>
        //
        // Start the write on the bus.
        //
        ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                               ui32NumBytes, ui32Options);
        if (ui32Status != AM_HAL_IOM_SUCCESS)
    1c2e:	2800      	cmp	r0, #0
    1c30:	f43f af53 	beq.w	1ada <am_hal_iom_i2c_write_nb.part.8+0x4e>
    1c34:	e7f1      	b.n	1c1a <am_hal_iom_i2c_write_nb.part.8+0x18e>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1c36:	4a08      	ldr	r2, [pc, #32]	; (1c58 <am_hal_iom_i2c_write_nb.part.8+0x1cc>)
    1c38:	4808      	ldr	r0, [pc, #32]	; (1c5c <am_hal_iom_i2c_write_nb.part.8+0x1d0>)
    1c3a:	9303      	str	r3, [sp, #12]
    1c3c:	f640 7107 	movw	r1, #3847	; 0xf07
    1c40:	f7ff fce4 	bl	160c <am_hal_debug_error>
    1c44:	9b03      	ldr	r3, [sp, #12]
    1c46:	e788      	b.n	1b5a <am_hal_iom_i2c_write_nb.part.8+0xce>
    1c48:	1000119c 	.word	0x1000119c
    1c4c:	100011a4 	.word	0x100011a4
    1c50:	000054a4 	.word	0x000054a4
    1c54:	10001594 	.word	0x10001594
    1c58:	00005360 	.word	0x00005360
    1c5c:	00005394 	.word	0x00005394

00001c60 <am_hal_iom_pwrctrl_enable>:
//
//*****************************************************************************
void
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
    1c60:	2805      	cmp	r0, #5
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
    1c62:	b510      	push	{r4, lr}
    1c64:	4604      	mov	r4, r0
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
    1c66:	d905      	bls.n	1c74 <am_hal_iom_pwrctrl_enable+0x14>
    1c68:	4a05      	ldr	r2, [pc, #20]	; (1c80 <am_hal_iom_pwrctrl_enable+0x20>)
    1c6a:	4806      	ldr	r0, [pc, #24]	; (1c84 <am_hal_iom_pwrctrl_enable+0x24>)
    1c6c:	f240 21d2 	movw	r1, #722	; 0x2d2
    1c70:	f7ff fccc 	bl	160c <am_hal_debug_error>
                            "Trying to enable an IOM module that doesn't exist.");

    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOM0 << ui32Module);
    1c74:	2002      	movs	r0, #2
    1c76:	40a0      	lsls	r0, r4
}
    1c78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
                            "Trying to enable an IOM module that doesn't exist.");

    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOM0 << ui32Module);
    1c7c:	f001 be7c 	b.w	3978 <am_hal_pwrctrl_periph_enable>
    1c80:	000053a8 	.word	0x000053a8
    1c84:	00005394 	.word	0x00005394

00001c88 <am_hal_iom_enable>:
//
//*****************************************************************************
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    1c88:	2805      	cmp	r0, #5
    1c8a:	d80f      	bhi.n	1cac <am_hal_iom_enable+0x24>
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    1c8c:	f500 23a0 	add.w	r3, r0, #327680	; 0x50000
    1c90:	3304      	adds	r3, #4
    1c92:	031b      	lsls	r3, r3, #12
        g_bIomBusy[ui32Module] = false;
    1c94:	4906      	ldr	r1, [pc, #24]	; (1cb0 <am_hal_iom_enable+0x28>)
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    1c96:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_enable(uint32_t ui32Module)
{
    1c9a:	b410      	push	{r4}
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    1c9c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
        g_bIomBusy[ui32Module] = false;
    1ca0:	2400      	movs	r4, #0
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    1ca2:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
        g_bIomBusy[ui32Module] = false;
    1ca6:	540c      	strb	r4, [r1, r0]
    }
}
    1ca8:	f85d 4b04 	ldr.w	r4, [sp], #4
    1cac:	4770      	bx	lr
    1cae:	bf00      	nop
    1cb0:	100011a4 	.word	0x100011a4

00001cb4 <am_hal_iom_config>:
    // Start by checking the interface mode (I2C or SPI), and writing it to the
    // configuration word.
    //
    ui32Config = psConfig->ui32InterfaceMode;

    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1cb4:	2805      	cmp	r0, #5
    1cb6:	f200 80ec 	bhi.w	1e92 <am_hal_iom_config+0x1de>
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_config(uint32_t ui32Module, const am_hal_iom_config_t *psConfig)
{
    1cba:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    //
    // Check the SPI format, and OR in the bits for SPHA (clock phase) and SPOL
    // (polarity). These shouldn't have any effect in I2C mode, so it should be
    // ok to write them without checking exactly which mode we're in.
    //
    if ( psConfig->bSPHA )
    1cbe:	7a0d      	ldrb	r5, [r1, #8]

    //
    // Start by checking the interface mode (I2C or SPI), and writing it to the
    // configuration word.
    //
    ui32Config = psConfig->ui32InterfaceMode;
    1cc0:	680b      	ldr	r3, [r1, #0]
    //
    // Check the SPI format, and OR in the bits for SPHA (clock phase) and SPOL
    // (polarity). These shouldn't have any effect in I2C mode, so it should be
    // ok to write them without checking exactly which mode we're in.
    //
    if ( psConfig->bSPHA )
    1cc2:	b10d      	cbz	r5, 1cc8 <am_hal_iom_config+0x14>
    {
        ui32Config |= AM_REG_IOMSTR_CFG_SPHA(1);
    1cc4:	f043 0304 	orr.w	r3, r3, #4
    }

    if ( psConfig->bSPOL )
    1cc8:	7a4a      	ldrb	r2, [r1, #9]
    1cca:	b10a      	cbz	r2, 1cd0 <am_hal_iom_config+0x1c>
    {
        ui32Config |= AM_REG_IOMSTR_CFG_SPOL(1);
    1ccc:	f043 0302 	orr.w	r3, r3, #2
    // For all I2C frequencies and SPI frequencies below 16 MHz, the STARTRD
    // field should be set to 0 to minimize the potential of the IO transfer
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
    1cd0:	684c      	ldr	r4, [r1, #4]
    1cd2:	4a8d      	ldr	r2, [pc, #564]	; (1f08 <am_hal_iom_config+0x254>)

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
    1cd4:	f500 26a0 	add.w	r6, r0, #327680	; 0x50000
    1cd8:	3604      	adds	r6, #4
    // For all I2C frequencies and SPI frequencies below 16 MHz, the STARTRD
    // field should be set to 0 to minimize the potential of the IO transfer
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
    1cda:	4294      	cmp	r4, r2

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
    1cdc:	ea4f 3406 	mov.w	r4, r6, lsl #12
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
    {
        ui32Config |= AM_REG_IOMSTR_CFG_STARTRD(2);
    1ce0:	bf88      	it	hi
    1ce2:	f043 0320 	orrhi.w	r3, r3, #32

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
    1ce6:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
    1cea:	7a8f      	ldrb	r7, [r1, #10]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
    1cec:	2f03      	cmp	r7, #3
    1cee:	f240 80c8 	bls.w	1e82 <am_hal_iom_config+0x1ce>
    {
        corrected_threshold = MIN_RW_THRESHOLD;
    }

    if ( corrected_threshold > MAX_RW_THRESHOLD )
    1cf2:	2f7c      	cmp	r7, #124	; 0x7c
    1cf4:	bf88      	it	hi
    1cf6:	f44f 42f8 	movhi.w	r2, #31744	; 0x7c00
    1cfa:	f240 8101 	bls.w	1f00 <am_hal_iom_config+0x24c>
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(check_iom_threshold(psConfig->ui8ReadThreshold)));
    1cfe:	7acb      	ldrb	r3, [r1, #11]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
    1d00:	2b03      	cmp	r3, #3
    1d02:	f240 80c4 	bls.w	1e8e <am_hal_iom_config+0x1da>
    1d06:	2b7c      	cmp	r3, #124	; 0x7c
    1d08:	bf28      	it	cs
    1d0a:	237c      	movcs	r3, #124	; 0x7c
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
    1d0c:	4313      	orrs	r3, r2

    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
    1d0e:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108

    // Apply I2C clock stretching workaround if B2 silicon and IOM 1,2,3, or 5
    // Note: Only I2C clock speeds of AM_HAL_IOM_800KHZ, AM_HAL_IOM_400KHZ,
    // AM_HAL_IOM_200KHZ, and AM_HAL_IOM_100KHZ are allowed.  Other values will
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
    1d12:	f030 0304 	bics.w	r3, r0, #4
    1d16:	d005      	beq.n	1d24 <am_hal_iom_config+0x70>
isRevB2(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) ==
    1d18:	4e7c      	ldr	r6, [pc, #496]	; (1f0c <am_hal_iom_config+0x258>)
    1d1a:	6837      	ldr	r7, [r6, #0]
    1d1c:	b2fa      	uxtb	r2, r7
    1d1e:	2a22      	cmp	r2, #34	; 0x22
    1d20:	f000 80bc 	beq.w	1e9c <am_hal_iom_config+0x1e8>
      //  is being selected.
      // If SPHA=0 the low period must be 60%. If SPHA=1 high period must be 60%.
      // Note that the predetermined frequency parameters use the formula
      //  lowper = (totper-1)/2, which results in a 60% low period.
      //
      ui32ClkCfg = iom_get_interface_clock_cfg(psConfig->ui32ClockFrequency,
    1d24:	f8d1 e004 	ldr.w	lr, [r1, #4]
    uint32_t ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer, ui32LowPer;
    uint32_t ui32Denom, ui32v1, ui32Denomfinal, ui32ClkFreq, ui32ClkCfg;
    uint32_t ui32HFRCfreqHz;
    int32_t i32Div, i32N;

    if ( ui32FreqHz == 0 )
    1d28:	f1be 0f00 	cmp.w	lr, #0
    1d2c:	f000 8099 	beq.w	1e62 <am_hal_iom_config+0x1ae>
    ui32HFRCfreqHz = AM_HAL_CLKGEN_FREQ_MAX_HZ;

    //
    // Compute various parameters used for computing the optimal CLKCFG setting.
    //
    i32Div = (ui32HFRCfreqHz / ui32FreqHz) + ((ui32HFRCfreqHz % ui32FreqHz) ? 1 : 0);    // Round up (ceiling)
    1d30:	4e77      	ldr	r6, [pc, #476]	; (1f10 <am_hal_iom_config+0x25c>)
    1d32:	fbb6 f7fe 	udiv	r7, r6, lr
    1d36:	fb0e f207 	mul.w	r2, lr, r7
    1d3a:	f1c2 7937 	rsb	r9, r2, #47972352	; 0x2dc0000
    1d3e:	f509 4ad8 	add.w	sl, r9, #27648	; 0x6c00
    1d42:	f1ba 0f00 	cmp.w	sl, #0
    1d46:	bf18      	it	ne
    1d48:	3701      	addne	r7, #1

    //
    // Compute N (count the number of LS zeros of Div) = ctz(Div) = log2(Div & (-Div))
    //
    i32N = 31 - AM_INSTR_CLZ((i32Div & (-i32Div)));
    1d4a:	427b      	negs	r3, r7
    1d4c:	403b      	ands	r3, r7
    1d4e:	fab3 f683 	clz	r6, r3
    1d52:	f1c6 031f 	rsb	r3, r6, #31
    1d56:	2b06      	cmp	r3, #6
    1d58:	bfa8      	it	ge
    1d5a:	2306      	movge	r3, #6
        i32N = 6;
    }

    ui32Div3 = ( (ui32FreqHz < (ui32HFRCfreqHz / 16384))            ||
                 ( ((ui32FreqHz >= (ui32HFRCfreqHz / 3))    &&
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
    1d5c:	f5be 6f37 	cmp.w	lr, #2928	; 0xb70
    1d60:	f240 8098 	bls.w	1e94 <am_hal_iom_config+0x1e0>
    1d64:	4e6b      	ldr	r6, [pc, #428]	; (1f14 <am_hal_iom_config+0x260>)
    1d66:	f5ae 0b74 	sub.w	fp, lr, #15990784	; 0xf40000
    1d6a:	f5ab 5c10 	sub.w	ip, fp, #9216	; 0x2400
    1d6e:	45b4      	cmp	ip, r6
    1d70:	bf8b      	itete	hi
    1d72:	f04f 0800 	movhi.w	r8, #0
    1d76:	f44f 6800 	movls.w	r8, #2048	; 0x800
    1d7a:	2601      	movhi	r6, #1
    1d7c:	2603      	movls	r6, #3
    ui32Denom = ( 1 << i32N ) * ( 1 + (ui32Div3 * 2) );
    1d7e:	fa06 f903 	lsl.w	r9, r6, r3
    ui32TotPer = i32Div / ui32Denom;
    1d82:	fbb7 f2f9 	udiv	r2, r7, r9
    ui32TotPer += (i32Div % ui32Denom) ? 1 : 0;
    1d86:	fb09 7a12 	mls	sl, r9, r2, r7
    1d8a:	f1ba 0f00 	cmp.w	sl, #0
    1d8e:	bf18      	it	ne
    1d90:	3201      	addne	r2, #1
    ui32v1 = 31 - AM_INSTR_CLZ(ui32TotPer);     // v1 = log2(TotPer)
    1d92:	fab2 fb82 	clz	fp, r2
    1d96:	f1cb 0c1f 	rsb	ip, fp, #31
    ui32Fsel = (ui32v1 > 7) ? ui32v1 + i32N - 7 : i32N;
    1d9a:	f1bc 0f07 	cmp.w	ip, #7
    1d9e:	f240 809b 	bls.w	1ed8 <am_hal_iom_config+0x224>
    1da2:	3b07      	subs	r3, #7
    1da4:	4463      	add	r3, ip
    ui32Fsel++;
    1da6:	f103 0901 	add.w	r9, r3, #1

    if ( ui32Fsel > 7 )
    1daa:	f1b9 0f07 	cmp.w	r9, #7
    1dae:	d858      	bhi.n	1e62 <am_hal_iom_config+0x1ae>
    }

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
    1db0:	f1ac 0b07 	sub.w	fp, ip, #7
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    1db4:	f04f 0a01 	mov.w	sl, #1
    1db8:	fa0a fc0b 	lsl.w	ip, sl, fp
    1dbc:	f10c 3aff 	add.w	sl, ip, #4294967295
    1dc0:	ea0a 0c02 	and.w	ip, sl, r2
    }

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
    1dc4:	fa22 f20b 	lsr.w	r2, r2, fp
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1dc8:	f8df b16c 	ldr.w	fp, [pc, #364]	; 1f38 <am_hal_iom_config+0x284>

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    1dcc:	f1bc 0f00 	cmp.w	ip, #0
    1dd0:	bf18      	it	ne
    1dd2:	3201      	addne	r2, #1
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1dd4:	45de      	cmp	lr, fp
    1dd6:	f200 8086 	bhi.w	1ee6 <am_hal_iom_config+0x232>
    1dda:	f04f 0e01 	mov.w	lr, #1
    1dde:	fa0e fa03 	lsl.w	sl, lr, r3
    1de2:	4557      	cmp	r7, sl
    1de4:	d07f      	beq.n	1ee6 <am_hal_iom_config+0x232>
    1de6:	f102 3eff 	add.w	lr, r2, #4294967295
    1dea:	4694      	mov	ip, r2
    1dec:	f44f 5780 	mov.w	r7, #4096	; 0x1000

    if (ui32Phase == 1)
    1df0:	2d00      	cmp	r5, #0
    1df2:	d17e      	bne.n	1ef2 <am_hal_iom_config+0x23e>
    {
        ui32LowPer = (ui32TotPer - 2) / 2;          // Longer high phase
    }
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    1df4:	ea4f 025e 	mov.w	r2, lr, lsr #1
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1df8:	409e      	lsls	r6, r3
    1dfa:	fb0c f606 	mul.w	r6, ip, r6
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    1dfe:	f8df b110 	ldr.w	fp, [pc, #272]	; 1f10 <am_hal_iom_config+0x25c>
    1e02:	fbbb f3f6 	udiv	r3, fp, r6
    1e06:	fb06 fa03 	mul.w	sl, r6, r3
    1e0a:	f1ca 7c37 	rsb	ip, sl, #47972352	; 0x2dc0000
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    1e0e:	ea4f 2509 	mov.w	r5, r9, lsl #8
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    1e12:	f50c 4bd8 	add.w	fp, ip, #27648	; 0x6c00
    1e16:	0876      	lsrs	r6, r6, #1
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    1e18:	f8df a120 	ldr.w	sl, [pc, #288]	; 1f3c <am_hal_iom_config+0x288>
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    1e1c:	455e      	cmp	r6, fp
    1e1e:	bf38      	it	cc
    1e20:	3301      	addcc	r3, #1
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    1e22:	f405 69e0 	and.w	r9, r5, #1792	; 0x700
    1e26:	ea49 0608 	orr.w	r6, r9, r8
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    1e2a:	fbaa bc03 	umull	fp, ip, sl, r3
    1e2e:	4d3a      	ldr	r5, [pc, #232]	; (1f18 <am_hal_iom_config+0x264>)
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    1e30:	433e      	orrs	r6, r7
    1e32:	0412      	lsls	r2, r2, #16
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    1e34:	ea4f 471c 	mov.w	r7, ip, lsr #16
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    1e38:	ea46 680e 	orr.w	r8, r6, lr, lsl #24
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    1e3c:	fb05 3317 	mls	r3, r5, r7, r3
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    1e40:	f402 0e7f 	and.w	lr, r2, #16711680	; 0xff0000
    1e44:	ea48 060e 	orr.w	r6, r8, lr
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    1e48:	b91b      	cbnz	r3, 1e52 <am_hal_iom_config+0x19e>
// A power of 2?
// Return true if ui32Value has exactly 1 bit set, otherwise false.
//
static bool onebit(uint32_t ui32Value)
{
    return ui32Value  &&  !(ui32Value & (ui32Value - 1));
    1e4a:	b117      	cbz	r7, 1e52 <am_hal_iom_config+0x19e>
    1e4c:	1e7d      	subs	r5, r7, #1
    1e4e:	423d      	tst	r5, r7
    1e50:	d03f      	beq.n	1ed2 <am_hal_iom_config+0x21e>
      //  is being selected.
      // If SPHA=0 the low period must be 60%. If SPHA=1 high period must be 60%.
      // Note that the predetermined frequency parameters use the formula
      //  lowper = (totper-1)/2, which results in a 60% low period.
      //
      ui32ClkCfg = iom_get_interface_clock_cfg(psConfig->ui32ClockFrequency,
    1e52:	f04f 0b00 	mov.w	fp, #0
    1e56:	ea4b 0206 	orr.w	r2, fp, r6
    1e5a:	4617      	mov	r7, r2
                                               psConfig->bSPHA );
    }

    if ( ui32ClkCfg )
    1e5c:	b10a      	cbz	r2, 1e62 <am_hal_iom_config+0x1ae>
    {
        AM_REGn(IOMSTR, ui32Module, CLKCFG) = (uint32_t)ui32ClkCfg;
    1e5e:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
    1e62:	4688      	mov	r8, r1
    1e64:	4604      	mov	r4, r0

    //
    // Compute the status timeout value.
    //
    ui32StatusTimeout[ui32Module] = MAX_IOM_BITS * AM_HAL_IOM_MAX_FIFO_SIZE *
      IOM_OVERHEAD_FACTOR * (am_hal_clkgen_sysclk_get() / psConfig->ui32ClockFrequency);
    1e66:	f7ff fbb7 	bl	15d8 <am_hal_clkgen_sysclk_get>
    }

    //
    // Compute the status timeout value.
    //
    ui32StatusTimeout[ui32Module] = MAX_IOM_BITS * AM_HAL_IOM_MAX_FIFO_SIZE *
    1e6a:	4f2c      	ldr	r7, [pc, #176]	; (1f1c <am_hal_iom_config+0x268>)
    1e6c:	f8d8 1004 	ldr.w	r1, [r8, #4]
    1e70:	fbb0 f0f1 	udiv	r0, r0, r1
    1e74:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
    1e78:	0215      	lsls	r5, r2, #8
    1e7a:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
    1e7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(check_iom_threshold(psConfig->ui8ReadThreshold)));
    1e82:	7acb      	ldrb	r3, [r1, #11]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
    1e84:	2b03      	cmp	r3, #3
    1e86:	f44f 6280 	mov.w	r2, #1024	; 0x400
    1e8a:	f63f af3c 	bhi.w	1d06 <am_hal_iom_config+0x52>
    1e8e:	2304      	movs	r3, #4
    1e90:	e73c      	b.n	1d0c <am_hal_iom_config+0x58>
    1e92:	4770      	bx	lr
        i32N = 6;
    }

    ui32Div3 = ( (ui32FreqHz < (ui32HFRCfreqHz / 16384))            ||
                 ( ((ui32FreqHz >= (ui32HFRCfreqHz / 3))    &&
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
    1e94:	f44f 6800 	mov.w	r8, #2048	; 0x800
    1e98:	2603      	movs	r6, #3
    1e9a:	e770      	b.n	1d7e <am_hal_iom_config+0xca>
    // Apply I2C clock stretching workaround if B2 silicon and IOM 1,2,3, or 5
    // Note: Only I2C clock speeds of AM_HAL_IOM_800KHZ, AM_HAL_IOM_400KHZ,
    // AM_HAL_IOM_200KHZ, and AM_HAL_IOM_100KHZ are allowed.  Other values will
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
			isRevB2() && (AM_HAL_IOM_I2CMODE == psConfig->ui32InterfaceMode))
    1e9c:	680b      	ldr	r3, [r1, #0]
    1e9e:	2b00      	cmp	r3, #0
    1ea0:	f47f af40 	bne.w	1d24 <am_hal_iom_config+0x70>
    {
      // Set SPHA field to 1 on B2 silicon to enable the feature;
      AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_SPHA_M;
    1ea4:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
    1ea8:	4a1d      	ldr	r2, [pc, #116]	; (1f20 <am_hal_iom_config+0x26c>)
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
			isRevB2() && (AM_HAL_IOM_I2CMODE == psConfig->ui32InterfaceMode))
    {
      // Set SPHA field to 1 on B2 silicon to enable the feature;
      AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_SPHA_M;
    1eaa:	f043 0504 	orr.w	r5, r3, #4
    1eae:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
      ui32ClkCfg = iom_get_i2c_workaround_clock_cfg(psConfig->ui32ClockFrequency);
    1eb2:	684d      	ldr	r5, [r1, #4]
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
    1eb4:	4295      	cmp	r5, r2
    1eb6:	d01f      	beq.n	1ef8 <am_hal_iom_config+0x244>
  {
    ui32Fsel = 2;
  }
  else if (ui32FreqHz == AM_HAL_IOM_400KHZ)
    1eb8:	4e1a      	ldr	r6, [pc, #104]	; (1f24 <am_hal_iom_config+0x270>)
    1eba:	42b5      	cmp	r5, r6
    1ebc:	d01e      	beq.n	1efc <am_hal_iom_config+0x248>
  {
    ui32Fsel = 3;
  }
  else if (ui32FreqHz == AM_HAL_IOM_200KHZ)
    1ebe:	4b1a      	ldr	r3, [pc, #104]	; (1f28 <am_hal_iom_config+0x274>)
    1ec0:	4f1a      	ldr	r7, [pc, #104]	; (1f2c <am_hal_iom_config+0x278>)
    1ec2:	f102 59e8 	add.w	r9, r2, #486539264	; 0x1d000000
    1ec6:	f509 3af0 	add.w	sl, r9, #122880	; 0x1e000
    1eca:	429d      	cmp	r5, r3
    1ecc:	bf18      	it	ne
    1ece:	4657      	movne	r7, sl
    1ed0:	e7c5      	b.n	1e5e <am_hal_iom_config+0x1aa>
            //
            // Now, compute the return values.
            //
            ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer);

            ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)    |
    1ed2:	f449 6600 	orr.w	r6, r9, #2048	; 0x800
    1ed6:	e7bc      	b.n	1e52 <am_hal_iom_config+0x19e>
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1ed8:	f8df b05c 	ldr.w	fp, [pc, #92]	; 1f38 <am_hal_iom_config+0x284>
    1edc:	45de      	cmp	lr, fp
    ui32Denom = ( 1 << i32N ) * ( 1 + (ui32Div3 * 2) );
    ui32TotPer = i32Div / ui32Denom;
    ui32TotPer += (i32Div % ui32Denom) ? 1 : 0;
    ui32v1 = 31 - AM_INSTR_CLZ(ui32TotPer);     // v1 = log2(TotPer)
    ui32Fsel = (ui32v1 > 7) ? ui32v1 + i32N - 7 : i32N;
    ui32Fsel++;
    1ede:	f103 0901 	add.w	r9, r3, #1
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1ee2:	f67f af7a 	bls.w	1dda <am_hal_iom_config+0x126>
    1ee6:	f102 3eff 	add.w	lr, r2, #4294967295
    1eea:	f04f 0c01 	mov.w	ip, #1
    1eee:	2700      	movs	r7, #0
    1ef0:	e77e      	b.n	1df0 <am_hal_iom_config+0x13c>

    if (ui32Phase == 1)
    {
        ui32LowPer = (ui32TotPer - 2) / 2;          // Longer high phase
    1ef2:	1e95      	subs	r5, r2, #2
    1ef4:	086a      	lsrs	r2, r5, #1
    1ef6:	e77f      	b.n	1df8 <am_hal_iom_config+0x144>
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
    1ef8:	4f0d      	ldr	r7, [pc, #52]	; (1f30 <am_hal_iom_config+0x27c>)
    1efa:	e7b0      	b.n	1e5e <am_hal_iom_config+0x1aa>
  {
    ui32Fsel = 2;
  }
  else if (ui32FreqHz == AM_HAL_IOM_400KHZ)
    1efc:	4f0d      	ldr	r7, [pc, #52]	; (1f34 <am_hal_iom_config+0x280>)
    1efe:	e7ae      	b.n	1e5e <am_hal_iom_config+0x1aa>
    1f00:	023a      	lsls	r2, r7, #8
    1f02:	f402 42fe 	and.w	r2, r2, #32512	; 0x7f00
    1f06:	e6fa      	b.n	1cfe <am_hal_iom_config+0x4a>
    1f08:	00f423ff 	.word	0x00f423ff
    1f0c:	4002000c 	.word	0x4002000c
    1f10:	02dc6c00 	.word	0x02dc6c00
    1f14:	007a11ff 	.word	0x007a11ff
    1f18:	0003d090 	.word	0x0003d090
    1f1c:	1000157c 	.word	0x1000157c
    1f20:	000c3500 	.word	0x000c3500
    1f24:	00061a80 	.word	0x00061a80
    1f28:	00030d40 	.word	0x00030d40
    1f2c:	1d0e1400 	.word	0x1d0e1400
    1f30:	1d0e1200 	.word	0x1d0e1200
    1f34:	1d0e1300 	.word	0x1d0e1300
    1f38:	00b71aff 	.word	0x00b71aff
    1f3c:	431bde83 	.word	0x431bde83

00001f40 <am_hal_iom_workaround_word_write>:
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
    1f40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t ui32HiFreq = 0, ui32NormalFreq = 0;
    uint32_t ui32DelayTime = 0;
    uint32_t ui32LowFsel = 0;
    uint32_t ui32HiFsel = 0;
    uint32_t ui32FirstWord = 0;
    uint32_t ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, WORKAROUND_IOM, CFG, FULLDUP)) ?
    1f44:	4cc9      	ldr	r4, [pc, #804]	; (226c <am_hal_iom_workaround_word_write+0x32c>)
    1f46:	6825      	ldr	r5, [r4, #0]
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
    1f48:	4691      	mov	r9, r2
    uint32_t ui32HiFreq = 0, ui32NormalFreq = 0;
    uint32_t ui32DelayTime = 0;
    uint32_t ui32LowFsel = 0;
    uint32_t ui32HiFsel = 0;
    uint32_t ui32FirstWord = 0;
    uint32_t ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, WORKAROUND_IOM, CFG, FULLDUP)) ?
    1f4a:	f015 0f08 	tst.w	r5, #8
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
    1f4e:	b08d      	sub	sp, #52	; 0x34
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
    1f50:	f640 72fb 	movw	r2, #4091	; 0xffb
    uint32_t ui32HiFreq = 0, ui32NormalFreq = 0;
    uint32_t ui32DelayTime = 0;
    uint32_t ui32LowFsel = 0;
    uint32_t ui32HiFsel = 0;
    uint32_t ui32FirstWord = 0;
    uint32_t ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, WORKAROUND_IOM, CFG, FULLDUP)) ?
    1f54:	bf14      	ite	ne
    1f56:	2740      	movne	r7, #64	; 0x40
    1f58:	2780      	moveq	r7, #128	; 0x80
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
    1f5a:	4591      	cmp	r9, r2
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
    1f5c:	4604      	mov	r4, r0
    1f5e:	4688      	mov	r8, r1
    1f60:	9301      	str	r3, [sp, #4]
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
    1f62:	f200 834e 	bhi.w	2602 <am_hal_iom_workaround_word_write+0x6c2>

    // We want to slow down the clock to help us count edges more
    // accurately. Save it first, then slow it down. Also, we will
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
    1f66:	4bc2      	ldr	r3, [pc, #776]	; (2270 <am_hal_iom_workaround_word_write+0x330>)
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    1f68:	4ec2      	ldr	r6, [pc, #776]	; (2274 <am_hal_iom_workaround_word_write+0x334>)

    // We want to slow down the clock to help us count edges more
    // accurately. Save it first, then slow it down. Also, we will
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
    1f6a:	681d      	ldr	r5, [r3, #0]
//*****************************************************************************
static uint32_t
iom_get_workaround_fsel(uint32_t maxFreq)
{
    uint32_t ui32Freq, ui32Fsel;
    uint32_t ui32ClkCfg = AM_REGn(IOMSTR, 4, CLKCFG);
    1f6c:	681a      	ldr	r2, [r3, #0]
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    1f6e:	49c2      	ldr	r1, [pc, #776]	; (2278 <am_hal_iom_workaround_word_write+0x338>)
    1f70:	f3c2 3000 	ubfx	r0, r2, #12, #1
    1f74:	f3c2 23c0 	ubfx	r3, r2, #11, #1
    1f78:	0e12      	lsrs	r2, r2, #24
    1f7a:	fb02 f200 	mul.w	r2, r2, r0
    1f7e:	005b      	lsls	r3, r3, #1
    1f80:	3301      	adds	r3, #1
    1f82:	3201      	adds	r2, #1
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1f84:	fb02 fe03 	mul.w	lr, r2, r3
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    1f88:	fbb6 fcfe 	udiv	ip, r6, lr
    1f8c:	fb0e fa0c 	mul.w	sl, lr, ip
    1f90:	f1ca 7b37 	rsb	fp, sl, #47972352	; 0x2dc0000
    1f94:	f50b 40d8 	add.w	r0, fp, #27648	; 0x6c00
    1f98:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
    1f9c:	4586      	cmp	lr, r0
    1f9e:	bf2c      	ite	cs
    1fa0:	4660      	movcs	r0, ip
    1fa2:	f10c 0001 	addcc.w	r0, ip, #1
    1fa6:	4288      	cmp	r0, r1
    1fa8:	f240 8378 	bls.w	269c <am_hal_iom_workaround_word_write+0x75c>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1fac:	005b      	lsls	r3, r3, #1
    1fae:	fb02 f303 	mul.w	r3, r2, r3
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    1fb2:	fbb6 f6f3 	udiv	r6, r6, r3
    1fb6:	fb03 f206 	mul.w	r2, r3, r6
    1fba:	f1c2 7c37 	rsb	ip, r2, #47972352	; 0x2dc0000
    1fbe:	f50c 40d8 	add.w	r0, ip, #27648	; 0x6c00
    1fc2:	085b      	lsrs	r3, r3, #1
    1fc4:	4283      	cmp	r3, r0
    1fc6:	bf38      	it	cc
    1fc8:	3601      	addcc	r6, #1

    //
    // Starting with the current clock configuration parameters, find a value
    // of FSEL that will bring our total frequency down to or below maxFreq.
    //
    for ( ui32Fsel = 1; ui32Fsel < 8; ui32Fsel++ )
    1fca:	428e      	cmp	r6, r1
    1fcc:	bf8c      	ite	hi
    1fce:	f04f 0e03 	movhi.w	lr, #3
    1fd2:	f04f 0e02 	movls.w	lr, #2
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1fd6:	f3c5 21c0 	ubfx	r1, r5, #11, #1
    1fda:	004e      	lsls	r6, r1, #1
    1fdc:	f3c5 2a02 	ubfx	sl, r5, #8, #3
    1fe0:	f3c5 3c00 	ubfx	ip, r5, #12, #1
    1fe4:	f10a 3bff 	add.w	fp, sl, #4294967295
    1fe8:	4663      	mov	r3, ip
    1fea:	3601      	adds	r6, #1
    1fec:	0e28      	lsrs	r0, r5, #24
    1fee:	fa06 f20b 	lsl.w	r2, r6, fp
    1ff2:	fb00 f003 	mul.w	r0, r0, r3
    1ff6:	fb00 2102 	mla	r1, r0, r2, r2
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    1ffa:	f8df b278 	ldr.w	fp, [pc, #632]	; 2274 <am_hal_iom_workaround_word_write+0x334>
    1ffe:	fbbb f6f1 	udiv	r6, fp, r1
    2002:	fb01 fa06 	mul.w	sl, r1, r6
    2006:	f1ca 7c37 	rsb	ip, sl, #47972352	; 0x2dc0000
    200a:	f50c 40d8 	add.w	r0, ip, #27648	; 0x6c00
    200e:	084a      	lsrs	r2, r1, #1
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
    // Get the largest speed we can configure within our rated speed of 16MHz
    ui32HiFsel = iom_get_workaround_fsel(16000000);
    ui32HiClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
    2010:	f425 6ae0 	bic.w	sl, r5, #1792	; 0x700
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32HiFsel));
    // Switch to Hi Freq
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
    2014:	4996      	ldr	r1, [pc, #600]	; (2270 <am_hal_iom_workaround_word_write+0x330>)
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    2016:	4282      	cmp	r2, r0
    2018:	bf2c      	ite	cs
    201a:	4633      	movcs	r3, r6
    201c:	1c73      	addcc	r3, r6, #1
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
    // Get the largest speed we can configure within our rated speed of 16MHz
    ui32HiFsel = iom_get_workaround_fsel(16000000);
    ui32HiClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
    201e:	ea4a 260e 	orr.w	r6, sl, lr, lsl #8
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    2022:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32HiFsel));
    // Switch to Hi Freq
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
    2026:	600e      	str	r6, [r1, #0]
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    2028:	4a94      	ldr	r2, [pc, #592]	; (227c <am_hal_iom_workaround_word_write+0x33c>)
    202a:	4895      	ldr	r0, [pc, #596]	; (2280 <am_hal_iom_workaround_word_write+0x340>)
    202c:	fbb0 f0fc 	udiv	r0, r0, ip
    2030:	4790      	blx	r2
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    2032:	f3c6 23c0 	ubfx	r3, r6, #11, #1
    2036:	0058      	lsls	r0, r3, #1
    2038:	f3c6 2101 	ubfx	r1, r6, #8, #2
    203c:	1c42      	adds	r2, r0, #1
    203e:	f101 3cff 	add.w	ip, r1, #4294967295
    2042:	f3c6 3000 	ubfx	r0, r6, #12, #1
    2046:	0e36      	lsrs	r6, r6, #24
    2048:	fa02 f30c 	lsl.w	r3, r2, ip
    204c:	fb06 f600 	mul.w	r6, r6, r0
    2050:	fb06 3103 	mla	r1, r6, r3, r3
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    2054:	fbbb f2f1 	udiv	r2, fp, r1
    2058:	fb01 f002 	mul.w	r0, r1, r2
    205c:	f1c0 7b37 	rsb	fp, r0, #47972352	; 0x2dc0000
    2060:	f50b 4cd8 	add.w	ip, fp, #27648	; 0x6c00
    2064:	084e      	lsrs	r6, r1, #1
    2066:	4566      	cmp	r6, ip
    2068:	bf2c      	ite	cs
    206a:	4616      	movcs	r6, r2
    206c:	1c56      	addcc	r6, r2, #1
    ui32HiFreq = am_hal_iom_frequency_get(ui32HiClkCfg);

    //
    // Validate return value to prevent DIVBY0 errors.
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");
    206e:	2e00      	cmp	r6, #0
    2070:	f000 82c0 	beq.w	25f4 <am_hal_iom_workaround_word_write+0x6b4>
//*****************************************************************************
static uint32_t
iom_get_workaround_fsel(uint32_t maxFreq)
{
    uint32_t ui32Freq, ui32Fsel;
    uint32_t ui32ClkCfg = AM_REGn(IOMSTR, 4, CLKCFG);
    2074:	4b7e      	ldr	r3, [pc, #504]	; (2270 <am_hal_iom_workaround_word_write+0x330>)
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    2076:	4a7f      	ldr	r2, [pc, #508]	; (2274 <am_hal_iom_workaround_word_write+0x334>)
//*****************************************************************************
static uint32_t
iom_get_workaround_fsel(uint32_t maxFreq)
{
    uint32_t ui32Freq, ui32Fsel;
    uint32_t ui32ClkCfg = AM_REGn(IOMSTR, 4, CLKCFG);
    2078:	6818      	ldr	r0, [r3, #0]
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    207a:	f8df e214 	ldr.w	lr, [pc, #532]	; 2290 <am_hal_iom_workaround_word_write+0x350>
    207e:	f3c0 21c0 	ubfx	r1, r0, #11, #1
    2082:	f3c0 3300 	ubfx	r3, r0, #12, #1
    2086:	0e00      	lsrs	r0, r0, #24
    2088:	fb00 f303 	mul.w	r3, r0, r3
    208c:	0049      	lsls	r1, r1, #1
    208e:	3101      	adds	r1, #1
    2090:	3301      	adds	r3, #1
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    2092:	fb03 f001 	mul.w	r0, r3, r1
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    2096:	fbb2 fbf0 	udiv	fp, r2, r0
    209a:	fb00 fc0b 	mul.w	ip, r0, fp
    209e:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    20a2:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    20a6:	0840      	lsrs	r0, r0, #1
    20a8:	4560      	cmp	r0, ip
    20aa:	bf38      	it	cc
    20ac:	f10b 0b01 	addcc.w	fp, fp, #1
    20b0:	45f3      	cmp	fp, lr
    20b2:	f240 82f1 	bls.w	2698 <am_hal_iom_workaround_word_write+0x758>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    20b6:	0048      	lsls	r0, r1, #1
    20b8:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    20bc:	fbb2 fbf0 	udiv	fp, r2, r0
    20c0:	fb00 fc0b 	mul.w	ip, r0, fp
    20c4:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    20c8:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    20cc:	0840      	lsrs	r0, r0, #1
    20ce:	4560      	cmp	r0, ip
    20d0:	bf38      	it	cc
    20d2:	f10b 0b01 	addcc.w	fp, fp, #1
    20d6:	45f3      	cmp	fp, lr
    20d8:	f240 82e3 	bls.w	26a2 <am_hal_iom_workaround_word_write+0x762>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    20dc:	0088      	lsls	r0, r1, #2
    20de:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    20e2:	fbb2 fbf0 	udiv	fp, r2, r0
    20e6:	fb00 fc0b 	mul.w	ip, r0, fp
    20ea:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    20ee:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    20f2:	0840      	lsrs	r0, r0, #1
    20f4:	4560      	cmp	r0, ip
    20f6:	bf38      	it	cc
    20f8:	f10b 0b01 	addcc.w	fp, fp, #1
    20fc:	45f3      	cmp	fp, lr
    20fe:	f240 82d2 	bls.w	26a6 <am_hal_iom_workaround_word_write+0x766>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    2102:	00c8      	lsls	r0, r1, #3
    2104:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    2108:	fbb2 fbf0 	udiv	fp, r2, r0
    210c:	fb00 fc0b 	mul.w	ip, r0, fp
    2110:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    2114:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    2118:	0840      	lsrs	r0, r0, #1
    211a:	4560      	cmp	r0, ip
    211c:	bf38      	it	cc
    211e:	f10b 0b01 	addcc.w	fp, fp, #1
    2122:	45f3      	cmp	fp, lr
    2124:	f240 82c1 	bls.w	26aa <am_hal_iom_workaround_word_write+0x76a>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    2128:	0108      	lsls	r0, r1, #4
    212a:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    212e:	fbb2 fbf0 	udiv	fp, r2, r0
    2132:	fb00 fc0b 	mul.w	ip, r0, fp
    2136:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    213a:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    213e:	0840      	lsrs	r0, r0, #1
    2140:	4560      	cmp	r0, ip
    2142:	bf38      	it	cc
    2144:	f10b 0b01 	addcc.w	fp, fp, #1
    2148:	45f3      	cmp	fp, lr
    214a:	f240 82b0 	bls.w	26ae <am_hal_iom_workaround_word_write+0x76e>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    214e:	0149      	lsls	r1, r1, #5
    2150:	fb03 f301 	mul.w	r3, r3, r1
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    2154:	fbb2 f2f3 	udiv	r2, r2, r3
    2158:	fb03 f002 	mul.w	r0, r3, r2
    215c:	f1c0 7c37 	rsb	ip, r0, #47972352	; 0x2dc0000
    2160:	f50c 4bd8 	add.w	fp, ip, #27648	; 0x6c00
    2164:	085b      	lsrs	r3, r3, #1
    2166:	455b      	cmp	r3, fp
    2168:	bf38      	it	cc
    216a:	3201      	addcc	r2, #1

    //
    // Starting with the current clock configuration parameters, find a value
    // of FSEL that will bring our total frequency down to or below maxFreq.
    //
    for ( ui32Fsel = 1; ui32Fsel < 8; ui32Fsel++ )
    216c:	4572      	cmp	r2, lr
    216e:	bf8c      	ite	hi
    2170:	2107      	movhi	r1, #7
    2172:	2106      	movls	r1, #6
    // Get a reasonably slow speed (~1MHz) we can safely poll for the transition
    ui32LowFsel = iom_get_workaround_fsel(1000000);
    ui32LowClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32LowFsel));

    if ( ui32Options & AM_HAL_IOM_RAW )
    2174:	9801      	ldr	r0, [sp, #4]
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");

    // Get a reasonably slow speed (~1MHz) we can safely poll for the transition
    ui32LowFsel = iom_get_workaround_fsel(1000000);
    ui32LowClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
    2176:	ea4a 2201 	orr.w	r2, sl, r1, lsl #8
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32LowFsel));

    if ( ui32Options & AM_HAL_IOM_RAW )
    217a:	f010 4180 	ands.w	r1, r0, #1073741824	; 0x40000000
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");

    // Get a reasonably slow speed (~1MHz) we can safely poll for the transition
    ui32LowFsel = iom_get_workaround_fsel(1000000);
    ui32LowClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
    217e:	9203      	str	r2, [sp, #12]
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32LowFsel));

    if ( ui32Options & AM_HAL_IOM_RAW )
    2180:	f000 813f 	beq.w	2402 <am_hal_iom_workaround_word_write+0x4c2>
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((27 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));

        if ( pui32Data[0] & 0x80 )
    2184:	f8d8 3000 	ldr.w	r3, [r8]
        // The transition we care for is on 33rd bit.
        // Prepare to delay 27 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((27 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    2188:	4a3e      	ldr	r2, [pc, #248]	; (2284 <am_hal_iom_workaround_word_write+0x344>)

        if ( pui32Data[0] & 0x80 )
    218a:	f003 0080 	and.w	r0, r3, #128	; 0x80
        {
            ui32FirstWord = 0x00000000;
    218e:	2800      	cmp	r0, #0
        // The transition we care for is on 33rd bit.
        // Prepare to delay 27 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((27 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    2190:	eb06 0146 	add.w	r1, r6, r6, lsl #1
    2194:	fbb2 f3f1 	udiv	r3, r2, r1
    2198:	9307      	str	r3, [sp, #28]

        if ( pui32Data[0] & 0x80 )
        {
            ui32FirstWord = 0x00000000;
    219a:	bf0b      	itete	eq
    219c:	2300      	moveq	r3, #0
    219e:	2301      	movne	r3, #1
    21a0:	f06f 06ff 	mvneq.w	r6, #255	; 0xff
    21a4:	2600      	movne	r6, #0
    21a6:	9306      	str	r3, [sp, #24]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    21a8:	4a30      	ldr	r2, [pc, #192]	; (226c <am_hal_iom_workaround_word_write+0x32c>)
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    21aa:	4837      	ldr	r0, [pc, #220]	; (2288 <am_hal_iom_workaround_word_write+0x348>)
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    21ac:	6812      	ldr	r2, [r2, #0]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    21ae:	6801      	ldr	r1, [r0, #0]
    // Now that weve taken care of the offset byte, we can run the
    // transaction in RAW mode.
    //
    ui32Options |= AM_HAL_IOM_RAW;

    ui32NumBytes += 4;
    21b0:	f109 0304 	add.w	r3, r9, #4

    //
    // Figure out how many bytes we can write to the FIFO immediately.
    //
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    21b4:	429f      	cmp	r7, r3
    21b6:	bf28      	it	cs
    21b8:	461f      	movcs	r7, r3
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    21ba:	f012 0f08 	tst.w	r2, #8
    21be:	bf14      	ite	ne
    21c0:	2240      	movne	r2, #64	; 0x40
    21c2:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    21c4:	1a50      	subs	r0, r2, r1
    21c6:	f000 02fc 	and.w	r2, r0, #252	; 0xfc
    21ca:	2a03      	cmp	r2, #3
    21cc:	f240 8209 	bls.w	25e2 <am_hal_iom_workaround_word_write+0x6a2>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    21d0:	492e      	ldr	r1, [pc, #184]	; (228c <am_hal_iom_workaround_word_write+0x34c>)
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    21d2:	4826      	ldr	r0, [pc, #152]	; (226c <am_hal_iom_workaround_word_write+0x32c>)
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    21d4:	600e      	str	r6, [r1, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    21d6:	6806      	ldr	r6, [r0, #0]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    21d8:	f850 1c1c 	ldr.w	r1, [r0, #-28]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    21dc:	f016 0f08 	tst.w	r6, #8
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    21e0:	f1a0 021c 	sub.w	r2, r0, #28
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    21e4:	bf14      	ite	ne
    21e6:	2240      	movne	r2, #64	; 0x40
    21e8:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    21ea:	1a50      	subs	r0, r2, r1
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
                        ui32MaxFifoSize);

    am_hal_iom_fifo_write(WORKAROUND_IOM, &ui32FirstWord, 4);

    am_hal_iom_fifo_write(WORKAROUND_IOM, pui32Data, ui32TransferSize - 4);
    21ec:	3f04      	subs	r7, #4
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    21ee:	f000 06fc 	and.w	r6, r0, #252	; 0xfc
    21f2:	42b7      	cmp	r7, r6
    21f4:	f200 81ec 	bhi.w	25d0 <am_hal_iom_workaround_word_write+0x690>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    21f8:	2f00      	cmp	r7, #0
    21fa:	d069      	beq.n	22d0 <am_hal_iom_workaround_word_write+0x390>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    21fc:	4642      	mov	r2, r8
    21fe:	ea6f 0908 	mvn.w	r9, r8
    2202:	f852 cb04 	ldr.w	ip, [r2], #4
    2206:	4921      	ldr	r1, [pc, #132]	; (228c <am_hal_iom_workaround_word_write+0x34c>)
    2208:	44c1      	add	r9, r8

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    220a:	ebc8 0b02 	rsb	fp, r8, r2
    220e:	44b9      	add	r9, r7
    2210:	455f      	cmp	r7, fp
    2212:	f3c9 0082 	ubfx	r0, r9, #2, #3
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2216:	f8c1 c000 	str.w	ip, [r1]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    221a:	d959      	bls.n	22d0 <am_hal_iom_workaround_word_write+0x390>
    221c:	2800      	cmp	r0, #0
    221e:	d039      	beq.n	2294 <am_hal_iom_workaround_word_write+0x354>
    2220:	2801      	cmp	r0, #1
    2222:	d01b      	beq.n	225c <am_hal_iom_workaround_word_write+0x31c>
    2224:	2802      	cmp	r0, #2
    2226:	d016      	beq.n	2256 <am_hal_iom_workaround_word_write+0x316>
    2228:	2803      	cmp	r0, #3
    222a:	d011      	beq.n	2250 <am_hal_iom_workaround_word_write+0x310>
    222c:	2804      	cmp	r0, #4
    222e:	d00c      	beq.n	224a <am_hal_iom_workaround_word_write+0x30a>
    2230:	2805      	cmp	r0, #5
    2232:	d007      	beq.n	2244 <am_hal_iom_workaround_word_write+0x304>
    2234:	2806      	cmp	r0, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2236:	bf1c      	itt	ne
    2238:	f852 0b04 	ldrne.w	r0, [r2], #4
    223c:	6008      	strne	r0, [r1, #0]
    223e:	f852 6b04 	ldr.w	r6, [r2], #4
    2242:	600e      	str	r6, [r1, #0]
    2244:	f852 0b04 	ldr.w	r0, [r2], #4
    2248:	6008      	str	r0, [r1, #0]
    224a:	f852 6b04 	ldr.w	r6, [r2], #4
    224e:	600e      	str	r6, [r1, #0]
    2250:	f852 0b04 	ldr.w	r0, [r2], #4
    2254:	6008      	str	r0, [r1, #0]
    2256:	f852 6b04 	ldr.w	r6, [r2], #4
    225a:	600e      	str	r6, [r1, #0]
    225c:	f852 0b04 	ldr.w	r0, [r2], #4
    2260:	6008      	str	r0, [r1, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2262:	ebc8 0602 	rsb	r6, r8, r2
    2266:	42b7      	cmp	r7, r6
    2268:	d932      	bls.n	22d0 <am_hal_iom_workaround_word_write+0x390>
    226a:	e013      	b.n	2294 <am_hal_iom_workaround_word_write+0x354>
    226c:	5000811c 	.word	0x5000811c
    2270:	5000810c 	.word	0x5000810c
    2274:	02dc6c00 	.word	0x02dc6c00
    2278:	00f42400 	.word	0x00f42400
    227c:	0800009d 	.word	0x0800009d
    2280:	05b8d800 	.word	0x05b8d800
    2284:	4d3f6400 	.word	0x4d3f6400
    2288:	50008100 	.word	0x50008100
    228c:	50008000 	.word	0x50008000
    2290:	000f4240 	.word	0x000f4240
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2294:	4692      	mov	sl, r2
    2296:	3220      	adds	r2, #32
    2298:	f85a 0b04 	ldr.w	r0, [sl], #4
    229c:	6008      	str	r0, [r1, #0]
    229e:	f852 6c1c 	ldr.w	r6, [r2, #-28]
    22a2:	600e      	str	r6, [r1, #0]
    22a4:	f8da 0004 	ldr.w	r0, [sl, #4]
    22a8:	6008      	str	r0, [r1, #0]
    22aa:	f852 6c14 	ldr.w	r6, [r2, #-20]
    22ae:	600e      	str	r6, [r1, #0]
    22b0:	f852 0c10 	ldr.w	r0, [r2, #-16]
    22b4:	6008      	str	r0, [r1, #0]
    22b6:	f852 6c0c 	ldr.w	r6, [r2, #-12]
    22ba:	600e      	str	r6, [r1, #0]
    22bc:	f852 0c08 	ldr.w	r0, [r2, #-8]
    22c0:	6008      	str	r0, [r1, #0]
    22c2:	f852 6c04 	ldr.w	r6, [r2, #-4]
    22c6:	600e      	str	r6, [r1, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    22c8:	ebc8 0e02 	rsb	lr, r8, r2
    22cc:	4577      	cmp	r7, lr
    22ce:	d8e1      	bhi.n	2294 <am_hal_iom_workaround_word_write+0x354>
    for ( index = 0; index < (sizeof(g_IOMPads) / sizeof(IOMPad_t)); index++ )
    {
        //
        //  Is this one of the CEn that we are using?
        //
        if ( g_IOMPads[index].channel == ui32ChipSelect )
    22d0:	2c00      	cmp	r4, #0
    22d2:	f000 81c7 	beq.w	2664 <am_hal_iom_workaround_word_write+0x724>
    22d6:	2c01      	cmp	r4, #1
    22d8:	f000 80a4 	beq.w	2424 <am_hal_iom_workaround_word_write+0x4e4>
    22dc:	2c02      	cmp	r4, #2
    22de:	f000 80b9 	beq.w	2454 <am_hal_iom_workaround_word_write+0x514>
    22e2:	2c03      	cmp	r4, #3
    22e4:	f000 80c7 	beq.w	2476 <am_hal_iom_workaround_word_write+0x536>
    22e8:	2c04      	cmp	r4, #4
    22ea:	f000 811f 	beq.w	252c <am_hal_iom_workaround_word_write+0x5ec>
    22ee:	2c05      	cmp	r4, #5
    22f0:	f000 8134 	beq.w	255c <am_hal_iom_workaround_word_write+0x61c>
    22f4:	2c06      	cmp	r4, #6
    22f6:	f000 8149 	beq.w	258c <am_hal_iom_workaround_word_write+0x64c>
    22fa:	2c07      	cmp	r4, #7
    22fc:	f000 8157 	beq.w	25ae <am_hal_iom_workaround_word_write+0x66e>
    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32CSPadregVal = *pui32CSPadreg;
    2300:	4ec3      	ldr	r6, [pc, #780]	; (2610 <am_hal_iom_workaround_word_write+0x6d0>)
    //
    // Calculate the GPIO to be controlled until the initial shift is
    // complete. Make sure we get a valid value.
    //
    ui32IOMGPIO = iom_calc_gpio(ui32ChipSelect);
    am_hal_debug_assert(0xDEADBEEF != ui32IOMGPIO);
    2302:	48c4      	ldr	r0, [pc, #784]	; (2614 <am_hal_iom_workaround_word_write+0x6d4>)
    2304:	9304      	str	r3, [sp, #16]
    2306:	f240 5126 	movw	r1, #1318	; 0x526
    230a:	2200      	movs	r2, #0
    230c:	f7ff f97e 	bl	160c <am_hal_debug_error>
    ui32CSPadregVal = *pui32CSPadreg;

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    2310:	4fc1      	ldr	r7, [pc, #772]	; (2618 <am_hal_iom_workaround_word_write+0x6d8>)
    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32CSPadregVal = *pui32CSPadreg;
    2312:	6833      	ldr	r3, [r6, #0]
    2314:	9302      	str	r3, [sp, #8]

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    2316:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    231a:	9b04      	ldr	r3, [sp, #16]
    231c:	6039      	str	r1, [r7, #0]

    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    231e:	46b3      	mov	fp, r6
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_GPIO_OUTPUT);

    //
    // Enable the input buffer on MOSI.
    //
    am_hal_gpio_pin_config(WORKAROUND_IOM_MOSI_PIN, WORKAROUND_IOM_MOSI_CFG | AM_HAL_PIN_DIR_INPUT);
    2320:	f3ef 8210 	mrs	r2, PRIMASK
    2324:	9204      	str	r2, [sp, #16]
    2326:	920a      	str	r2, [sp, #40]	; 0x28
    2328:	b672      	cpsid	i
    232a:	4ebc      	ldr	r6, [pc, #752]	; (261c <am_hal_iom_workaround_word_write+0x6dc>)
    232c:	f8df 9324 	ldr.w	r9, [pc, #804]	; 2654 <am_hal_iom_workaround_word_write+0x714>
    2330:	f8df 8324 	ldr.w	r8, [pc, #804]	; 2658 <am_hal_iom_workaround_word_write+0x718>
    2334:	4fba      	ldr	r7, [pc, #744]	; (2620 <am_hal_iom_workaround_word_write+0x6e0>)
    2336:	2173      	movs	r1, #115	; 0x73
    2338:	6031      	str	r1, [r6, #0]
    233a:	f8d9 0000 	ldr.w	r0, [r9]
    233e:	f420 22e0 	bic.w	r2, r0, #458752	; 0x70000
    2342:	f8c9 2000 	str.w	r2, [r9]
    2346:	f8d8 1000 	ldr.w	r1, [r8]
    234a:	f021 00ff 	bic.w	r0, r1, #255	; 0xff
    234e:	f040 022a 	orr.w	r2, r0, #42	; 0x2a
    2352:	f8c8 2000 	str.w	r2, [r8]
    2356:	6839      	ldr	r1, [r7, #0]
    2358:	f04f 0a00 	mov.w	sl, #0
    235c:	f021 00ff 	bic.w	r0, r1, #255	; 0xff
    2360:	6038      	str	r0, [r7, #0]
    2362:	f8c6 a000 	str.w	sl, [r6]
    2366:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    2368:	f382 8810 	msr	PRIMASK, r2
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    236c:	9901      	ldr	r1, [sp, #4]
    236e:	0424      	lsls	r4, r4, #16
    2370:	f021 4c23 	bic.w	ip, r1, #2734686208	; 0xa3000000
    2374:	f404 20e0 	and.w	r0, r4, #458752	; 0x70000
    2378:	f00c 22ff 	and.w	r2, ip, #4278255360	; 0xff00ff00
    237c:	f040 4480 	orr.w	r4, r0, #1073741824	; 0x40000000
    2380:	b2d9      	uxtb	r1, r3
    2382:	4322      	orrs	r2, r4
    2384:	03db      	lsls	r3, r3, #15
    2386:	f003 64f0 	and.w	r4, r3, #125829120	; 0x7800000
    238a:	430a      	orrs	r2, r1

    //
    // Write the GPIO PADKEY register to allow the workaround loop to
    // reconfigure chip enable.
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    238c:	2073      	movs	r0, #115	; 0x73
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    238e:	4322      	orrs	r2, r4

    //
    // Write the GPIO PADKEY register to allow the workaround loop to
    // reconfigure chip enable.
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    2390:	6030      	str	r0, [r6, #0]
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    2392:	9205      	str	r2, [sp, #20]
{
    uint32_t ui32Critical = 0;
    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    2394:	f7ff fa30 	bl	17f8 <am_hal_interrupt_master_disable>

    //
    // Start the write on the bus.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CMD) = ui32Command;
    2398:	4ba2      	ldr	r3, [pc, #648]	; (2624 <am_hal_iom_workaround_word_write+0x6e4>)
{
    uint32_t ui32Critical = 0;
    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    239a:	9001      	str	r0, [sp, #4]

    //
    // Start the write on the bus.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CMD) = ui32Command;
    239c:	9805      	ldr	r0, [sp, #20]
    // loop runs an edge-detector on MOSI, and triggers a falling edge on
    // chip-enable on the first bit of our real data.
    //
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    // Switch to Low Freq
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32LowClkCfg;
    239e:	4ca2      	ldr	r4, [pc, #648]	; (2628 <am_hal_iom_workaround_word_write+0x6e8>)
    ui32Critical = am_hal_interrupt_master_disable();

    //
    // Start the write on the bus.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CMD) = ui32Command;
    23a0:	6018      	str	r0, [r3, #0]
    //
    // Slow down the clock, and run the workaround loop. The workaround
    // loop runs an edge-detector on MOSI, and triggers a falling edge on
    // chip-enable on the first bit of our real data.
    //
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    23a2:	49a2      	ldr	r1, [pc, #648]	; (262c <am_hal_iom_workaround_word_write+0x6ec>)
    23a4:	9807      	ldr	r0, [sp, #28]
    23a6:	4788      	blx	r1
    // Switch to Low Freq
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32LowClkCfg;
    23a8:	9b03      	ldr	r3, [sp, #12]
    iom_workaround_loop(ui32CSPadregVal, pui32CSPadreg, bRising);
    23aa:	9a06      	ldr	r2, [sp, #24]
    23ac:	9802      	ldr	r0, [sp, #8]
    // loop runs an edge-detector on MOSI, and triggers a falling edge on
    // chip-enable on the first bit of our real data.
    //
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    // Switch to Low Freq
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32LowClkCfg;
    23ae:	6023      	str	r3, [r4, #0]
    iom_workaround_loop(ui32CSPadregVal, pui32CSPadreg, bRising);
    23b0:	4659      	mov	r1, fp
    23b2:	f7ff fa29 	bl	1808 <iom_workaround_loop>
    //
    // Restore the clock frequency and the normal MOSI pin function.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32ClkCfg;
    23b6:	6025      	str	r5, [r4, #0]
    am_hal_gpio_pin_config(WORKAROUND_IOM_MOSI_PIN, WORKAROUND_IOM_MOSI_CFG);
    23b8:	9d04      	ldr	r5, [sp, #16]
    23ba:	950b      	str	r5, [sp, #44]	; 0x2c
    23bc:	b672      	cpsid	i
    23be:	2473      	movs	r4, #115	; 0x73
    23c0:	6034      	str	r4, [r6, #0]
    23c2:	f8d9 2000 	ldr.w	r2, [r9]
    23c6:	f422 21e0 	bic.w	r1, r2, #458752	; 0x70000
    23ca:	f8c9 1000 	str.w	r1, [r9]
    23ce:	f8d8 0000 	ldr.w	r0, [r8]
    23d2:	f020 03ff 	bic.w	r3, r0, #255	; 0xff
    23d6:	f043 0528 	orr.w	r5, r3, #40	; 0x28
    23da:	f8c8 5000 	str.w	r5, [r8]
    23de:	683c      	ldr	r4, [r7, #0]
    23e0:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
    23e4:	603a      	str	r2, [r7, #0]
    23e6:	f8c6 a000 	str.w	sl, [r6]
    23ea:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    23ec:	f387 8810 	msr	PRIMASK, r7

    //
    // End the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    23f0:	9901      	ldr	r1, [sp, #4]
    23f2:	4608      	mov	r0, r1
    23f4:	f7ff fa04 	bl	1800 <am_hal_interrupt_master_set>
            ui32DelayTime, ui32ClkCfg,
            ui32LowClkCfg, bRising);
    //
    // Re-lock the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = 0;
    23f8:	f8c6 a000 	str.w	sl, [r6]
    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += (ui32TransferSize - 4) >> 2;
}
    23fc:	b00d      	add	sp, #52	; 0x34
    23fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        // Prepare to delay 19 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
    2402:	0402      	lsls	r2, r0, #16
        // The transition we care for is on 25th bit.
        // Prepare to delay 19 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    2404:	eb06 0a46 	add.w	sl, r6, r6, lsl #1
    2408:	4e89      	ldr	r6, [pc, #548]	; (2630 <am_hal_iom_workaround_word_write+0x6f0>)
    240a:	fbb6 f3fa 	udiv	r3, r6, sl
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
        if ( ui32FirstWord & 0x80000000 )
    240e:	f012 467f 	ands.w	r6, r2, #4278190080	; 0xff000000
        // The transition we care for is on 25th bit.
        // Prepare to delay 19 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    2412:	9307      	str	r3, [sp, #28]
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
        if ( ui32FirstWord & 0x80000000 )
    2414:	f100 813d 	bmi.w	2692 <am_hal_iom_workaround_word_write+0x752>
        {
            bRising = true;
        }
        else
        {
            ui32FirstWord |= 0x00FFFF00;
    2418:	f446 007f 	orr.w	r0, r6, #16711680	; 0xff0000
    241c:	f440 467f 	orr.w	r6, r0, #65280	; 0xff00
            bRising = false;
    2420:	9106      	str	r1, [sp, #24]
    2422:	e6c1      	b.n	21a8 <am_hal_iom_workaround_word_write+0x268>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2424:	4e83      	ldr	r6, [pc, #524]	; (2634 <am_hal_iom_workaround_word_write+0x6f4>)
    2426:	6837      	ldr	r7, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2428:	f3c7 41c2 	ubfx	r1, r7, #19, #3
    242c:	2904      	cmp	r1, #4
    242e:	f000 814a 	beq.w	26c6 <am_hal_iom_workaround_word_write+0x786>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2432:	3614      	adds	r6, #20
    2434:	6832      	ldr	r2, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2436:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    243a:	2805      	cmp	r0, #5
    243c:	f47f af60 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2440:	2225      	movs	r2, #37	; 0x25
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2442:	46b3      	mov	fp, r6
    2444:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2446:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    244a:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    244e:	f04f 0824 	mov.w	r8, #36	; 0x24
    2452:	e027      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    2454:	4978      	ldr	r1, [pc, #480]	; (2638 <am_hal_iom_workaround_word_write+0x6f8>)
    2456:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2458:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    245c:	2806      	cmp	r0, #6
    245e:	f47f af4f 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2462:	2229      	movs	r2, #41	; 0x29
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2464:	468b      	mov	fp, r1
    2466:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2468:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    246c:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2470:	f04f 0828 	mov.w	r8, #40	; 0x28
    2474:	e016      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    2476:	496f      	ldr	r1, [pc, #444]	; (2634 <am_hal_iom_workaround_word_write+0x6f4>)
    2478:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    247a:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    247e:	2804      	cmp	r0, #4
    2480:	f000 812a 	beq.w	26d8 <am_hal_iom_workaround_word_write+0x798>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2484:	311c      	adds	r1, #28
    2486:	680e      	ldr	r6, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2488:	f3c6 27c2 	ubfx	r7, r6, #11, #3
    248c:	2f04      	cmp	r7, #4
    248e:	f47f af37 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2492:	222d      	movs	r2, #45	; 0x2d
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2494:	468b      	mov	fp, r1
    2496:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2498:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    249c:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    24a0:	f04f 082c 	mov.w	r8, #44	; 0x2c
    ui32CSPadregVal = *pui32CSPadreg;

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    24a4:	08d0      	lsrs	r0, r2, #3
    24a6:	f00c 071f 	and.w	r7, ip, #31
    24aa:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 265c <am_hal_iom_workaround_word_write+0x71c>
    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32CSPadregVal = *pui32CSPadreg;
    24ae:	f8db 1000 	ldr.w	r1, [fp]
    24b2:	9102      	str	r1, [sp, #8]

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    24b4:	f000 0c04 	and.w	ip, r0, #4
    24b8:	2601      	movs	r6, #1
    24ba:	40be      	lsls	r6, r7
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_GPIO_OUTPUT);
    24bc:	f3ef 8010 	mrs	r0, PRIMASK
    ui32CSPadregVal = *pui32CSPadreg;

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    24c0:	f84c 600e 	str.w	r6, [ip, lr]
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_GPIO_OUTPUT);
    24c4:	9009      	str	r0, [sp, #36]	; 0x24
    24c6:	b672      	cpsid	i
    24c8:	4f54      	ldr	r7, [pc, #336]	; (261c <am_hal_iom_workaround_word_write+0x6dc>)
    24ca:	f8df c194 	ldr.w	ip, [pc, #404]	; 2660 <am_hal_iom_workaround_word_write+0x720>
    24ce:	0856      	lsrs	r6, r2, #1
    24d0:	f006 067c 	and.w	r6, r6, #124	; 0x7c
    24d4:	2173      	movs	r1, #115	; 0x73
    24d6:	6039      	str	r1, [r7, #0]
    24d8:	0092      	lsls	r2, r2, #2
    24da:	f856 000c 	ldr.w	r0, [r6, ip]
    24de:	f002 021c 	and.w	r2, r2, #28
    24e2:	2107      	movs	r1, #7
    24e4:	4091      	lsls	r1, r2
    24e6:	ea20 0001 	bic.w	r0, r0, r1
    24ea:	2102      	movs	r1, #2
    24ec:	fa01 f202 	lsl.w	r2, r1, r2
    24f0:	4302      	orrs	r2, r0
    24f2:	f846 200c 	str.w	r2, [r6, ip]
    24f6:	f8db 6000 	ldr.w	r6, [fp]
    24fa:	ea6f 0009 	mvn.w	r0, r9
    24fe:	f04f 0918 	mov.w	r9, #24
    2502:	fa09 f10a 	lsl.w	r1, r9, sl
    2506:	ea06 0a00 	and.w	sl, r6, r0
    250a:	f10e 0e50 	add.w	lr, lr, #80	; 0x50
    250e:	ea41 020a 	orr.w	r2, r1, sl
    2512:	f8cb 2000 	str.w	r2, [fp]
    2516:	f858 600e 	ldr.w	r6, [r8, lr]
    251a:	2100      	movs	r1, #0
    251c:	4030      	ands	r0, r6
    251e:	f848 000e 	str.w	r0, [r8, lr]
    2522:	6039      	str	r1, [r7, #0]
    2524:	9f09      	ldr	r7, [sp, #36]	; 0x24
    2526:	f387 8810 	msr	PRIMASK, r7
    252a:	e6f9      	b.n	2320 <am_hal_iom_workaround_word_write+0x3e0>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    252c:	4943      	ldr	r1, [pc, #268]	; (263c <am_hal_iom_workaround_word_write+0x6fc>)
    252e:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2530:	f3c2 40c2 	ubfx	r0, r2, #19, #3
    2534:	2806      	cmp	r0, #6
    2536:	f000 80d9 	beq.w	26ec <am_hal_iom_workaround_word_write+0x7ac>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    253a:	3124      	adds	r1, #36	; 0x24
    253c:	680e      	ldr	r6, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    253e:	f3c6 47c2 	ubfx	r7, r6, #19, #3
    2542:	2f06      	cmp	r7, #6
    2544:	f47f aedc 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2548:	222e      	movs	r2, #46	; 0x2e
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    254a:	468b      	mov	fp, r1
    254c:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    254e:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    2552:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2556:	f04f 082c 	mov.w	r8, #44	; 0x2c
    255a:	e7a3      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    255c:	4937      	ldr	r1, [pc, #220]	; (263c <am_hal_iom_workaround_word_write+0x6fc>)
    255e:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2560:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    2564:	2804      	cmp	r0, #4
    2566:	f000 80cb 	beq.w	2700 <am_hal_iom_workaround_word_write+0x7c0>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    256a:	3124      	adds	r1, #36	; 0x24
    256c:	680e      	ldr	r6, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    256e:	f3c6 67c2 	ubfx	r7, r6, #27, #3
    2572:	2f06      	cmp	r7, #6
    2574:	f47f aec4 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2578:	222f      	movs	r2, #47	; 0x2f
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    257a:	468b      	mov	fp, r1
    257c:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    257e:	f04f 497f 	mov.w	r9, #4278190080	; 0xff000000
    2582:	f04f 0a18 	mov.w	sl, #24
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2586:	f04f 082c 	mov.w	r8, #44	; 0x2c
    258a:	e78b      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    258c:	482c      	ldr	r0, [pc, #176]	; (2640 <am_hal_iom_workaround_word_write+0x700>)
    258e:	6806      	ldr	r6, [r0, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2590:	f3c6 67c2 	ubfx	r7, r6, #27, #3
    2594:	2f04      	cmp	r7, #4
    2596:	f47f aeb3 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    259a:	2223      	movs	r2, #35	; 0x23
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    259c:	4683      	mov	fp, r0
    259e:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    25a0:	f04f 497f 	mov.w	r9, #4278190080	; 0xff000000
    25a4:	f04f 0a18 	mov.w	sl, #24
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    25a8:	f04f 0820 	mov.w	r8, #32
    25ac:	e77a      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    25ae:	4f25      	ldr	r7, [pc, #148]	; (2644 <am_hal_iom_workaround_word_write+0x704>)
    25b0:	683a      	ldr	r2, [r7, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    25b2:	f3c2 41c2 	ubfx	r1, r2, #19, #3
    25b6:	2906      	cmp	r1, #6
    25b8:	f47f aea2 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    25bc:	2226      	movs	r2, #38	; 0x26
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    25be:	46bb      	mov	fp, r7
    25c0:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    25c2:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    25c6:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    25ca:	f04f 0824 	mov.w	r8, #36	; 0x24
    25ce:	e769      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    25d0:	4a1d      	ldr	r2, [pc, #116]	; (2648 <am_hal_iom_workaround_word_write+0x708>)
    25d2:	4810      	ldr	r0, [pc, #64]	; (2614 <am_hal_iom_workaround_word_write+0x6d4>)
    25d4:	9302      	str	r3, [sp, #8]
    25d6:	f640 7107 	movw	r1, #3847	; 0xf07
    25da:	f7ff f817 	bl	160c <am_hal_debug_error>
    25de:	9b02      	ldr	r3, [sp, #8]
    25e0:	e60c      	b.n	21fc <am_hal_iom_workaround_word_write+0x2bc>
    25e2:	4a19      	ldr	r2, [pc, #100]	; (2648 <am_hal_iom_workaround_word_write+0x708>)
    25e4:	480b      	ldr	r0, [pc, #44]	; (2614 <am_hal_iom_workaround_word_write+0x6d4>)
    25e6:	9302      	str	r3, [sp, #8]
    25e8:	f640 7107 	movw	r1, #3847	; 0xf07
    25ec:	f7ff f80e 	bl	160c <am_hal_debug_error>
    25f0:	9b02      	ldr	r3, [sp, #8]
    25f2:	e5ed      	b.n	21d0 <am_hal_iom_workaround_word_write+0x290>
    ui32HiFreq = am_hal_iom_frequency_get(ui32HiClkCfg);

    //
    // Validate return value to prevent DIVBY0 errors.
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");
    25f4:	4a15      	ldr	r2, [pc, #84]	; (264c <am_hal_iom_workaround_word_write+0x70c>)
    25f6:	4807      	ldr	r0, [pc, #28]	; (2614 <am_hal_iom_workaround_word_write+0x6d4>)
    25f8:	f240 41de 	movw	r1, #1246	; 0x4de
    25fc:	f7ff f806 	bl	160c <am_hal_debug_error>
    2600:	e538      	b.n	2074 <am_hal_iom_workaround_word_write+0x134>
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
    2602:	4a13      	ldr	r2, [pc, #76]	; (2650 <am_hal_iom_workaround_word_write+0x710>)
    2604:	4803      	ldr	r0, [pc, #12]	; (2614 <am_hal_iom_workaround_word_write+0x6d4>)
    2606:	f240 41b3 	movw	r1, #1203	; 0x4b3
    260a:	f7fe ffff 	bl	160c <am_hal_debug_error>
    260e:	e4aa      	b.n	1f66 <am_hal_iom_workaround_word_write+0x26>
    2610:	400100ec 	.word	0x400100ec
    2614:	00005394 	.word	0x00005394
    2618:	40010094 	.word	0x40010094
    261c:	40010060 	.word	0x40010060
    2620:	4001010c 	.word	0x4001010c
    2624:	50008110 	.word	0x50008110
    2628:	5000810c 	.word	0x5000810c
    262c:	0800009d 	.word	0x0800009d
    2630:	365c0400 	.word	0x365c0400
    2634:	40010010 	.word	0x40010010
    2638:	40010028 	.word	0x40010028
    263c:	40010008 	.word	0x40010008
    2640:	40010020 	.word	0x40010020
    2644:	40010024 	.word	0x40010024
    2648:	00005360 	.word	0x00005360
    264c:	00005428 	.word	0x00005428
    2650:	00005410 	.word	0x00005410
    2654:	40010054 	.word	0x40010054
    2658:	4001002c 	.word	0x4001002c
    265c:	40010090 	.word	0x40010090
    2660:	40010040 	.word	0x40010040
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2664:	4e2b      	ldr	r6, [pc, #172]	; (2714 <am_hal_iom_workaround_word_write+0x7d4>)
    2666:	6837      	ldr	r7, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2668:	f3c7 21c2 	ubfx	r1, r7, #11, #3
    266c:	2906      	cmp	r1, #6
    266e:	d020      	beq.n	26b2 <am_hal_iom_workaround_word_write+0x772>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2670:	3604      	adds	r6, #4
    2672:	6832      	ldr	r2, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    2674:	f3c2 40c2 	ubfx	r0, r2, #19, #3
    2678:	2806      	cmp	r0, #6
    267a:	f47f ae41 	bne.w	2300 <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    267e:	2222      	movs	r2, #34	; 0x22
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2680:	46b3      	mov	fp, r6
    2682:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2684:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    2688:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    268c:	f04f 0820 	mov.w	r8, #32
    2690:	e708      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
        if ( ui32FirstWord & 0x80000000 )
        {
            bRising = true;
    2692:	2101      	movs	r1, #1
    2694:	9106      	str	r1, [sp, #24]
    2696:	e587      	b.n	21a8 <am_hal_iom_workaround_word_write+0x268>

    //
    // Starting with the current clock configuration parameters, find a value
    // of FSEL that will bring our total frequency down to or below maxFreq.
    //
    for ( ui32Fsel = 1; ui32Fsel < 8; ui32Fsel++ )
    2698:	2101      	movs	r1, #1
    269a:	e56b      	b.n	2174 <am_hal_iom_workaround_word_write+0x234>
    269c:	f04f 0e01 	mov.w	lr, #1
    26a0:	e499      	b.n	1fd6 <am_hal_iom_workaround_word_write+0x96>
    26a2:	2102      	movs	r1, #2
    26a4:	e566      	b.n	2174 <am_hal_iom_workaround_word_write+0x234>
    26a6:	2103      	movs	r1, #3
    26a8:	e564      	b.n	2174 <am_hal_iom_workaround_word_write+0x234>
    26aa:	2104      	movs	r1, #4
    26ac:	e562      	b.n	2174 <am_hal_iom_workaround_word_write+0x234>
    26ae:	2105      	movs	r1, #5
    26b0:	e560      	b.n	2174 <am_hal_iom_workaround_word_write+0x234>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    26b2:	221d      	movs	r2, #29
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    26b4:	46b3      	mov	fp, r6
    26b6:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    26b8:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    26bc:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    26c0:	f04f 081c 	mov.w	r8, #28
    26c4:	e6ee      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    26c6:	f04f 0a10 	mov.w	sl, #16
    26ca:	2212      	movs	r2, #18
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    26cc:	46b3      	mov	fp, r6
    26ce:	46d0      	mov	r8, sl
    26d0:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    26d2:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    26d6:	e6e5      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    26d8:	2211      	movs	r2, #17
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    26da:	468b      	mov	fp, r1
    26dc:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    26de:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    26e2:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    26e6:	f04f 0810 	mov.w	r8, #16
    26ea:	e6db      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    26ec:	220a      	movs	r2, #10
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    26ee:	468b      	mov	fp, r1
    26f0:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    26f2:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    26f6:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    26fa:	f04f 0808 	mov.w	r8, #8
    26fe:	e6d1      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    2700:	f04f 0a08 	mov.w	sl, #8
    2704:	2209      	movs	r2, #9
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    2706:	468b      	mov	fp, r1
    2708:	46d0      	mov	r8, sl
    270a:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    270c:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    2710:	e6c8      	b.n	24a4 <am_hal_iom_workaround_word_write+0x564>
    2712:	bf00      	nop
    2714:	4001001c 	.word	0x4001001c

00002718 <am_hal_iom_spi_write_nb.part.6>:
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    2718:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    271c:	f500 24a0 	add.w	r4, r0, #327680	; 0x50000
    2720:	3404      	adds	r4, #4
    2722:	0324      	lsls	r4, r4, #12
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    2724:	4607      	mov	r7, r0
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2726:	f8d4 011c 	ldr.w	r0, [r4, #284]	; 0x11c
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    272a:	4e68      	ldr	r6, [pc, #416]	; (28cc <am_hal_iom_spi_write_nb.part.6+0x1b4>)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    272c:	f3c0 05c0 	ubfx	r5, r0, #3, #1
    2730:	2d00      	cmp	r5, #0
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    2732:	f04f 0e01 	mov.w	lr, #1
    2736:	f806 e007 	strb.w	lr, [r6, r7]
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    273a:	461d      	mov	r5, r3
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    273c:	f240 70ff 	movw	r0, #2047	; 0x7ff
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2740:	bf15      	itete	ne
    2742:	233c      	movne	r3, #60	; 0x3c
    2744:	237c      	moveq	r3, #124	; 0x7c
    2746:	2640      	movne	r6, #64	; 0x40
    2748:	2680      	moveq	r6, #128	; 0x80
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Check to see if we need to do the workaround.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    274a:	2f04      	cmp	r7, #4
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    274c:	4689      	mov	r9, r1
    274e:	4690      	mov	r8, r2
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2750:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208

    //
    // Check to see if we need to do the workaround.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    2754:	d004      	beq.n	2760 <am_hal_iom_spi_write_nb.part.6+0x48>
    uint32_t ui32Index;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    2756:	2f05      	cmp	r7, #5
    2758:	d908      	bls.n	276c <am_hal_iom_spi_write_nb.part.6+0x54>
            am_hal_iom_spi_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32ChipSelect,
                                   ui32NumBytes, ui32Options);
        }
    }
    return ui32Status;
}
    275a:	2000      	movs	r0, #0
    275c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
isRevB0(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B )
    2760:	4a5b      	ldr	r2, [pc, #364]	; (28d0 <am_hal_iom_spi_write_nb.part.6+0x1b8>)
    2762:	6811      	ldr	r1, [r2, #0]
    2764:	b2c8      	uxtb	r0, r1
    2766:	2820      	cmp	r0, #32
    2768:	f000 8093 	beq.w	2892 <am_hal_iom_spi_write_nb.part.6+0x17a>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    276c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    2770:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    else
    {
        //
        // Figure out how many bytes we can write to the FIFO immediately.
        //
        ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    2774:	42ae      	cmp	r6, r5
    2776:	bf28      	it	cs
    2778:	462e      	movcs	r6, r5
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    277a:	f013 0f08 	tst.w	r3, #8
    277e:	bf14      	ite	ne
    2780:	2340      	movne	r3, #64	; 0x40
    2782:	2380      	moveq	r3, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2784:	1a99      	subs	r1, r3, r2
    2786:	f001 00fc 	and.w	r0, r1, #252	; 0xfc
    278a:	4286      	cmp	r6, r0
    278c:	f200 8097 	bhi.w	28be <am_hal_iom_spi_write_nb.part.6+0x1a6>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2790:	2e00      	cmp	r6, #0
    2792:	d0e2      	beq.n	275a <am_hal_iom_spi_write_nb.part.6+0x42>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2794:	4642      	mov	r2, r8
    2796:	ea6f 0c08 	mvn.w	ip, r8
    279a:	f852 3b04 	ldr.w	r3, [r2], #4
    279e:	6023      	str	r3, [r4, #0]
    27a0:	44c4      	add	ip, r8

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    27a2:	ebc8 0102 	rsb	r1, r8, r2
    27a6:	44b4      	add	ip, r6
    27a8:	428e      	cmp	r6, r1
    27aa:	f3cc 0082 	ubfx	r0, ip, #2, #3
    27ae:	d942      	bls.n	2836 <am_hal_iom_spi_write_nb.part.6+0x11e>
    27b0:	b320      	cbz	r0, 27fc <am_hal_iom_spi_write_nb.part.6+0xe4>
    27b2:	2801      	cmp	r0, #1
    27b4:	d01b      	beq.n	27ee <am_hal_iom_spi_write_nb.part.6+0xd6>
    27b6:	2802      	cmp	r0, #2
    27b8:	d016      	beq.n	27e8 <am_hal_iom_spi_write_nb.part.6+0xd0>
    27ba:	2803      	cmp	r0, #3
    27bc:	d011      	beq.n	27e2 <am_hal_iom_spi_write_nb.part.6+0xca>
    27be:	2804      	cmp	r0, #4
    27c0:	d00c      	beq.n	27dc <am_hal_iom_spi_write_nb.part.6+0xc4>
    27c2:	2805      	cmp	r0, #5
    27c4:	d007      	beq.n	27d6 <am_hal_iom_spi_write_nb.part.6+0xbe>
    27c6:	2806      	cmp	r0, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    27c8:	bf1c      	itt	ne
    27ca:	f852 0b04 	ldrne.w	r0, [r2], #4
    27ce:	6020      	strne	r0, [r4, #0]
    27d0:	f852 3b04 	ldr.w	r3, [r2], #4
    27d4:	6023      	str	r3, [r4, #0]
    27d6:	f852 1b04 	ldr.w	r1, [r2], #4
    27da:	6021      	str	r1, [r4, #0]
    27dc:	f852 0b04 	ldr.w	r0, [r2], #4
    27e0:	6020      	str	r0, [r4, #0]
    27e2:	f852 3b04 	ldr.w	r3, [r2], #4
    27e6:	6023      	str	r3, [r4, #0]
    27e8:	f852 1b04 	ldr.w	r1, [r2], #4
    27ec:	6021      	str	r1, [r4, #0]
    27ee:	f852 0b04 	ldr.w	r0, [r2], #4
    27f2:	6020      	str	r0, [r4, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    27f4:	ebc8 0c02 	rsb	ip, r8, r2
    27f8:	4566      	cmp	r6, ip
    27fa:	d91c      	bls.n	2836 <am_hal_iom_spi_write_nb.part.6+0x11e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    27fc:	4611      	mov	r1, r2
    27fe:	3220      	adds	r2, #32
    2800:	f851 3b04 	ldr.w	r3, [r1], #4
    2804:	6023      	str	r3, [r4, #0]
    2806:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    280a:	6020      	str	r0, [r4, #0]
    280c:	6849      	ldr	r1, [r1, #4]
    280e:	6021      	str	r1, [r4, #0]
    2810:	f852 3c14 	ldr.w	r3, [r2, #-20]
    2814:	6023      	str	r3, [r4, #0]
    2816:	f852 0c10 	ldr.w	r0, [r2, #-16]
    281a:	6020      	str	r0, [r4, #0]
    281c:	f852 1c0c 	ldr.w	r1, [r2, #-12]
    2820:	6021      	str	r1, [r4, #0]
    2822:	f852 3c08 	ldr.w	r3, [r2, #-8]
    2826:	6023      	str	r3, [r4, #0]
    2828:	f852 0c04 	ldr.w	r0, [r2, #-4]
    282c:	6020      	str	r0, [r4, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    282e:	ebc8 0102 	rsb	r1, r8, r2
    2832:	428e      	cmp	r6, r1
    2834:	d8e2      	bhi.n	27fc <am_hal_iom_spi_write_nb.part.6+0xe4>
        if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
        {
            //
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    2836:	4a27      	ldr	r2, [pc, #156]	; (28d4 <am_hal_iom_spi_write_nb.part.6+0x1bc>)
    2838:	eb07 0787 	add.w	r7, r7, r7, lsl #2
    283c:	00b8      	lsls	r0, r7, #2
    283e:	1813      	adds	r3, r2, r0
            //
            // Update the pointer and the byte counter based on the portion of
            // the transfer we just sent to the fifo.
            //
            g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
            g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    2840:	f026 0703 	bic.w	r7, r6, #3
        if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
        {
            //
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    2844:	2101      	movs	r1, #1
    2846:	5011      	str	r1, [r2, r0]

            //
            // Update the pointer and the byte counter based on the portion of
            // the transfer we just sent to the fifo.
            //
            g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    2848:	1bae      	subs	r6, r5, r6
            g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    284a:	4447      	add	r7, r8
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
            g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
            g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
            g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    284c:	9a09      	ldr	r2, [sp, #36]	; 0x24
            g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    284e:	9808      	ldr	r0, [sp, #32]
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
            g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
            g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
            g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    2850:	611a      	str	r2, [r3, #16]
            g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    2852:	60d8      	str	r0, [r3, #12]

            //
            // Update the pointer and the byte counter based on the portion of
            // the transfer we just sent to the fifo.
            //
            g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    2854:	609e      	str	r6, [r3, #8]
            g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    2856:	605f      	str	r7, [r3, #4]
                       uint32_t ui32ChipSelect, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    uint32_t ui32Command;

    am_hal_debug_assert_msg(ui32NumBytes > 0,
    2858:	b92d      	cbnz	r5, 2866 <am_hal_iom_spi_write_nb.part.6+0x14e>
    285a:	4a1f      	ldr	r2, [pc, #124]	; (28d8 <am_hal_iom_spi_write_nb.part.6+0x1c0>)
    285c:	481f      	ldr	r0, [pc, #124]	; (28dc <am_hal_iom_spi_write_nb.part.6+0x1c4>)
    285e:	f640 219c 	movw	r1, #2716	; 0xa9c
    2862:	f7fe fed3 	bl	160c <am_hal_debug_error>
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    2866:	9b08      	ldr	r3, [sp, #32]
    2868:	ea4f 4109 	mov.w	r1, r9, lsl #16
    286c:	f023 4723 	bic.w	r7, r3, #2734686208	; 0xa3000000
    2870:	f401 26e0 	and.w	r6, r1, #458752	; 0x70000
    2874:	f007 22ff 	and.w	r2, r7, #4278255360	; 0xff00ff00
    2878:	b2e9      	uxtb	r1, r5
    287a:	ea46 0002 	orr.w	r0, r6, r2
    287e:	03ed      	lsls	r5, r5, #15
    2880:	4308      	orrs	r0, r1
    2882:	f005 63f0 	and.w	r3, r5, #125829120	; 0x7800000
    2886:	4303      	orrs	r3, r0


    //
    // Write the complete command word to the IOM command register.
    //
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    2888:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
            am_hal_iom_spi_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32ChipSelect,
                                   ui32NumBytes, ui32Options);
        }
    }
    return ui32Status;
}
    288c:	2000      	movs	r0, #0
    288e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    {
        //
        // Figure out how many bytes we can write to the FIFO immediately,
        // accounting for the extra word from the workaround.
        //
        ui32TransferSize = (ui32NumBytes <= (ui32MaxFifoSize - 4) ?  ui32NumBytes :
    2892:	42ab      	cmp	r3, r5
    2894:	bf28      	it	cs
    2896:	462b      	movcs	r3, r5
                            (ui32MaxFifoSize - 4));

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    2898:	4e0e      	ldr	r6, [pc, #56]	; (28d4 <am_hal_iom_spi_write_nb.part.6+0x1bc>)
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
    289a:	f023 0703 	bic.w	r7, r3, #3
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
    289e:	1aec      	subs	r4, r5, r3

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
    28a0:	4447      	add	r7, r8
        //
        // Start the write on the bus using the workaround. This includes both
        // the command write and the first fifo write, so we won't need to do
        // either of those things manually.
        //
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    28a2:	462a      	mov	r2, r5
    28a4:	9b08      	ldr	r3, [sp, #32]
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    28a6:	9d09      	ldr	r5, [sp, #36]	; 0x24

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
    28a8:	6577      	str	r7, [r6, #84]	; 0x54
        //
        // Start the write on the bus using the workaround. This includes both
        // the command write and the first fifo write, so we won't need to do
        // either of those things manually.
        //
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    28aa:	4648      	mov	r0, r9
    28ac:	4641      	mov	r1, r8
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
    28ae:	65b4      	str	r4, [r6, #88]	; 0x58
                            (ui32MaxFifoSize - 4));

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    28b0:	f8c6 e050 	str.w	lr, [r6, #80]	; 0x50
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    28b4:	6635      	str	r5, [r6, #96]	; 0x60
        g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    28b6:	65f3      	str	r3, [r6, #92]	; 0x5c
        //
        // Start the write on the bus using the workaround. This includes both
        // the command write and the first fifo write, so we won't need to do
        // either of those things manually.
        //
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    28b8:	f7ff fb42 	bl	1f40 <am_hal_iom_workaround_word_write>
    28bc:	e74d      	b.n	275a <am_hal_iom_spi_write_nb.part.6+0x42>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    28be:	4a08      	ldr	r2, [pc, #32]	; (28e0 <am_hal_iom_spi_write_nb.part.6+0x1c8>)
    28c0:	4806      	ldr	r0, [pc, #24]	; (28dc <am_hal_iom_spi_write_nb.part.6+0x1c4>)
    28c2:	f640 7107 	movw	r1, #3847	; 0xf07
    28c6:	f7fe fea1 	bl	160c <am_hal_debug_error>
    28ca:	e763      	b.n	2794 <am_hal_iom_spi_write_nb.part.6+0x7c>
    28cc:	100011a4 	.word	0x100011a4
    28d0:	4002000c 	.word	0x4002000c
    28d4:	10001594 	.word	0x10001594
    28d8:	00005448 	.word	0x00005448
    28dc:	00005394 	.word	0x00005394
    28e0:	00005360 	.word	0x00005360

000028e4 <am_hal_iom_spi_read_nb.part.7>:
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_read_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    28e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    28e8:	f500 26a0 	add.w	r6, r0, #327680	; 0x50000
    28ec:	3604      	adds	r6, #4
    28ee:	0336      	lsls	r6, r6, #12
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    28f0:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 29ec <am_hal_iom_spi_read_nb.part.7+0x108>
    28f4:	f04f 0801 	mov.w	r8, #1

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    28f8:	f240 7bff 	movw	fp, #2047	; 0x7ff
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    28fc:	2804      	cmp	r0, #4
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    28fe:	f80a 8000 	strb.w	r8, [sl, r0]
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_read_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    2902:	b083      	sub	sp, #12
    2904:	4605      	mov	r5, r0
    2906:	460f      	mov	r7, r1
    2908:	4691      	mov	r9, r2
    290a:	461c      	mov	r4, r3
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    290c:	f8c6 b208 	str.w	fp, [r6, #520]	; 0x208
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    2910:	d02c      	beq.n	296c <am_hal_iom_spi_read_nb.part.7+0x88>
    }

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    2912:	482f      	ldr	r0, [pc, #188]	; (29d0 <am_hal_iom_spi_read_nb.part.7+0xec>)
    2914:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    2918:	00aa      	lsls	r2, r5, #2
    291a:	1883      	adds	r3, r0, r2
    291c:	2102      	movs	r1, #2
    291e:	5081      	str	r1, [r0, r2]
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    2920:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    2922:	980c      	ldr	r0, [sp, #48]	; 0x30

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    2924:	f8c3 9004 	str.w	r9, [r3, #4]
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
    2928:	609c      	str	r4, [r3, #8]
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    292a:	611d      	str	r5, [r3, #16]
    g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    292c:	60d8      	str	r0, [r3, #12]
                       uint32_t ui32ChipSelect, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    uint32_t ui32Command;

    am_hal_debug_assert_msg(ui32NumBytes > 0,
    292e:	b92c      	cbnz	r4, 293c <am_hal_iom_spi_read_nb.part.7+0x58>
    2930:	4a28      	ldr	r2, [pc, #160]	; (29d4 <am_hal_iom_spi_read_nb.part.7+0xf0>)
    2932:	4829      	ldr	r0, [pc, #164]	; (29d8 <am_hal_iom_spi_read_nb.part.7+0xf4>)
    2934:	f640 219c 	movw	r1, #2716	; 0xa9c
    2938:	f7fe fe68 	bl	160c <am_hal_debug_error>
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    293c:	03e2      	lsls	r2, r4, #15
    293e:	fa5f fc84 	uxtb.w	ip, r4
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    2942:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    2944:	f002 61f0 	and.w	r1, r2, #125829120	; 0x7800000
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    2948:	043f      	lsls	r7, r7, #16
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    294a:	f04c 4400 	orr.w	r4, ip, #2147483648	; 0x80000000
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    294e:	f023 4023 	bic.w	r0, r3, #2734686208	; 0xa3000000
    2952:	f407 25e0 	and.w	r5, r7, #458752	; 0x70000
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    2956:	430c      	orrs	r4, r1
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    2958:	f000 22ff 	and.w	r2, r0, #4278255360	; 0xff00ff00
    295c:	4325      	orrs	r5, r4
    295e:	4315      	orrs	r5, r2


    //
    // Write the complete command word to the IOM command register.
    //
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    2960:	f8c6 5110 	str.w	r5, [r6, #272]	; 0x110
    // Start the read transaction on the bus.
    //
    am_hal_iom_spi_cmd_run(AM_HAL_IOM_READ, ui32Module, ui32ChipSelect,
                           ui32NumBytes, ui32Options);

    return ui32Status;
    2964:	2000      	movs	r0, #0
}
    2966:	b003      	add	sp, #12
    2968:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    296c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    296e:	f013 4180 	ands.w	r1, r3, #1073741824	; 0x40000000
    2972:	d1ce      	bne.n	2912 <am_hal_iom_spi_read_nb.part.7+0x2e>
isRevB0(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B )
    2974:	4819      	ldr	r0, [pc, #100]	; (29dc <am_hal_iom_spi_read_nb.part.7+0xf8>)
    2976:	6802      	ldr	r2, [r0, #0]
    2978:	b2d3      	uxtb	r3, r2
    297a:	2b20      	cmp	r3, #32
    297c:	d1c9      	bne.n	2912 <am_hal_iom_spi_read_nb.part.7+0x2e>
        //
        // We might mess up the interrupt handler behavior if we allow this
        // polled transaction to complete with interrupts enabled. We'll
        // briefly turn them off here.
        //
        ui32IntConfig = AM_REGn(IOMSTR, 4, INTEN);
    297e:	4818      	ldr	r0, [pc, #96]	; (29e0 <am_hal_iom_spi_read_nb.part.7+0xfc>)
    2980:	6803      	ldr	r3, [r0, #0]
        AM_REGn(IOMSTR, 4, INTEN) = 0;
    2982:	4817      	ldr	r0, [pc, #92]	; (29e0 <am_hal_iom_spi_read_nb.part.7+0xfc>)
        //
        // We might mess up the interrupt handler behavior if we allow this
        // polled transaction to complete with interrupts enabled. We'll
        // briefly turn them off here.
        //
        ui32IntConfig = AM_REGn(IOMSTR, 4, INTEN);
    2984:	9301      	str	r3, [sp, #4]
        AM_REGn(IOMSTR, 4, INTEN) = 0;
    2986:	6001      	str	r1, [r0, #0]

        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    2988:	460a      	mov	r2, r1
    298a:	990c      	ldr	r1, [sp, #48]	; 0x30
    298c:	4638      	mov	r0, r7
    298e:	f041 5380 	orr.w	r3, r1, #268435456	; 0x10000000
    2992:	4649      	mov	r1, r9
    2994:	f7ff fad4 	bl	1f40 <am_hal_iom_workaround_word_write>

        //
        // Wait for the dummy word to go out over the bus.
        //
        // Make sure the command complete has also been raised
        waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    2998:	4a12      	ldr	r2, [pc, #72]	; (29e4 <am_hal_iom_spi_read_nb.part.7+0x100>)
    299a:	4643      	mov	r3, r8
    299c:	6910      	ldr	r0, [r2, #16]
    299e:	f506 7101 	add.w	r1, r6, #516	; 0x204
    29a2:	4642      	mov	r2, r8
    29a4:	f7fe fe3a 	bl	161c <am_hal_flash_delay_status_change>
                     AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                     AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

        if (waitStatus != 1)
    29a8:	2801      	cmp	r0, #1
    29aa:	d004      	beq.n	29b6 <am_hal_iom_spi_read_nb.part.7+0xd2>
        {
            g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    29ac:	4e0e      	ldr	r6, [pc, #56]	; (29e8 <am_hal_iom_spi_read_nb.part.7+0x104>)
            return ui32Status;
    29ae:	4640      	mov	r0, r8
                     AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                     AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

        if (waitStatus != 1)
        {
            g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    29b0:	f886 8004 	strb.w	r8, [r6, #4]
    29b4:	e7d7      	b.n	2966 <am_hal_iom_spi_read_nb.part.7+0x82>

        //
        // The workaround will send our offset for us, so we can run a RAW
        // command after.
        //
        ui32Options |= AM_HAL_IOM_RAW;
    29b6:	9b0c      	ldr	r3, [sp, #48]	; 0x30

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, 4, INTEN) = ui32IntConfig;
    29b8:	4909      	ldr	r1, [pc, #36]	; (29e0 <am_hal_iom_spi_read_nb.part.7+0xfc>)

        //
        // Re-mark IOM as busy
        //

        g_bIomBusy[ui32Module] = true;
    29ba:	f88a 0004 	strb.w	r0, [sl, #4]

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, 4, INTEN) = ui32IntConfig;
    29be:	9a01      	ldr	r2, [sp, #4]
        g_bIomBusy[ui32Module] = true;

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    29c0:	f8c6 b208 	str.w	fp, [r6, #520]	; 0x208

        //
        // The workaround will send our offset for us, so we can run a RAW
        // command after.
        //
        ui32Options |= AM_HAL_IOM_RAW;
    29c4:	f043 4080 	orr.w	r0, r3, #1073741824	; 0x40000000
    29c8:	900c      	str	r0, [sp, #48]	; 0x30

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, 4, INTEN) = ui32IntConfig;
    29ca:	600a      	str	r2, [r1, #0]
    29cc:	e7a1      	b.n	2912 <am_hal_iom_spi_read_nb.part.7+0x2e>
    29ce:	bf00      	nop
    29d0:	10001594 	.word	0x10001594
    29d4:	00005448 	.word	0x00005448
    29d8:	00005394 	.word	0x00005394
    29dc:	4002000c 	.word	0x4002000c
    29e0:	50008200 	.word	0x50008200
    29e4:	1000157c 	.word	0x1000157c
    29e8:	1000119c 	.word	0x1000119c
    29ec:	100011a4 	.word	0x100011a4

000029f0 <am_hal_iom_i2c_write_nq>:
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;

    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    29f0:	2806      	cmp	r0, #6
    29f2:	d901      	bls.n	29f8 <am_hal_iom_i2c_write_nq+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    29f4:	2002      	movs	r0, #2
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    return ui32Status;
}
    29f6:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write_nq(uint32_t ui32Module, uint32_t ui32BusAddress,
                        uint32_t *pui32Data, uint32_t ui32NumBytes,
                        uint32_t ui32Options)
{
    29f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    29fc:	461e      	mov	r6, r3
    29fe:	b085      	sub	sp, #20
    2a00:	460b      	mov	r3, r1
    2a02:	4604      	mov	r4, r0
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    2a04:	d013      	beq.n	2a2e <am_hal_iom_i2c_write_nq+0x3e>
    2a06:	48be      	ldr	r0, [pc, #760]	; (2d00 <am_hal_iom_i2c_write_nq+0x310>)
    2a08:	4615      	mov	r5, r2
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    2a0a:	5d02      	ldrb	r2, [r0, r4]
    2a0c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    2a10:	2a00      	cmp	r2, #0
    2a12:	d1fa      	bne.n	2a0a <am_hal_iom_i2c_write_nq+0x1a>
    // Wait until any earlier transactions have completed.
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2a14:	f8df 82fc 	ldr.w	r8, [pc, #764]	; 2d14 <am_hal_iom_i2c_write_nq+0x324>
    2a18:	f808 1004 	strb.w	r1, [r8, r4]
    if (ui32NumBytes == 0)
    2a1c:	b10e      	cbz	r6, 2a22 <am_hal_iom_i2c_write_nq+0x32>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    2a1e:	2eff      	cmp	r6, #255	; 0xff
    2a20:	d923      	bls.n	2a6a <am_hal_iom_i2c_write_nq+0x7a>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    2a22:	2003      	movs	r0, #3
    2a24:	f808 0004 	strb.w	r0, [r8, r4]
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    return ui32Status;
}
    2a28:	b005      	add	sp, #20
    2a2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Wait until any earlier transactions have completed.
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2a2e:	f8df 82e4 	ldr.w	r8, [pc, #740]	; 2d14 <am_hal_iom_i2c_write_nq+0x324>
    2a32:	2700      	movs	r7, #0
    2a34:	f888 7006 	strb.w	r7, [r8, #6]
    if (ui32NumBytes == 0)
    2a38:	2e00      	cmp	r6, #0
    2a3a:	d0f2      	beq.n	2a22 <am_hal_iom_i2c_write_nq+0x32>
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    2a3c:	980e      	ldr	r0, [sp, #56]	; 0x38
    2a3e:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    2a42:	ea4f 0143 	mov.w	r1, r3, lsl #1
    2a46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    2a48:	f000 8131 	beq.w	2cae <am_hal_iom_i2c_write_nq+0x2be>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    2a4c:	f3c3 7500 	ubfx	r5, r3, #28, #1
    2a50:	f001 00fe 	and.w	r0, r1, #254	; 0xfe
    2a54:	9700      	str	r7, [sp, #0]
    2a56:	463b      	mov	r3, r7
    2a58:	4631      	mov	r1, r6
    2a5a:	9501      	str	r5, [sp, #4]
    2a5c:	f002 f854 	bl	4b08 <am_hal_i2c_bit_bang_send>
        }

        //
        // Return. convert BB retCode to proper retCode here
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    2a60:	4ca8      	ldr	r4, [pc, #672]	; (2d04 <am_hal_iom_i2c_write_nq+0x314>)
    2a62:	5c20      	ldrb	r0, [r4, r0]
    2a64:	f888 0006 	strb.w	r0, [r8, #6]
    2a68:	e7de      	b.n	2a28 <am_hal_iom_i2c_write_nq+0x38>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2a6a:	f504 27a0 	add.w	r7, r4, #327680	; 0x50000
    2a6e:	3704      	adds	r7, #4
    2a70:	033f      	lsls	r7, r7, #12
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2a72:	f240 7eff 	movw	lr, #2047	; 0x7ff
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2a76:	f8d7 011c 	ldr.w	r0, [r7, #284]	; 0x11c
                      AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    2a7a:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    2a7e:	f8c7 1200 	str.w	r1, [r7, #512]	; 0x200

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2a82:	f8c7 e208 	str.w	lr, [r7, #520]	; 0x208
                      AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    2a86:	9202      	str	r2, [sp, #8]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2a88:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    2a8c:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2a90:	f010 0f08 	tst.w	r0, #8
    2a94:	bf14      	ite	ne
    2a96:	f04f 0940 	movne.w	r9, #64	; 0x40
    2a9a:	f04f 0980 	moveq.w	r9, #128	; 0x80
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2a9e:	f012 0f08 	tst.w	r2, #8
    2aa2:	bf14      	ite	ne
    2aa4:	2240      	movne	r2, #64	; 0x40
    2aa6:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2aa8:	1a50      	subs	r0, r2, r1
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Figure out how many bytes we can write to the FIFO immediately.
    //
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    2aaa:	45b1      	cmp	r9, r6
    2aac:	bf28      	it	cs
    2aae:	46b1      	movcs	r9, r6
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2ab0:	f000 0cfc 	and.w	ip, r0, #252	; 0xfc
    2ab4:	45e1      	cmp	r9, ip
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2ab6:	f507 7a8e 	add.w	sl, r7, #284	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    2aba:	f507 7b80 	add.w	fp, r7, #256	; 0x100
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2abe:	f200 8116 	bhi.w	2cee <am_hal_iom_i2c_write_nq+0x2fe>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2ac2:	462a      	mov	r2, r5
    2ac4:	43e9      	mvns	r1, r5
    2ac6:	f852 0b04 	ldr.w	r0, [r2], #4
    2aca:	6038      	str	r0, [r7, #0]
    2acc:	4429      	add	r1, r5

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2ace:	1b50      	subs	r0, r2, r5
    2ad0:	4449      	add	r1, r9
    2ad2:	4581      	cmp	r9, r0
    2ad4:	f3c1 0182 	ubfx	r1, r1, #2, #3
    2ad8:	d941      	bls.n	2b5e <am_hal_iom_i2c_write_nq+0x16e>
    2ada:	b319      	cbz	r1, 2b24 <am_hal_iom_i2c_write_nq+0x134>
    2adc:	2901      	cmp	r1, #1
    2ade:	d01b      	beq.n	2b18 <am_hal_iom_i2c_write_nq+0x128>
    2ae0:	2902      	cmp	r1, #2
    2ae2:	d016      	beq.n	2b12 <am_hal_iom_i2c_write_nq+0x122>
    2ae4:	2903      	cmp	r1, #3
    2ae6:	d011      	beq.n	2b0c <am_hal_iom_i2c_write_nq+0x11c>
    2ae8:	2904      	cmp	r1, #4
    2aea:	d00c      	beq.n	2b06 <am_hal_iom_i2c_write_nq+0x116>
    2aec:	2905      	cmp	r1, #5
    2aee:	d007      	beq.n	2b00 <am_hal_iom_i2c_write_nq+0x110>
    2af0:	2906      	cmp	r1, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2af2:	bf1c      	itt	ne
    2af4:	f852 1b04 	ldrne.w	r1, [r2], #4
    2af8:	6039      	strne	r1, [r7, #0]
    2afa:	f852 0b04 	ldr.w	r0, [r2], #4
    2afe:	6038      	str	r0, [r7, #0]
    2b00:	f852 1b04 	ldr.w	r1, [r2], #4
    2b04:	6039      	str	r1, [r7, #0]
    2b06:	f852 0b04 	ldr.w	r0, [r2], #4
    2b0a:	6038      	str	r0, [r7, #0]
    2b0c:	f852 1b04 	ldr.w	r1, [r2], #4
    2b10:	6039      	str	r1, [r7, #0]
    2b12:	f852 0b04 	ldr.w	r0, [r2], #4
    2b16:	6038      	str	r0, [r7, #0]
    2b18:	f852 1b04 	ldr.w	r1, [r2], #4
    2b1c:	6039      	str	r1, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2b1e:	1b50      	subs	r0, r2, r5
    2b20:	4581      	cmp	r9, r0
    2b22:	d91c      	bls.n	2b5e <am_hal_iom_i2c_write_nq+0x16e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2b24:	4696      	mov	lr, r2
    2b26:	3220      	adds	r2, #32
    2b28:	f85e 1b04 	ldr.w	r1, [lr], #4
    2b2c:	6039      	str	r1, [r7, #0]
    2b2e:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    2b32:	6038      	str	r0, [r7, #0]
    2b34:	f8de 1004 	ldr.w	r1, [lr, #4]
    2b38:	6039      	str	r1, [r7, #0]
    2b3a:	f852 0c14 	ldr.w	r0, [r2, #-20]
    2b3e:	6038      	str	r0, [r7, #0]
    2b40:	f852 1c10 	ldr.w	r1, [r2, #-16]
    2b44:	6039      	str	r1, [r7, #0]
    2b46:	f852 0c0c 	ldr.w	r0, [r2, #-12]
    2b4a:	6038      	str	r0, [r7, #0]
    2b4c:	f852 1c08 	ldr.w	r1, [r2, #-8]
    2b50:	6039      	str	r1, [r7, #0]
    2b52:	f852 0c04 	ldr.w	r0, [r2, #-4]
    2b56:	6038      	str	r0, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2b58:	1b51      	subs	r1, r2, r5
    2b5a:	4589      	cmp	r9, r1
    2b5c:	d8e2      	bhi.n	2b24 <am_hal_iom_i2c_write_nq+0x134>
    2b5e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    2b60:	9200      	str	r2, [sp, #0]
    2b62:	4621      	mov	r1, r4
    2b64:	461a      	mov	r2, r3
    2b66:	2000      	movs	r0, #0
    2b68:	4633      	mov	r3, r6
    2b6a:	f7fe fe81 	bl	1870 <am_hal_iom_i2c_cmd_run.part.1>
    // Start the write on the bus.
    //
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    2b6e:	2800      	cmp	r0, #0
    2b70:	f040 80b3 	bne.w	2cda <am_hal_iom_i2c_write_nq+0x2ea>
    }
    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += ui32TransferSize >> 2;
    2b74:	f029 0303 	bic.w	r3, r9, #3

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    2b78:	ebb6 0609 	subs.w	r6, r6, r9
    }
    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += ui32TransferSize >> 2;
    2b7c:	441d      	add	r5, r3

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    2b7e:	f000 80e0 	beq.w	2d42 <am_hal_iom_i2c_write_nq+0x352>
    2b82:	f8d7 0204 	ldr.w	r0, [r7, #516]	; 0x204
    2b86:	07c1      	lsls	r1, r0, #31
    2b88:	f507 7901 	add.w	r9, r7, #516	; 0x204
    2b8c:	d47a      	bmi.n	2c84 <am_hal_iom_i2c_write_nq+0x294>
    2b8e:	46a4      	mov	ip, r4
    2b90:	4663      	mov	r3, ip
    2b92:	465c      	mov	r4, fp
    2b94:	46d3      	mov	fp, sl
    2b96:	46b2      	mov	sl, r6
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2b98:	f8db 1000 	ldr.w	r1, [fp]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    2b9c:	6826      	ldr	r6, [r4, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2b9e:	f8db 2000 	ldr.w	r2, [fp]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    2ba2:	6820      	ldr	r0, [r4, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2ba4:	f011 0f08 	tst.w	r1, #8
    2ba8:	bf14      	ite	ne
    2baa:	2140      	movne	r1, #64	; 0x40
    2bac:	2180      	moveq	r1, #128	; 0x80
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    {
        //
        // This will always return a multiple of four.
        //
        ui32SpaceInFifo =  am_hal_iom_fifo_empty_slots(ui32Module);
    2bae:	1b89      	subs	r1, r1, r6
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2bb0:	f012 0f08 	tst.w	r2, #8
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    {
        //
        // This will always return a multiple of four.
        //
        ui32SpaceInFifo =  am_hal_iom_fifo_empty_slots(ui32Module);
    2bb4:	f001 06fc 	and.w	r6, r1, #252	; 0xfc
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2bb8:	bf14      	ite	ne
    2bba:	2240      	movne	r2, #64	; 0x40
    2bbc:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2bbe:	1a12      	subs	r2, r2, r0
    2bc0:	4556      	cmp	r6, sl
    2bc2:	bf28      	it	cs
    2bc4:	4656      	movcs	r6, sl
    2bc6:	f002 00fc 	and.w	r0, r2, #252	; 0xfc
    2bca:	4286      	cmp	r6, r0
    2bcc:	d87c      	bhi.n	2cc8 <am_hal_iom_i2c_write_nq+0x2d8>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2bce:	2e00      	cmp	r6, #0
    2bd0:	d04d      	beq.n	2c6e <am_hal_iom_i2c_write_nq+0x27e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2bd2:	462a      	mov	r2, r5
    2bd4:	43e9      	mvns	r1, r5
    2bd6:	f852 0b04 	ldr.w	r0, [r2], #4
    2bda:	6038      	str	r0, [r7, #0]
    2bdc:	4429      	add	r1, r5

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2bde:	1b50      	subs	r0, r2, r5
    2be0:	4431      	add	r1, r6
    2be2:	4286      	cmp	r6, r0
    2be4:	f3c1 0182 	ubfx	r1, r1, #2, #3
    2be8:	d941      	bls.n	2c6e <am_hal_iom_i2c_write_nq+0x27e>
    2bea:	b319      	cbz	r1, 2c34 <am_hal_iom_i2c_write_nq+0x244>
    2bec:	2901      	cmp	r1, #1
    2bee:	d01b      	beq.n	2c28 <am_hal_iom_i2c_write_nq+0x238>
    2bf0:	2902      	cmp	r1, #2
    2bf2:	d016      	beq.n	2c22 <am_hal_iom_i2c_write_nq+0x232>
    2bf4:	2903      	cmp	r1, #3
    2bf6:	d011      	beq.n	2c1c <am_hal_iom_i2c_write_nq+0x22c>
    2bf8:	2904      	cmp	r1, #4
    2bfa:	d00c      	beq.n	2c16 <am_hal_iom_i2c_write_nq+0x226>
    2bfc:	2905      	cmp	r1, #5
    2bfe:	d007      	beq.n	2c10 <am_hal_iom_i2c_write_nq+0x220>
    2c00:	2906      	cmp	r1, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2c02:	bf1c      	itt	ne
    2c04:	f852 1b04 	ldrne.w	r1, [r2], #4
    2c08:	6039      	strne	r1, [r7, #0]
    2c0a:	f852 0b04 	ldr.w	r0, [r2], #4
    2c0e:	6038      	str	r0, [r7, #0]
    2c10:	f852 1b04 	ldr.w	r1, [r2], #4
    2c14:	6039      	str	r1, [r7, #0]
    2c16:	f852 0b04 	ldr.w	r0, [r2], #4
    2c1a:	6038      	str	r0, [r7, #0]
    2c1c:	f852 1b04 	ldr.w	r1, [r2], #4
    2c20:	6039      	str	r1, [r7, #0]
    2c22:	f852 0b04 	ldr.w	r0, [r2], #4
    2c26:	6038      	str	r0, [r7, #0]
    2c28:	f852 1b04 	ldr.w	r1, [r2], #4
    2c2c:	6039      	str	r1, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2c2e:	1b50      	subs	r0, r2, r5
    2c30:	4286      	cmp	r6, r0
    2c32:	d91c      	bls.n	2c6e <am_hal_iom_i2c_write_nq+0x27e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2c34:	4696      	mov	lr, r2
    2c36:	3220      	adds	r2, #32
    2c38:	f85e 1b04 	ldr.w	r1, [lr], #4
    2c3c:	6039      	str	r1, [r7, #0]
    2c3e:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    2c42:	6038      	str	r0, [r7, #0]
    2c44:	f8de 1004 	ldr.w	r1, [lr, #4]
    2c48:	6039      	str	r1, [r7, #0]
    2c4a:	f852 0c14 	ldr.w	r0, [r2, #-20]
    2c4e:	6038      	str	r0, [r7, #0]
    2c50:	f852 1c10 	ldr.w	r1, [r2, #-16]
    2c54:	6039      	str	r1, [r7, #0]
    2c56:	f852 0c0c 	ldr.w	r0, [r2, #-12]
    2c5a:	6038      	str	r0, [r7, #0]
    2c5c:	f852 1c08 	ldr.w	r1, [r2, #-8]
    2c60:	6039      	str	r1, [r7, #0]
    2c62:	f852 0c04 	ldr.w	r0, [r2, #-4]
    2c66:	6038      	str	r0, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2c68:	1b51      	subs	r1, r2, r5
    2c6a:	428e      	cmp	r6, r1
    2c6c:	d8e2      	bhi.n	2c34 <am_hal_iom_i2c_write_nq+0x244>

        //
        // Update the data pointer and bytes-left count.
        //
        ui32NumBytes -= ui32TransferSize;
        pui32Data += ui32TransferSize >> 2;
    2c6e:	f026 0c03 	bic.w	ip, r6, #3
    pui32Data += ui32TransferSize >> 2;

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    2c72:	ebba 0a06 	subs.w	sl, sl, r6

        //
        // Update the data pointer and bytes-left count.
        //
        ui32NumBytes -= ui32TransferSize;
        pui32Data += ui32TransferSize >> 2;
    2c76:	4465      	add	r5, ip
    pui32Data += ui32TransferSize >> 2;

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    2c78:	d003      	beq.n	2c82 <am_hal_iom_i2c_write_nq+0x292>
    2c7a:	f8d9 2000 	ldr.w	r2, [r9]
    2c7e:	07d2      	lsls	r2, r2, #31
    2c80:	d58a      	bpl.n	2b98 <am_hal_iom_i2c_write_nq+0x1a8>
    2c82:	461c      	mov	r4, r3
    }

    //
    // Make sure CMDCMP was raised,
    //
    waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    2c84:	4d20      	ldr	r5, [pc, #128]	; (2d08 <am_hal_iom_i2c_write_nq+0x318>)
    2c86:	2301      	movs	r3, #1
    2c88:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
    2c8c:	461a      	mov	r2, r3
    2c8e:	4649      	mov	r1, r9
    2c90:	f7fe fcc4 	bl	161c <am_hal_flash_delay_status_change>
                 AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                 AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

    if (waitStatus != 1)
    2c94:	2801      	cmp	r0, #1
    2c96:	d03f      	beq.n	2d18 <am_hal_iom_i2c_write_nq+0x328>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    2c98:	2001      	movs	r0, #1
    2c9a:	f808 0004 	strb.w	r0, [r8, r4]

    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2c9e:	f240 74ff 	movw	r4, #2047	; 0x7ff
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    2ca2:	9e02      	ldr	r6, [sp, #8]

    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2ca4:	f8c7 4208 	str.w	r4, [r7, #520]	; 0x208
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    2ca8:	f8c7 6200 	str.w	r6, [r7, #512]	; 0x200
    2cac:	e6bc      	b.n	2a28 <am_hal_iom_i2c_write_nq+0x38>
                                     (uint8_t *)pui32Data, 0, false,
                                     (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    2cae:	f3c3 7500 	ubfx	r5, r3, #28, #1
    2cb2:	2401      	movs	r4, #1
    2cb4:	f001 00fe 	and.w	r0, r1, #254	; 0xfe
    2cb8:	e88d 0030 	stmia.w	sp, {r4, r5}
    2cbc:	4631      	mov	r1, r6
    2cbe:	f3c3 2307 	ubfx	r3, r3, #8, #8
    2cc2:	f001 ff21 	bl	4b08 <am_hal_i2c_bit_bang_send>
    2cc6:	e6cb      	b.n	2a60 <am_hal_iom_i2c_write_nq+0x70>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2cc8:	4a10      	ldr	r2, [pc, #64]	; (2d0c <am_hal_iom_i2c_write_nq+0x31c>)
    2cca:	4811      	ldr	r0, [pc, #68]	; (2d10 <am_hal_iom_i2c_write_nq+0x320>)
    2ccc:	9303      	str	r3, [sp, #12]
    2cce:	f640 7107 	movw	r1, #3847	; 0xf07
    2cd2:	f7fe fc9b 	bl	160c <am_hal_debug_error>
    2cd6:	9b03      	ldr	r3, [sp, #12]
    2cd8:	e77b      	b.n	2bd2 <am_hal_iom_i2c_write_nq+0x1e2>
        g_iom_error_status[ui32Module] = ui32Status = ui32Status;
        //
        // Re-enable IOM interrupts.
        //
        // Clear interrupts
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2cda:	f240 71ff 	movw	r1, #2047	; 0x7ff
        AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    2cde:	9a02      	ldr	r2, [sp, #8]
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status = ui32Status;
    2ce0:	f808 0004 	strb.w	r0, [r8, r4]
        //
        // Re-enable IOM interrupts.
        //
        // Clear interrupts
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2ce4:	f8c7 1208 	str.w	r1, [r7, #520]	; 0x208
        AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    2ce8:	f8c7 2200 	str.w	r2, [r7, #512]	; 0x200
    2cec:	e69c      	b.n	2a28 <am_hal_iom_i2c_write_nq+0x38>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2cee:	4a07      	ldr	r2, [pc, #28]	; (2d0c <am_hal_iom_i2c_write_nq+0x31c>)
    2cf0:	4807      	ldr	r0, [pc, #28]	; (2d10 <am_hal_iom_i2c_write_nq+0x320>)
    2cf2:	9303      	str	r3, [sp, #12]
    2cf4:	f640 7107 	movw	r1, #3847	; 0xf07
    2cf8:	f7fe fc88 	bl	160c <am_hal_debug_error>
    2cfc:	9b03      	ldr	r3, [sp, #12]
    2cfe:	e6e0      	b.n	2ac2 <am_hal_iom_i2c_write_nq+0xd2>
    2d00:	100011a4 	.word	0x100011a4
    2d04:	000054a4 	.word	0x000054a4
    2d08:	1000157c 	.word	0x1000157c
    2d0c:	00005360 	.word	0x00005360
    2d10:	00005394 	.word	0x00005394
    2d14:	1000119c 	.word	0x1000119c
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    2d18:	f8d9 3000 	ldr.w	r3, [r9]
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    2d1c:	f013 0fcc 	tst.w	r3, #204	; 0xcc
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    2d20:	bf18      	it	ne
    2d22:	2005      	movne	r0, #5
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    2d24:	d002      	beq.n	2d2c <am_hal_iom_i2c_write_nq+0x33c>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    }
    else
    {
        g_iom_error_status[ui32Module] = ui32Status = internal_iom_get_int_err(ui32Module, 0);
    2d26:	f808 0004 	strb.w	r0, [r8, r4]
    2d2a:	e7b8      	b.n	2c9e <am_hal_iom_i2c_write_nq+0x2ae>
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    2d2c:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    2d30:	d105      	bne.n	2d3e <am_hal_iom_i2c_write_nq+0x34e>
//!
//*****************************************************************************
static am_hal_iom_status_e
internal_iom_get_int_err(uint32_t ui32Module, uint32_t ui32IntStatus)
{
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;
    2d32:	f013 0f10 	tst.w	r3, #16
    2d36:	bf14      	ite	ne
    2d38:	2006      	movne	r0, #6
    2d3a:	2000      	moveq	r0, #0
    2d3c:	e7f3      	b.n	2d26 <am_hal_iom_i2c_write_nq+0x336>
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    {
        // Loss of I2C multi-master arbitration
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    2d3e:	2007      	movs	r0, #7
    2d40:	e7f1      	b.n	2d26 <am_hal_iom_i2c_write_nq+0x336>
    2d42:	f507 7901 	add.w	r9, r7, #516	; 0x204
    2d46:	e79d      	b.n	2c84 <am_hal_iom_i2c_write_nq+0x294>

00002d48 <am_hal_iom_i2c_write>:
    am_hal_iom_status_e ui32Status;
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;
    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    2d48:	2806      	cmp	r0, #6
    2d4a:	d901      	bls.n	2d50 <am_hal_iom_i2c_write+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    2d4c:	2002      	movs	r0, #2
        //
        ui32Status = am_hal_iom_i2c_write_nq(ui32Module, ui32BusAddress, pui32Data,
                                ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    2d4e:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write(uint32_t ui32Module, uint32_t ui32BusAddress,
                     uint32_t *pui32Data, uint32_t ui32NumBytes,
                     uint32_t ui32Options)
{
    2d50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2d54:	461e      	mov	r6, r3
    2d56:	b08f      	sub	sp, #60	; 0x3c
    2d58:	4605      	mov	r5, r0
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    2d5a:	d014      	beq.n	2d86 <am_hal_iom_i2c_write+0x3e>
    2d5c:	4f4a      	ldr	r7, [pc, #296]	; (2e88 <am_hal_iom_i2c_write+0x140>)
    2d5e:	4691      	mov	r9, r2
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    2d60:	5d7c      	ldrb	r4, [r7, r5]
    2d62:	4a49      	ldr	r2, [pc, #292]	; (2e88 <am_hal_iom_i2c_write+0x140>)
    2d64:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    2d68:	2c00      	cmp	r4, #0
    2d6a:	d1f9      	bne.n	2d60 <am_hal_iom_i2c_write+0x18>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2d6c:	f8df 8128 	ldr.w	r8, [pc, #296]	; 2e98 <am_hal_iom_i2c_write+0x150>
    2d70:	f808 3005 	strb.w	r3, [r8, r5]
    if (ui32NumBytes == 0)
    2d74:	b10e      	cbz	r6, 2d7a <am_hal_iom_i2c_write+0x32>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    2d76:	2eff      	cmp	r6, #255	; 0xff
    2d78:	d91f      	bls.n	2dba <am_hal_iom_i2c_write+0x72>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    2d7a:	2003      	movs	r0, #3
    2d7c:	f808 0005 	strb.w	r0, [r8, r5]
        //
        ui32Status = am_hal_iom_i2c_write_nq(ui32Module, ui32BusAddress, pui32Data,
                                ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    2d80:	b00f      	add	sp, #60	; 0x3c
    2d82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2d86:	f8df 8110 	ldr.w	r8, [pc, #272]	; 2e98 <am_hal_iom_i2c_write+0x150>
    2d8a:	2300      	movs	r3, #0
    2d8c:	f888 3006 	strb.w	r3, [r8, #6]
    if (ui32NumBytes == 0)
    2d90:	2e00      	cmp	r6, #0
    2d92:	d0f2      	beq.n	2d7a <am_hal_iom_i2c_write+0x32>
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    2d94:	9d18      	ldr	r5, [sp, #96]	; 0x60
    2d96:	006c      	lsls	r4, r5, #1
    2d98:	d55e      	bpl.n	2e58 <am_hal_iom_i2c_write+0x110>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    2d9a:	9c18      	ldr	r4, [sp, #96]	; 0x60
    2d9c:	9300      	str	r3, [sp, #0]
    2d9e:	004f      	lsls	r7, r1, #1
    2da0:	f3c4 7500 	ubfx	r5, r4, #28, #1
    2da4:	f007 00fe 	and.w	r0, r7, #254	; 0xfe
    2da8:	4631      	mov	r1, r6
    2daa:	9501      	str	r5, [sp, #4]
    2dac:	f001 feac 	bl	4b08 <am_hal_i2c_bit_bang_send>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    2db0:	4e36      	ldr	r6, [pc, #216]	; (2e8c <am_hal_iom_i2c_write+0x144>)
    2db2:	5c30      	ldrb	r0, [r6, r0]
    2db4:	f888 0006 	strb.w	r0, [r8, #6]
        return ui32Status;
    2db8:	e7e2      	b.n	2d80 <am_hal_iom_i2c_write+0x38>

    //
    // Check to see if queues have been enabled. If they are, we'll actually
    // switch to the queued interface.
    //
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    2dba:	4835      	ldr	r0, [pc, #212]	; (2e90 <am_hal_iom_i2c_write+0x148>)
    2dbc:	9204      	str	r2, [sp, #16]
    2dbe:	ea4f 0b45 	mov.w	fp, r5, lsl #1
    2dc2:	eb0b 0a05 	add.w	sl, fp, r5
    2dc6:	eb00 04ca 	add.w	r4, r0, sl, lsl #3
    2dca:	9003      	str	r0, [sp, #12]
    2dcc:	6962      	ldr	r2, [r4, #20]
    2dce:	2a00      	cmp	r2, #0
    2dd0:	d051      	beq.n	2e76 <am_hal_iom_i2c_write+0x12e>
    2dd2:	9105      	str	r1, [sp, #20]
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    2dd4:	f7fe fd10 	bl	17f8 <am_hal_interrupt_master_disable>
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    2dd8:	9904      	ldr	r1, [sp, #16]
    2dda:	9b03      	ldr	r3, [sp, #12]
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    2ddc:	4682      	mov	sl, r0
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    2dde:	5d48      	ldrb	r0, [r1, r5]
    2de0:	9905      	ldr	r1, [sp, #20]
    2de2:	b908      	cbnz	r0, 2de8 <am_hal_iom_i2c_write+0xa0>
    2de4:	68a4      	ldr	r4, [r4, #8]
    2de6:	b1dc      	cbz	r4, 2e20 <am_hal_iom_i2c_write+0xd8>
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    2de8:	eb0b 0205 	add.w	r2, fp, r5
    2dec:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
    2df0:	2702      	movs	r7, #2
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    2df2:	2300      	movs	r3, #0
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
    2df4:	9109      	str	r1, [sp, #36]	; 0x24
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
    2df6:	960b      	str	r6, [sp, #44]	; 0x2c
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    2df8:	2201      	movs	r2, #1
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    2dfa:	9e18      	ldr	r6, [sp, #96]	; 0x60
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
    2dfc:	9508      	str	r5, [sp, #32]
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    2dfe:	a907      	add	r1, sp, #28
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
    2e00:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    2e04:	960c      	str	r6, [sp, #48]	; 0x30
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
    2e06:	9707      	str	r7, [sp, #28]
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    2e08:	930d      	str	r3, [sp, #52]	; 0x34

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    2e0a:	f000 ff8b 	bl	3d24 <am_hal_queue_item_add>
    2e0e:	b9c8      	cbnz	r0, 2e44 <am_hal_iom_i2c_write+0xfc>
        {
            //
            // Didn't have enough memory.
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
    2e10:	2408      	movs	r4, #8
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    2e12:	4650      	mov	r0, sl
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    2e14:	f808 4005 	strb.w	r4, [r8, r5]
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    2e18:	f7fe fcf2 	bl	1800 <am_hal_interrupt_master_set>
    2e1c:	4620      	mov	r0, r4
    2e1e:	e7af      	b.n	2d80 <am_hal_iom_i2c_write+0x38>
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    2e20:	5d78      	ldrb	r0, [r7, r5]
    2e22:	f000 04ff 	and.w	r4, r0, #255	; 0xff
    2e26:	2800      	cmp	r0, #0
    2e28:	d1fa      	bne.n	2e20 <am_hal_iom_i2c_write+0xd8>
    2e2a:	9a18      	ldr	r2, [sp, #96]	; 0x60
    2e2c:	9401      	str	r4, [sp, #4]
    2e2e:	9200      	str	r2, [sp, #0]
    2e30:	4633      	mov	r3, r6
    2e32:	464a      	mov	r2, r9
    2e34:	4628      	mov	r0, r5
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2e36:	f808 4005 	strb.w	r4, [r8, r5]
    2e3a:	f7fe fe27 	bl	1a8c <am_hal_iom_i2c_write_nb.part.8>
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    2e3e:	4604      	mov	r4, r0
    2e40:	2800      	cmp	r0, #0
    2e42:	d1e6      	bne.n	2e12 <am_hal_iom_i2c_write+0xca>
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    2e44:	4650      	mov	r0, sl
    2e46:	f7fe fcdb 	bl	1800 <am_hal_interrupt_master_set>
        if (ui32Status == AM_HAL_IOM_SUCCESS)
        {
            //
            // Wait until the transaction actually clears.
            //
            am_hal_iom_queue_flush(ui32Module);
    2e4a:	4912      	ldr	r1, [pc, #72]	; (2e94 <am_hal_iom_i2c_write+0x14c>)
    2e4c:	4628      	mov	r0, r5
    2e4e:	680f      	ldr	r7, [r1, #0]
    2e50:	47b8      	blx	r7
            // g_iom_error_status gets set in the isr handling
            ui32Status = g_iom_error_status[ui32Module];
    2e52:	f818 0005 	ldrb.w	r0, [r8, r5]
    2e56:	e793      	b.n	2d80 <am_hal_iom_i2c_write+0x38>
                                     (uint8_t *)pui32Data, 0, false,
                                     (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    2e58:	f3c5 7400 	ubfx	r4, r5, #28, #1
    2e5c:	2301      	movs	r3, #1
    2e5e:	e88d 0018 	stmia.w	sp, {r3, r4}
    2e62:	9b18      	ldr	r3, [sp, #96]	; 0x60
    2e64:	0048      	lsls	r0, r1, #1
    2e66:	f3c3 2307 	ubfx	r3, r3, #8, #8
    2e6a:	4631      	mov	r1, r6
    2e6c:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    2e70:	f001 fe4a 	bl	4b08 <am_hal_i2c_bit_bang_send>
    2e74:	e79c      	b.n	2db0 <am_hal_iom_i2c_write+0x68>
    else
    {
        //
        // Otherwise, we'll just do a polled transaction.
        //
        ui32Status = am_hal_iom_i2c_write_nq(ui32Module, ui32BusAddress, pui32Data,
    2e76:	9f18      	ldr	r7, [sp, #96]	; 0x60
    2e78:	9700      	str	r7, [sp, #0]
    2e7a:	4633      	mov	r3, r6
    2e7c:	464a      	mov	r2, r9
    2e7e:	4628      	mov	r0, r5
    2e80:	f7ff fdb6 	bl	29f0 <am_hal_iom_i2c_write_nq>
    2e84:	e77c      	b.n	2d80 <am_hal_iom_i2c_write+0x38>
    2e86:	bf00      	nop
    2e88:	100011a4 	.word	0x100011a4
    2e8c:	000054a4 	.word	0x000054a4
    2e90:	1000160c 	.word	0x1000160c
    2e94:	10001084 	.word	0x10001084
    2e98:	1000119c 	.word	0x1000119c

00002e9c <am_hal_iom_i2c_write_nb>:
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;

    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    2e9c:	2806      	cmp	r0, #6
    2e9e:	d901      	bls.n	2ea4 <am_hal_iom_i2c_write_nb+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    2ea0:	2002      	movs	r0, #2
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
    2ea2:	4770      	bx	lr
am_hal_iom_status_e
am_hal_iom_i2c_write_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
                        uint32_t *pui32Data, uint32_t ui32NumBytes,
                        uint32_t ui32Options,
                        am_hal_iom_callback_t pfnCallback)
{
    2ea4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2ea8:	461e      	mov	r6, r3
    2eaa:	b082      	sub	sp, #8
    2eac:	4689      	mov	r9, r1
    2eae:	4605      	mov	r5, r0
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    2eb0:	d010      	beq.n	2ed4 <am_hal_iom_i2c_write_nb+0x38>
    2eb2:	4b6f      	ldr	r3, [pc, #444]	; (3070 <am_hal_iom_i2c_write_nb+0x1d4>)
    2eb4:	4690      	mov	r8, r2
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    2eb6:	5d5c      	ldrb	r4, [r3, r5]
    2eb8:	f004 00ff 	and.w	r0, r4, #255	; 0xff
    2ebc:	2c00      	cmp	r4, #0
    2ebe:	d1fa      	bne.n	2eb6 <am_hal_iom_i2c_write_nb+0x1a>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2ec0:	4f6c      	ldr	r7, [pc, #432]	; (3074 <am_hal_iom_i2c_write_nb+0x1d8>)
    2ec2:	5578      	strb	r0, [r7, r5]
    if (ui32NumBytes == 0)
    2ec4:	b10e      	cbz	r6, 2eca <am_hal_iom_i2c_write_nb+0x2e>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    2ec6:	2eff      	cmp	r6, #255	; 0xff
    2ec8:	d922      	bls.n	2f10 <am_hal_iom_i2c_write_nb+0x74>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    2eca:	2003      	movs	r0, #3
    2ecc:	5578      	strb	r0, [r7, r5]
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
    2ece:	b002      	add	sp, #8
    2ed0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2ed4:	4f67      	ldr	r7, [pc, #412]	; (3074 <am_hal_iom_i2c_write_nb+0x1d8>)
    2ed6:	2300      	movs	r3, #0
    2ed8:	71bb      	strb	r3, [r7, #6]
    if (ui32NumBytes == 0)
    2eda:	2e00      	cmp	r6, #0
    2edc:	d0f5      	beq.n	2eca <am_hal_iom_i2c_write_nb+0x2e>
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
    2ede:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    2ee0:	0068      	lsls	r0, r5, #1
    2ee2:	f140 80ab 	bpl.w	303c <am_hal_iom_i2c_write_nb+0x1a0>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    2ee6:	ea4f 0c49 	mov.w	ip, r9, lsl #1
    2eea:	f3c5 7400 	ubfx	r4, r5, #28, #1
    2eee:	f00c 00fe 	and.w	r0, ip, #254	; 0xfe
    2ef2:	9300      	str	r3, [sp, #0]
    2ef4:	4631      	mov	r1, r6
    2ef6:	9401      	str	r4, [sp, #4]
    2ef8:	f001 fe06 	bl	4b08 <am_hal_i2c_bit_bang_send>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    2efc:	4a5e      	ldr	r2, [pc, #376]	; (3078 <am_hal_iom_i2c_write_nb+0x1dc>)
    2efe:	5c16      	ldrb	r6, [r2, r0]
    2f00:	71be      	strb	r6, [r7, #6]
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
    2f02:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    2f04:	2f00      	cmp	r7, #0
    2f06:	f000 80a9 	beq.w	305c <am_hal_iom_i2c_write_nb+0x1c0>
        {
            pfnCallback();
    2f0a:	47b8      	blx	r7
        }
        return ui32Status;
    2f0c:	4630      	mov	r0, r6
    2f0e:	e7de      	b.n	2ece <am_hal_iom_i2c_write_nb+0x32>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2f10:	f505 21a0 	add.w	r1, r5, #327680	; 0x50000
    2f14:	3104      	adds	r1, #4
    2f16:	030c      	lsls	r4, r1, #12
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
    2f18:	2201      	movs	r2, #1
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2f1a:	f8d4 011c 	ldr.w	r0, [r4, #284]	; 0x11c
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
    2f1e:	555a      	strb	r2, [r3, r5]

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2f20:	f240 73ff 	movw	r3, #2047	; 0x7ff
    2f24:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2f28:	f8d4 111c 	ldr.w	r1, [r4, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    2f2c:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    2f30:	f010 0f08 	tst.w	r0, #8
    2f34:	bf14      	ite	ne
    2f36:	f04f 0a40 	movne.w	sl, #64	; 0x40
    2f3a:	f04f 0a80 	moveq.w	sl, #128	; 0x80
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    2f3e:	f011 0f08 	tst.w	r1, #8
    2f42:	bf14      	ite	ne
    2f44:	2140      	movne	r1, #64	; 0x40
    2f46:	2180      	moveq	r1, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2f48:	1a88      	subs	r0, r1, r2
                       AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);

    //
    // Figure out how many bytes we can write to the FIFO immediately.
    //
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    2f4a:	45b2      	cmp	sl, r6
    2f4c:	bf28      	it	cs
    2f4e:	46b2      	movcs	sl, r6
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    2f50:	f000 0cfc 	and.w	ip, r0, #252	; 0xfc
    2f54:	45e2      	cmp	sl, ip
    2f56:	f200 8083 	bhi.w	3060 <am_hal_iom_i2c_write_nb+0x1c4>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2f5a:	4642      	mov	r2, r8
    2f5c:	ea6f 0e08 	mvn.w	lr, r8
    2f60:	f852 3b04 	ldr.w	r3, [r2], #4
    2f64:	6023      	str	r3, [r4, #0]
    2f66:	44c6      	add	lr, r8

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2f68:	ebc8 0102 	rsb	r1, r8, r2
    2f6c:	44d6      	add	lr, sl
    2f6e:	458a      	cmp	sl, r1
    2f70:	f3ce 0082 	ubfx	r0, lr, #2, #3
    2f74:	d943      	bls.n	2ffe <am_hal_iom_i2c_write_nb+0x162>
    2f76:	b320      	cbz	r0, 2fc2 <am_hal_iom_i2c_write_nb+0x126>
    2f78:	2801      	cmp	r0, #1
    2f7a:	d01b      	beq.n	2fb4 <am_hal_iom_i2c_write_nb+0x118>
    2f7c:	2802      	cmp	r0, #2
    2f7e:	d016      	beq.n	2fae <am_hal_iom_i2c_write_nb+0x112>
    2f80:	2803      	cmp	r0, #3
    2f82:	d011      	beq.n	2fa8 <am_hal_iom_i2c_write_nb+0x10c>
    2f84:	2804      	cmp	r0, #4
    2f86:	d00c      	beq.n	2fa2 <am_hal_iom_i2c_write_nb+0x106>
    2f88:	2805      	cmp	r0, #5
    2f8a:	d007      	beq.n	2f9c <am_hal_iom_i2c_write_nb+0x100>
    2f8c:	2806      	cmp	r0, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2f8e:	bf1c      	itt	ne
    2f90:	f852 0b04 	ldrne.w	r0, [r2], #4
    2f94:	6020      	strne	r0, [r4, #0]
    2f96:	f852 3b04 	ldr.w	r3, [r2], #4
    2f9a:	6023      	str	r3, [r4, #0]
    2f9c:	f852 1b04 	ldr.w	r1, [r2], #4
    2fa0:	6021      	str	r1, [r4, #0]
    2fa2:	f852 0b04 	ldr.w	r0, [r2], #4
    2fa6:	6020      	str	r0, [r4, #0]
    2fa8:	f852 3b04 	ldr.w	r3, [r2], #4
    2fac:	6023      	str	r3, [r4, #0]
    2fae:	f852 1b04 	ldr.w	r1, [r2], #4
    2fb2:	6021      	str	r1, [r4, #0]
    2fb4:	f852 0b04 	ldr.w	r0, [r2], #4
    2fb8:	6020      	str	r0, [r4, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2fba:	ebc8 0c02 	rsb	ip, r8, r2
    2fbe:	45e2      	cmp	sl, ip
    2fc0:	d91d      	bls.n	2ffe <am_hal_iom_i2c_write_nb+0x162>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    2fc2:	4696      	mov	lr, r2
    2fc4:	3220      	adds	r2, #32
    2fc6:	f85e 3b04 	ldr.w	r3, [lr], #4
    2fca:	6023      	str	r3, [r4, #0]
    2fcc:	f852 1c1c 	ldr.w	r1, [r2, #-28]
    2fd0:	6021      	str	r1, [r4, #0]
    2fd2:	f8de 0004 	ldr.w	r0, [lr, #4]
    2fd6:	6020      	str	r0, [r4, #0]
    2fd8:	f852 3c14 	ldr.w	r3, [r2, #-20]
    2fdc:	6023      	str	r3, [r4, #0]
    2fde:	f852 1c10 	ldr.w	r1, [r2, #-16]
    2fe2:	6021      	str	r1, [r4, #0]
    2fe4:	f852 0c0c 	ldr.w	r0, [r2, #-12]
    2fe8:	6020      	str	r0, [r4, #0]
    2fea:	f852 3c08 	ldr.w	r3, [r2, #-8]
    2fee:	6023      	str	r3, [r4, #0]
    2ff0:	f852 1c04 	ldr.w	r1, [r2, #-4]
    2ff4:	6021      	str	r1, [r4, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    2ff6:	ebc8 0002 	rsb	r0, r8, r2
    2ffa:	4582      	cmp	sl, r0
    2ffc:	d8e1      	bhi.n	2fc2 <am_hal_iom_i2c_write_nb+0x126>
    if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
    {
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    2ffe:	491f      	ldr	r1, [pc, #124]	; (307c <am_hal_iom_i2c_write_nb+0x1e0>)
    3000:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3002:	9200      	str	r2, [sp, #0]
    3004:	eb05 0485 	add.w	r4, r5, r5, lsl #2
    3008:	00a3      	lsls	r3, r4, #2
    300a:	18cc      	adds	r4, r1, r3
    300c:	2001      	movs	r0, #1
    300e:	464a      	mov	r2, r9
        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    3010:	f02a 0903 	bic.w	r9, sl, #3
    if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
    {
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    3014:	50c8      	str	r0, [r1, r3]

        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    3016:	ebca 0a06 	rsb	sl, sl, r6
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    301a:	44c8      	add	r8, r9
    301c:	4633      	mov	r3, r6
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    301e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    3020:	6126      	str	r6, [r4, #16]
    3022:	4629      	mov	r1, r5
    3024:	2000      	movs	r0, #0

        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    3026:	f8c4 a008 	str.w	sl, [r4, #8]
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    302a:	f8c4 8004 	str.w	r8, [r4, #4]
    302e:	f7fe fc1f 	bl	1870 <am_hal_iom_i2c_cmd_run.part.1>
        //
        // Start the write on the bus.
        //
        ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                               ui32NumBytes, ui32Options);
        if (ui32Status != AM_HAL_IOM_SUCCESS)
    3032:	2800      	cmp	r0, #0
    3034:	f43f af4b 	beq.w	2ece <am_hal_iom_i2c_write_nb+0x32>
        {
            g_iom_error_status[ui32Module] = ui32Status;
    3038:	5578      	strb	r0, [r7, r5]
    303a:	e748      	b.n	2ece <am_hal_iom_i2c_write_nb+0x32>
                                     (uint8_t *)pui32Data, 0, false,
                                     (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    303c:	f3c5 7400 	ubfx	r4, r5, #28, #1
    3040:	2301      	movs	r3, #1
    3042:	e88d 0018 	stmia.w	sp, {r3, r4}
    3046:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3048:	ea4f 0149 	mov.w	r1, r9, lsl #1
    304c:	f001 00fe 	and.w	r0, r1, #254	; 0xfe
    3050:	f3c3 2307 	ubfx	r3, r3, #8, #8
    3054:	4631      	mov	r1, r6
    3056:	f001 fd57 	bl	4b08 <am_hal_i2c_bit_bang_send>
    305a:	e74f      	b.n	2efc <am_hal_iom_i2c_write_nb+0x60>
        //
        if ( pfnCallback )
        {
            pfnCallback();
        }
        return ui32Status;
    305c:	4630      	mov	r0, r6
    305e:	e736      	b.n	2ece <am_hal_iom_i2c_write_nb+0x32>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    3060:	4a07      	ldr	r2, [pc, #28]	; (3080 <am_hal_iom_i2c_write_nb+0x1e4>)
    3062:	4808      	ldr	r0, [pc, #32]	; (3084 <am_hal_iom_i2c_write_nb+0x1e8>)
    3064:	f640 7107 	movw	r1, #3847	; 0xf07
    3068:	f7fe fad0 	bl	160c <am_hal_debug_error>
    306c:	e775      	b.n	2f5a <am_hal_iom_i2c_write_nb+0xbe>
    306e:	bf00      	nop
    3070:	100011a4 	.word	0x100011a4
    3074:	1000119c 	.word	0x1000119c
    3078:	000054a4 	.word	0x000054a4
    307c:	10001594 	.word	0x10001594
    3080:	00005360 	.word	0x00005360
    3084:	00005394 	.word	0x00005394

00003088 <am_hal_iom_i2c_read_nb>:
    am_hal_iom_status_e ui32Status;
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;
    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    3088:	2806      	cmp	r0, #6
    308a:	d901      	bls.n	3090 <am_hal_iom_i2c_read_nb+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    308c:	2002      	movs	r0, #2
    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    }
    return ui32Status;
}
    308e:	4770      	bx	lr
am_hal_iom_status_e
am_hal_iom_i2c_read_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
                       uint32_t *pui32Data, uint32_t ui32NumBytes,
                       uint32_t ui32Options,
                       am_hal_iom_callback_t pfnCallback)
{
    3090:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3094:	461e      	mov	r6, r3
    3096:	b082      	sub	sp, #8
    3098:	4605      	mov	r5, r0
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    309a:	d014      	beq.n	30c6 <am_hal_iom_i2c_read_nb+0x3e>
    309c:	4836      	ldr	r0, [pc, #216]	; (3178 <am_hal_iom_i2c_read_nb+0xf0>)
    309e:	4696      	mov	lr, r2
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    30a0:	5d44      	ldrb	r4, [r0, r5]
    30a2:	4f35      	ldr	r7, [pc, #212]	; (3178 <am_hal_iom_i2c_read_nb+0xf0>)
    30a4:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    30a8:	2c00      	cmp	r4, #0
    30aa:	d1f9      	bne.n	30a0 <am_hal_iom_i2c_read_nb+0x18>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    30ac:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 3180 <am_hal_iom_i2c_read_nb+0xf8>
    30b0:	f808 3005 	strb.w	r3, [r8, r5]
    if (ui32NumBytes == 0)
    30b4:	b10e      	cbz	r6, 30ba <am_hal_iom_i2c_read_nb+0x32>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    30b6:	2eff      	cmp	r6, #255	; 0xff
    30b8:	d925      	bls.n	3106 <am_hal_iom_i2c_read_nb+0x7e>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    30ba:	2003      	movs	r0, #3
    30bc:	f808 0005 	strb.w	r0, [r8, r5]
    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    }
    return ui32Status;
}
    30c0:	b002      	add	sp, #8
    30c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    30c6:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 3180 <am_hal_iom_i2c_read_nb+0xf8>
    30ca:	2300      	movs	r3, #0
    30cc:	f888 3006 	strb.w	r3, [r8, #6]
    if (ui32NumBytes == 0)
    30d0:	2e00      	cmp	r6, #0
    30d2:	d0f2      	beq.n	30ba <am_hal_iom_i2c_read_nb+0x32>
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
    30d4:	9d08      	ldr	r5, [sp, #32]
    30d6:	006c      	lsls	r4, r5, #1
    30d8:	d53c      	bpl.n	3154 <am_hal_iom_i2c_read_nb+0xcc>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    30da:	9c08      	ldr	r4, [sp, #32]
    30dc:	9300      	str	r3, [sp, #0]
    30de:	0048      	lsls	r0, r1, #1
    30e0:	f040 0501 	orr.w	r5, r0, #1
    30e4:	f3c4 7700 	ubfx	r7, r4, #28, #1
    30e8:	b2e8      	uxtb	r0, r5
    30ea:	4631      	mov	r1, r6
    30ec:	9701      	str	r7, [sp, #4]
    30ee:	f001 f8b3 	bl	4258 <am_hal_i2c_bit_bang_receive>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    30f2:	4a22      	ldr	r2, [pc, #136]	; (317c <am_hal_iom_i2c_read_nb+0xf4>)
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
    30f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    30f6:	5c16      	ldrb	r6, [r2, r0]
    30f8:	f888 6006 	strb.w	r6, [r8, #6]
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
    30fc:	2b00      	cmp	r3, #0
    30fe:	d039      	beq.n	3174 <am_hal_iom_i2c_read_nb+0xec>
        {
            pfnCallback();
    3100:	4798      	blx	r3
        }

        return ui32Status;
    3102:	4630      	mov	r0, r6
    3104:	e7dc      	b.n	30c0 <am_hal_iom_i2c_read_nb+0x38>
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    3106:	f505 22a0 	add.w	r2, r5, #327680	; 0x50000
    310a:	3204      	adds	r2, #4

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    310c:	eb05 0485 	add.w	r4, r5, r5, lsl #2
    3110:	f8df c070 	ldr.w	ip, [pc, #112]	; 3184 <am_hal_iom_i2c_read_nb+0xfc>
    3114:	00a3      	lsls	r3, r4, #2
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    3116:	0310      	lsls	r0, r2, #12

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    3118:	2401      	movs	r4, #1
    311a:	557c      	strb	r4, [r7, r5]
    311c:	460a      	mov	r2, r1
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    311e:	eb0c 0703 	add.w	r7, ip, r3
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    3122:	f240 71ff 	movw	r1, #2047	; 0x7ff
    3126:	f8c0 1208 	str.w	r1, [r0, #520]	; 0x208

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    312a:	2402      	movs	r4, #2
    312c:	9808      	ldr	r0, [sp, #32]
    312e:	9000      	str	r0, [sp, #0]
    3130:	f84c 4003 	str.w	r4, [ip, r3]
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
    3134:	60be      	str	r6, [r7, #8]
    3136:	4633      	mov	r3, r6
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    3138:	9e09      	ldr	r6, [sp, #36]	; 0x24

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    313a:	f8c7 e004 	str.w	lr, [r7, #4]
    313e:	4629      	mov	r1, r5
    3140:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    3144:	613e      	str	r6, [r7, #16]
    3146:	f7fe fb93 	bl	1870 <am_hal_iom_i2c_cmd_run.part.1>
    //
    // Start the read transaction on the bus.
    //
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_READ, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);
    if (ui32Status != AM_HAL_IOM_SUCCESS)
    314a:	2800      	cmp	r0, #0
    314c:	d0b8      	beq.n	30c0 <am_hal_iom_i2c_read_nb+0x38>
    {
        g_iom_error_status[ui32Module] = ui32Status;
    314e:	f808 0005 	strb.w	r0, [r8, r5]
    3152:	e7b5      	b.n	30c0 <am_hal_iom_i2c_read_nb+0x38>
                                        (uint8_t *)pui32Data, 0, false,
                                        (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    3154:	004b      	lsls	r3, r1, #1
    3156:	9f08      	ldr	r7, [sp, #32]
    3158:	f043 0101 	orr.w	r1, r3, #1
    315c:	f3c5 7400 	ubfx	r4, r5, #28, #1
    3160:	2301      	movs	r3, #1
    3162:	e88d 0018 	stmia.w	sp, {r3, r4}
    3166:	b2c8      	uxtb	r0, r1
    3168:	f3c7 2307 	ubfx	r3, r7, #8, #8
    316c:	4631      	mov	r1, r6
    316e:	f001 f873 	bl	4258 <am_hal_i2c_bit_bang_receive>
    3172:	e7be      	b.n	30f2 <am_hal_iom_i2c_read_nb+0x6a>
        if ( pfnCallback )
        {
            pfnCallback();
        }

        return ui32Status;
    3174:	4630      	mov	r0, r6
    3176:	e7a3      	b.n	30c0 <am_hal_iom_i2c_read_nb+0x38>
    3178:	100011a4 	.word	0x100011a4
    317c:	000054a4 	.word	0x000054a4
    3180:	1000119c 	.word	0x1000119c
    3184:	10001594 	.word	0x10001594

00003188 <am_hal_iom_queue_init>:
                      uint32_t ui32QueueMemSize)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    3188:	2805      	cmp	r0, #5
    318a:	d900      	bls.n	318e <am_hal_iom_queue_init+0x6>
    318c:	4770      	bx	lr
//
//*****************************************************************************
void
am_hal_iom_queue_init(uint32_t ui32Module, am_hal_iom_queue_entry_t *psQueueMemory,
                      uint32_t ui32QueueMemSize)
{
    318e:	b410      	push	{r4}
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return;
    }

    am_hal_queue_init(&g_psIOMQueue[ui32Module], psQueueMemory,
    3190:	4c05      	ldr	r4, [pc, #20]	; (31a8 <am_hal_iom_queue_init+0x20>)
    3192:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    3196:	4613      	mov	r3, r2
    3198:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    319c:	221c      	movs	r2, #28
                      sizeof(am_hal_iom_queue_entry_t), ui32QueueMemSize);
}
    319e:	f85d 4b04 	ldr.w	r4, [sp], #4
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return;
    }

    am_hal_queue_init(&g_psIOMQueue[ui32Module], psQueueMemory,
    31a2:	f000 bdb3 	b.w	3d0c <am_hal_queue_init>
    31a6:	bf00      	nop
    31a8:	1000160c 	.word	0x1000160c

000031ac <am_hal_iom_queue_service>:
am_hal_iom_queue_service(uint32_t ui32Module, uint32_t ui32Status)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    31ac:	2805      	cmp	r0, #5
    31ae:	d85b      	bhi.n	3268 <am_hal_iom_queue_service+0xbc>
//! @return
//
//*****************************************************************************
void
am_hal_iom_queue_service(uint32_t ui32Module, uint32_t ui32Status)
{
    31b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    //
    psBuffer = &g_psIOMBuffers[ui32Module];

    // Keep accumulating any error indications
    // This is to account for the case if the error indication comes before CMDCMP
    g_iom_error_status[ui32Module] |= ui32Status;
    31b4:	4ea5      	ldr	r6, [pc, #660]	; (344c <am_hal_iom_queue_service+0x2a0>)
    31b6:	5c33      	ldrb	r3, [r6, r0]
    31b8:	430b      	orrs	r3, r1
    31ba:	b2db      	uxtb	r3, r3
    //
    // Figure out what type of interrupt this was.
    //
    if ( ui32Status & AM_HAL_IOM_INT_CMDCMP )
    31bc:	07cd      	lsls	r5, r1, #31
//! @return
//
//*****************************************************************************
void
am_hal_iom_queue_service(uint32_t ui32Module, uint32_t ui32Status)
{
    31be:	b08d      	sub	sp, #52	; 0x34
    31c0:	4604      	mov	r4, r0
    //
    psBuffer = &g_psIOMBuffers[ui32Module];

    // Keep accumulating any error indications
    // This is to account for the case if the error indication comes before CMDCMP
    g_iom_error_status[ui32Module] |= ui32Status;
    31c2:	5433      	strb	r3, [r6, r0]
    //
    // Figure out what type of interrupt this was.
    //
    if ( ui32Status & AM_HAL_IOM_INT_CMDCMP )
    31c4:	d551      	bpl.n	326a <am_hal_iom_queue_service+0xbe>

        //
        // If we're not in the middle of a non-blocking call right now, there's
        // nothing for this routine to do.
        //
        if ( psBuffer->ui32State == BUFFER_IDLE )
    31c6:	0085      	lsls	r5, r0, #2
    31c8:	1829      	adds	r1, r5, r0
    31ca:	008a      	lsls	r2, r1, #2
    31cc:	f8df 8288 	ldr.w	r8, [pc, #648]	; 3458 <am_hal_iom_queue_service+0x2ac>
    if ( ui32Status & AM_HAL_IOM_INT_CMDCMP )
    {
        //
        // Need to mark IOM Free
        //
        g_bIomBusy[ui32Module] = false;
    31d0:	4f9f      	ldr	r7, [pc, #636]	; (3450 <am_hal_iom_queue_service+0x2a4>)

        //
        // If we're not in the middle of a non-blocking call right now, there's
        // nothing for this routine to do.
        //
        if ( psBuffer->ui32State == BUFFER_IDLE )
    31d2:	f858 1002 	ldr.w	r1, [r8, r2]
    if ( ui32Status & AM_HAL_IOM_INT_CMDCMP )
    {
        //
        // Need to mark IOM Free
        //
        g_bIomBusy[ui32Module] = false;
    31d6:	2000      	movs	r0, #0

        //
        // If we're not in the middle of a non-blocking call right now, there's
        // nothing for this routine to do.
        //
        if ( psBuffer->ui32State == BUFFER_IDLE )
    31d8:	4442      	add	r2, r8
    if ( ui32Status & AM_HAL_IOM_INT_CMDCMP )
    {
        //
        // Need to mark IOM Free
        //
        g_bIomBusy[ui32Module] = false;
    31da:	5538      	strb	r0, [r7, r4]

        //
        // If we're not in the middle of a non-blocking call right now, there's
        // nothing for this routine to do.
        //
        if ( psBuffer->ui32State == BUFFER_IDLE )
    31dc:	b1d1      	cbz	r1, 3214 <am_hal_iom_queue_service+0x68>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    31de:	f504 2ca0 	add.w	ip, r4, #327680	; 0x50000
    31e2:	f10c 0004 	add.w	r0, ip, #4
        }

        //
        // If a command just completed, we need to transfer all available data.
        //
        if ( psBuffer->ui32State == BUFFER_RECEIVING )
    31e6:	2902      	cmp	r1, #2
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    31e8:	ea4f 3900 	mov.w	r9, r0, lsl #12
        }

        //
        // If a command just completed, we need to transfer all available data.
        //
        if ( psBuffer->ui32State == BUFFER_RECEIVING )
    31ec:	d076      	beq.n	32dc <am_hal_iom_queue_service+0x130>

        //
        // A command complete event also means that we've already transferred
        // all of the data we need, so we can mark the data buffer as IDLE.
        //
        psBuffer->ui32State = BUFFER_IDLE;
    31ee:	192a      	adds	r2, r5, r4
    31f0:	0090      	lsls	r0, r2, #2
    31f2:	2100      	movs	r1, #0
    31f4:	f848 1000 	str.w	r1, [r8, r0]
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    31f8:	f8d9 2204 	ldr.w	r2, [r9, #516]	; 0x204
{
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);
    31fc:	4313      	orrs	r3, r2

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    31fe:	f013 0fcc 	tst.w	r3, #204	; 0xcc
    3202:	d060      	beq.n	32c6 <am_hal_iom_queue_service+0x11a>
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    3204:	2305      	movs	r3, #5

        g_iom_error_status[ui32Module] = internal_iom_get_int_err(ui32Module, g_iom_error_status[ui32Module]);
        //
        // If we have a callback, call it now.
        //
        if ( psBuffer->pfnCallback )
    3206:	4425      	add	r5, r4
    3208:	eb08 0585 	add.w	r5, r8, r5, lsl #2
        // A command complete event also means that we've already transferred
        // all of the data we need, so we can mark the data buffer as IDLE.
        //
        psBuffer->ui32State = BUFFER_IDLE;

        g_iom_error_status[ui32Module] = internal_iom_get_int_err(ui32Module, g_iom_error_status[ui32Module]);
    320c:	5533      	strb	r3, [r6, r4]
        //
        // If we have a callback, call it now.
        //
        if ( psBuffer->pfnCallback )
    320e:	6928      	ldr	r0, [r5, #16]
    3210:	b100      	cbz	r0, 3214 <am_hal_iom_queue_service+0x68>
        {
            psBuffer->pfnCallback();
    3212:	4780      	blx	r0
    // idle already or very soon. Make absolutely sure that the IOM is not in
    // use, and then start the next transaction in the queue.
    //
    if ( ui32Status & AM_HAL_IOM_INT_CMDCMP )
    {
        if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    3214:	498f      	ldr	r1, [pc, #572]	; (3454 <am_hal_iom_queue_service+0x2a8>)
    3216:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    321a:	eb01 09c2 	add.w	r9, r1, r2, lsl #3
    321e:	f8d9 3014 	ldr.w	r3, [r9, #20]
    3222:	2b00      	cmp	r3, #0
    3224:	d048      	beq.n	32b8 <am_hal_iom_queue_service+0x10c>
//
//*****************************************************************************
void
am_hal_iom_queue_start_next_msg(uint32_t ui32Module)
{
    am_hal_iom_queue_entry_t sIOMTransaction = {0};
    3226:	2500      	movs	r5, #0
    3228:	9506      	str	r5, [sp, #24]
    322a:	9505      	str	r5, [sp, #20]
    322c:	9507      	str	r5, [sp, #28]
    322e:	9508      	str	r5, [sp, #32]
    3230:	9509      	str	r5, [sp, #36]	; 0x24
    3232:	950a      	str	r5, [sp, #40]	; 0x28
    3234:	950b      	str	r5, [sp, #44]	; 0x2c
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    3236:	f7fe fadf 	bl	17f8 <am_hal_interrupt_master_disable>

    //
    // Try to get the next IOM operation from the queue.
    //
    if ( am_hal_queue_item_get(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) )
    323a:	a905      	add	r1, sp, #20
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    323c:	4680      	mov	r8, r0

    //
    // Try to get the next IOM operation from the queue.
    //
    if ( am_hal_queue_item_get(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) )
    323e:	2201      	movs	r2, #1
    3240:	4648      	mov	r0, r9
    3242:	f000 fdfd 	bl	3e40 <am_hal_queue_item_get>
    3246:	2800      	cmp	r0, #0
    3248:	d039      	beq.n	32be <am_hal_iom_queue_service+0x112>

        //
        // Figure out if this was a SPI or I2C write or read, and call the
        // appropriate non-blocking function.
        //
        switch ( sIOMTransaction.ui32Operation )
    324a:	9805      	ldr	r0, [sp, #20]
        //
        ui32ChipSelect = sIOMTransaction.ui32ChipSelect;
        pui32Data = sIOMTransaction.pui32Data;
        ui32NumBytes = sIOMTransaction.ui32NumBytes;
        ui32Options = sIOMTransaction.ui32Options;
        pfnCallback = sIOMTransaction.pfnCallback;
    324c:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
        // Read the operation parameters
        //
        ui32ChipSelect = sIOMTransaction.ui32ChipSelect;
        pui32Data = sIOMTransaction.pui32Data;
        ui32NumBytes = sIOMTransaction.ui32NumBytes;
        ui32Options = sIOMTransaction.ui32Options;
    3250:	f10d 0e1c 	add.w	lr, sp, #28
    3254:	e89e 002e 	ldmia.w	lr, {r1, r2, r3, r5}

        //
        // Figure out if this was a SPI or I2C write or read, and call the
        // appropriate non-blocking function.
        //
        switch ( sIOMTransaction.ui32Operation )
    3258:	2803      	cmp	r0, #3
    325a:	d830      	bhi.n	32be <am_hal_iom_queue_service+0x112>
    325c:	e8df f010 	tbh	[pc, r0, lsl #1]
    3260:	00cb00b7 	.word	0x00cb00b7
    3264:	00df00ee 	.word	0x00df00ee
    3268:	4770      	bx	lr
        if ( psBuffer->pfnCallback )
        {
            psBuffer->pfnCallback();
        }
    }
    else if ( ui32Status & AM_HAL_IOM_INT_THR )
    326a:	0789      	lsls	r1, r1, #30
    326c:	d524      	bpl.n	32b8 <am_hal_iom_queue_service+0x10c>
    {
        //
        // If we're not in the middle of a non-blocking call right now, there's
        // nothing for this routine to do.
        //
        if ( psBuffer->ui32State == BUFFER_IDLE )
    326e:	eb00 0980 	add.w	r9, r0, r0, lsl #2
    3272:	ea4f 0589 	mov.w	r5, r9, lsl #2
    3276:	4a78      	ldr	r2, [pc, #480]	; (3458 <am_hal_iom_queue_service+0x2ac>)
    3278:	5951      	ldr	r1, [r2, r5]
    327a:	4415      	add	r5, r2
    327c:	b1e1      	cbz	r1, 32b8 <am_hal_iom_queue_service+0x10c>
        // If we received a threshold event in the middle of a command, we need
        // to transfer data.
        //
        if ( psBuffer->ui32State == BUFFER_SENDING )
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFOWTHR);
    327e:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
        }
        //
        // If we received a threshold event in the middle of a command, we need
        // to transfer data.
        //
        if ( psBuffer->ui32State == BUFFER_SENDING )
    3282:	2901      	cmp	r1, #1
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFOWTHR);
    3284:	f100 0004 	add.w	r0, r0, #4
        }
        //
        // If we received a threshold event in the middle of a command, we need
        // to transfer data.
        //
        if ( psBuffer->ui32State == BUFFER_SENDING )
    3288:	f000 81e5 	beq.w	3656 <am_hal_iom_queue_service+0x4aa>
                }
            } while ( am_hal_iom_fifo_full_slots(ui32Module) <= thresh );
        }
        else
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFORTHR);
    328c:	ea4f 3800 	mov.w	r8, r0, lsl #12
            {
                //
                // If we get here, we're in the middle of a read. Transfer as much
                // data as possible out of the FIFO and into our buffer.
                //
                if ( ui32NumBytes == psBuffer->ui32BytesLeft )
    3290:	462c      	mov	r4, r5
                }
            } while ( am_hal_iom_fifo_full_slots(ui32Module) <= thresh );
        }
        else
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFORTHR);
    3292:	f8d8 6108 	ldr.w	r6, [r8, #264]	; 0x108
    3296:	f508 7780 	add.w	r7, r8, #256	; 0x100
    329a:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    329e:	e007      	b.n	32b0 <am_hal_iom_queue_service+0x104>
            {
                //
                // If we get here, we're in the middle of a read. Transfer as much
                // data as possible out of the FIFO and into our buffer.
                //
                if ( ui32NumBytes == psBuffer->ui32BytesLeft )
    32a0:	68a2      	ldr	r2, [r4, #8]
    32a2:	496d      	ldr	r1, [pc, #436]	; (3458 <am_hal_iom_queue_service+0x2ac>)
    32a4:	42aa      	cmp	r2, r5
    32a6:	f000 80d9 	beq.w	345c <am_hal_iom_queue_service+0x2b0>
                    am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data,
                                         psBuffer->ui32BytesLeft);

                    break;
                }
                else if ( ui32NumBytes >= 4 )
    32aa:	2d03      	cmp	r5, #3
    32ac:	f200 814a 	bhi.w	3544 <am_hal_iom_queue_service+0x398>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    32b0:	683b      	ldr	r3, [r7, #0]
    32b2:	b2dd      	uxtb	r5, r3
            } while ( am_hal_iom_fifo_full_slots(ui32Module) <= thresh );
        }
        else
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFORTHR);
            while ( (ui32NumBytes = am_hal_iom_fifo_full_slots(ui32Module)) >= thresh )
    32b4:	42ae      	cmp	r6, r5
    32b6:	d9f3      	bls.n	32a0 <am_hal_iom_queue_service+0xf4>
        if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
        {
            am_hal_iom_queue_start_next_msg(ui32Module);
        }
    }
}
    32b8:	b00d      	add	sp, #52	; 0x34
    32ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    32be:	4640      	mov	r0, r8
    32c0:	f7fe fa9e 	bl	1800 <am_hal_interrupt_master_set>
    32c4:	e7f8      	b.n	32b8 <am_hal_iom_queue_service+0x10c>
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    32c6:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    {
        // Loss of I2C multi-master arbitration
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    32ca:	bf18      	it	ne
    32cc:	2307      	movne	r3, #7
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    32ce:	d19a      	bne.n	3206 <am_hal_iom_queue_service+0x5a>
//!
//*****************************************************************************
static am_hal_iom_status_e
internal_iom_get_int_err(uint32_t ui32Module, uint32_t ui32IntStatus)
{
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;
    32d0:	f013 0f10 	tst.w	r3, #16
    32d4:	bf14      	ite	ne
    32d6:	2306      	movne	r3, #6
    32d8:	460b      	moveq	r3, r1
    32da:	e794      	b.n	3206 <am_hal_iom_queue_service+0x5a>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    32dc:	f8d9 3100 	ldr.w	r3, [r9, #256]	; 0x100
            //
            // If we were receiving, we need to copy any remaining data out of
            // the IOM FIFO before calling the callback.
            //
            ui32NumBytes = am_hal_iom_fifo_full_slots(ui32Module);
            am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data, ui32NumBytes);
    32e0:	f8d2 a004 	ldr.w	sl, [r2, #4]

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    32e4:	f8d9 211c 	ldr.w	r2, [r9, #284]	; 0x11c
    32e8:	0710      	lsls	r0, r2, #28
    32ea:	fa5f fb83 	uxtb.w	fp, r3
    32ee:	d405      	bmi.n	32fc <am_hal_iom_queue_service+0x150>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    32f0:	f8d9 1100 	ldr.w	r1, [r9, #256]	; 0x100
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    32f4:	b2c8      	uxtb	r0, r1
    32f6:	4583      	cmp	fp, r0
    32f8:	f200 824e 	bhi.w	3798 <am_hal_iom_queue_service+0x5ec>

    //
    // Figure out how many whole words we're reading from the fifo, and how
    // many bytes will be left over when we're done.
    //
    ui32NumWords = ui32NumBytes / 4;
    32fc:	f3c3 0185 	ubfx	r1, r3, #2, #6
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    3300:	0088      	lsls	r0, r1, #2
    3302:	ebc0 020b 	rsb	r2, r0, fp

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    3306:	2900      	cmp	r1, #0
    3308:	d056      	beq.n	33b8 <am_hal_iom_queue_service+0x20c>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    330a:	4653      	mov	r3, sl
    330c:	f8d9 1000 	ldr.w	r1, [r9]
    3310:	f843 1b04 	str.w	r1, [r3], #4
    3314:	eb0a 0e00 	add.w	lr, sl, r0
    3318:	f1a0 0c04 	sub.w	ip, r0, #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    331c:	4573      	cmp	r3, lr
    331e:	f3cc 0182 	ubfx	r1, ip, #2, #3
    3322:	d049      	beq.n	33b8 <am_hal_iom_queue_service+0x20c>
    3324:	b349      	cbz	r1, 337a <am_hal_iom_queue_service+0x1ce>
    3326:	2901      	cmp	r1, #1
    3328:	d021      	beq.n	336e <am_hal_iom_queue_service+0x1c2>
    332a:	2902      	cmp	r1, #2
    332c:	d01b      	beq.n	3366 <am_hal_iom_queue_service+0x1ba>
    332e:	2903      	cmp	r1, #3
    3330:	d015      	beq.n	335e <am_hal_iom_queue_service+0x1b2>
    3332:	2904      	cmp	r1, #4
    3334:	d00f      	beq.n	3356 <am_hal_iom_queue_service+0x1aa>
    3336:	2905      	cmp	r1, #5
    3338:	d009      	beq.n	334e <am_hal_iom_queue_service+0x1a2>
    333a:	2906      	cmp	r1, #6
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    333c:	bf1c      	itt	ne
    333e:	f8d9 1000 	ldrne.w	r1, [r9]
    3342:	f843 1b04 	strne.w	r1, [r3], #4
    3346:	f8d9 1000 	ldr.w	r1, [r9]
    334a:	f843 1b04 	str.w	r1, [r3], #4
    334e:	f8d9 1000 	ldr.w	r1, [r9]
    3352:	f843 1b04 	str.w	r1, [r3], #4
    3356:	f8d9 1000 	ldr.w	r1, [r9]
    335a:	f843 1b04 	str.w	r1, [r3], #4
    335e:	f8d9 1000 	ldr.w	r1, [r9]
    3362:	f843 1b04 	str.w	r1, [r3], #4
    3366:	f8d9 1000 	ldr.w	r1, [r9]
    336a:	f843 1b04 	str.w	r1, [r3], #4
    336e:	f8d9 1000 	ldr.w	r1, [r9]
    3372:	f843 1b04 	str.w	r1, [r3], #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    3376:	4573      	cmp	r3, lr
    3378:	d01e      	beq.n	33b8 <am_hal_iom_queue_service+0x20c>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    337a:	469b      	mov	fp, r3
    337c:	f8d9 c000 	ldr.w	ip, [r9]
    3380:	f84b cb04 	str.w	ip, [fp], #4
    3384:	f8d9 c000 	ldr.w	ip, [r9]
    3388:	f8c3 c004 	str.w	ip, [r3, #4]
    338c:	f8d9 c000 	ldr.w	ip, [r9]
    3390:	f8cb c004 	str.w	ip, [fp, #4]
    3394:	f8d9 1000 	ldr.w	r1, [r9]
    3398:	60d9      	str	r1, [r3, #12]
    339a:	f8d9 1000 	ldr.w	r1, [r9]
    339e:	6119      	str	r1, [r3, #16]
    33a0:	f8d9 1000 	ldr.w	r1, [r9]
    33a4:	6159      	str	r1, [r3, #20]
    33a6:	f8d9 1000 	ldr.w	r1, [r9]
    33aa:	6199      	str	r1, [r3, #24]
    33ac:	f8d9 1000 	ldr.w	r1, [r9]
    33b0:	61d9      	str	r1, [r3, #28]
    33b2:	3320      	adds	r3, #32
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    33b4:	4573      	cmp	r3, lr
    33b6:	d1e0      	bne.n	337a <am_hal_iom_queue_service+0x1ce>
    // definition requests, we wouldn't need to do this. It's possible to call
    // this function with a re-cast or packed pointer instead though. If that
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    33b8:	b13a      	cbz	r2, 33ca <am_hal_iom_queue_service+0x21e>
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    33ba:	a90c      	add	r1, sp, #48	; 0x30
    33bc:	f8d9 3000 	ldr.w	r3, [r9]
    33c0:	f841 3d1c 	str.w	r3, [r1, #-28]!
    33c4:	4450      	add	r0, sl
    33c6:	f001 ff1d 	bl	5204 <memcpy>
    33ca:	5d33      	ldrb	r3, [r6, r4]
    33cc:	e70f      	b.n	31ee <am_hal_iom_queue_service+0x42>
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    33ce:	5d38      	ldrb	r0, [r7, r4]
    33d0:	f000 0cff 	and.w	ip, r0, #255	; 0xff
    33d4:	2800      	cmp	r0, #0
    33d6:	d1fa      	bne.n	33ce <am_hal_iom_queue_service+0x222>
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status for non-blocking transfer
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    33d8:	f103 3eff 	add.w	lr, r3, #4294967295
    33dc:	f640 77fe 	movw	r7, #4094	; 0xffe
    33e0:	45be      	cmp	lr, r7
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status for non-blocking transfer
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    33e2:	f806 c004 	strb.w	ip, [r6, r4]
    if (ui32NumBytes == 0)
    33e6:	f240 81e7 	bls.w	37b8 <am_hal_iom_queue_service+0x60c>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    33ea:	2703      	movs	r7, #3
    }

    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    33ec:	4640      	mov	r0, r8

    // Reset the error status for non-blocking transfer
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    33ee:	5537      	strb	r7, [r6, r4]
    }

    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    33f0:	f7fe fa06 	bl	1800 <am_hal_interrupt_master_set>
    33f4:	e01f      	b.n	3436 <am_hal_iom_queue_service+0x28a>
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    33f6:	5d38      	ldrb	r0, [r7, r4]
    33f8:	f000 0aff 	and.w	sl, r0, #255	; 0xff
    33fc:	2800      	cmp	r0, #0
    33fe:	d1fa      	bne.n	33f6 <am_hal_iom_queue_service+0x24a>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);
    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    3400:	f103 3bff 	add.w	fp, r3, #4294967295
    3404:	f640 77fe 	movw	r7, #4094	; 0xffe
    3408:	45bb      	cmp	fp, r7
    //
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);
    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    340a:	f806 a004 	strb.w	sl, [r6, r4]
    if (ui32NumBytes == 0)
    340e:	d8ec      	bhi.n	33ea <am_hal_iom_queue_service+0x23e>
    3410:	e88d 0220 	stmia.w	sp, {r5, r9}
    3414:	4620      	mov	r0, r4
    3416:	f7ff fa65 	bl	28e4 <am_hal_iom_spi_read_nb.part.7>
    341a:	4607      	mov	r7, r0
    341c:	e005      	b.n	342a <am_hal_iom_queue_service+0x27e>
                ui32Status = am_hal_iom_i2c_write_nb(ui32Module, ui32ChipSelect, pui32Data,
                                        ui32NumBytes, ui32Options, pfnCallback);
                break;

            case AM_HAL_IOM_QUEUE_I2C_READ:
                ui32Status = am_hal_iom_i2c_read_nb(ui32Module, ui32ChipSelect, pui32Data,
    341e:	e88d 0220 	stmia.w	sp, {r5, r9}
    3422:	4620      	mov	r0, r4
    3424:	f7ff fe30 	bl	3088 <am_hal_iom_i2c_read_nb>
    3428:	4607      	mov	r7, r0
    }

    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    342a:	4640      	mov	r0, r8
    342c:	f7fe f9e8 	bl	1800 <am_hal_interrupt_master_set>

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    3430:	2f00      	cmp	r7, #0
    3432:	f43f af41 	beq.w	32b8 <am_hal_iom_queue_service+0x10c>
    {
        // Preserve the error
        g_iom_error_status[ui32Module] = ui32Status;
    3436:	5537      	strb	r7, [r6, r4]
        // Call the respective callback
        pfnCallback();
    3438:	47c8      	blx	r9
    343a:	e73d      	b.n	32b8 <am_hal_iom_queue_service+0x10c>
                ui32Status = am_hal_iom_spi_read_nb(ui32Module, ui32ChipSelect, pui32Data,
                                       ui32NumBytes, ui32Options, pfnCallback);
                break;

            case AM_HAL_IOM_QUEUE_I2C_WRITE:
                ui32Status = am_hal_iom_i2c_write_nb(ui32Module, ui32ChipSelect, pui32Data,
    343c:	e88d 0220 	stmia.w	sp, {r5, r9}
    3440:	4620      	mov	r0, r4
    3442:	f7ff fd2b 	bl	2e9c <am_hal_iom_i2c_write_nb>
    3446:	4607      	mov	r7, r0
    3448:	e7ef      	b.n	342a <am_hal_iom_queue_service+0x27e>
    344a:	bf00      	nop
    344c:	1000119c 	.word	0x1000119c
    3450:	100011a4 	.word	0x100011a4
    3454:	1000160c 	.word	0x1000160c
    3458:	10001594 	.word	0x10001594

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    345c:	f8d8 611c 	ldr.w	r6, [r8, #284]	; 0x11c
                {
                    //
                    // If the fifo contains our entire message, just copy the whole
                    // thing out.
                    //
                    am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data,
    3460:	eb01 0489 	add.w	r4, r1, r9, lsl #2

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    3464:	0732      	lsls	r2, r6, #28
                {
                    //
                    // If the fifo contains our entire message, just copy the whole
                    // thing out.
                    //
                    am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data,
    3466:	6864      	ldr	r4, [r4, #4]

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    3468:	d406      	bmi.n	3478 <am_hal_iom_queue_service+0x2cc>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    346a:	f8d8 7100 	ldr.w	r7, [r8, #256]	; 0x100
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    346e:	fa5f f987 	uxtb.w	r9, r7
    3472:	454d      	cmp	r5, r9
    3474:	f200 8189 	bhi.w	378a <am_hal_iom_queue_service+0x5de>

    //
    // Figure out how many whole words we're reading from the fifo, and how
    // many bytes will be left over when we're done.
    //
    ui32NumWords = ui32NumBytes / 4;
    3478:	08ab      	lsrs	r3, r5, #2
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    347a:	0098      	lsls	r0, r3, #2
    347c:	1a2a      	subs	r2, r5, r0

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    347e:	2b00      	cmp	r3, #0
    3480:	d054      	beq.n	352c <am_hal_iom_queue_service+0x380>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    3482:	4627      	mov	r7, r4
    3484:	f8d8 5000 	ldr.w	r5, [r8]
    3488:	f847 5b04 	str.w	r5, [r7], #4
    348c:	1826      	adds	r6, r4, r0
    348e:	f1a0 0a04 	sub.w	sl, r0, #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    3492:	42b7      	cmp	r7, r6
    3494:	f3ca 0182 	ubfx	r1, sl, #2, #3
    3498:	d048      	beq.n	352c <am_hal_iom_queue_service+0x380>
    349a:	b349      	cbz	r1, 34f0 <am_hal_iom_queue_service+0x344>
    349c:	2901      	cmp	r1, #1
    349e:	d021      	beq.n	34e4 <am_hal_iom_queue_service+0x338>
    34a0:	2902      	cmp	r1, #2
    34a2:	d01b      	beq.n	34dc <am_hal_iom_queue_service+0x330>
    34a4:	2903      	cmp	r1, #3
    34a6:	d015      	beq.n	34d4 <am_hal_iom_queue_service+0x328>
    34a8:	2904      	cmp	r1, #4
    34aa:	d00f      	beq.n	34cc <am_hal_iom_queue_service+0x320>
    34ac:	2905      	cmp	r1, #5
    34ae:	d009      	beq.n	34c4 <am_hal_iom_queue_service+0x318>
    34b0:	2906      	cmp	r1, #6
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    34b2:	bf1c      	itt	ne
    34b4:	f8d8 1000 	ldrne.w	r1, [r8]
    34b8:	f847 1b04 	strne.w	r1, [r7], #4
    34bc:	f8d8 3000 	ldr.w	r3, [r8]
    34c0:	f847 3b04 	str.w	r3, [r7], #4
    34c4:	f8d8 5000 	ldr.w	r5, [r8]
    34c8:	f847 5b04 	str.w	r5, [r7], #4
    34cc:	f8d8 1000 	ldr.w	r1, [r8]
    34d0:	f847 1b04 	str.w	r1, [r7], #4
    34d4:	f8d8 3000 	ldr.w	r3, [r8]
    34d8:	f847 3b04 	str.w	r3, [r7], #4
    34dc:	f8d8 5000 	ldr.w	r5, [r8]
    34e0:	f847 5b04 	str.w	r5, [r7], #4
    34e4:	f8d8 1000 	ldr.w	r1, [r8]
    34e8:	f847 1b04 	str.w	r1, [r7], #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    34ec:	42b7      	cmp	r7, r6
    34ee:	d01d      	beq.n	352c <am_hal_iom_queue_service+0x380>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    34f0:	46bc      	mov	ip, r7
    34f2:	f8d8 3000 	ldr.w	r3, [r8]
    34f6:	f84c 3b04 	str.w	r3, [ip], #4
    34fa:	f8d8 5000 	ldr.w	r5, [r8]
    34fe:	607d      	str	r5, [r7, #4]
    3500:	f8d8 1000 	ldr.w	r1, [r8]
    3504:	f8cc 1004 	str.w	r1, [ip, #4]
    3508:	f8d8 3000 	ldr.w	r3, [r8]
    350c:	60fb      	str	r3, [r7, #12]
    350e:	f8d8 5000 	ldr.w	r5, [r8]
    3512:	613d      	str	r5, [r7, #16]
    3514:	f8d8 1000 	ldr.w	r1, [r8]
    3518:	6179      	str	r1, [r7, #20]
    351a:	f8d8 3000 	ldr.w	r3, [r8]
    351e:	61bb      	str	r3, [r7, #24]
    3520:	f8d8 5000 	ldr.w	r5, [r8]
    3524:	61fd      	str	r5, [r7, #28]
    3526:	3720      	adds	r7, #32
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    3528:	42b7      	cmp	r7, r6
    352a:	d1e1      	bne.n	34f0 <am_hal_iom_queue_service+0x344>
    // definition requests, we wouldn't need to do this. It's possible to call
    // this function with a re-cast or packed pointer instead though. If that
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    352c:	2a00      	cmp	r2, #0
    352e:	f43f aec3 	beq.w	32b8 <am_hal_iom_queue_service+0x10c>
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    3532:	a90c      	add	r1, sp, #48	; 0x30
    3534:	f8d8 7000 	ldr.w	r7, [r8]
    3538:	f841 7d1c 	str.w	r7, [r1, #-28]!
    353c:	4420      	add	r0, r4
    353e:	f001 fe61 	bl	5204 <memcpy>
    3542:	e6b9      	b.n	32b8 <am_hal_iom_queue_service+0x10c>

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    3544:	f8d8 011c 	ldr.w	r0, [r8, #284]	; 0x11c
                    // If the fifo has at least one 32-bit word in it, copy out the
                    // biggest block we can.
                    //
                    ui32NumBytes = (ui32NumBytes & (~0x3));

                    am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data, ui32NumBytes);
    3548:	f8d4 a004 	ldr.w	sl, [r4, #4]
                {
                    //
                    // If the fifo has at least one 32-bit word in it, copy out the
                    // biggest block we can.
                    //
                    ui32NumBytes = (ui32NumBytes & (~0x3));
    354c:	f003 05fc 	and.w	r5, r3, #252	; 0xfc

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    3550:	0703      	lsls	r3, r0, #28
    3552:	d404      	bmi.n	355e <am_hal_iom_queue_service+0x3b2>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    3554:	683b      	ldr	r3, [r7, #0]
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    3556:	b2da      	uxtb	r2, r3
    3558:	4295      	cmp	r5, r2
    355a:	f200 8126 	bhi.w	37aa <am_hal_iom_queue_service+0x5fe>

    //
    // Figure out how many whole words we're reading from the fifo, and how
    // many bytes will be left over when we're done.
    //
    ui32NumWords = ui32NumBytes / 4;
    355e:	08aa      	lsrs	r2, r5, #2
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    3560:	0090      	lsls	r0, r2, #2

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    3562:	2a00      	cmp	r2, #0
    3564:	d057      	beq.n	3616 <am_hal_iom_queue_service+0x46a>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    3566:	4653      	mov	r3, sl
    3568:	f8d8 1000 	ldr.w	r1, [r8]
    356c:	f843 1b04 	str.w	r1, [r3], #4
    3570:	eb0a 0e00 	add.w	lr, sl, r0
    3574:	f1a0 0b04 	sub.w	fp, r0, #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    3578:	459e      	cmp	lr, r3
    357a:	f3cb 0182 	ubfx	r1, fp, #2, #3
    357e:	d04a      	beq.n	3616 <am_hal_iom_queue_service+0x46a>
    3580:	b351      	cbz	r1, 35d8 <am_hal_iom_queue_service+0x42c>
    3582:	2901      	cmp	r1, #1
    3584:	d022      	beq.n	35cc <am_hal_iom_queue_service+0x420>
    3586:	2902      	cmp	r1, #2
    3588:	d01c      	beq.n	35c4 <am_hal_iom_queue_service+0x418>
    358a:	2903      	cmp	r1, #3
    358c:	d016      	beq.n	35bc <am_hal_iom_queue_service+0x410>
    358e:	2904      	cmp	r1, #4
    3590:	d010      	beq.n	35b4 <am_hal_iom_queue_service+0x408>
    3592:	2905      	cmp	r1, #5
    3594:	d00a      	beq.n	35ac <am_hal_iom_queue_service+0x400>
    3596:	2906      	cmp	r1, #6
    3598:	d004      	beq.n	35a4 <am_hal_iom_queue_service+0x3f8>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    359a:	f8d8 1000 	ldr.w	r1, [r8]
    359e:	f8ca 1004 	str.w	r1, [sl, #4]
    35a2:	3304      	adds	r3, #4
    35a4:	f8d8 1000 	ldr.w	r1, [r8]
    35a8:	f843 1b04 	str.w	r1, [r3], #4
    35ac:	f8d8 1000 	ldr.w	r1, [r8]
    35b0:	f843 1b04 	str.w	r1, [r3], #4
    35b4:	f8d8 1000 	ldr.w	r1, [r8]
    35b8:	f843 1b04 	str.w	r1, [r3], #4
    35bc:	f8d8 1000 	ldr.w	r1, [r8]
    35c0:	f843 1b04 	str.w	r1, [r3], #4
    35c4:	f8d8 1000 	ldr.w	r1, [r8]
    35c8:	f843 1b04 	str.w	r1, [r3], #4
    35cc:	f8d8 1000 	ldr.w	r1, [r8]
    35d0:	f843 1b04 	str.w	r1, [r3], #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    35d4:	459e      	cmp	lr, r3
    35d6:	d01e      	beq.n	3616 <am_hal_iom_queue_service+0x46a>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    35d8:	469b      	mov	fp, r3
    35da:	f8d8 c000 	ldr.w	ip, [r8]
    35de:	f84b cb04 	str.w	ip, [fp], #4
    35e2:	f8d8 c000 	ldr.w	ip, [r8]
    35e6:	f8c3 c004 	str.w	ip, [r3, #4]
    35ea:	f8d8 c000 	ldr.w	ip, [r8]
    35ee:	f8cb c004 	str.w	ip, [fp, #4]
    35f2:	f8d8 1000 	ldr.w	r1, [r8]
    35f6:	60d9      	str	r1, [r3, #12]
    35f8:	f8d8 1000 	ldr.w	r1, [r8]
    35fc:	6119      	str	r1, [r3, #16]
    35fe:	f8d8 1000 	ldr.w	r1, [r8]
    3602:	6159      	str	r1, [r3, #20]
    3604:	f8d8 1000 	ldr.w	r1, [r8]
    3608:	6199      	str	r1, [r3, #24]
    360a:	f8d8 1000 	ldr.w	r1, [r8]
    360e:	61d9      	str	r1, [r3, #28]
    3610:	3320      	adds	r3, #32
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    3612:	459e      	cmp	lr, r3
    3614:	d1e0      	bne.n	35d8 <am_hal_iom_queue_service+0x42c>
    // definition requests, we wouldn't need to do this. It's possible to call
    // this function with a re-cast or packed pointer instead though. If that
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    3616:	4285      	cmp	r5, r0
    3618:	d010      	beq.n	363c <am_hal_iom_queue_service+0x490>
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    361a:	f8d8 3000 	ldr.w	r3, [r8]
        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    361e:	f80a 3022 	strb.w	r3, [sl, r2, lsl #2]
    3622:	4482      	add	sl, r0
    3624:	f3c3 2b07 	ubfx	fp, r3, #8, #8
    3628:	f3c3 4207 	ubfx	r2, r3, #16, #8
    362c:	f3c3 6107 	ubfx	r1, r3, #24, #8
    3630:	f88a b001 	strb.w	fp, [sl, #1]
    3634:	f88a 2002 	strb.w	r2, [sl, #2]
    3638:	f88a 1003 	strb.w	r1, [sl, #3]
                    am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data, ui32NumBytes);

                    //
                    // Update the pointer and the byte counter.
                    //
                    psBuffer->ui32BytesLeft -= ui32NumBytes;
    363c:	68a3      	ldr	r3, [r4, #8]
                    psBuffer->pui32Data += (ui32NumBytes / 4);
    363e:	6862      	ldr	r2, [r4, #4]
                    am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data, ui32NumBytes);

                    //
                    // Update the pointer and the byte counter.
                    //
                    psBuffer->ui32BytesLeft -= ui32NumBytes;
    3640:	1b5d      	subs	r5, r3, r5
                    psBuffer->pui32Data += (ui32NumBytes / 4);
    3642:	4402      	add	r2, r0
                    am_hal_iom_fifo_read(ui32Module, psBuffer->pui32Data, ui32NumBytes);

                    //
                    // Update the pointer and the byte counter.
                    //
                    psBuffer->ui32BytesLeft -= ui32NumBytes;
    3644:	60a5      	str	r5, [r4, #8]
                    psBuffer->pui32Data += (ui32NumBytes / 4);
    3646:	6062      	str	r2, [r4, #4]

                    // Clear any spurious THR interrupt that might have got raised
                    // while we were reading the data from FIFO
                    AM_BFWn(IOMSTR, ui32Module, INTCLR, THR, 1);
    3648:	f8d8 0208 	ldr.w	r0, [r8, #520]	; 0x208
    364c:	f040 0102 	orr.w	r1, r0, #2
    3650:	f8c8 1208 	str.w	r1, [r8, #520]	; 0x208
    3654:	e62c      	b.n	32b0 <am_hal_iom_queue_service+0x104>
        // If we received a threshold event in the middle of a command, we need
        // to transfer data.
        //
        if ( psBuffer->ui32State == BUFFER_SENDING )
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFOWTHR);
    3656:	0307      	lsls	r7, r0, #12
    3658:	686e      	ldr	r6, [r5, #4]
    365a:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
    365e:	f507 7a8e 	add.w	sl, r7, #284	; 0x11c
    3662:	f3c2 2b06 	ubfx	fp, r2, #8, #7
    3666:	f507 7880 	add.w	r8, r7, #256	; 0x100
    366a:	f507 7902 	add.w	r9, r7, #520	; 0x208
                ui32SpaceInFifo = am_hal_iom_fifo_empty_slots(ui32Module);

                //
                // Figure out how much data we can send.
                //
                if ( psBuffer->ui32BytesLeft <= ui32SpaceInFifo )
    366e:	462c      	mov	r4, r5
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    3670:	f8da 0000 	ldr.w	r0, [sl]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    3674:	f8d8 5000 	ldr.w	r5, [r8]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    3678:	f8da 3000 	ldr.w	r3, [sl]
                ui32SpaceInFifo = am_hal_iom_fifo_empty_slots(ui32Module);

                //
                // Figure out how much data we can send.
                //
                if ( psBuffer->ui32BytesLeft <= ui32SpaceInFifo )
    367c:	68a2      	ldr	r2, [r4, #8]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    367e:	f8d8 1000 	ldr.w	r1, [r8]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    3682:	f010 0f08 	tst.w	r0, #8
    3686:	bf14      	ite	ne
    3688:	2040      	movne	r0, #64	; 0x40
    368a:	2080      	moveq	r0, #128	; 0x80
        if ( psBuffer->ui32State == BUFFER_SENDING )
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFOWTHR);
            do
            {
                ui32SpaceInFifo = am_hal_iom_fifo_empty_slots(ui32Module);
    368c:	1b40      	subs	r0, r0, r5
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    368e:	f013 0f08 	tst.w	r3, #8
        if ( psBuffer->ui32State == BUFFER_SENDING )
        {
            thresh = AM_BFRn(IOMSTR, ui32Module, FIFOTHR, FIFOWTHR);
            do
            {
                ui32SpaceInFifo = am_hal_iom_fifo_empty_slots(ui32Module);
    3692:	f000 05fc 	and.w	r5, r0, #252	; 0xfc
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    3696:	bf14      	ite	ne
    3698:	2340      	movne	r3, #64	; 0x40
    369a:	2380      	moveq	r3, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    369c:	1a5b      	subs	r3, r3, r1
    369e:	4295      	cmp	r5, r2
    36a0:	bf28      	it	cs
    36a2:	4615      	movcs	r5, r2
    36a4:	f003 01fc 	and.w	r1, r3, #252	; 0xfc
    36a8:	42a9      	cmp	r1, r5
    36aa:	d367      	bcc.n	377c <am_hal_iom_queue_service+0x5d0>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    36ac:	2d00      	cmp	r5, #0
    36ae:	d04d      	beq.n	374c <am_hal_iom_queue_service+0x5a0>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    36b0:	4630      	mov	r0, r6
    36b2:	43f2      	mvns	r2, r6
    36b4:	f850 3b04 	ldr.w	r3, [r0], #4
    36b8:	603b      	str	r3, [r7, #0]
    36ba:	4432      	add	r2, r6

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    36bc:	1b81      	subs	r1, r0, r6
    36be:	442a      	add	r2, r5
    36c0:	42a9      	cmp	r1, r5
    36c2:	f3c2 0282 	ubfx	r2, r2, #2, #3
    36c6:	d241      	bcs.n	374c <am_hal_iom_queue_service+0x5a0>
    36c8:	b31a      	cbz	r2, 3712 <am_hal_iom_queue_service+0x566>
    36ca:	2a01      	cmp	r2, #1
    36cc:	d01b      	beq.n	3706 <am_hal_iom_queue_service+0x55a>
    36ce:	2a02      	cmp	r2, #2
    36d0:	d016      	beq.n	3700 <am_hal_iom_queue_service+0x554>
    36d2:	2a03      	cmp	r2, #3
    36d4:	d011      	beq.n	36fa <am_hal_iom_queue_service+0x54e>
    36d6:	2a04      	cmp	r2, #4
    36d8:	d00c      	beq.n	36f4 <am_hal_iom_queue_service+0x548>
    36da:	2a05      	cmp	r2, #5
    36dc:	d007      	beq.n	36ee <am_hal_iom_queue_service+0x542>
    36de:	2a06      	cmp	r2, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    36e0:	bf1c      	itt	ne
    36e2:	f850 2b04 	ldrne.w	r2, [r0], #4
    36e6:	603a      	strne	r2, [r7, #0]
    36e8:	f850 3b04 	ldr.w	r3, [r0], #4
    36ec:	603b      	str	r3, [r7, #0]
    36ee:	f850 1b04 	ldr.w	r1, [r0], #4
    36f2:	6039      	str	r1, [r7, #0]
    36f4:	f850 2b04 	ldr.w	r2, [r0], #4
    36f8:	603a      	str	r2, [r7, #0]
    36fa:	f850 3b04 	ldr.w	r3, [r0], #4
    36fe:	603b      	str	r3, [r7, #0]
    3700:	f850 1b04 	ldr.w	r1, [r0], #4
    3704:	6039      	str	r1, [r7, #0]
    3706:	f850 2b04 	ldr.w	r2, [r0], #4
    370a:	603a      	str	r2, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    370c:	1b83      	subs	r3, r0, r6
    370e:	42ab      	cmp	r3, r5
    3710:	d21c      	bcs.n	374c <am_hal_iom_queue_service+0x5a0>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    3712:	4684      	mov	ip, r0
    3714:	3020      	adds	r0, #32
    3716:	f85c 1b04 	ldr.w	r1, [ip], #4
    371a:	6039      	str	r1, [r7, #0]
    371c:	f850 2c1c 	ldr.w	r2, [r0, #-28]
    3720:	603a      	str	r2, [r7, #0]
    3722:	f8dc 3004 	ldr.w	r3, [ip, #4]
    3726:	603b      	str	r3, [r7, #0]
    3728:	f850 1c14 	ldr.w	r1, [r0, #-20]
    372c:	6039      	str	r1, [r7, #0]
    372e:	f850 2c10 	ldr.w	r2, [r0, #-16]
    3732:	603a      	str	r2, [r7, #0]
    3734:	f850 3c0c 	ldr.w	r3, [r0, #-12]
    3738:	603b      	str	r3, [r7, #0]
    373a:	f850 1c08 	ldr.w	r1, [r0, #-8]
    373e:	6039      	str	r1, [r7, #0]
    3740:	f850 2c04 	ldr.w	r2, [r0, #-4]
    3744:	603a      	str	r2, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    3746:	1b83      	subs	r3, r0, r6
    3748:	42ab      	cmp	r3, r5
    374a:	d3e2      	bcc.n	3712 <am_hal_iom_queue_service+0x566>
                //
                am_hal_iom_fifo_write(ui32Module, psBuffer->pui32Data, ui32NumBytes);

                // Clear any spurious THR interrupt that might have got raised
                // while we were adding data to FIFO
                AM_BFWn(IOMSTR, ui32Module, INTCLR, THR, 1);
    374c:	f8d9 6000 	ldr.w	r6, [r9]
    3750:	f046 0002 	orr.w	r0, r6, #2
    3754:	f8c9 0000 	str.w	r0, [r9]
                //
                // Update the pointer and the byte counter.
                //
                psBuffer->ui32BytesLeft -= ui32NumBytes;
    3758:	68a1      	ldr	r1, [r4, #8]
                psBuffer->pui32Data += (ui32NumBytes / 4);
    375a:	6862      	ldr	r2, [r4, #4]
    375c:	f025 0603 	bic.w	r6, r5, #3
    3760:	4416      	add	r6, r2
                // while we were adding data to FIFO
                AM_BFWn(IOMSTR, ui32Module, INTCLR, THR, 1);
                //
                // Update the pointer and the byte counter.
                //
                psBuffer->ui32BytesLeft -= ui32NumBytes;
    3762:	1b4d      	subs	r5, r1, r5
    3764:	60a5      	str	r5, [r4, #8]
                psBuffer->pui32Data += (ui32NumBytes / 4);
    3766:	6066      	str	r6, [r4, #4]

                if ( 0 == psBuffer->ui32BytesLeft )
    3768:	2d00      	cmp	r5, #0
    376a:	f43f ada5 	beq.w	32b8 <am_hal_iom_queue_service+0x10c>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    376e:	f8d8 3000 	ldr.w	r3, [r8]
                    //
                    // Done with this transaction
                    //
                    break;
                }
            } while ( am_hal_iom_fifo_full_slots(ui32Module) <= thresh );
    3772:	b2d8      	uxtb	r0, r3
    3774:	4583      	cmp	fp, r0
    3776:	f4bf af7b 	bcs.w	3670 <am_hal_iom_queue_service+0x4c4>
    377a:	e59d      	b.n	32b8 <am_hal_iom_queue_service+0x10c>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    377c:	4a12      	ldr	r2, [pc, #72]	; (37c8 <am_hal_iom_queue_service+0x61c>)
    377e:	4813      	ldr	r0, [pc, #76]	; (37cc <am_hal_iom_queue_service+0x620>)
    3780:	f640 7107 	movw	r1, #3847	; 0xf07
    3784:	f7fd ff42 	bl	160c <am_hal_debug_error>
    3788:	e792      	b.n	36b0 <am_hal_iom_queue_service+0x504>
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    378a:	4a11      	ldr	r2, [pc, #68]	; (37d0 <am_hal_iom_queue_service+0x624>)
    378c:	480f      	ldr	r0, [pc, #60]	; (37cc <am_hal_iom_queue_service+0x620>)
    378e:	f640 7142 	movw	r1, #3906	; 0xf42
    3792:	f7fd ff3b 	bl	160c <am_hal_debug_error>
    3796:	e66f      	b.n	3478 <am_hal_iom_queue_service+0x2cc>
    3798:	4a0d      	ldr	r2, [pc, #52]	; (37d0 <am_hal_iom_queue_service+0x624>)
    379a:	480c      	ldr	r0, [pc, #48]	; (37cc <am_hal_iom_queue_service+0x620>)
    379c:	9303      	str	r3, [sp, #12]
    379e:	f640 7142 	movw	r1, #3906	; 0xf42
    37a2:	f7fd ff33 	bl	160c <am_hal_debug_error>
    37a6:	9b03      	ldr	r3, [sp, #12]
    37a8:	e5a8      	b.n	32fc <am_hal_iom_queue_service+0x150>
    37aa:	4a09      	ldr	r2, [pc, #36]	; (37d0 <am_hal_iom_queue_service+0x624>)
    37ac:	4807      	ldr	r0, [pc, #28]	; (37cc <am_hal_iom_queue_service+0x620>)
    37ae:	f640 7142 	movw	r1, #3906	; 0xf42
    37b2:	f7fd ff2b 	bl	160c <am_hal_debug_error>
    37b6:	e6d2      	b.n	355e <am_hal_iom_queue_service+0x3b2>
    37b8:	e88d 0220 	stmia.w	sp, {r5, r9}
    37bc:	4620      	mov	r0, r4
    37be:	f7fe ffab 	bl	2718 <am_hal_iom_spi_write_nb.part.6>
    37c2:	4607      	mov	r7, r0
    37c4:	e631      	b.n	342a <am_hal_iom_queue_service+0x27e>
    37c6:	bf00      	nop
    37c8:	00005360 	.word	0x00005360
    37cc:	00005394 	.word	0x00005394
    37d0:	0000546c 	.word	0x0000546c

000037d4 <am_hal_iom_int_enable>:
am_hal_iom_int_enable(uint32_t ui32Module, uint32_t ui32Interrupt)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    37d4:	2805      	cmp	r0, #5
    37d6:	d808      	bhi.n	37ea <am_hal_iom_int_enable+0x16>
    {
        return;
    }

    AM_REGn(IOMSTR, ui32Module, INTEN) |= ui32Interrupt;
    37d8:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    37dc:	3004      	adds	r0, #4
    37de:	0302      	lsls	r2, r0, #12
    37e0:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    37e4:	4319      	orrs	r1, r3
    37e6:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    37ea:	4770      	bx	lr

000037ec <am_hal_iom_int_clear>:
am_hal_iom_int_clear(uint32_t ui32Module, uint32_t ui32Interrupt)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    37ec:	2805      	cmp	r0, #5
    37ee:	d805      	bhi.n	37fc <am_hal_iom_int_clear+0x10>
    {
        return;
    }

    AM_REGn(IOMSTR, ui32Module, INTCLR) = ui32Interrupt;
    37f0:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    37f4:	3004      	adds	r0, #4
    37f6:	0302      	lsls	r2, r0, #12
    37f8:	f8c2 1208 	str.w	r1, [r2, #520]	; 0x208
    37fc:	4770      	bx	lr
    37fe:	bf00      	nop

00003800 <am_hal_iom_int_status_get>:
am_hal_iom_int_status_get(uint32_t ui32Module, bool bEnabledOnly)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    3800:	2805      	cmp	r0, #5
    3802:	d80e      	bhi.n	3822 <am_hal_iom_int_status_get+0x22>
        return 0;
    }

    if ( bEnabledOnly )
    {
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
    3804:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    3808:	3004      	adds	r0, #4
    380a:	0303      	lsls	r3, r0, #12
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    if ( bEnabledOnly )
    380c:	b911      	cbnz	r1, 3814 <am_hal_iom_int_status_get+0x14>
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    380e:	f8d3 0204 	ldr.w	r0, [r3, #516]	; 0x204
    3812:	4770      	bx	lr
        return 0;
    }

    if ( bEnabledOnly )
    {
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
    3814:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    3818:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
    381c:	ea02 0001 	and.w	r0, r2, r1
    3820:	4770      	bx	lr
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    3822:	2000      	movs	r0, #0
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    }
}
    3824:	4770      	bx	lr
    3826:	bf00      	nop

00003828 <am_hal_ios_config>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ios_config(am_hal_ios_config_t *psConfig)
{
    3828:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    382a:	4604      	mov	r4, r0
    uint32_t ui32LRAMConfig;

    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOS);
    382c:	2001      	movs	r0, #1
    382e:	f000 f8a3 	bl	3978 <am_hal_pwrctrl_periph_enable>

    //
    // Record the FIFO parameters for later use.
    //
    g_pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    3832:	68a0      	ldr	r0, [r4, #8]
    g_pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    3834:	68e3      	ldr	r3, [r4, #12]
    g_ui32HwFifoSize = g_pui8FIFOEnd - g_pui8FIFOBase;
    g_ui32FifoBaseOffset = psConfig->ui32FIFOBase;
    3836:	4a1c      	ldr	r2, [pc, #112]	; (38a8 <am_hal_ios_config+0x80>)
    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOS);

    //
    // Record the FIFO parameters for later use.
    //
    g_pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    3838:	491c      	ldr	r1, [pc, #112]	; (38ac <am_hal_ios_config+0x84>)
    g_pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    g_ui32HwFifoSize = g_pui8FIFOEnd - g_pui8FIFOBase;
    g_ui32FifoBaseOffset = psConfig->ui32FIFOBase;
    383a:	6010      	str	r0, [r2, #0]

    //
    // Record the FIFO parameters for later use.
    //
    g_pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    g_pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    383c:	f103 45a0 	add.w	r5, r3, #1342177280	; 0x50000000
    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOS);

    //
    // Record the FIFO parameters for later use.
    //
    g_pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    3840:	f100 42a0 	add.w	r2, r0, #1342177280	; 0x50000000
    g_pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    g_ui32HwFifoSize = g_pui8FIFOEnd - g_pui8FIFOBase;
    3844:	4f1a      	ldr	r7, [pc, #104]	; (38b0 <am_hal_ios_config+0x88>)
    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOS);

    //
    // Record the FIFO parameters for later use.
    //
    g_pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    3846:	600a      	str	r2, [r1, #0]
    g_pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    g_ui32HwFifoSize = g_pui8FIFOEnd - g_pui8FIFOBase;
    3848:	1aa9      	subs	r1, r5, r2
    384a:	7039      	strb	r1, [r7, #0]
//
//*****************************************************************************
void
am_hal_ios_disable(uint32_t ui32Module)
{
    AM_REGn(IOSLAVE, ui32Module, CFG) &= ~(AM_REG_IOSLAVE_CFG_IFCEN(1));
    384c:	4919      	ldr	r1, [pc, #100]	; (38b4 <am_hal_ios_config+0x8c>)
    384e:	6862      	ldr	r2, [r4, #4]

    //
    // Record the FIFO parameters for later use.
    //
    g_pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    g_pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    3850:	4e19      	ldr	r6, [pc, #100]	; (38b8 <am_hal_ios_config+0x90>)
//
//*****************************************************************************
void
am_hal_ios_disable(uint32_t ui32Module)
{
    AM_REGn(IOSLAVE, ui32Module, CFG) &= ~(AM_REG_IOSLAVE_CFG_IFCEN(1));
    3852:	680f      	ldr	r7, [r1, #0]

    //
    // Record the FIFO parameters for later use.
    //
    g_pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    g_pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    3854:	6035      	str	r5, [r6, #0]
    3856:	015b      	lsls	r3, r3, #5
    3858:	0555      	lsls	r5, r2, #21
//
//*****************************************************************************
void
am_hal_ios_disable(uint32_t ui32Module)
{
    AM_REGn(IOSLAVE, ui32Module, CFG) &= ~(AM_REG_IOSLAVE_CFG_IFCEN(1));
    385a:	f027 4700 	bic.w	r7, r7, #2147483648	; 0x80000000
    385e:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    3862:	f005 537c 	and.w	r3, r5, #1056964608	; 0x3f000000
    3866:	600f      	str	r7, [r1, #0]
    AM_REG(IOSLAVE, CFG) = psConfig->ui32InterfaceSelect;

    //
    // Write the FIFO configuration register to set the memory map for the LRAM.
    //
    AM_REG(IOSLAVE, FIFOCFG) = ui32LRAMConfig;
    3868:	4e14      	ldr	r6, [pc, #80]	; (38bc <am_hal_ios_config+0x94>)

    //
    // Write the configuration register with the user's selected interface
    // characteristics.
    //
    AM_REG(IOSLAVE, CFG) = psConfig->ui32InterfaceSelect;
    386a:	6825      	ldr	r5, [r4, #0]
    386c:	600d      	str	r5, [r1, #0]
    //
    // Caluclate the value for the IO Slave FIFO configuration register.
    //
    ui32LRAMConfig = AM_REG_IOSLAVE_FIFOCFG_ROBASE(psConfig->ui32ROBase >> 3);
    ui32LRAMConfig |= AM_REG_IOSLAVE_FIFOCFG_FIFOBASE(psConfig->ui32FIFOBase >> 3);
    ui32LRAMConfig |= AM_REG_IOSLAVE_FIFOCFG_FIFOMAX(psConfig->ui32RAMBase >> 3);
    386e:	f3c0 00c4 	ubfx	r0, r0, #3, #5
    3872:	4313      	orrs	r3, r2
    3874:	4303      	orrs	r3, r0
    AM_REG(IOSLAVE, CFG) = psConfig->ui32InterfaceSelect;

    //
    // Write the FIFO configuration register to set the memory map for the LRAM.
    //
    AM_REG(IOSLAVE, FIFOCFG) = ui32LRAMConfig;
    3876:	6033      	str	r3, [r6, #0]
//
//*****************************************************************************
void
am_hal_ios_enable(uint32_t ui32Module)
{
    AM_REGn(IOSLAVE, ui32Module, CFG) |= AM_REG_IOSLAVE_CFG_IFCEN(1);
    3878:	680a      	ldr	r2, [r1, #0]
    387a:	f042 4300 	orr.w	r3, r2, #2147483648	; 0x80000000
    387e:	600b      	str	r3, [r1, #0]
    am_hal_ios_enable(0);

    //
    // Initialize the FIFO pointer to the beginning of the FIFO section.
    //
    am_hal_ios_fifo_ptr_set(psConfig->ui32FIFOBase);
    3880:	68a5      	ldr	r5, [r4, #8]
    uint32_t ui32Primask;

    //
    // Start a critical section for thread safety.
    //
    ui32Primask = am_hal_interrupt_master_disable();
    3882:	f7fd ffb9 	bl	17f8 <am_hal_interrupt_master_disable>

    //
    // Set the FIFO Update bit.
    //
    AM_REG(IOSLAVE, FUPD) = 0x1;
    3886:	4b0e      	ldr	r3, [pc, #56]	; (38c0 <am_hal_ios_config+0x98>)
    AM_REG(IOSLAVE, FUPD) = 0x0;

    //
    // Set the global FIFO-pointer tracking variable.
    //
    g_pui8FIFOPtr = (uint8_t *) (REG_IOSLAVE_BASEADDR + ui32Offset);
    3888:	4a0e      	ldr	r2, [pc, #56]	; (38c4 <am_hal_ios_config+0x9c>)
    AM_REG(IOSLAVE, FIFOPTR) = ui32Offset;

    //
    // Clear the FIFO update bit.
    //
    AM_REG(IOSLAVE, FUPD) = 0x0;
    388a:	2100      	movs	r1, #0
    ui32Primask = am_hal_interrupt_master_disable();

    //
    // Set the FIFO Update bit.
    //
    AM_REG(IOSLAVE, FUPD) = 0x1;
    388c:	2701      	movs	r7, #1
    388e:	601f      	str	r7, [r3, #0]

    //
    // Change the FIFO offset.
    //
    AM_REG(IOSLAVE, FIFOPTR) = ui32Offset;
    3890:	f846 5c04 	str.w	r5, [r6, #-4]

    //
    // Clear the FIFO update bit.
    //
    AM_REG(IOSLAVE, FUPD) = 0x0;
    3894:	6019      	str	r1, [r3, #0]

    //
    // Set the global FIFO-pointer tracking variable.
    //
    g_pui8FIFOPtr = (uint8_t *) (REG_IOSLAVE_BASEADDR + ui32Offset);
    3896:	f105 46a0 	add.w	r6, r5, #1342177280	; 0x50000000
    389a:	6016      	str	r6, [r2, #0]

    //
    // End the critical section.
    //
    am_hal_interrupt_master_set(ui32Primask);
    389c:	f7fd ffb0 	bl	1800 <am_hal_interrupt_master_set>
    am_hal_ios_fifo_ptr_set(psConfig->ui32FIFOBase);

    //
    // Write the FIFO threshold register.
    //
    AM_REG(IOSLAVE, FIFOTHR) = psConfig->ui32FIFOThreshold;
    38a0:	4809      	ldr	r0, [pc, #36]	; (38c8 <am_hal_ios_config+0xa0>)
    38a2:	6924      	ldr	r4, [r4, #16]
    38a4:	6004      	str	r4, [r0, #0]
    38a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    38a8:	100011ac 	.word	0x100011ac
    38ac:	10001090 	.word	0x10001090
    38b0:	100011ab 	.word	0x100011ab
    38b4:	50000118 	.word	0x50000118
    38b8:	10001088 	.word	0x10001088
    38bc:	50000104 	.word	0x50000104
    38c0:	5000010c 	.word	0x5000010c
    38c4:	1000108c 	.word	0x1000108c
    38c8:	50000108 	.word	0x50000108

000038cc <am_hal_ios_access_int_clear>:
am_hal_ios_access_int_clear(uint32_t ui32Interrupt)
{
    //
    // Use the interrupt clear register to deactivate the chosen interrupt.
    //
    AM_REG(IOSLAVE, REGACCINTCLR) = ui32Interrupt;
    38cc:	4b01      	ldr	r3, [pc, #4]	; (38d4 <am_hal_ios_access_int_clear+0x8>)
    38ce:	6018      	str	r0, [r3, #0]
    38d0:	4770      	bx	lr
    38d2:	bf00      	nop
    38d4:	50000218 	.word	0x50000218

000038d8 <am_hal_ios_int_clear>:
am_hal_ios_int_clear(uint32_t ui32Interrupt)
{
    //
    // Use the interrupt clear register to deactivate the chosen interrupt.
    //
    AM_REG(IOSLAVE, INTCLR) = ui32Interrupt;
    38d8:	4b01      	ldr	r3, [pc, #4]	; (38e0 <am_hal_ios_int_clear+0x8>)
    38da:	6018      	str	r0, [r3, #0]
    38dc:	4770      	bx	lr
    38de:	bf00      	nop
    38e0:	50000208 	.word	0x50000208

000038e4 <am_hal_ios_lram_read>:
am_hal_ios_lram_read(uint32_t ui32Offset)
{
    //
    // Read the LRAM.
    //
    return am_hal_ios_pui8LRAM[ui32Offset];
    38e4:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
    38e8:	7800      	ldrb	r0, [r0, #0]
}
    38ea:	4770      	bx	lr

000038ec <am_hal_itm_enable>:
//
//*****************************************************************************
void
am_hal_itm_enable(void)
{
    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    38ec:	4b0d      	ldr	r3, [pc, #52]	; (3924 <am_hal_itm_enable+0x38>)
    38ee:	6818      	ldr	r0, [r3, #0]
    38f0:	07c2      	lsls	r2, r0, #31
    38f2:	d416      	bmi.n	3922 <am_hal_itm_enable+0x36>

    //
    // To be able to access ITM registers, set the Trace Enable bit
    // in the Debug Exception and Monitor Control Register (DEMCR).
    //
    AM_REG(SYSCTRL, DEMCR) |= AM_REG_SYSCTRL_DEMCR_TRCENA(1);
    38f4:	4a0c      	ldr	r2, [pc, #48]	; (3928 <am_hal_itm_enable+0x3c>)
    38f6:	6811      	ldr	r1, [r2, #0]
    38f8:	f041 7380 	orr.w	r3, r1, #16777216	; 0x1000000
    38fc:	6013      	str	r3, [r2, #0]
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );
    38fe:	6810      	ldr	r0, [r2, #0]
    3900:	01c3      	lsls	r3, r0, #7
    3902:	d5fc      	bpl.n	38fe <am_hal_itm_enable+0x12>
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_enable(void)
{
    3904:	b430      	push	{r4, r5}
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );

    //
    // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
    //
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    3906:	4809      	ldr	r0, [pc, #36]	; (392c <am_hal_itm_enable+0x40>)

    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    3908:	4c09      	ldr	r4, [pc, #36]	; (3930 <am_hal_itm_enable+0x44>)
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );

    //
    // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
    //
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    390a:	4d0a      	ldr	r5, [pc, #40]	; (3934 <am_hal_itm_enable+0x48>)
    390c:	6005      	str	r5, [r0, #0]

    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    390e:	250f      	movs	r5, #15
    3910:	6025      	str	r5, [r4, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_DWT_ENABLE, 0)     |
        AM_WRITE_SM(AM_REG_ITM_TCR_SYNC_ENABLE, 0)    |
        AM_WRITE_SM(AM_REG_ITM_TCR_TS_ENABLE, 0)      |
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

}
    3912:	bc30      	pop	{r4, r5}
    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    3914:	4908      	ldr	r1, [pc, #32]	; (3938 <am_hal_itm_enable+0x4c>)

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    3916:	4b09      	ldr	r3, [pc, #36]	; (393c <am_hal_itm_enable+0x50>)
    3918:	4a09      	ldr	r2, [pc, #36]	; (3940 <am_hal_itm_enable+0x54>)
    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    391a:	f04f 30ff 	mov.w	r0, #4294967295
    391e:	6008      	str	r0, [r1, #0]

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    3920:	601a      	str	r2, [r3, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_DWT_ENABLE, 0)     |
        AM_WRITE_SM(AM_REG_ITM_TCR_SYNC_ENABLE, 0)    |
        AM_WRITE_SM(AM_REG_ITM_TCR_TS_ENABLE, 0)      |
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

}
    3922:	4770      	bx	lr
    3924:	10001198 	.word	0x10001198
    3928:	e000edfc 	.word	0xe000edfc
    392c:	e0000fb0 	.word	0xe0000fb0
    3930:	e0000e40 	.word	0xe0000e40
    3934:	c5acce55 	.word	0xc5acce55
    3938:	e0000e00 	.word	0xe0000e00
    393c:	e0000e80 	.word	0xe0000e80
    3940:	00150511 	.word	0x00150511

00003944 <am_hal_itm_print>:
    uint32_t ui32Length = 0;

    //
    // Determine the length of the string.
    //
    while (*(pcString + ui32Length))
    3944:	7803      	ldrb	r3, [r0, #0]
    3946:	b1ab      	cbz	r3, 3974 <am_hal_itm_print+0x30>
    3948:	4602      	mov	r2, r0
    394a:	2300      	movs	r3, #0
    394c:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    {
        ui32Length++;
    3950:	3301      	adds	r3, #1
    uint32_t ui32Length = 0;

    //
    // Determine the length of the string.
    //
    while (*(pcString + ui32Length))
    3952:	2900      	cmp	r1, #0
    3954:	d1fa      	bne.n	394c <am_hal_itm_print+0x8>
    ui32StimAddr = (AM_REG_ITM_STIM0_O + (4 * ui32StimReg));

    //
    // Busy waiting until it is available (non-zero means ready)
    //
    while (!AM_REGVAL(ui32StimAddr));
    3956:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_print(char *pcString)
{
    395a:	b430      	push	{r4, r5}
    395c:	18c2      	adds	r2, r0, r3
    ui32StimAddr = (AM_REG_ITM_STIM0_O + (4 * ui32StimReg));

    //
    // Busy waiting until it is available (non-zero means ready)
    //
    while (!AM_REGVAL(ui32StimAddr));
    395e:	4665      	mov	r5, ip
    while (ui32Length)
    {
            //
            // Print string out the ITM.
            //
            am_hal_itm_stimulus_reg_byte_write(0, (uint8_t)*pcString++);
    3960:	f810 4b01 	ldrb.w	r4, [r0], #1
    ui32StimAddr = (AM_REG_ITM_STIM0_O + (4 * ui32StimReg));

    //
    // Busy waiting until it is available (non-zero means ready)
    //
    while (!AM_REGVAL(ui32StimAddr));
    3964:	f8dc 3000 	ldr.w	r3, [ip]
    3968:	2b00      	cmp	r3, #0
    396a:	d0fb      	beq.n	3964 <am_hal_itm_print+0x20>
    }

    //
    // If there is no longer a word left, empty out the remaining characters.
    //
    while (ui32Length)
    396c:	4290      	cmp	r0, r2
    while (!AM_REGVAL(ui32StimAddr));

    //
    // Write the register.
    //
    *((volatile uint8_t *) ui32StimAddr) = ui8Value;
    396e:	702c      	strb	r4, [r5, #0]
    }

    //
    // If there is no longer a word left, empty out the remaining characters.
    //
    while (ui32Length)
    3970:	d1f6      	bne.n	3960 <am_hal_itm_print+0x1c>
            //
            // Subtract from length.
            //
            ui32Length--;
    }
}
    3972:	bc30      	pop	{r4, r5}
    3974:	4770      	bx	lr
    3976:	bf00      	nop

00003978 <am_hal_pwrctrl_periph_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{
    3978:	b510      	push	{r4, lr}

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    397a:	4604      	mov	r4, r0
//! @return None.
//
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{
    397c:	b082      	sub	sp, #8

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    397e:	b1c0      	cbz	r0, 39b2 <am_hal_pwrctrl_periph_enable+0x3a>
    3980:	1e43      	subs	r3, r0, #1
    3982:	4203      	tst	r3, r0
    3984:	d115      	bne.n	39b2 <am_hal_pwrctrl_periph_enable+0x3a>
                        "Cannot enable more than one peripheral at a time.");

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    3986:	f3ef 8010 	mrs	r0, PRIMASK
    398a:	9001      	str	r0, [sp, #4]
    398c:	b672      	cpsid	i

    //
    // Enable power control for the given device.
    //
    AM_REG(PWRCTRL, DEVICEEN) |= ui32Peripheral;
    398e:	4a18      	ldr	r2, [pc, #96]	; (39f0 <am_hal_pwrctrl_periph_enable+0x78>)
    3990:	6811      	ldr	r1, [r2, #0]
    3992:	4321      	orrs	r1, r4
    3994:	6011      	str	r1, [r2, #0]

    //
    // End Critical Section.
    //
    AM_CRITICAL_END_ASM
    3996:	9b01      	ldr	r3, [sp, #4]
    3998:	f383 8810 	msr	PRIMASK, r3

    //
    // Wait for the power to stablize.  Using a simple delay loop is more
    // power efficient than a polling loop.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);
    399c:	200e      	movs	r0, #14
    399e:	f7fd fe37 	bl	1610 <am_hal_flash_delay>

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    39a2:	f014 0f0e 	tst.w	r4, #14
    39a6:	d10a      	bne.n	39be <am_hal_pwrctrl_periph_enable+0x46>
    39a8:	f014 0f70 	tst.w	r4, #112	; 0x70
    39ac:	d00e      	beq.n	39cc <am_hal_pwrctrl_periph_enable+0x54>
    39ae:	2408      	movs	r4, #8
    39b0:	e006      	b.n	39c0 <am_hal_pwrctrl_periph_enable+0x48>
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    39b2:	4a10      	ldr	r2, [pc, #64]	; (39f4 <am_hal_pwrctrl_periph_enable+0x7c>)
    39b4:	4810      	ldr	r0, [pc, #64]	; (39f8 <am_hal_pwrctrl_periph_enable+0x80>)
    39b6:	215d      	movs	r1, #93	; 0x5d
    39b8:	f7fd fe28 	bl	160c <am_hal_debug_error>
    39bc:	e7e3      	b.n	3986 <am_hal_pwrctrl_periph_enable+0xe>
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    39be:	2404      	movs	r4, #4
    39c0:	4a0e      	ldr	r2, [pc, #56]	; (39fc <am_hal_pwrctrl_periph_enable+0x84>)
    39c2:	6811      	ldr	r1, [r2, #0]
    39c4:	420c      	tst	r4, r1
    39c6:	d0fc      	beq.n	39c2 <am_hal_pwrctrl_periph_enable+0x4a>
}
    39c8:	b002      	add	sp, #8
    39ca:	bd10      	pop	{r4, pc}
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    39cc:	f240 1081 	movw	r0, #385	; 0x181
    39d0:	4020      	ands	r0, r4
    39d2:	b940      	cbnz	r0, 39e6 <am_hal_pwrctrl_periph_enable+0x6e>
    39d4:	05a3      	lsls	r3, r4, #22
    39d6:	d408      	bmi.n	39ea <am_hal_pwrctrl_periph_enable+0x72>
    39d8:	f414 6f80 	tst.w	r4, #1024	; 0x400
    39dc:	bf14      	ite	ne
    39de:	2410      	movne	r4, #16
    39e0:	f04f 34ff 	moveq.w	r4, #4294967295
    39e4:	e7ec      	b.n	39c0 <am_hal_pwrctrl_periph_enable+0x48>
    39e6:	2402      	movs	r4, #2
    39e8:	e7ea      	b.n	39c0 <am_hal_pwrctrl_periph_enable+0x48>
    39ea:	2480      	movs	r4, #128	; 0x80
    39ec:	e7e8      	b.n	39c0 <am_hal_pwrctrl_periph_enable+0x48>
    39ee:	bf00      	nop
    39f0:	40021008 	.word	0x40021008
    39f4:	000054ac 	.word	0x000054ac
    39f8:	000054e0 	.word	0x000054e0
    39fc:	40021014 	.word	0x40021014

00003a00 <am_hal_pwrctrl_memory_enable>:
{
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    3a00:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    3a04:	b430      	push	{r4, r5}
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    3a06:	d03a      	beq.n	3a7e <am_hal_pwrctrl_memory_enable+0x7e>
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    3a08:	f5b0 5fc0 	cmp.w	r0, #6144	; 0x1800
    3a0c:	f000 809d 	beq.w	3b4a <am_hal_pwrctrl_memory_enable+0x14a>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    3a10:	2801      	cmp	r0, #1
    3a12:	f000 809d 	beq.w	3b50 <am_hal_pwrctrl_memory_enable+0x150>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    3a16:	2803      	cmp	r0, #3
    3a18:	f000 80a6 	beq.w	3b68 <am_hal_pwrctrl_memory_enable+0x168>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM24K )
    3a1c:	2807      	cmp	r0, #7
    3a1e:	f000 809c 	beq.w	3b5a <am_hal_pwrctrl_memory_enable+0x15a>
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    3a22:	280f      	cmp	r0, #15
    3a24:	f000 80a5 	beq.w	3b72 <am_hal_pwrctrl_memory_enable+0x172>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    3a28:	281f      	cmp	r0, #31
    3a2a:	f000 80b1 	beq.w	3b90 <am_hal_pwrctrl_memory_enable+0x190>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    3a2e:	283f      	cmp	r0, #63	; 0x3f
    3a30:	f000 80b5 	beq.w	3b9e <am_hal_pwrctrl_memory_enable+0x19e>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    3a34:	287f      	cmp	r0, #127	; 0x7f
    3a36:	f000 80b9 	beq.w	3bac <am_hal_pwrctrl_memory_enable+0x1ac>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    3a3a:	28ff      	cmp	r0, #255	; 0xff
    3a3c:	f000 80a0 	beq.w	3b80 <am_hal_pwrctrl_memory_enable+0x180>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    3a40:	f240 13ff 	movw	r3, #511	; 0x1ff
    3a44:	4298      	cmp	r0, r3
    3a46:	f000 80b8 	beq.w	3bba <am_hal_pwrctrl_memory_enable+0x1ba>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    3a4a:	f240 31ff 	movw	r1, #1023	; 0x3ff
    3a4e:	4288      	cmp	r0, r1
    3a50:	f000 80b9 	beq.w	3bc6 <am_hal_pwrctrl_memory_enable+0x1c6>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM256K )
    3a54:	f240 72ff 	movw	r2, #2047	; 0x7ff
    3a58:	4290      	cmp	r0, r2
    3a5a:	d00e      	beq.n	3a7a <am_hal_pwrctrl_memory_enable+0x7a>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM256K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    3a5c:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
    3a60:	f000 80b7 	beq.w	3bd2 <am_hal_pwrctrl_memory_enable+0x1d2>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    3a64:	f06f 4420 	mvn.w	r4, #2684354560	; 0xa0000000
    3a68:	42a0      	cmp	r0, r4
    3a6a:	f000 80b5 	beq.w	3bd8 <am_hal_pwrctrl_memory_enable+0x1d8>
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_ALL )
    3a6e:	f104 4580 	add.w	r5, r4, #1073741824	; 0x40000000
    3a72:	f505 5c00 	add.w	ip, r5, #8192	; 0x2000
    3a76:	4560      	cmp	r0, ip
    3a78:	d132      	bne.n	3ae0 <am_hal_pwrctrl_memory_enable+0xe0>
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_ALL;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
    3a7a:	495c      	ldr	r1, [pc, #368]	; (3bec <am_hal_pwrctrl_memory_enable+0x1ec>)
    3a7c:	e066      	b.n	3b4c <am_hal_pwrctrl_memory_enable+0x14c>
    3a7e:	f46f 5580 	mvn.w	r5, #4096	; 0x1000
    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    3a82:	2340      	movs	r3, #64	; 0x40

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
    3a84:	2120      	movs	r1, #32
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    3a86:	4c5a      	ldr	r4, [pc, #360]	; (3bf0 <am_hal_pwrctrl_memory_enable+0x1f0>)
    3a88:	6822      	ldr	r2, [r4, #0]
    3a8a:	402a      	ands	r2, r5
    3a8c:	6022      	str	r2, [r4, #0]
    //
    // Enable the required memory.
    //
    if ( ui32MemEnMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) |= ui32MemEnMask;
    3a8e:	4d58      	ldr	r5, [pc, #352]	; (3bf0 <am_hal_pwrctrl_memory_enable+0x1f0>)
    3a90:	682c      	ldr	r4, [r5, #0]
    3a92:	4320      	orrs	r0, r4
    3a94:	6028      	str	r0, [r5, #0]
    //
    // Wait for the power to be turned on.
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    3a96:	2b00      	cmp	r3, #0
    3a98:	d029      	beq.n	3aee <am_hal_pwrctrl_memory_enable+0xee>
    {
        while ( --i32TOcnt              &&
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3a9a:	4a56      	ldr	r2, [pc, #344]	; (3bf4 <am_hal_pwrctrl_memory_enable+0x1f4>)
    3a9c:	6810      	ldr	r0, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3a9e:	4203      	tst	r3, r0
    3aa0:	bf18      	it	ne
    3aa2:	20c6      	movne	r0, #198	; 0xc6
    3aa4:	d01f      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3aa6:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3aa8:	422b      	tst	r3, r5
    3aaa:	d01c      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3aac:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3aae:	4223      	tst	r3, r4
    3ab0:	d019      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3ab2:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3ab4:	422b      	tst	r3, r5
    3ab6:	d016      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3ab8:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3aba:	4223      	tst	r3, r4
    3abc:	d013      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3abe:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3ac0:	422b      	tst	r3, r5
    3ac2:	d010      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3ac4:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3ac6:	4223      	tst	r3, r4
    3ac8:	d00d      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3aca:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3acc:	422b      	tst	r3, r5
    3ace:	d00a      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3ad0:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3ad2:	4223      	tst	r3, r4
    3ad4:	d007      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    3ad6:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    3ad8:	422b      	tst	r3, r5
    3ada:	d004      	beq.n	3ae6 <am_hal_pwrctrl_memory_enable+0xe6>
    3adc:	3809      	subs	r0, #9
    3ade:	d1e2      	bne.n	3aa6 <am_hal_pwrctrl_memory_enable+0xa6>
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
        ui32PwrStatDisMask = 0;
    }
    else
    {
        return false;
    3ae0:	2000      	movs	r0, #0
    {
        return false;
    }

    return true;
}
    3ae2:	bc30      	pop	{r4, r5}
    3ae4:	4770      	bx	lr
    {
        return false;
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    3ae6:	b911      	cbnz	r1, 3aee <am_hal_pwrctrl_memory_enable+0xee>
    if ( i32TOcnt <= 0 )
    {
        return false;
    }

    return true;
    3ae8:	2001      	movs	r0, #1
}
    3aea:	bc30      	pop	{r4, r5}
    3aec:	4770      	bx	lr

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3aee:	4b41      	ldr	r3, [pc, #260]	; (3bf4 <am_hal_pwrctrl_memory_enable+0x1f4>)
    3af0:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3af2:	ea31 0402 	bics.w	r4, r1, r2
    3af6:	bf18      	it	ne
    3af8:	24c6      	movne	r4, #198	; 0xc6
    3afa:	d0f5      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3afc:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3afe:	ea31 0000 	bics.w	r0, r1, r0
    3b02:	d0f1      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b04:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b06:	ea31 0005 	bics.w	r0, r1, r5
    3b0a:	d0ed      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b0c:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b0e:	ea31 0002 	bics.w	r0, r1, r2
    3b12:	d0e9      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b14:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b16:	ea31 0000 	bics.w	r0, r1, r0
    3b1a:	d0e5      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b1c:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b1e:	ea31 0005 	bics.w	r0, r1, r5
    3b22:	d0e1      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b24:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b26:	ea31 0002 	bics.w	r0, r1, r2
    3b2a:	d0dd      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b2c:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b2e:	ea31 0000 	bics.w	r0, r1, r0
    3b32:	d0d9      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b34:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b36:	ea31 0005 	bics.w	r0, r1, r5
    3b3a:	d0d5      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    3b3c:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    3b3e:	ea31 0002 	bics.w	r0, r1, r2
    3b42:	d0d1      	beq.n	3ae8 <am_hal_pwrctrl_memory_enable+0xe8>
    3b44:	3c09      	subs	r4, #9
    3b46:	d1d9      	bne.n	3afc <am_hal_pwrctrl_memory_enable+0xfc>
    3b48:	e7ca      	b.n	3ae0 <am_hal_pwrctrl_memory_enable+0xe0>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN |
                         AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
    3b4a:	2160      	movs	r1, #96	; 0x60
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    3b4c:	2300      	movs	r3, #0
    3b4e:	e79e      	b.n	3a8e <am_hal_pwrctrl_memory_enable+0x8e>
    3b50:	4d29      	ldr	r5, [pc, #164]	; (3bf8 <am_hal_pwrctrl_memory_enable+0x1f8>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3b52:	4b2a      	ldr	r3, [pc, #168]	; (3bfc <am_hal_pwrctrl_memory_enable+0x1fc>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    3b54:	f44f 7180 	mov.w	r1, #256	; 0x100
    3b58:	e795      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3b5a:	f46f 65ff 	mvn.w	r5, #2040	; 0x7f8
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3b5e:	f44f 23ff 	mov.w	r3, #522240	; 0x7f800
                         AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    3b62:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    3b66:	e78e      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3b68:	4d25      	ldr	r5, [pc, #148]	; (3c00 <am_hal_pwrctrl_memory_enable+0x200>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3b6a:	4b26      	ldr	r3, [pc, #152]	; (3c04 <am_hal_pwrctrl_memory_enable+0x204>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    3b6c:	f44f 7140 	mov.w	r1, #768	; 0x300
    3b70:	e789      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3b72:	f46f 65fe 	mvn.w	r5, #2032	; 0x7f0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3b76:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    3b7a:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    3b7e:	e782      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3b80:	f46f 65e0 	mvn.w	r5, #1792	; 0x700
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3b84:	f44f 23e0 	mov.w	r3, #458752	; 0x70000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    3b88:	f44f 417f 	mov.w	r1, #65280	; 0xff00
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
    3b8c:	20ff      	movs	r0, #255	; 0xff
    3b8e:	e77a      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3b90:	f46f 65fc 	mvn.w	r5, #2016	; 0x7e0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3b94:	f44f 23fc 	mov.w	r3, #516096	; 0x7e000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    3b98:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
    3b9c:	e773      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3b9e:	f46f 65f8 	mvn.w	r5, #1984	; 0x7c0
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3ba2:	f44f 23f8 	mov.w	r3, #507904	; 0x7c000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    3ba6:	f44f 517c 	mov.w	r1, #16128	; 0x3f00
    3baa:	e76c      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3bac:	f46f 65f0 	mvn.w	r5, #1920	; 0x780
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3bb0:	f44f 23f0 	mov.w	r3, #491520	; 0x78000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    3bb4:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
    3bb8:	e765      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    3bba:	f46f 65c0 	mvn.w	r5, #1536	; 0x600
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3bbe:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    3bc2:	4911      	ldr	r1, [pc, #68]	; (3c08 <am_hal_pwrctrl_memory_enable+0x208>)
    3bc4:	e75f      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    3bc6:	4911      	ldr	r1, [pc, #68]	; (3c0c <am_hal_pwrctrl_memory_enable+0x20c>)
    3bc8:	f46f 6580 	mvn.w	r5, #1024	; 0x400
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    3bcc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    3bd0:	e759      	b.n	3a86 <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN    |
                         AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    3bd2:	f44f 1120 	mov.w	r1, #2621440	; 0x280000
    3bd6:	e7b9      	b.n	3b4c <am_hal_pwrctrl_memory_enable+0x14c>
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    3bd8:	4805      	ldr	r0, [pc, #20]	; (3bf0 <am_hal_pwrctrl_memory_enable+0x1f0>)
    3bda:	6803      	ldr	r3, [r0, #0]
    3bdc:	f023 4120 	bic.w	r1, r3, #2684354560	; 0xa0000000
    3be0:	6001      	str	r1, [r0, #0]
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    3be2:	f44f 1320 	mov.w	r3, #2621440	; 0x280000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
    3be6:	2100      	movs	r1, #0
    3be8:	e757      	b.n	3a9a <am_hal_pwrctrl_memory_enable+0x9a>
    3bea:	bf00      	nop
    3bec:	0007ff00 	.word	0x0007ff00
    3bf0:	40021010 	.word	0x40021010
    3bf4:	40021014 	.word	0x40021014
    3bf8:	fffff801 	.word	0xfffff801
    3bfc:	0007fe00 	.word	0x0007fe00
    3c00:	fffff803 	.word	0xfffff803
    3c04:	0007fc00 	.word	0x0007fc00
    3c08:	0001ff00 	.word	0x0001ff00
    3c0c:	0003ff00 	.word	0x0003ff00

00003c10 <am_hal_pwrctrl_bucks_init>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    3c10:	4b0f      	ldr	r3, [pc, #60]	; (3c50 <am_hal_pwrctrl_bucks_init+0x40>)
    3c12:	681a      	ldr	r2, [r3, #0]
    3c14:	0792      	lsls	r2, r2, #30
    3c16:	d502      	bpl.n	3c1e <am_hal_pwrctrl_bucks_init+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    3c18:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    3c1a:	07c3      	lsls	r3, r0, #31
    3c1c:	d40e      	bmi.n	3c3c <am_hal_pwrctrl_bucks_init+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    3c1e:	4b0d      	ldr	r3, [pc, #52]	; (3c54 <am_hal_pwrctrl_bucks_init+0x44>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    3c20:	4a0b      	ldr	r2, [pc, #44]	; (3c50 <am_hal_pwrctrl_bucks_init+0x40>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    3c22:	6819      	ldr	r1, [r3, #0]
    3c24:	f041 0002 	orr.w	r0, r1, #2
    3c28:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    3c2a:	6819      	ldr	r1, [r3, #0]
    3c2c:	f041 0001 	orr.w	r0, r1, #1
    3c30:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    3c32:	6813      	ldr	r3, [r2, #0]
    3c34:	f003 0103 	and.w	r1, r3, #3
    3c38:	2903      	cmp	r1, #3
    3c3a:	d1fa      	bne.n	3c32 <am_hal_pwrctrl_bucks_init+0x22>
void
am_hal_pwrctrl_bucks_init(void)
{
    am_hal_pwrctrl_bucks_enable();

    while ( ( AM_REG(PWRCTRL, POWERSTATUS) &
    3c3c:	4a04      	ldr	r2, [pc, #16]	; (3c50 <am_hal_pwrctrl_bucks_init+0x40>)
    3c3e:	6810      	ldr	r0, [r2, #0]
    3c40:	f000 0303 	and.w	r3, r0, #3
    3c44:	2b03      	cmp	r3, #3
    3c46:	d1fa      	bne.n	3c3e <am_hal_pwrctrl_bucks_init+0x2e>
                AM_REG_PWRCTRL_POWERSTATUS_MEMBUCKON_M ) );

    //
    // Additional delay to make sure BUCKs are initialized.
    //
    am_hal_flash_delay(200 / 3);
    3c48:	2042      	movs	r0, #66	; 0x42
    3c4a:	f7fd bce1 	b.w	1610 <am_hal_flash_delay>
    3c4e:	bf00      	nop
    3c50:	40021004 	.word	0x40021004
    3c54:	40021000 	.word	0x40021000

00003c58 <am_hal_pwrctrl_bucks_enable>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    3c58:	4b0b      	ldr	r3, [pc, #44]	; (3c88 <am_hal_pwrctrl_bucks_enable+0x30>)
    3c5a:	681a      	ldr	r2, [r3, #0]
    3c5c:	0792      	lsls	r2, r2, #30
    3c5e:	d502      	bpl.n	3c66 <am_hal_pwrctrl_bucks_enable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    3c60:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    3c62:	07c3      	lsls	r3, r0, #31
    3c64:	d40e      	bmi.n	3c84 <am_hal_pwrctrl_bucks_enable+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    3c66:	4b09      	ldr	r3, [pc, #36]	; (3c8c <am_hal_pwrctrl_bucks_enable+0x34>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    3c68:	4a07      	ldr	r2, [pc, #28]	; (3c88 <am_hal_pwrctrl_bucks_enable+0x30>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    3c6a:	6819      	ldr	r1, [r3, #0]
    3c6c:	f041 0002 	orr.w	r0, r1, #2
    3c70:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    3c72:	6819      	ldr	r1, [r3, #0]
    3c74:	f041 0001 	orr.w	r0, r1, #1
    3c78:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    3c7a:	6813      	ldr	r3, [r2, #0]
    3c7c:	f003 0103 	and.w	r1, r3, #3
    3c80:	2903      	cmp	r1, #3
    3c82:	d1fa      	bne.n	3c7a <am_hal_pwrctrl_bucks_enable+0x22>
    3c84:	4770      	bx	lr
    3c86:	bf00      	nop
    3c88:	40021004 	.word	0x40021004
    3c8c:	40021000 	.word	0x40021000

00003c90 <am_hal_pwrctrl_bucks_disable>:
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    3c90:	4b12      	ldr	r3, [pc, #72]	; (3cdc <am_hal_pwrctrl_bucks_disable+0x4c>)
    3c92:	681a      	ldr	r2, [r3, #0]
    3c94:	0792      	lsls	r2, r2, #30
    3c96:	d402      	bmi.n	3c9e <am_hal_pwrctrl_bucks_disable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) == 0)
    3c98:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    3c9a:	07c3      	lsls	r3, r0, #31
    3c9c:	d51c      	bpl.n	3cd8 <am_hal_pwrctrl_bucks_disable+0x48>
//
//*****************************************************************************
static bool
isRev_ADC(void)
{
    return AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    3c9e:	4910      	ldr	r1, [pc, #64]	; (3ce0 <am_hal_pwrctrl_bucks_disable+0x50>)
    3ca0:	680b      	ldr	r3, [r1, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    3ca2:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    3ca6:	2a20      	cmp	r2, #32
    3ca8:	d00b      	beq.n	3cc2 <am_hal_pwrctrl_bucks_disable+0x32>
    else
    {
        //
        // Power them down
        //
        AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 0);
    3caa:	4b0e      	ldr	r3, [pc, #56]	; (3ce4 <am_hal_pwrctrl_bucks_disable+0x54>)
    3cac:	681a      	ldr	r2, [r3, #0]
    3cae:	f022 0002 	bic.w	r0, r2, #2
    3cb2:	6018      	str	r0, [r3, #0]
        AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 0);
    3cb4:	6819      	ldr	r1, [r3, #0]
    3cb6:	f021 0201 	bic.w	r2, r1, #1
    3cba:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait until BUCKs are disabled.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_BUCKDIS_DELAYCYCLES / 3);
    3cbc:	200a      	movs	r0, #10
    3cbe:	f7fd bca7 	b.w	1610 <am_hal_flash_delay>

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    3cc2:	4809      	ldr	r0, [pc, #36]	; (3ce8 <am_hal_pwrctrl_bucks_disable+0x58>)
    3cc4:	6801      	ldr	r1, [r0, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    3cc6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    3cca:	d1ee      	bne.n	3caa <am_hal_pwrctrl_bucks_disable+0x1a>
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    {
            //
            // Set SUPPLYSRC to handle this case
            //
            AM_REG(PWRCTRL, SUPPLYSRC) &=
    3ccc:	4805      	ldr	r0, [pc, #20]	; (3ce4 <am_hal_pwrctrl_bucks_disable+0x54>)
    3cce:	6803      	ldr	r3, [r0, #0]
    3cd0:	f003 0105 	and.w	r1, r3, #5
    3cd4:	6001      	str	r1, [r0, #0]
    3cd6:	e7f1      	b.n	3cbc <am_hal_pwrctrl_bucks_disable+0x2c>
    3cd8:	4770      	bx	lr
    3cda:	bf00      	nop
    3cdc:	40021004 	.word	0x40021004
    3ce0:	4002000c 	.word	0x4002000c
    3ce4:	40021000 	.word	0x40021000
    3ce8:	40021008 	.word	0x40021008

00003cec <am_hal_pwrctrl_low_power_init>:
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    3cec:	4905      	ldr	r1, [pc, #20]	; (3d04 <am_hal_pwrctrl_low_power_init+0x18>)
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    3cee:	4a06      	ldr	r2, [pc, #24]	; (3d08 <am_hal_pwrctrl_low_power_init+0x1c>)
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    3cf0:	680b      	ldr	r3, [r1, #0]
    3cf2:	f043 0006 	orr.w	r0, r3, #6
    3cf6:	6008      	str	r0, [r1, #0]
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    3cf8:	6811      	ldr	r1, [r2, #0]
    3cfa:	f021 0304 	bic.w	r3, r1, #4
    3cfe:	6013      	str	r3, [r2, #0]
    3d00:	4770      	bx	lr
    3d02:	bf00      	nop
    3d04:	40021018 	.word	0x40021018
    3d08:	40021000 	.word	0x40021000

00003d0c <am_hal_queue_init>:
//
//*****************************************************************************
void
am_hal_queue_init(am_hal_queue_t *psQueue, void *pvData, uint32_t ui32ItemSize,
                  uint32_t ui32ArraySize)
{
    3d0c:	b410      	push	{r4}
    psQueue->ui32WriteIndex = 0;
    3d0e:	2400      	movs	r4, #0
    3d10:	6004      	str	r4, [r0, #0]
    psQueue->ui32ReadIndex = 0;
    3d12:	6044      	str	r4, [r0, #4]
    psQueue->ui32Length = 0;
    3d14:	6084      	str	r4, [r0, #8]
    psQueue->ui32Capacity = ui32ArraySize;
    3d16:	60c3      	str	r3, [r0, #12]
    psQueue->ui32ItemSize = ui32ItemSize;
    3d18:	6102      	str	r2, [r0, #16]
    psQueue->pui8Data = (uint8_t *) pvData;
    3d1a:	6141      	str	r1, [r0, #20]
}
    3d1c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3d20:	4770      	bx	lr
    3d22:	bf00      	nop

00003d24 <am_hal_queue_item_add>:
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
    3d24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3d26:	4604      	mov	r4, r0
    uint32_t i;
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    3d28:	6907      	ldr	r7, [r0, #16]
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
    3d2a:	460e      	mov	r6, r1
    uint32_t i;
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    3d2c:	fb07 f702 	mul.w	r7, r7, r2
    bool bSuccess = false;
    uint32_t ui32Primask;

    pui8Source = (uint8_t *) pvSource;

    ui32Primask = am_hal_interrupt_master_disable();
    3d30:	f7fd fd62 	bl	17f8 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't already full
    //
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    3d34:	68a5      	ldr	r5, [r4, #8]
    3d36:	68e3      	ldr	r3, [r4, #12]
    3d38:	1b59      	subs	r1, r3, r5
    3d3a:	428f      	cmp	r7, r1
    3d3c:	d87a      	bhi.n	3e34 <am_hal_queue_item_add+0x110>
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3d3e:	2f00      	cmp	r7, #0
    3d40:	d071      	beq.n	3e26 <am_hal_queue_item_add+0x102>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3d42:	4635      	mov	r5, r6
    3d44:	6823      	ldr	r3, [r4, #0]
    3d46:	6962      	ldr	r2, [r4, #20]
    3d48:	f815 1b01 	ldrb.w	r1, [r5], #1
    3d4c:	54d1      	strb	r1, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3d4e:	6822      	ldr	r2, [r4, #0]
    3d50:	68e3      	ldr	r3, [r4, #12]
    3d52:	3201      	adds	r2, #1
    3d54:	19f1      	adds	r1, r6, r7
    3d56:	fbb2 fcf3 	udiv	ip, r2, r3
    3d5a:	1e7e      	subs	r6, r7, #1
    3d5c:	fb03 231c 	mls	r3, r3, ip, r2
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3d60:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3d62:	6023      	str	r3, [r4, #0]
    3d64:	f006 0203 	and.w	r2, r6, #3
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3d68:	d05c      	beq.n	3e24 <am_hal_queue_item_add+0x100>
    3d6a:	b34a      	cbz	r2, 3dc0 <am_hal_queue_item_add+0x9c>
    3d6c:	2a01      	cmp	r2, #1
    3d6e:	d019      	beq.n	3da4 <am_hal_queue_item_add+0x80>
    3d70:	2a02      	cmp	r2, #2
    3d72:	d00b      	beq.n	3d8c <am_hal_queue_item_add+0x68>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3d74:	6962      	ldr	r2, [r4, #20]
    3d76:	f815 6b01 	ldrb.w	r6, [r5], #1
    3d7a:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3d7c:	6822      	ldr	r2, [r4, #0]
    3d7e:	68e3      	ldr	r3, [r4, #12]
    3d80:	3201      	adds	r2, #1
    3d82:	fbb2 fef3 	udiv	lr, r2, r3
    3d86:	fb03 231e 	mls	r3, r3, lr, r2
    3d8a:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3d8c:	6962      	ldr	r2, [r4, #20]
    3d8e:	f815 6b01 	ldrb.w	r6, [r5], #1
    3d92:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3d94:	6822      	ldr	r2, [r4, #0]
    3d96:	68e3      	ldr	r3, [r4, #12]
    3d98:	3201      	adds	r2, #1
    3d9a:	fbb2 fcf3 	udiv	ip, r2, r3
    3d9e:	fb03 231c 	mls	r3, r3, ip, r2
    3da2:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3da4:	6962      	ldr	r2, [r4, #20]
    3da6:	f815 6b01 	ldrb.w	r6, [r5], #1
    3daa:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3dac:	6822      	ldr	r2, [r4, #0]
    3dae:	68e3      	ldr	r3, [r4, #12]
    3db0:	3201      	adds	r2, #1
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3db2:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3db4:	fbb2 fef3 	udiv	lr, r2, r3
    3db8:	fb03 231e 	mls	r3, r3, lr, r2
    3dbc:	6023      	str	r3, [r4, #0]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3dbe:	d031      	beq.n	3e24 <am_hal_queue_item_add+0x100>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3dc0:	46ac      	mov	ip, r5
    3dc2:	6962      	ldr	r2, [r4, #20]
    3dc4:	f81c 6b01 	ldrb.w	r6, [ip], #1
    3dc8:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3dca:	6823      	ldr	r3, [r4, #0]
    3dcc:	68e2      	ldr	r2, [r4, #12]
    3dce:	3301      	adds	r3, #1
    3dd0:	fbb3 fef2 	udiv	lr, r3, r2
    3dd4:	fb02 331e 	mls	r3, r2, lr, r3
    3dd8:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3dda:	6962      	ldr	r2, [r4, #20]
    3ddc:	786e      	ldrb	r6, [r5, #1]
    3dde:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3de0:	6823      	ldr	r3, [r4, #0]
    3de2:	68e6      	ldr	r6, [r4, #12]
    3de4:	3301      	adds	r3, #1
    3de6:	fbb3 fef6 	udiv	lr, r3, r6
    3dea:	fb06 331e 	mls	r3, r6, lr, r3
    3dee:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3df0:	6966      	ldr	r6, [r4, #20]
    3df2:	f89c 2001 	ldrb.w	r2, [ip, #1]
    3df6:	54f2      	strb	r2, [r6, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3df8:	6823      	ldr	r3, [r4, #0]
    3dfa:	68e2      	ldr	r2, [r4, #12]
    3dfc:	3301      	adds	r3, #1
    3dfe:	fbb3 fcf2 	udiv	ip, r3, r2
    3e02:	fb02 331c 	mls	r3, r2, ip, r3
    3e06:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    3e08:	6962      	ldr	r2, [r4, #20]
    3e0a:	78ee      	ldrb	r6, [r5, #3]
    3e0c:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3e0e:	6826      	ldr	r6, [r4, #0]
    3e10:	68e3      	ldr	r3, [r4, #12]
    3e12:	3601      	adds	r6, #1
    3e14:	3504      	adds	r5, #4
    3e16:	fbb6 fef3 	udiv	lr, r6, r3
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3e1a:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    3e1c:	fb03 631e 	mls	r3, r3, lr, r6
    3e20:	6023      	str	r3, [r4, #0]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3e22:	d1cd      	bne.n	3dc0 <am_hal_queue_item_add+0x9c>
    3e24:	68a5      	ldr	r5, [r4, #8]
        }

        //
        // Update the length value appropriately.
        //
        psQueue->ui32Length += ui32Bytes;
    3e26:	443d      	add	r5, r7
    3e28:	60a5      	str	r5, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
    3e2a:	2401      	movs	r4, #1
        // failure.
        //
        bSuccess = false;
    }

    am_hal_interrupt_master_set(ui32Primask);
    3e2c:	f7fd fce8 	bl	1800 <am_hal_interrupt_master_set>

    return bSuccess;
}
    3e30:	4620      	mov	r0, r4
    3e32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    {
        //
        // The buffer can't fit the amount of data requested. Return a
        // failure.
        //
        bSuccess = false;
    3e34:	2400      	movs	r4, #0
    }

    am_hal_interrupt_master_set(ui32Primask);
    3e36:	f7fd fce3 	bl	1800 <am_hal_interrupt_master_set>

    return bSuccess;
}
    3e3a:	4620      	mov	r0, r4
    3e3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3e3e:	bf00      	nop

00003e40 <am_hal_queue_item_get>:
//! queue, or false if the queue didn't have that many items to pull.
//
//*****************************************************************************
bool
am_hal_queue_item_get(am_hal_queue_t *psQueue, void *pvDest, uint32_t ui32NumItems)
{
    3e40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3e42:	4604      	mov	r4, r0
    uint32_t i;
    uint8_t *pui8Dest;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    3e44:	6907      	ldr	r7, [r0, #16]
//! queue, or false if the queue didn't have that many items to pull.
//
//*****************************************************************************
bool
am_hal_queue_item_get(am_hal_queue_t *psQueue, void *pvDest, uint32_t ui32NumItems)
{
    3e46:	460d      	mov	r5, r1
    uint32_t i;
    uint8_t *pui8Dest;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    3e48:	fb07 f702 	mul.w	r7, r7, r2
    bool bSuccess = false;
    uint32_t ui32Primask;

    pui8Dest = (uint8_t *) pvDest;

    ui32Primask = am_hal_interrupt_master_disable();
    3e4c:	f7fd fcd4 	bl	17f8 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't empty
    //
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    3e50:	68a6      	ldr	r6, [r4, #8]
    3e52:	42b7      	cmp	r7, r6
    3e54:	d87d      	bhi.n	3f52 <am_hal_queue_item_get+0x112>
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3e56:	2f00      	cmp	r7, #0
    3e58:	d074      	beq.n	3f44 <am_hal_queue_item_get+0x104>
    3e5a:	6863      	ldr	r3, [r4, #4]
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3e5c:	6962      	ldr	r2, [r4, #20]
    3e5e:	462e      	mov	r6, r5
    3e60:	5cd1      	ldrb	r1, [r2, r3]
    3e62:	f806 1b01 	strb.w	r1, [r6], #1

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3e66:	6863      	ldr	r3, [r4, #4]
    3e68:	68e2      	ldr	r2, [r4, #12]
    3e6a:	3301      	adds	r3, #1
    3e6c:	19e9      	adds	r1, r5, r7
    3e6e:	fbb3 fcf2 	udiv	ip, r3, r2
    3e72:	1e7d      	subs	r5, r7, #1
    3e74:	fb02 331c 	mls	r3, r2, ip, r3
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3e78:	42b1      	cmp	r1, r6
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3e7a:	6063      	str	r3, [r4, #4]
    3e7c:	f005 0203 	and.w	r2, r5, #3
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3e80:	d05f      	beq.n	3f42 <am_hal_queue_item_get+0x102>
    3e82:	b362      	cbz	r2, 3ede <am_hal_queue_item_get+0x9e>
    3e84:	2a01      	cmp	r2, #1
    3e86:	d01b      	beq.n	3ec0 <am_hal_queue_item_get+0x80>
    3e88:	2a02      	cmp	r2, #2
    3e8a:	d00c      	beq.n	3ea6 <am_hal_queue_item_get+0x66>
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3e8c:	6965      	ldr	r5, [r4, #20]
    3e8e:	f815 e003 	ldrb.w	lr, [r5, r3]
    3e92:	f806 eb01 	strb.w	lr, [r6], #1

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3e96:	6863      	ldr	r3, [r4, #4]
    3e98:	68e2      	ldr	r2, [r4, #12]
    3e9a:	3301      	adds	r3, #1
    3e9c:	fbb3 fcf2 	udiv	ip, r3, r2
    3ea0:	fb02 331c 	mls	r3, r2, ip, r3
    3ea4:	6063      	str	r3, [r4, #4]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3ea6:	6965      	ldr	r5, [r4, #20]
    3ea8:	f815 e003 	ldrb.w	lr, [r5, r3]
    3eac:	f806 eb01 	strb.w	lr, [r6], #1

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3eb0:	6863      	ldr	r3, [r4, #4]
    3eb2:	68e2      	ldr	r2, [r4, #12]
    3eb4:	3301      	adds	r3, #1
    3eb6:	fbb3 fcf2 	udiv	ip, r3, r2
    3eba:	fb02 331c 	mls	r3, r2, ip, r3
    3ebe:	6063      	str	r3, [r4, #4]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3ec0:	6965      	ldr	r5, [r4, #20]
    3ec2:	f815 e003 	ldrb.w	lr, [r5, r3]
    3ec6:	f806 eb01 	strb.w	lr, [r6], #1

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3eca:	6863      	ldr	r3, [r4, #4]
    3ecc:	68e2      	ldr	r2, [r4, #12]
    3ece:	3301      	adds	r3, #1
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3ed0:	42b1      	cmp	r1, r6
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3ed2:	fbb3 fcf2 	udiv	ip, r3, r2
    3ed6:	fb02 331c 	mls	r3, r2, ip, r3
    3eda:	6063      	str	r3, [r4, #4]
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3edc:	d031      	beq.n	3f42 <am_hal_queue_item_get+0x102>
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3ede:	6965      	ldr	r5, [r4, #20]
    3ee0:	46b6      	mov	lr, r6
    3ee2:	5cea      	ldrb	r2, [r5, r3]
    3ee4:	f80e 2b01 	strb.w	r2, [lr], #1

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3ee8:	6863      	ldr	r3, [r4, #4]
    3eea:	68e2      	ldr	r2, [r4, #12]
    3eec:	3301      	adds	r3, #1
    3eee:	fbb3 fcf2 	udiv	ip, r3, r2
    3ef2:	fb02 351c 	mls	r5, r2, ip, r3
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3ef6:	6963      	ldr	r3, [r4, #20]

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3ef8:	6065      	str	r5, [r4, #4]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3efa:	5d5a      	ldrb	r2, [r3, r5]
    3efc:	7072      	strb	r2, [r6, #1]

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3efe:	6863      	ldr	r3, [r4, #4]
    3f00:	68e5      	ldr	r5, [r4, #12]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3f02:	6962      	ldr	r2, [r4, #20]

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3f04:	3301      	adds	r3, #1
    3f06:	fbb3 fcf5 	udiv	ip, r3, r5
    3f0a:	fb05 331c 	mls	r3, r5, ip, r3
    3f0e:	6063      	str	r3, [r4, #4]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3f10:	5cd5      	ldrb	r5, [r2, r3]
    3f12:	f88e 5001 	strb.w	r5, [lr, #1]

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3f16:	6863      	ldr	r3, [r4, #4]
    3f18:	68e5      	ldr	r5, [r4, #12]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3f1a:	6962      	ldr	r2, [r4, #20]

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3f1c:	3301      	adds	r3, #1
    3f1e:	fbb3 fef5 	udiv	lr, r3, r5
    3f22:	fb05 331e 	mls	r3, r5, lr, r3
    3f26:	6063      	str	r3, [r4, #4]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Grab the next value from the buffer.
            //
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    3f28:	5cd5      	ldrb	r5, [r2, r3]
    3f2a:	70f5      	strb	r5, [r6, #3]

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3f2c:	6863      	ldr	r3, [r4, #4]
    3f2e:	68e2      	ldr	r2, [r4, #12]
    3f30:	3301      	adds	r3, #1
    3f32:	3604      	adds	r6, #4
    3f34:	fbb3 fcf2 	udiv	ip, r3, r2
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3f38:	42b1      	cmp	r1, r6
            pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    3f3a:	fb02 331c 	mls	r3, r2, ip, r3
    3f3e:	6063      	str	r3, [r4, #4]
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    3f40:	d1cd      	bne.n	3ede <am_hal_queue_item_get+0x9e>
    3f42:	68a6      	ldr	r6, [r4, #8]
        }

        //
        // Adjust the length value to reflect the change.
        //
        psQueue->ui32Length -= ui32Bytes;
    3f44:	1bf7      	subs	r7, r6, r7
    3f46:	60a7      	str	r7, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
    3f48:	2601      	movs	r6, #1
        // If the buffer didn't have enough data, just return false.
        //
        bSuccess = false;
    }

    am_hal_interrupt_master_set(ui32Primask);
    3f4a:	f7fd fc59 	bl	1800 <am_hal_interrupt_master_set>

    return bSuccess;
}
    3f4e:	4630      	mov	r0, r6
    3f50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else
    {
        //
        // If the buffer didn't have enough data, just return false.
        //
        bSuccess = false;
    3f52:	2600      	movs	r6, #0
    }

    am_hal_interrupt_master_set(ui32Primask);
    3f54:	f7fd fc54 	bl	1800 <am_hal_interrupt_master_set>

    return bSuccess;
}
    3f58:	4630      	mov	r0, r6
    3f5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00003f5c <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    3f5c:	4a05      	ldr	r2, [pc, #20]	; (3f74 <am_hal_rtc_osc_select+0x18>)
    3f5e:	6813      	ldr	r3, [r2, #0]
{
    //
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    3f60:	b918      	cbnz	r0, 3f6a <am_hal_rtc_osc_select+0xe>
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    3f62:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    3f66:	6010      	str	r0, [r2, #0]
    3f68:	4770      	bx	lr
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    3f6a:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    3f6e:	6011      	str	r1, [r2, #0]
    3f70:	4770      	bx	lr
    3f72:	bf00      	nop
    3f74:	4000400c 	.word	0x4000400c

00003f78 <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_REG(RTC, RTCCTL) |= AM_REG_RTC_RTCCTL_RSTOP(1);
    3f78:	4a02      	ldr	r2, [pc, #8]	; (3f84 <am_hal_rtc_osc_disable+0xc>)
    3f7a:	6813      	ldr	r3, [r2, #0]
    3f7c:	f043 0010 	orr.w	r0, r3, #16
    3f80:	6010      	str	r0, [r2, #0]
    3f82:	4770      	bx	lr
    3f84:	40004050 	.word	0x40004050

00003f88 <am_hal_sysctrl_sleep>:
//! @return None.
//
//*****************************************************************************
void
am_hal_sysctrl_sleep(bool bSleepDeep)
{
    3f88:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f8a:	b083      	sub	sp, #12
    3f8c:	4605      	mov	r5, r0
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    3f8e:	f7fd fc33 	bl	17f8 <am_hal_interrupt_master_disable>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    3f92:	4a41      	ldr	r2, [pc, #260]	; (4098 <am_hal_sysctrl_sleep+0x110>)
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    3f94:	4604      	mov	r4, r0

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    3f96:	b11d      	cbz	r5, 3fa0 <am_hal_sysctrl_sleep+0x18>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    3f98:	4b40      	ldr	r3, [pc, #256]	; (409c <am_hal_sysctrl_sleep+0x114>)
    3f9a:	6818      	ldr	r0, [r3, #0]

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    3f9c:	07c3      	lsls	r3, r0, #31
    3f9e:	d509      	bpl.n	3fb4 <am_hal_sysctrl_sleep+0x2c>
    else
    {
        //
        // Prepare the core for normal sleep (write 0 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 0);
    3fa0:	6811      	ldr	r1, [r2, #0]
    3fa2:	f021 0604 	bic.w	r6, r1, #4
    3fa6:	6016      	str	r6, [r2, #0]

        //
        // Go to sleep.
        //
        AM_ASM_WFI;
    3fa8:	bf30      	wfi
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    3faa:	4620      	mov	r0, r4
    3fac:	f7fd fc28 	bl	1800 <am_hal_interrupt_master_set>
}
    3fb0:	b003      	add	sp, #12
    3fb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    3fb4:	6813      	ldr	r3, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    3fb6:	493a      	ldr	r1, [pc, #232]	; (40a0 <am_hal_sysctrl_sleep+0x118>)
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    3fb8:	4f3a      	ldr	r7, [pc, #232]	; (40a4 <am_hal_sysctrl_sleep+0x11c>)
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    3fba:	4d3b      	ldr	r5, [pc, #236]	; (40a8 <am_hal_sysctrl_sleep+0x120>)

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    3fbc:	483b      	ldr	r0, [pc, #236]	; (40ac <am_hal_sysctrl_sleep+0x124>)
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    3fbe:	f043 0604 	orr.w	r6, r3, #4
    3fc2:	6016      	str	r6, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    3fc4:	6809      	ldr	r1, [r1, #0]
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    3fc6:	683b      	ldr	r3, [r7, #0]
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    3fc8:	682a      	ldr	r2, [r5, #0]

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    3fca:	6800      	ldr	r0, [r0, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    3fcc:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
    3fd0:	2920      	cmp	r1, #32

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    3fd2:	f103 36ff 	add.w	r6, r3, #4294967295
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    3fd6:	bf14      	ite	ne
    3fd8:	2500      	movne	r5, #0
    3fda:	2502      	moveq	r5, #2

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    3fdc:	2e03      	cmp	r6, #3
    3fde:	bf8c      	ite	hi
    3fe0:	2100      	movhi	r1, #0
    3fe2:	2104      	movls	r1, #4
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    3fe4:	f012 0303 	ands.w	r3, r2, #3
    3fe8:	bf18      	it	ne
    3fea:	2301      	movne	r3, #1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    3fec:	f240 56ff 	movw	r6, #1535	; 0x5ff
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    3ff0:	432b      	orrs	r3, r5
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    3ff2:	4006      	ands	r6, r0
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    3ff4:	ea43 0501 	orr.w	r5, r3, r1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    3ff8:	b91e      	cbnz	r6, 4002 <am_hal_sysctrl_sleep+0x7a>
    3ffa:	f045 0508 	orr.w	r5, r5, #8
        //
        // Check if special buck handling is needed
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
    3ffe:	2d0f      	cmp	r5, #15
    4000:	d00a      	beq.n	4018 <am_hal_sysctrl_sleep+0x90>
        }

        //
        // Execute the sleep instruction.
        //
        AM_ASM_WFI;
    4002:	bf30      	wfi

        //
        // Return from sleep
        //
        if ( bBuckZX_chk )
    4004:	2d0f      	cmp	r5, #15
    4006:	d01a      	beq.n	403e <am_hal_sysctrl_sleep+0xb6>
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    4008:	4f29      	ldr	r7, [pc, #164]	; (40b0 <am_hal_sysctrl_sleep+0x128>)
    400a:	2101      	movs	r1, #1
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    400c:	4620      	mov	r0, r4
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    400e:	7039      	strb	r1, [r7, #0]
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    4010:	f7fd fbf6 	bl	1800 <am_hal_interrupt_master_set>
}
    4014:	b003      	add	sp, #12
    4016:	bdf0      	pop	{r4, r5, r6, r7, pc}
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
        {
            ui32BuckTimer = g_ui32BuckTimer - 1;
    4018:	683a      	ldr	r2, [r7, #0]
    401a:	1e50      	subs	r0, r2, #1
    401c:	9000      	str	r0, [sp, #0]
            //
            // Before going to sleep, clear the buck timers.
            // This will also handle the case where we're going back to
            // sleep before the buck sequence has even completed.
            //
            am_hal_ctimer_clear(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    401e:	9800      	ldr	r0, [sp, #0]
    4020:	f04f 31ff 	mov.w	r1, #4294967295
    4024:	f000 f8c0 	bl	41a8 <am_hal_ctimer_clear>

            //
            // Set CMPR0 of both timerA and timerB to the period value
            //
            #define     TIMER_PERIOD_BUCKS  1
            am_hal_ctimer_period_set(ui32BuckTimer,
    4028:	9800      	ldr	r0, [sp, #0]
    402a:	4633      	mov	r3, r6
    402c:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    4030:	f04f 31ff 	mov.w	r1, #4294967295
    4034:	f000 f8cc 	bl	41d0 <am_hal_ctimer_period_set>
                                     0);

            //
            // Disable bucks before going to sleep.
            //
            am_hal_pwrctrl_bucks_disable();
    4038:	f7ff fe2a 	bl	3c90 <am_hal_pwrctrl_bucks_disable>
    403c:	e7e1      	b.n	4002 <am_hal_sysctrl_sleep+0x7a>
    bool bDoRestore = false;

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    403e:	f3ef 8310 	mrs	r3, PRIMASK
    4042:	9301      	str	r3, [sp, #4]
    4044:	b672      	cpsid	i

    //
    // Get the current zero cross trim values.
    //
    ui32SaveCore = AM_BFR(MCUCTRL, BUCK3, COREBUCKZXTRIM);
    4046:	4e1b      	ldr	r6, [pc, #108]	; (40b4 <am_hal_sysctrl_sleep+0x12c>)
    4048:	6832      	ldr	r2, [r6, #0]
    ui32SaveMem  = AM_BFR(MCUCTRL, BUCK3, MEMBUCKZXTRIM);
    404a:	6832      	ldr	r2, [r6, #0]
    //
    if ( bDoRestore )
    {
        if ( ui32Flags & SETBUCKZX_RESTORE_CORE_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, COREBUCKZXTRIM, ui32NewCore);
    404c:	6835      	ldr	r5, [r6, #0]
    404e:	f025 0c3c 	bic.w	ip, r5, #60	; 0x3c
    4052:	f04c 021c 	orr.w	r2, ip, #28
    4056:	6032      	str	r2, [r6, #0]
        }

        if ( ui32Flags & SETBUCKZX_RESTORE_MEM_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, MEMBUCKZXTRIM,  ui32NewMem);
    4058:	6830      	ldr	r0, [r6, #0]
    405a:	f420 31f0 	bic.w	r1, r0, #122880	; 0x1e000
    405e:	f441 4360 	orr.w	r3, r1, #57344	; 0xe000
    4062:	6033      	str	r3, [r6, #0]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    4064:	9e01      	ldr	r6, [sp, #4]
    4066:	f386 8810 	msr	PRIMASK, r6
                      SETBUCKZX_RESTORE_BOTH );

            //
            // Delay for 2us before enabling bucks.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(2) );
    406a:	201c      	movs	r0, #28
    406c:	f7fd fad0 	bl	1610 <am_hal_flash_delay>

            //
            // Turn on the bucks
            //
            am_hal_pwrctrl_bucks_enable();
    4070:	f7ff fdf2 	bl	3c58 <am_hal_pwrctrl_bucks_enable>

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    4074:	683f      	ldr	r7, [r7, #0]
            g_bBuckRestoreComplete = false;

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    4076:	4910      	ldr	r1, [pc, #64]	; (40b8 <am_hal_sysctrl_sleep+0x130>)
            ui32BuckTimer = g_ui32BuckTimer - 1;

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    4078:	4d0d      	ldr	r5, [pc, #52]	; (40b0 <am_hal_sysctrl_sleep+0x128>)
    407a:	2200      	movs	r2, #0
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    407c:	1e7b      	subs	r3, r7, #1
            g_ui32BuckInputs = 0;

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    407e:	204c      	movs	r0, #76	; 0x4c
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    4080:	9300      	str	r3, [sp, #0]

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    4082:	702a      	strb	r2, [r5, #0]

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    4084:	600a      	str	r2, [r1, #0]

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    4086:	f7fd fac3 	bl	1610 <am_hal_flash_delay>

            //
            // Start timers (set the enable bit, clear the clear bit)
            //
            am_hal_ctimer_start(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    408a:	9800      	ldr	r0, [sp, #0]
    408c:	f04f 31ff 	mov.w	r1, #4294967295
    4090:	f000 f870 	bl	4174 <am_hal_ctimer_start>
    4094:	e789      	b.n	3faa <am_hal_sysctrl_sleep+0x22>
    4096:	bf00      	nop
    4098:	e000ed10 	.word	0xe000ed10
    409c:	40020250 	.word	0x40020250
    40a0:	4002000c 	.word	0x4002000c
    40a4:	100011b8 	.word	0x100011b8
    40a8:	40021000 	.word	0x40021000
    40ac:	40021008 	.word	0x40021008
    40b0:	100011b0 	.word	0x100011b0
    40b4:	40020068 	.word	0x40020068
    40b8:	100011b4 	.word	0x100011b4

000040bc <am_hal_tpiu_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_tpiu_enable(am_hal_tpiu_config_t *psConfig)
{
    40bc:	b538      	push	{r3, r4, r5, lr}
    ui32ITMbitrate = psConfig->ui32SetItmBaud;

    //
    // TPIU formatter & flush control register.
    //
    AM_REG(TPIU, FFCR) = 0;
    40be:	4a22      	ldr	r2, [pc, #136]	; (4148 <am_hal_tpiu_enable+0x8c>)
void
am_hal_tpiu_enable(am_hal_tpiu_config_t *psConfig)
{
    uint32_t ui32HFRC, ui32SWOscaler, ui32ITMbitrate;

    ui32ITMbitrate = psConfig->ui32SetItmBaud;
    40c0:	6803      	ldr	r3, [r0, #0]

    //
    // TPIU formatter & flush control register.
    //
    AM_REG(TPIU, FFCR) = 0;
    40c2:	2100      	movs	r1, #0
    40c4:	6011      	str	r1, [r2, #0]

    if ( ui32ITMbitrate )
    40c6:	b333      	cbz	r3, 4116 <am_hal_tpiu_enable+0x5a>
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    40c8:	4d20      	ldr	r5, [pc, #128]	; (414c <am_hal_tpiu_enable+0x90>)

        //
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    40ca:	4921      	ldr	r1, [pc, #132]	; (4150 <am_hal_tpiu_enable+0x94>)
             (ui32ITMbitrate > AM_HAL_TPIU_BAUD_2M ) )
        {
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    40cc:	4a21      	ldr	r2, [pc, #132]	; (4154 <am_hal_tpiu_enable+0x98>)
    if ( ui32ITMbitrate )
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    40ce:	2401      	movs	r4, #1

        //
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    40d0:	f5a3 4c61 	sub.w	ip, r3, #57600	; 0xe100
    if ( ui32ITMbitrate )
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    40d4:	602c      	str	r4, [r5, #0]
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
             (ui32ITMbitrate > AM_HAL_TPIU_BAUD_2M ) )
        {
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    40d6:	458c      	cmp	ip, r1
    40d8:	bf94      	ite	ls
    40da:	461d      	movls	r5, r3
    40dc:	4615      	movhi	r5, r2
        }

        //
        // Get the current HFRC frequency.
        //
        ui32HFRC = am_hal_clkgen_sysclk_get();
    40de:	f7fd fa7b 	bl	15d8 <am_hal_clkgen_sysclk_get>

        //
        // Compute the SWO scaler value.
        //
        if ( ui32HFRC != 0xFFFFFFFF )
    40e2:	1c43      	adds	r3, r0, #1
    40e4:	d02e      	beq.n	4144 <am_hal_tpiu_enable+0x88>
    40e6:	08c3      	lsrs	r3, r0, #3
    40e8:	fbb3 fef5 	udiv	lr, r3, r5
    40ec:	f10e 31ff 	add.w	r1, lr, #4294967295
    40f0:	b288      	uxth	r0, r1
        }

        //
        // Set the scaler value.
        //
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    40f2:	4a19      	ldr	r2, [pc, #100]	; (4158 <am_hal_tpiu_enable+0x9c>)

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    40f4:	4c19      	ldr	r4, [pc, #100]	; (415c <am_hal_tpiu_enable+0xa0>)

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6 or 3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    40f6:	4b1a      	ldr	r3, [pc, #104]	; (4160 <am_hal_tpiu_enable+0xa4>)

        //
        // Make sure we are not in test mode (important for proper deep sleep
        // operation).
        //
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    40f8:	491a      	ldr	r1, [pc, #104]	; (4164 <am_hal_tpiu_enable+0xa8>)
        }

        //
        // Set the scaler value.
        //
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    40fa:	6010      	str	r0, [r2, #0]

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    40fc:	2502      	movs	r5, #2

        //
        // Make sure we are not in test mode (important for proper deep sleep
        // operation).
        //
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    40fe:	2000      	movs	r0, #0

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6 or 3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    4100:	f240 2201 	movw	r2, #513	; 0x201
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    4104:	6025      	str	r5, [r4, #0]

        //
        // Make sure we are not in test mode (important for proper deep sleep
        // operation).
        //
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    4106:	6008      	str	r0, [r1, #0]

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6 or 3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    4108:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    410a:	f44f 7047 	mov.w	r0, #796	; 0x31c
}
    410e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    4112:	f7fd ba7d 	b.w	1610 <am_hal_flash_delay>
        //

        //
        // Set the Asynchronous Clock Prescaler Register.
        //
        AM_REG(TPIU, ACPR) = psConfig->ui32ClockPrescaler;
    4116:	4c10      	ldr	r4, [pc, #64]	; (4158 <am_hal_tpiu_enable+0x9c>)
    4118:	6905      	ldr	r5, [r0, #16]
    411a:	6025      	str	r5, [r4, #0]

        //
        // Set the Selected Pin Protocol Register.
        //  e.g. AM_REG_TPIU_SPPR_TXMODE_UART
        //
        AM_REG(TPIU, SPPR) = psConfig->ui32PinProtocol;
    411c:	6882      	ldr	r2, [r0, #8]
    411e:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        // This may be redundant if the user has selected a serial protocol,
        // but we'll set it anyway.
        //
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    4122:	68c3      	ldr	r3, [r0, #12]
    4124:	4c09      	ldr	r4, [pc, #36]	; (414c <am_hal_tpiu_enable+0x90>)

        //
        // Set the clock freq in the MCUCTRL register.
        //
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    4126:	490e      	ldr	r1, [pc, #56]	; (4160 <am_hal_tpiu_enable+0xa4>)
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        // This may be redundant if the user has selected a serial protocol,
        // but we'll set it anyway.
        //
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    4128:	1e5d      	subs	r5, r3, #1
    412a:	2201      	movs	r2, #1
    412c:	40aa      	lsls	r2, r5
    412e:	6022      	str	r2, [r4, #0]

        //
        // Set the clock freq in the MCUCTRL register.
        //
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    4130:	680b      	ldr	r3, [r1, #0]
    4132:	6840      	ldr	r0, [r0, #4]
    4134:	4318      	orrs	r0, r3
    4136:	6008      	str	r0, [r1, #0]

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
}
    4138:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    413c:	f44f 7047 	mov.w	r0, #796	; 0x31c
    4140:	f7fd ba66 	b.w	1610 <am_hal_flash_delay>
    4144:	2005      	movs	r0, #5
    4146:	e7d4      	b.n	40f2 <am_hal_tpiu_enable+0x36>
    4148:	e0040304 	.word	0xe0040304
    414c:	e0040004 	.word	0xe0040004
    4150:	001da380 	.word	0x001da380
    4154:	000f4240 	.word	0x000f4240
    4158:	e0040010 	.word	0xe0040010
    415c:	e00400f0 	.word	0xe00400f0
    4160:	40020250 	.word	0x40020250
    4164:	e0040f00 	.word	0xe0040f00

00004168 <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    4168:	4b01      	ldr	r3, [pc, #4]	; (4170 <am_hal_vcomp_disable+0x8>)
    416a:	2237      	movs	r2, #55	; 0x37
    416c:	601a      	str	r2, [r3, #0]
    416e:	4770      	bx	lr
    4170:	4000c008 	.word	0x4000c008

00004174 <am_hal_ctimer_start>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    4174:	b410      	push	{r4}
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    4176:	f3ef 8310 	mrs	r3, PRIMASK
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    417a:	b083      	sub	sp, #12
    uint32_t ui32ConfigVal;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    417c:	0100      	lsls	r0, r0, #4
    417e:	4a09      	ldr	r2, [pc, #36]	; (41a4 <am_hal_ctimer_start+0x30>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    4180:	9301      	str	r3, [sp, #4]
    4182:	b672      	cpsid	i

    //
    // Read the current value.
    //
    ui32ConfigVal = *pui32ConfigReg;
    4184:	5883      	ldr	r3, [r0, r2]

    //
    // Clear out the "clear" bit.
    //
    ui32ConfigVal &= ~(ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0CLR_M |
    4186:	f001 2408 	and.w	r4, r1, #134219776	; 0x8000800
    418a:	ea23 0304 	bic.w	r3, r3, r4
                                           AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Set the "enable bit"
    //
    ui32ConfigVal |= (ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0EN_M |
    418e:	f001 1101 	and.w	r1, r1, #65537	; 0x10001
    4192:	4319      	orrs	r1, r3
                                          AM_REG_CTIMER_CTRL0_TMRB0EN_M));

    //
    // Write the value back to the register.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    4194:	5081      	str	r1, [r0, r2]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    4196:	9801      	ldr	r0, [sp, #4]
    4198:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_start()
    419c:	b003      	add	sp, #12
    419e:	f85d 4b04 	ldr.w	r4, [sp], #4
    41a2:	4770      	bx	lr
    41a4:	4000800c 	.word	0x4000800c

000041a8 <am_hal_ctimer_clear>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_clear(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    41a8:	b082      	sub	sp, #8
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    41aa:	f3ef 8310 	mrs	r3, PRIMASK
    volatile uint32_t *pui32ConfigReg;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    41ae:	0100      	lsls	r0, r0, #4
    41b0:	4a06      	ldr	r2, [pc, #24]	; (41cc <am_hal_ctimer_clear+0x24>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    41b2:	9301      	str	r3, [sp, #4]
    41b4:	b672      	cpsid	i

    //
    // Set the "clear" bit
    //
    AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
    41b6:	5883      	ldr	r3, [r0, r2]
    41b8:	f001 2108 	and.w	r1, r1, #134219776	; 0x8000800
    41bc:	4319      	orrs	r1, r3
    41be:	5081      	str	r1, [r0, r2]
                                   AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    41c0:	9801      	ldr	r0, [sp, #4]
    41c2:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_clear()
    41c6:	b002      	add	sp, #8
    41c8:	4770      	bx	lr
    41ca:	bf00      	nop
    41cc:	4000800c 	.word	0x4000800c

000041d0 <am_hal_ctimer_period_set>:
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    41d0:	b4f0      	push	{r4, r5, r6, r7}
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    41d2:	f3ef 8410 	mrs	r4, PRIMASK
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    41d6:	b082      	sub	sp, #8
    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                   (ui32TimerNumber * TIMER_OFFSET));
    41d8:	0100      	lsls	r0, r0, #4

    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    41da:	4d1c      	ldr	r5, [pc, #112]	; (424c <am_hal_ctimer_period_set+0x7c>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    41dc:	9401      	str	r4, [sp, #4]
                                   (ui32TimerNumber * TIMER_OFFSET));

    //
    // Find the correct compare registers to write.
    //
    pui32CompareRegA = (uint32_t *)(AM_REG_CTIMERn(0) +
    41de:	4e1c      	ldr	r6, [pc, #112]	; (4250 <am_hal_ctimer_period_set+0x80>)
                                    AM_REG_CTIMER_CMPRA0_O +
                                    (ui32TimerNumber * TIMER_OFFSET));

    pui32CompareRegB = (uint32_t *)(AM_REG_CTIMERn(0) +
    41e0:	4f1c      	ldr	r7, [pc, #112]	; (4254 <am_hal_ctimer_period_set+0x84>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    41e2:	b672      	cpsid	i
    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    41e4:	f511 3f80 	cmn.w	r1, #65536	; 0x10000

    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    41e8:	5944      	ldr	r4, [r0, r5]
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    41ea:	d01a      	beq.n	4222 <am_hal_ctimer_period_set+0x52>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    41ec:	f404 75c0 	and.w	r5, r4, #384	; 0x180
    41f0:	2d80      	cmp	r5, #128	; 0x80
    41f2:	d01b      	beq.n	422c <am_hal_ctimer_period_set+0x5c>

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    41f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    41f8:	2500      	movs	r5, #0
    41fa:	4299      	cmp	r1, r3
        ui32Comp1 = ui32Period;
    }
    else
    {
        ui32Comp0 = ui32Period;
        ui32Comp1 = 0;
    41fc:	462c      	mov	r4, r5

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    41fe:	d01c      	beq.n	423a <am_hal_ctimer_period_set+0x6a>
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));
    }
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    4200:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    4204:	d01e      	beq.n	4244 <am_hal_ctimer_period_set+0x74>
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    4206:	0c21      	lsrs	r1, r4, #16
    4208:	040c      	lsls	r4, r1, #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    420a:	b291      	uxth	r1, r2
    420c:	430d      	orrs	r5, r1
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    420e:	ea44 4212 	orr.w	r2, r4, r2, lsr #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    4212:	5185      	str	r5, [r0, r6]
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    4214:	51c2      	str	r2, [r0, r7]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    4216:	9801      	ldr	r0, [sp, #4]
    4218:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_period_set()
    421c:	b002      	add	sp, #8
    421e:	bcf0      	pop	{r4, r5, r6, r7}
    4220:	4770      	bx	lr

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    4222:	0c25      	lsrs	r5, r4, #16
    4224:	f405 74c0 	and.w	r4, r5, #384	; 0x180
    4228:	2c80      	cmp	r4, #128	; 0x80
    422a:	d10a      	bne.n	4242 <am_hal_ctimer_period_set+0x72>
    422c:	0415      	lsls	r5, r2, #16
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
        ui32Comp1 = ui32Period;
    422e:	4614      	mov	r4, r2
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
    4230:	1ad2      	subs	r2, r2, r3

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    4232:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4236:	4299      	cmp	r1, r3
    4238:	d1e2      	bne.n	4200 <am_hal_ctimer_period_set+0x30>
    {
        //
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    423a:	b297      	uxth	r7, r2
    423c:	433d      	orrs	r5, r7
    423e:	5185      	str	r5, [r0, r6]
    4240:	e7e9      	b.n	4216 <am_hal_ctimer_period_set+0x46>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    4242:	2500      	movs	r5, #0
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    {
        //
        // For timer B, write the values to the TIMERA compare register.
        //
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    4244:	b296      	uxth	r6, r2
    4246:	4335      	orrs	r5, r6
    4248:	51c5      	str	r5, [r0, r7]
    424a:	e7e4      	b.n	4216 <am_hal_ctimer_period_set+0x46>
    424c:	4000800c 	.word	0x4000800c
    4250:	40008004 	.word	0x40008004
    4254:	40008008 	.word	0x40008008

00004258 <am_hal_i2c_bit_bang_receive>:
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    4258:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    425c:	4c9c      	ldr	r4, [pc, #624]	; (44d0 <am_hal_i2c_bit_bang_receive+0x278>)
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    425e:	b085      	sub	sp, #20
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4260:	68e6      	ldr	r6, [r4, #12]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    4262:	f89d 5038 	ldrb.w	r5, [sp, #56]	; 0x38
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4266:	69a7      	ldr	r7, [r4, #24]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    4268:	9503      	str	r5, [sp, #12]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    426a:	6965      	ldr	r5, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    426c:	6037      	str	r7, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    426e:	682d      	ldr	r5, [r5, #0]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    4270:	f89d b03c 	ldrb.w	fp, [sp, #60]	; 0x3c
    4274:	9101      	str	r1, [sp, #4]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4276:	422f      	tst	r7, r5
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    4278:	4680      	mov	r8, r0
    427a:	4691      	mov	r9, r2
    427c:	9302      	str	r3, [sp, #8]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    427e:	bf08      	it	eq
    4280:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4284:	d14c      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4286:	2004      	movs	r0, #4
    4288:	f7fd f9c2 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    428c:	6962      	ldr	r2, [r4, #20]
    428e:	69a3      	ldr	r3, [r4, #24]
    4290:	6811      	ldr	r1, [r2, #0]
    4292:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4294:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4298:	d142      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    429a:	f7fd f9b9 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    429e:	6966      	ldr	r6, [r4, #20]
    42a0:	69a7      	ldr	r7, [r4, #24]
    42a2:	6832      	ldr	r2, [r6, #0]
    42a4:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42a6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42aa:	d139      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42ac:	f7fd f9b0 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42b0:	6961      	ldr	r1, [r4, #20]
    42b2:	69a3      	ldr	r3, [r4, #24]
    42b4:	680e      	ldr	r6, [r1, #0]
    42b6:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42b8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42bc:	d130      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42be:	f7fd f9a7 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42c2:	6967      	ldr	r7, [r4, #20]
    42c4:	69a1      	ldr	r1, [r4, #24]
    42c6:	683a      	ldr	r2, [r7, #0]
    42c8:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42ca:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42ce:	d127      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42d0:	f7fd f99e 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42d4:	6966      	ldr	r6, [r4, #20]
    42d6:	69a3      	ldr	r3, [r4, #24]
    42d8:	6837      	ldr	r7, [r6, #0]
    42da:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42dc:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42e0:	d11e      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42e2:	f7fd f995 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42e6:	6961      	ldr	r1, [r4, #20]
    42e8:	69a6      	ldr	r6, [r4, #24]
    42ea:	680a      	ldr	r2, [r1, #0]
    42ec:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42ee:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42f2:	d115      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    42f4:	f7fd f98c 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    42f8:	6967      	ldr	r7, [r4, #20]
    42fa:	69a3      	ldr	r3, [r4, #24]
    42fc:	6839      	ldr	r1, [r7, #0]
    42fe:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4300:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4304:	d10c      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4306:	f7fd f983 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    430a:	6960      	ldr	r0, [r4, #20]
    430c:	69a6      	ldr	r6, [r4, #24]
    430e:	6802      	ldr	r2, [r0, #0]
    4310:	4232      	tst	r2, r6
    4312:	d105      	bne.n	4320 <am_hal_i2c_bit_bang_receive+0xc8>
    {
        if (--maxLoop == 0)
    4314:	3d08      	subs	r5, #8
    4316:	d1b6      	bne.n	4286 <am_hal_i2c_bit_bang_receive+0x2e>
    status = i2c_send_byte(address);
    if ( status != AM_HAL_I2C_BIT_BANG_SUCCESS )
    {
        if ( status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
        {
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    4318:	2003      	movs	r0, #3

    //
    // message successfully received (how could we fail???)
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
}
    431a:	b005      	add	sp, #20
    431c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Pull down on data line with clock high --> START CONDITION
    //
    WRITE_SDA_LO();
    4320:	6a27      	ldr	r7, [r4, #32]
    4322:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4324:	603b      	str	r3, [r7, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4326:	2005      	movs	r0, #5
    4328:	f7fd f972 	bl	1610 <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    432c:	4f68      	ldr	r7, [pc, #416]	; (44d0 <am_hal_i2c_bit_bang_receive+0x278>)
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    432e:	2600      	movs	r6, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    4330:	f04f 0a80 	mov.w	sl, #128	; 0x80
    4334:	fa4a f306 	asr.w	r3, sl, r6
    4338:	ea13 0f08 	tst.w	r3, r8
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    433c:	6921      	ldr	r1, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    433e:	bf14      	ite	ne
    4340:	69fb      	ldrne	r3, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    4342:	6a3b      	ldreq	r3, [r7, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4344:	69a0      	ldr	r0, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    4346:	6aba      	ldr	r2, [r7, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4348:	6008      	str	r0, [r1, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    434a:	601a      	str	r2, [r3, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    434c:	2007      	movs	r0, #7
    434e:	f7fd f95f 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4352:	68e1      	ldr	r1, [r4, #12]
    4354:	69a0      	ldr	r0, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4356:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4358:	6008      	str	r0, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    435a:	681a      	ldr	r2, [r3, #0]
    435c:	4210      	tst	r0, r2
    435e:	bf08      	it	eq
    4360:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4364:	d149      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4366:	2004      	movs	r0, #4
    4368:	f7fd f952 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    436c:	6961      	ldr	r1, [r4, #20]
    436e:	69a3      	ldr	r3, [r4, #24]
    4370:	680a      	ldr	r2, [r1, #0]
    4372:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4374:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4378:	d13f      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    437a:	f7fd f949 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    437e:	6961      	ldr	r1, [r4, #20]
    4380:	69a3      	ldr	r3, [r4, #24]
    4382:	680a      	ldr	r2, [r1, #0]
    4384:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4386:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    438a:	d136      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    438c:	f7fd f940 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4390:	6961      	ldr	r1, [r4, #20]
    4392:	69a3      	ldr	r3, [r4, #24]
    4394:	680a      	ldr	r2, [r1, #0]
    4396:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4398:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    439c:	d12d      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    439e:	f7fd f937 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43a2:	6961      	ldr	r1, [r4, #20]
    43a4:	69a3      	ldr	r3, [r4, #24]
    43a6:	680a      	ldr	r2, [r1, #0]
    43a8:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43aa:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43ae:	d124      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43b0:	f7fd f92e 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43b4:	6961      	ldr	r1, [r4, #20]
    43b6:	69a3      	ldr	r3, [r4, #24]
    43b8:	680a      	ldr	r2, [r1, #0]
    43ba:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43bc:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43c0:	d11b      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43c2:	f7fd f925 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43c6:	6961      	ldr	r1, [r4, #20]
    43c8:	69a3      	ldr	r3, [r4, #24]
    43ca:	680a      	ldr	r2, [r1, #0]
    43cc:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43ce:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43d2:	d112      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43d4:	f7fd f91c 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43d8:	6961      	ldr	r1, [r4, #20]
    43da:	69a3      	ldr	r3, [r4, #24]
    43dc:	680a      	ldr	r2, [r1, #0]
    43de:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43e0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43e4:	d109      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    43e6:	f7fd f913 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    43ea:	6960      	ldr	r0, [r4, #20]
    43ec:	69a1      	ldr	r1, [r4, #24]
    43ee:	6803      	ldr	r3, [r0, #0]
    43f0:	420b      	tst	r3, r1
    43f2:	d102      	bne.n	43fa <am_hal_i2c_bit_bang_receive+0x1a2>
    {
        if (--maxLoop == 0)
    43f4:	3d08      	subs	r5, #8
    43f6:	d1b6      	bne.n	4366 <am_hal_i2c_bit_bang_receive+0x10e>
    43f8:	e78e      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    43fa:	3601      	adds	r6, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    43fc:	2005      	movs	r0, #5
    43fe:	f7fd f907 	bl	1610 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4402:	2e08      	cmp	r6, #8
    4404:	d196      	bne.n	4334 <am_hal_i2c_bit_bang_receive+0xdc>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    4406:	6927      	ldr	r7, [r4, #16]
    4408:	69a2      	ldr	r2, [r4, #24]
    440a:	603a      	str	r2, [r7, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    440c:	2007      	movs	r0, #7
    440e:	f7fd f8ff 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4412:	68e0      	ldr	r0, [r4, #12]
    4414:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4416:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4418:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    441a:	681f      	ldr	r7, [r3, #0]
    441c:	4239      	tst	r1, r7
    441e:	bf08      	it	eq
    4420:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4424:	d149      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4426:	2004      	movs	r0, #4
    4428:	f7fd f8f2 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    442c:	6962      	ldr	r2, [r4, #20]
    442e:	69a1      	ldr	r1, [r4, #24]
    4430:	6813      	ldr	r3, [r2, #0]
    4432:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4434:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4438:	d13f      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    443a:	f7fd f8e9 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    443e:	6967      	ldr	r7, [r4, #20]
    4440:	69a1      	ldr	r1, [r4, #24]
    4442:	683a      	ldr	r2, [r7, #0]
    4444:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4446:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    444a:	d136      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    444c:	f7fd f8e0 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4450:	6967      	ldr	r7, [r4, #20]
    4452:	69a3      	ldr	r3, [r4, #24]
    4454:	6839      	ldr	r1, [r7, #0]
    4456:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4458:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    445c:	d12d      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    445e:	f7fd f8d7 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4462:	6962      	ldr	r2, [r4, #20]
    4464:	69a7      	ldr	r7, [r4, #24]
    4466:	6813      	ldr	r3, [r2, #0]
    4468:	423b      	tst	r3, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    446a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    446e:	d124      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4470:	f7fd f8ce 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4474:	6961      	ldr	r1, [r4, #20]
    4476:	69a7      	ldr	r7, [r4, #24]
    4478:	680a      	ldr	r2, [r1, #0]
    447a:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    447c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4480:	d11b      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4482:	f7fd f8c5 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4486:	6961      	ldr	r1, [r4, #20]
    4488:	69a3      	ldr	r3, [r4, #24]
    448a:	680f      	ldr	r7, [r1, #0]
    448c:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    448e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4492:	d112      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4494:	f7fd f8bc 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4498:	6962      	ldr	r2, [r4, #20]
    449a:	69a1      	ldr	r1, [r4, #24]
    449c:	6813      	ldr	r3, [r2, #0]
    449e:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    44a0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    44a4:	d109      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    44a6:	f7fd f8b3 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    44aa:	6960      	ldr	r0, [r4, #20]
    44ac:	69a7      	ldr	r7, [r4, #24]
    44ae:	6802      	ldr	r2, [r0, #0]
    44b0:	423a      	tst	r2, r7
    44b2:	d102      	bne.n	44ba <am_hal_i2c_bit_bang_receive+0x262>
    {
        if (--maxLoop == 0)
    44b4:	3d08      	subs	r5, #8
    44b6:	d1b6      	bne.n	4426 <am_hal_i2c_bit_bang_receive+0x1ce>
    44b8:	e72e      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    44ba:	6a65      	ldr	r5, [r4, #36]	; 0x24
    44bc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    44be:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    44c0:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    44c2:	400d      	ands	r5, r1
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    44c4:	f7fd f8a4 	bl	1610 <am_hal_flash_delay>
    if ( data_naked )
    44c8:	b125      	cbz	r5, 44d4 <am_hal_i2c_bit_bang_receive+0x27c>
    status = i2c_send_byte(address);
    if ( status != AM_HAL_I2C_BIT_BANG_SUCCESS )
    {
        if ( status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
        {
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    44ca:	2001      	movs	r0, #1
    44cc:	e725      	b.n	431a <am_hal_i2c_bit_bang_receive+0xc2>
    44ce:	bf00      	nop
    44d0:	100011bc 	.word	0x100011bc
        }
        return status;
    }

    if ( bUseOffset )
    44d4:	9b03      	ldr	r3, [sp, #12]
    44d6:	2b00      	cmp	r3, #0
    44d8:	f040 81b5 	bne.w	4846 <am_hal_i2c_bit_bang_receive+0x5ee>
    }

    //
    // receive the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    44dc:	9f01      	ldr	r7, [sp, #4]
    44de:	f1b7 0a01 	subs.w	sl, r7, #1
    44e2:	f000 80d8 	beq.w	4696 <am_hal_i2c_bit_bang_receive+0x43e>
    44e6:	46c8      	mov	r8, r9
    44e8:	44ca      	add	sl, r9
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    44ea:	2700      	movs	r7, #0
    44ec:	463e      	mov	r6, r7
        if ( GET_SDA() )
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    44ee:	f04f 0980 	mov.w	r9, #128	; 0x80
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    44f2:	6921      	ldr	r1, [r4, #16]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    44f4:	69e3      	ldr	r3, [r4, #28]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    44f6:	69a0      	ldr	r0, [r4, #24]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    44f8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    44fa:	6008      	str	r0, [r1, #0]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    44fc:	601a      	str	r2, [r3, #0]

        //
        // Delay for 1/2 bit cell time to start the clock and let peer write on SDA
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    44fe:	2007      	movs	r0, #7
    4500:	f7fd f886 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4504:	68e1      	ldr	r1, [r4, #12]
    4506:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4508:	6960      	ldr	r0, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    450a:	600b      	str	r3, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    450c:	6802      	ldr	r2, [r0, #0]
    450e:	4213      	tst	r3, r2
    4510:	bf08      	it	eq
    4512:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4516:	d149      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4518:	2004      	movs	r0, #4
    451a:	f7fd f879 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    451e:	6961      	ldr	r1, [r4, #20]
    4520:	69a3      	ldr	r3, [r4, #24]
    4522:	680a      	ldr	r2, [r1, #0]
    4524:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4526:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    452a:	d13f      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    452c:	f7fd f870 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4530:	6961      	ldr	r1, [r4, #20]
    4532:	69a3      	ldr	r3, [r4, #24]
    4534:	680a      	ldr	r2, [r1, #0]
    4536:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4538:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    453c:	d136      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    453e:	f7fd f867 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4542:	6961      	ldr	r1, [r4, #20]
    4544:	69a3      	ldr	r3, [r4, #24]
    4546:	680a      	ldr	r2, [r1, #0]
    4548:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    454a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    454e:	d12d      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4550:	f7fd f85e 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4554:	6961      	ldr	r1, [r4, #20]
    4556:	69a3      	ldr	r3, [r4, #24]
    4558:	680a      	ldr	r2, [r1, #0]
    455a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    455c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4560:	d124      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4562:	f7fd f855 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4566:	6961      	ldr	r1, [r4, #20]
    4568:	69a3      	ldr	r3, [r4, #24]
    456a:	680a      	ldr	r2, [r1, #0]
    456c:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    456e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4572:	d11b      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4574:	f7fd f84c 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4578:	6961      	ldr	r1, [r4, #20]
    457a:	69a3      	ldr	r3, [r4, #24]
    457c:	680a      	ldr	r2, [r1, #0]
    457e:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4580:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4584:	d112      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4586:	f7fd f843 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    458a:	6961      	ldr	r1, [r4, #20]
    458c:	69a3      	ldr	r3, [r4, #24]
    458e:	680a      	ldr	r2, [r1, #0]
    4590:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4592:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4596:	d109      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4598:	f7fd f83a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    459c:	6960      	ldr	r0, [r4, #20]
    459e:	69a1      	ldr	r1, [r4, #24]
    45a0:	6803      	ldr	r3, [r0, #0]
    45a2:	420b      	tst	r3, r1
    45a4:	d102      	bne.n	45ac <am_hal_i2c_bit_bang_receive+0x354>
    {
        if (--maxLoop == 0)
    45a6:	3d08      	subs	r5, #8
    45a8:	d1b6      	bne.n	4518 <am_hal_i2c_bit_bang_receive+0x2c0>
    45aa:	e6b5      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // grab the data bit here
        //
        if ( GET_SDA() )
    45ac:	6a62      	ldr	r2, [r4, #36]	; 0x24
    45ae:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    45b0:	6811      	ldr	r1, [r2, #0]
    45b2:	4201      	tst	r1, r0
    45b4:	d003      	beq.n	45be <am_hal_i2c_bit_bang_receive+0x366>
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    45b6:	fa49 f306 	asr.w	r3, r9, r6
    45ba:	431f      	orrs	r7, r3
    45bc:	b2ff      	uxtb	r7, r7
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    45be:	3601      	adds	r6, #1
        }

        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    45c0:	2005      	movs	r0, #5
    45c2:	f7fd f825 	bl	1610 <am_hal_flash_delay>
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    45c6:	2e08      	cmp	r6, #8
    45c8:	d193      	bne.n	44f2 <am_hal_i2c_bit_bang_receive+0x29a>

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    45ca:	6921      	ldr	r1, [r4, #16]
    else
    {
        //
        // Pull down on data line with clock low to indicate ACK
        //
        WRITE_SDA_LO();
    45cc:	6a26      	ldr	r6, [r4, #32]

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    45ce:	69a0      	ldr	r0, [r4, #24]
    else
    {
        //
        // Pull down on data line with clock low to indicate ACK
        //
        WRITE_SDA_LO();
    45d0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    }

    *pRxByte = data_byte;
    45d2:	f808 7b01 	strb.w	r7, [r8], #1
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    45d6:	6008      	str	r0, [r1, #0]
    else
    {
        //
        // Pull down on data line with clock low to indicate ACK
        //
        WRITE_SDA_LO();
    45d8:	6032      	str	r2, [r6, #0]
    }
    //
    // Delay for 1/2 bit cell time before sending ACK to device
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    45da:	2007      	movs	r0, #7
    45dc:	f7fd f818 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    45e0:	68e7      	ldr	r7, [r4, #12]
    45e2:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    45e4:	6961      	ldr	r1, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    45e6:	603b      	str	r3, [r7, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    45e8:	680e      	ldr	r6, [r1, #0]
    45ea:	421e      	tst	r6, r3
    45ec:	bf08      	it	eq
    45ee:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    45f2:	d149      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    45f4:	2004      	movs	r0, #4
    45f6:	f7fd f80b 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    45fa:	6962      	ldr	r2, [r4, #20]
    45fc:	69a7      	ldr	r7, [r4, #24]
    45fe:	6813      	ldr	r3, [r2, #0]
    4600:	423b      	tst	r3, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4602:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4606:	d13f      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4608:	f7fd f802 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    460c:	6961      	ldr	r1, [r4, #20]
    460e:	69a6      	ldr	r6, [r4, #24]
    4610:	680a      	ldr	r2, [r1, #0]
    4612:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4614:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4618:	d136      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    461a:	f7fc fff9 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    461e:	6967      	ldr	r7, [r4, #20]
    4620:	69a3      	ldr	r3, [r4, #24]
    4622:	6839      	ldr	r1, [r7, #0]
    4624:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4626:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    462a:	d12d      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    462c:	f7fc fff0 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4630:	6966      	ldr	r6, [r4, #20]
    4632:	69a7      	ldr	r7, [r4, #24]
    4634:	6832      	ldr	r2, [r6, #0]
    4636:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4638:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    463c:	d124      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    463e:	f7fc ffe7 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4642:	6961      	ldr	r1, [r4, #20]
    4644:	69a3      	ldr	r3, [r4, #24]
    4646:	680e      	ldr	r6, [r1, #0]
    4648:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    464a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    464e:	d11b      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4650:	f7fc ffde 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4654:	6967      	ldr	r7, [r4, #20]
    4656:	69a1      	ldr	r1, [r4, #24]
    4658:	683a      	ldr	r2, [r7, #0]
    465a:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    465c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4660:	d112      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4662:	f7fc ffd5 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4666:	6966      	ldr	r6, [r4, #20]
    4668:	69a3      	ldr	r3, [r4, #24]
    466a:	6837      	ldr	r7, [r6, #0]
    466c:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    466e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4672:	d109      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4674:	f7fc ffcc 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4678:	6960      	ldr	r0, [r4, #20]
    467a:	69a1      	ldr	r1, [r4, #24]
    467c:	6802      	ldr	r2, [r0, #0]
    467e:	420a      	tst	r2, r1
    4680:	d102      	bne.n	4688 <am_hal_i2c_bit_bang_receive+0x430>
    {
        if (--maxLoop == 0)
    4682:	3d08      	subs	r5, #8
    4684:	d1b6      	bne.n	45f4 <am_hal_i2c_bit_bang_receive+0x39c>
    4686:	e647      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high to le peer sample the ACK/NAK
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4688:	2005      	movs	r0, #5
    468a:	f7fc ffc1 	bl	1610 <am_hal_flash_delay>
    }

    //
    // receive the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    468e:	45d0      	cmp	r8, sl
        status = i2c_receive_byte(pData, false);
        if (status != AM_HAL_I2C_BIT_BANG_SUCCESS)
        {
            return status;
        }
        pData++;
    4690:	46c1      	mov	r9, r8
    }

    //
    // receive the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    4692:	f47f af2a 	bne.w	44ea <am_hal_i2c_bit_bang_receive+0x292>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4696:	2600      	movs	r6, #0
    4698:	4637      	mov	r7, r6
        if ( GET_SDA() )
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    469a:	f04f 0880 	mov.w	r8, #128	; 0x80
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    469e:	6920      	ldr	r0, [r4, #16]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    46a0:	69e3      	ldr	r3, [r4, #28]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    46a2:	69a1      	ldr	r1, [r4, #24]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    46a4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    46a6:	6001      	str	r1, [r0, #0]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    46a8:	601a      	str	r2, [r3, #0]

        //
        // Delay for 1/2 bit cell time to start the clock and let peer write on SDA
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    46aa:	2007      	movs	r0, #7
    46ac:	f7fc ffb0 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    46b0:	68e0      	ldr	r0, [r4, #12]
    46b2:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46b4:	6961      	ldr	r1, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    46b6:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46b8:	680a      	ldr	r2, [r1, #0]
    46ba:	4213      	tst	r3, r2
    46bc:	bf08      	it	eq
    46be:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    46c2:	d149      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    46c4:	2004      	movs	r0, #4
    46c6:	f7fc ffa3 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46ca:	6961      	ldr	r1, [r4, #20]
    46cc:	69a3      	ldr	r3, [r4, #24]
    46ce:	680a      	ldr	r2, [r1, #0]
    46d0:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    46d2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46d6:	d13f      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    46d8:	f7fc ff9a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46dc:	6961      	ldr	r1, [r4, #20]
    46de:	69a3      	ldr	r3, [r4, #24]
    46e0:	680a      	ldr	r2, [r1, #0]
    46e2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    46e4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46e8:	d136      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    46ea:	f7fc ff91 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46ee:	6961      	ldr	r1, [r4, #20]
    46f0:	69a3      	ldr	r3, [r4, #24]
    46f2:	680a      	ldr	r2, [r1, #0]
    46f4:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    46f6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    46fa:	d12d      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    46fc:	f7fc ff88 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4700:	6961      	ldr	r1, [r4, #20]
    4702:	69a3      	ldr	r3, [r4, #24]
    4704:	680a      	ldr	r2, [r1, #0]
    4706:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4708:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    470c:	d124      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    470e:	f7fc ff7f 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4712:	6961      	ldr	r1, [r4, #20]
    4714:	69a3      	ldr	r3, [r4, #24]
    4716:	680a      	ldr	r2, [r1, #0]
    4718:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    471a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    471e:	d11b      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4720:	f7fc ff76 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4724:	6961      	ldr	r1, [r4, #20]
    4726:	69a3      	ldr	r3, [r4, #24]
    4728:	680a      	ldr	r2, [r1, #0]
    472a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    472c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4730:	d112      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4732:	f7fc ff6d 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4736:	6961      	ldr	r1, [r4, #20]
    4738:	69a3      	ldr	r3, [r4, #24]
    473a:	680a      	ldr	r2, [r1, #0]
    473c:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    473e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4742:	d109      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4744:	f7fc ff64 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4748:	6960      	ldr	r0, [r4, #20]
    474a:	69a1      	ldr	r1, [r4, #24]
    474c:	6803      	ldr	r3, [r0, #0]
    474e:	420b      	tst	r3, r1
    4750:	d102      	bne.n	4758 <am_hal_i2c_bit_bang_receive+0x500>
    {
        if (--maxLoop == 0)
    4752:	3d08      	subs	r5, #8
    4754:	d1b6      	bne.n	46c4 <am_hal_i2c_bit_bang_receive+0x46c>
    4756:	e5df      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // grab the data bit here
        //
        if ( GET_SDA() )
    4758:	6a62      	ldr	r2, [r4, #36]	; 0x24
    475a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    475c:	6811      	ldr	r1, [r2, #0]
    475e:	4201      	tst	r1, r0
    4760:	d003      	beq.n	476a <am_hal_i2c_bit_bang_receive+0x512>
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    4762:	fa48 f307 	asr.w	r3, r8, r7
    4766:	431e      	orrs	r6, r3
    4768:	b2f6      	uxtb	r6, r6
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    476a:	3701      	adds	r7, #1
        }

        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    476c:	2005      	movs	r0, #5
    476e:	f7fc ff4f 	bl	1610 <am_hal_flash_delay>
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    4772:	2f08      	cmp	r7, #8
    4774:	d193      	bne.n	469e <am_hal_i2c_bit_bang_receive+0x446>

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    4776:	6921      	ldr	r1, [r4, #16]
    if (bNack)
    {
        //
        // Pull up on data line with clock low to indicate NAK
        //
        PULL_SDA_HI();
    4778:	69e7      	ldr	r7, [r4, #28]

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    477a:	69a5      	ldr	r5, [r4, #24]
    if (bNack)
    {
        //
        // Pull up on data line with clock low to indicate NAK
        //
        PULL_SDA_HI();
    477c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    }

    *pRxByte = data_byte;
    477e:	f889 6000 	strb.w	r6, [r9]
        WRITE_SDA_LO();
    }
    //
    // Delay for 1/2 bit cell time before sending ACK to device
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    4782:	2007      	movs	r0, #7

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    4784:	600d      	str	r5, [r1, #0]
    if (bNack)
    {
        //
        // Pull up on data line with clock low to indicate NAK
        //
        PULL_SDA_HI();
    4786:	603a      	str	r2, [r7, #0]
        WRITE_SDA_LO();
    }
    //
    // Delay for 1/2 bit cell time before sending ACK to device
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    4788:	f7fc ff42 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    478c:	68e0      	ldr	r0, [r4, #12]
    478e:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4790:	6966      	ldr	r6, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4792:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4794:	6831      	ldr	r1, [r6, #0]
    4796:	420b      	tst	r3, r1
    4798:	bf08      	it	eq
    479a:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    479e:	f040 811e 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47a2:	2004      	movs	r0, #4
    47a4:	f7fc ff34 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47a8:	6967      	ldr	r7, [r4, #20]
    47aa:	69a3      	ldr	r3, [r4, #24]
    47ac:	683a      	ldr	r2, [r7, #0]
    47ae:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47b0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47b4:	f040 8113 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47b8:	f7fc ff2a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47bc:	6966      	ldr	r6, [r4, #20]
    47be:	69a1      	ldr	r1, [r4, #24]
    47c0:	6837      	ldr	r7, [r6, #0]
    47c2:	420f      	tst	r7, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47c4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47c8:	f040 8109 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47cc:	f7fc ff20 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47d0:	6962      	ldr	r2, [r4, #20]
    47d2:	69a3      	ldr	r3, [r4, #24]
    47d4:	6816      	ldr	r6, [r2, #0]
    47d6:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47d8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47dc:	f040 80ff 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47e0:	f7fc ff16 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47e4:	6961      	ldr	r1, [r4, #20]
    47e6:	69a7      	ldr	r7, [r4, #24]
    47e8:	680a      	ldr	r2, [r1, #0]
    47ea:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47ec:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47f0:	f040 80f5 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    47f4:	f7fc ff0c 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    47f8:	6966      	ldr	r6, [r4, #20]
    47fa:	69a3      	ldr	r3, [r4, #24]
    47fc:	6831      	ldr	r1, [r6, #0]
    47fe:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4800:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4804:	f040 80eb 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4808:	f7fc ff02 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    480c:	6967      	ldr	r7, [r4, #20]
    480e:	69a6      	ldr	r6, [r4, #24]
    4810:	683a      	ldr	r2, [r7, #0]
    4812:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4814:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4818:	f040 80e1 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    481c:	f7fc fef8 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4820:	6961      	ldr	r1, [r4, #20]
    4822:	69a3      	ldr	r3, [r4, #24]
    4824:	680f      	ldr	r7, [r1, #0]
    4826:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4828:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    482c:	f040 80d7 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4830:	f7fc feee 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4834:	6960      	ldr	r0, [r4, #20]
    4836:	69a6      	ldr	r6, [r4, #24]
    4838:	6802      	ldr	r2, [r0, #0]
    483a:	4232      	tst	r2, r6
    483c:	f040 80cf 	bne.w	49de <am_hal_i2c_bit_bang_receive+0x786>
    {
        if (--maxLoop == 0)
    4840:	3d08      	subs	r5, #8
    4842:	d1ae      	bne.n	47a2 <am_hal_i2c_bit_bang_receive+0x54a>
    4844:	e568      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4846:	4fa4      	ldr	r7, [pc, #656]	; (4ad8 <am_hal_i2c_bit_bang_receive+0x880>)

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    4848:	f04f 0880 	mov.w	r8, #128	; 0x80
    484c:	9b02      	ldr	r3, [sp, #8]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    484e:	6920      	ldr	r0, [r4, #16]
    4850:	69a2      	ldr	r2, [r4, #24]
    4852:	6002      	str	r2, [r0, #0]

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    4854:	fa48 f105 	asr.w	r1, r8, r5
    4858:	4219      	tst	r1, r3
        {
            PULL_SDA_HI();
    485a:	bf14      	ite	ne
    485c:	69f9      	ldrne	r1, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    485e:	6a39      	ldreq	r1, [r7, #32]
    4860:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    4862:	6008      	str	r0, [r1, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    4864:	2007      	movs	r0, #7
    4866:	f7fc fed3 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    486a:	68e1      	ldr	r1, [r4, #12]
    486c:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    486e:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4870:	600b      	str	r3, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4872:	6810      	ldr	r0, [r2, #0]
    4874:	4203      	tst	r3, r0
    4876:	bf08      	it	eq
    4878:	f44f 76c8 	moveq.w	r6, #400	; 0x190
    487c:	d149      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    487e:	2004      	movs	r0, #4
    4880:	f7fc fec6 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4884:	6961      	ldr	r1, [r4, #20]
    4886:	69a3      	ldr	r3, [r4, #24]
    4888:	680a      	ldr	r2, [r1, #0]
    488a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    488c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4890:	d13f      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4892:	f7fc febd 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4896:	6961      	ldr	r1, [r4, #20]
    4898:	69a3      	ldr	r3, [r4, #24]
    489a:	680a      	ldr	r2, [r1, #0]
    489c:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    489e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48a2:	d136      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48a4:	f7fc feb4 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48a8:	6961      	ldr	r1, [r4, #20]
    48aa:	69a3      	ldr	r3, [r4, #24]
    48ac:	680a      	ldr	r2, [r1, #0]
    48ae:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48b0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48b4:	d12d      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48b6:	f7fc feab 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48ba:	6961      	ldr	r1, [r4, #20]
    48bc:	69a3      	ldr	r3, [r4, #24]
    48be:	680a      	ldr	r2, [r1, #0]
    48c0:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48c2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48c6:	d124      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48c8:	f7fc fea2 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48cc:	6961      	ldr	r1, [r4, #20]
    48ce:	69a3      	ldr	r3, [r4, #24]
    48d0:	680a      	ldr	r2, [r1, #0]
    48d2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48d4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48d8:	d11b      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48da:	f7fc fe99 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48de:	6961      	ldr	r1, [r4, #20]
    48e0:	69a3      	ldr	r3, [r4, #24]
    48e2:	680a      	ldr	r2, [r1, #0]
    48e4:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48e6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48ea:	d112      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48ec:	f7fc fe90 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48f0:	6961      	ldr	r1, [r4, #20]
    48f2:	69a3      	ldr	r3, [r4, #24]
    48f4:	680a      	ldr	r2, [r1, #0]
    48f6:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48f8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    48fc:	d109      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    48fe:	f7fc fe87 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4902:	6960      	ldr	r0, [r4, #20]
    4904:	69a1      	ldr	r1, [r4, #24]
    4906:	6803      	ldr	r3, [r0, #0]
    4908:	420b      	tst	r3, r1
    490a:	d102      	bne.n	4912 <am_hal_i2c_bit_bang_receive+0x6ba>
    {
        if (--maxLoop == 0)
    490c:	3e08      	subs	r6, #8
    490e:	d1b6      	bne.n	487e <am_hal_i2c_bit_bang_receive+0x626>
    4910:	e502      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4912:	3501      	adds	r5, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    4914:	2005      	movs	r0, #5
    4916:	f7fc fe7b 	bl	1610 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    491a:	2d08      	cmp	r5, #8
    491c:	d196      	bne.n	484c <am_hal_i2c_bit_bang_receive+0x5f4>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    491e:	6926      	ldr	r6, [r4, #16]
    4920:	69a7      	ldr	r7, [r4, #24]
    4922:	6037      	str	r7, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    4924:	2007      	movs	r0, #7
    4926:	f7fc fe73 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    492a:	68e0      	ldr	r0, [r4, #12]
    492c:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    492e:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4930:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4932:	6813      	ldr	r3, [r2, #0]
    4934:	4219      	tst	r1, r3
    4936:	bf08      	it	eq
    4938:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    493c:	f040 80b5 	bne.w	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4940:	2004      	movs	r0, #4
    4942:	f7fc fe65 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4946:	6966      	ldr	r6, [r4, #20]
    4948:	69a7      	ldr	r7, [r4, #24]
    494a:	6831      	ldr	r1, [r6, #0]
    494c:	4239      	tst	r1, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    494e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4952:	f040 80aa 	bne.w	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4956:	f7fc fe5b 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    495a:	6962      	ldr	r2, [r4, #20]
    495c:	69a3      	ldr	r3, [r4, #24]
    495e:	6816      	ldr	r6, [r2, #0]
    4960:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4962:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4966:	f040 80a0 	bne.w	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    496a:	f7fc fe51 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    496e:	6967      	ldr	r7, [r4, #20]
    4970:	69a1      	ldr	r1, [r4, #24]
    4972:	683a      	ldr	r2, [r7, #0]
    4974:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4976:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    497a:	f040 8096 	bne.w	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    497e:	f7fc fe47 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4982:	6966      	ldr	r6, [r4, #20]
    4984:	69a3      	ldr	r3, [r4, #24]
    4986:	6837      	ldr	r7, [r6, #0]
    4988:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    498a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    498e:	f040 808c 	bne.w	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4992:	f7fc fe3d 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4996:	6961      	ldr	r1, [r4, #20]
    4998:	69a6      	ldr	r6, [r4, #24]
    499a:	680a      	ldr	r2, [r1, #0]
    499c:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    499e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    49a2:	f040 8082 	bne.w	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    49a6:	f7fc fe33 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    49aa:	6967      	ldr	r7, [r4, #20]
    49ac:	69a3      	ldr	r3, [r4, #24]
    49ae:	6839      	ldr	r1, [r7, #0]
    49b0:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    49b2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    49b6:	d178      	bne.n	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    49b8:	f7fc fe2a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    49bc:	6966      	ldr	r6, [r4, #20]
    49be:	69a7      	ldr	r7, [r4, #24]
    49c0:	6832      	ldr	r2, [r6, #0]
    49c2:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    49c4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    49c8:	d16f      	bne.n	4aaa <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    49ca:	f7fc fe21 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    49ce:	6960      	ldr	r0, [r4, #20]
    49d0:	69a3      	ldr	r3, [r4, #24]
    49d2:	6801      	ldr	r1, [r0, #0]
    49d4:	4219      	tst	r1, r3
    49d6:	d168      	bne.n	4aaa <am_hal_i2c_bit_bang_receive+0x852>
    {
        if (--maxLoop == 0)
    49d8:	3d08      	subs	r5, #8
    49da:	d1b1      	bne.n	4940 <am_hal_i2c_bit_bang_receive+0x6e8>
    49dc:	e49c      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high to le peer sample the ACK/NAK
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    49de:	2005      	movs	r0, #5
    49e0:	f7fc fe16 	bl	1610 <am_hal_flash_delay>
    // Send stop condition
    //********************
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    49e4:	6925      	ldr	r5, [r4, #16]
    49e6:	69a1      	ldr	r1, [r4, #24]
    49e8:	6029      	str	r1, [r5, #0]

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    49ea:	2004      	movs	r0, #4
    // Send stop condition
    //********************
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    49ec:	4f3a      	ldr	r7, [pc, #232]	; (4ad8 <am_hal_i2c_bit_bang_receive+0x880>)

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    49ee:	f7fc fe0f 	bl	1610 <am_hal_flash_delay>


    if (!bNoStop)
    49f2:	f1bb 0f00 	cmp.w	fp, #0
    49f6:	d171      	bne.n	4adc <am_hal_i2c_bit_bang_receive+0x884>
    {
        //
        // Pull down on data line with clock low
        //
        WRITE_SDA_LO();
    49f8:	6a3b      	ldr	r3, [r7, #32]
    49fa:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    49fc:	6018      	str	r0, [r3, #0]
    }
    //
    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    49fe:	2004      	movs	r0, #4
    4a00:	f7fc fe06 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4a04:	68fe      	ldr	r6, [r7, #12]
    4a06:	69bd      	ldr	r5, [r7, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a08:	697f      	ldr	r7, [r7, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4a0a:	6035      	str	r5, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a0c:	683a      	ldr	r2, [r7, #0]
    4a0e:	422a      	tst	r2, r5
    4a10:	d176      	bne.n	4b00 <am_hal_i2c_bit_bang_receive+0x8a8>
    4a12:	f44f 76c8 	mov.w	r6, #400	; 0x190
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a16:	2004      	movs	r0, #4
    4a18:	f7fc fdfa 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a1c:	6961      	ldr	r1, [r4, #20]
    4a1e:	69a3      	ldr	r3, [r4, #24]
    4a20:	680d      	ldr	r5, [r1, #0]
    4a22:	421d      	tst	r5, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a24:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a28:	d14b      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a2a:	f7fc fdf1 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a2e:	6967      	ldr	r7, [r4, #20]
    4a30:	69a1      	ldr	r1, [r4, #24]
    4a32:	683a      	ldr	r2, [r7, #0]
    4a34:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a36:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a3a:	d142      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a3c:	f7fc fde8 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a40:	6965      	ldr	r5, [r4, #20]
    4a42:	69a3      	ldr	r3, [r4, #24]
    4a44:	682f      	ldr	r7, [r5, #0]
    4a46:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a48:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a4c:	d139      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a4e:	f7fc fddf 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a52:	6961      	ldr	r1, [r4, #20]
    4a54:	69a5      	ldr	r5, [r4, #24]
    4a56:	680a      	ldr	r2, [r1, #0]
    4a58:	422a      	tst	r2, r5
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a5a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a5e:	d130      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a60:	f7fc fdd6 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a64:	6967      	ldr	r7, [r4, #20]
    4a66:	69a3      	ldr	r3, [r4, #24]
    4a68:	6839      	ldr	r1, [r7, #0]
    4a6a:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a6c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a70:	d127      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a72:	f7fc fdcd 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a76:	6965      	ldr	r5, [r4, #20]
    4a78:	69a7      	ldr	r7, [r4, #24]
    4a7a:	682a      	ldr	r2, [r5, #0]
    4a7c:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a7e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a82:	d11e      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a84:	f7fc fdc4 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a88:	6961      	ldr	r1, [r4, #20]
    4a8a:	69a3      	ldr	r3, [r4, #24]
    4a8c:	680d      	ldr	r5, [r1, #0]
    4a8e:	421d      	tst	r5, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a90:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a94:	d115      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4a96:	f7fc fdbb 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4a9a:	6960      	ldr	r0, [r4, #20]
    4a9c:	69a7      	ldr	r7, [r4, #24]
    4a9e:	6802      	ldr	r2, [r0, #0]
    4aa0:	423a      	tst	r2, r7
    4aa2:	d10e      	bne.n	4ac2 <am_hal_i2c_bit_bang_receive+0x86a>
    {
        if (--maxLoop == 0)
    4aa4:	3e08      	subs	r6, #8
    4aa6:	d1b6      	bne.n	4a16 <am_hal_i2c_bit_bang_receive+0x7be>
    4aa8:	e436      	b.n	4318 <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    4aaa:	6a65      	ldr	r5, [r4, #36]	; 0x24
    4aac:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    4aae:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4ab0:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    4ab2:	4035      	ands	r5, r6
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4ab4:	f7fc fdac 	bl	1610 <am_hal_flash_delay>
    if ( data_naked )
    4ab8:	2d00      	cmp	r5, #0
    4aba:	f43f ad0f 	beq.w	44dc <am_hal_i2c_bit_bang_receive+0x284>
    {
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;
    4abe:	2002      	movs	r0, #2
    4ac0:	e42b      	b.n	431a <am_hal_i2c_bit_bang_receive+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4ac2:	2005      	movs	r0, #5
    4ac4:	f7fc fda4 	bl	1610 <am_hal_flash_delay>

    if (!bNoStop)
    4ac8:	f1bb 0f00 	cmp.w	fp, #0
    4acc:	d116      	bne.n	4afc <am_hal_i2c_bit_bang_receive+0x8a4>
    {
        //
        // release data line with clock high --> STOP CONDITION
        //
        PULL_SDA_HI();
    4ace:	69e6      	ldr	r6, [r4, #28]
    4ad0:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    4ad2:	6034      	str	r4, [r6, #0]
    }

    //
    // message successfully received (how could we fail???)
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    4ad4:	2000      	movs	r0, #0
    4ad6:	e420      	b.n	431a <am_hal_i2c_bit_bang_receive+0xc2>
    4ad8:	100011bc 	.word	0x100011bc
    else
    {
        //
        // Release data line with clock low itself, as we are not sending STOP
        //
        PULL_SDA_HI();
    4adc:	69fb      	ldr	r3, [r7, #28]
    4ade:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    4ae0:	6018      	str	r0, [r3, #0]
    }
    //
    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    4ae2:	2004      	movs	r0, #4
    4ae4:	f7fc fd94 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4ae8:	68fe      	ldr	r6, [r7, #12]
    4aea:	69bd      	ldr	r5, [r7, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4aec:	697a      	ldr	r2, [r7, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4aee:	6035      	str	r5, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4af0:	6811      	ldr	r1, [r2, #0]
    4af2:	4229      	tst	r1, r5
    4af4:	d08d      	beq.n	4a12 <am_hal_i2c_bit_bang_receive+0x7ba>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4af6:	2005      	movs	r0, #5
    4af8:	f7fc fd8a 	bl	1610 <am_hal_flash_delay>
    }

    //
    // message successfully received (how could we fail???)
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    4afc:	2000      	movs	r0, #0
    4afe:	e40c      	b.n	431a <am_hal_i2c_bit_bang_receive+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4b00:	2005      	movs	r0, #5
    4b02:	f7fc fd85 	bl	1610 <am_hal_flash_delay>
    4b06:	e7e2      	b.n	4ace <am_hal_i2c_bit_bang_receive+0x876>

00004b08 <am_hal_i2c_bit_bang_send>:
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    4b08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4b0c:	4c9c      	ldr	r4, [pc, #624]	; (4d80 <am_hal_i2c_bit_bang_send+0x278>)
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    4b0e:	b085      	sub	sp, #20
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4b10:	68e6      	ldr	r6, [r4, #12]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    4b12:	f89d 5038 	ldrb.w	r5, [sp, #56]	; 0x38
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4b16:	69a7      	ldr	r7, [r4, #24]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    4b18:	9503      	str	r5, [sp, #12]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b1a:	6965      	ldr	r5, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4b1c:	6037      	str	r7, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b1e:	682d      	ldr	r5, [r5, #0]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    4b20:	f89d 603c 	ldrb.w	r6, [sp, #60]	; 0x3c
    4b24:	9602      	str	r6, [sp, #8]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b26:	422f      	tst	r7, r5
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    4b28:	4680      	mov	r8, r0
    4b2a:	9101      	str	r1, [sp, #4]
    4b2c:	4693      	mov	fp, r2
    4b2e:	469a      	mov	sl, r3
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b30:	bf08      	it	eq
    4b32:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4b36:	d14c      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b38:	2004      	movs	r0, #4
    4b3a:	f7fc fd69 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b3e:	6962      	ldr	r2, [r4, #20]
    4b40:	69a3      	ldr	r3, [r4, #24]
    4b42:	6811      	ldr	r1, [r2, #0]
    4b44:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b46:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b4a:	d142      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b4c:	f7fc fd60 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b50:	6967      	ldr	r7, [r4, #20]
    4b52:	69a6      	ldr	r6, [r4, #24]
    4b54:	683a      	ldr	r2, [r7, #0]
    4b56:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b58:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b5c:	d139      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b5e:	f7fc fd57 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b62:	6961      	ldr	r1, [r4, #20]
    4b64:	69a3      	ldr	r3, [r4, #24]
    4b66:	680f      	ldr	r7, [r1, #0]
    4b68:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b6a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b6e:	d130      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b70:	f7fc fd4e 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b74:	6966      	ldr	r6, [r4, #20]
    4b76:	69a1      	ldr	r1, [r4, #24]
    4b78:	6832      	ldr	r2, [r6, #0]
    4b7a:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b7c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b80:	d127      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b82:	f7fc fd45 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b86:	6967      	ldr	r7, [r4, #20]
    4b88:	69a3      	ldr	r3, [r4, #24]
    4b8a:	683e      	ldr	r6, [r7, #0]
    4b8c:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b8e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b92:	d11e      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4b94:	f7fc fd3c 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4b98:	6961      	ldr	r1, [r4, #20]
    4b9a:	69a7      	ldr	r7, [r4, #24]
    4b9c:	680a      	ldr	r2, [r1, #0]
    4b9e:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ba0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ba4:	d115      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ba6:	f7fc fd33 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4baa:	6966      	ldr	r6, [r4, #20]
    4bac:	69a3      	ldr	r3, [r4, #24]
    4bae:	6831      	ldr	r1, [r6, #0]
    4bb0:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4bb2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4bb6:	d10c      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4bb8:	f7fc fd2a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4bbc:	6960      	ldr	r0, [r4, #20]
    4bbe:	69a7      	ldr	r7, [r4, #24]
    4bc0:	6802      	ldr	r2, [r0, #0]
    4bc2:	423a      	tst	r2, r7
    4bc4:	d105      	bne.n	4bd2 <am_hal_i2c_bit_bang_send+0xca>
    {
        if (--maxLoop == 0)
    4bc6:	3d08      	subs	r5, #8
    4bc8:	d1b6      	bne.n	4b38 <am_hal_i2c_bit_bang_send+0x30>
    //
    WAIT_I2C_CLOCK_HI_PERIOD();

    if ( data_naked )
    {
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;  // if it happens early
    4bca:	2003      	movs	r0, #3

    //
    // message successfully sent
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
}
    4bcc:	b005      	add	sp, #20
    4bce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Pull down on data line with clock high --> START CONDITION
    //
    WRITE_SDA_LO();
    4bd2:	6a26      	ldr	r6, [r4, #32]
    4bd4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4bd6:	6033      	str	r3, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4bd8:	2005      	movs	r0, #5
    4bda:	f7fc fd19 	bl	1610 <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4bde:	4f68      	ldr	r7, [pc, #416]	; (4d80 <am_hal_i2c_bit_bang_send+0x278>)
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4be0:	2600      	movs	r6, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    4be2:	f04f 0980 	mov.w	r9, #128	; 0x80
    4be6:	fa49 f306 	asr.w	r3, r9, r6
    4bea:	ea13 0f08 	tst.w	r3, r8
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4bee:	6921      	ldr	r1, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    4bf0:	bf14      	ite	ne
    4bf2:	69fb      	ldrne	r3, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    4bf4:	6a3b      	ldreq	r3, [r7, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4bf6:	69a0      	ldr	r0, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    4bf8:	6aba      	ldr	r2, [r7, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4bfa:	6008      	str	r0, [r1, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    4bfc:	601a      	str	r2, [r3, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    4bfe:	2007      	movs	r0, #7
    4c00:	f7fc fd06 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4c04:	68e1      	ldr	r1, [r4, #12]
    4c06:	69a0      	ldr	r0, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c08:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4c0a:	6008      	str	r0, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c0c:	681a      	ldr	r2, [r3, #0]
    4c0e:	4202      	tst	r2, r0
    4c10:	bf08      	it	eq
    4c12:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4c16:	d149      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c18:	2004      	movs	r0, #4
    4c1a:	f7fc fcf9 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c1e:	6961      	ldr	r1, [r4, #20]
    4c20:	69a3      	ldr	r3, [r4, #24]
    4c22:	680a      	ldr	r2, [r1, #0]
    4c24:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c26:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c2a:	d13f      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c2c:	f7fc fcf0 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c30:	6961      	ldr	r1, [r4, #20]
    4c32:	69a3      	ldr	r3, [r4, #24]
    4c34:	680a      	ldr	r2, [r1, #0]
    4c36:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c38:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c3c:	d136      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c3e:	f7fc fce7 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c42:	6961      	ldr	r1, [r4, #20]
    4c44:	69a3      	ldr	r3, [r4, #24]
    4c46:	680a      	ldr	r2, [r1, #0]
    4c48:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c4a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c4e:	d12d      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c50:	f7fc fcde 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c54:	6961      	ldr	r1, [r4, #20]
    4c56:	69a3      	ldr	r3, [r4, #24]
    4c58:	680a      	ldr	r2, [r1, #0]
    4c5a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c5c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c60:	d124      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c62:	f7fc fcd5 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c66:	6961      	ldr	r1, [r4, #20]
    4c68:	69a3      	ldr	r3, [r4, #24]
    4c6a:	680a      	ldr	r2, [r1, #0]
    4c6c:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c6e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c72:	d11b      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c74:	f7fc fccc 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c78:	6961      	ldr	r1, [r4, #20]
    4c7a:	69a3      	ldr	r3, [r4, #24]
    4c7c:	680a      	ldr	r2, [r1, #0]
    4c7e:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c80:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c84:	d112      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c86:	f7fc fcc3 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c8a:	6961      	ldr	r1, [r4, #20]
    4c8c:	69a3      	ldr	r3, [r4, #24]
    4c8e:	680a      	ldr	r2, [r1, #0]
    4c90:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c92:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c96:	d109      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4c98:	f7fc fcba 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4c9c:	6960      	ldr	r0, [r4, #20]
    4c9e:	69a1      	ldr	r1, [r4, #24]
    4ca0:	6803      	ldr	r3, [r0, #0]
    4ca2:	420b      	tst	r3, r1
    4ca4:	d102      	bne.n	4cac <am_hal_i2c_bit_bang_send+0x1a4>
    {
        if (--maxLoop == 0)
    4ca6:	3d08      	subs	r5, #8
    4ca8:	d1b6      	bne.n	4c18 <am_hal_i2c_bit_bang_send+0x110>
    4caa:	e78e      	b.n	4bca <am_hal_i2c_bit_bang_send+0xc2>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4cac:	3601      	adds	r6, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    4cae:	2005      	movs	r0, #5
    4cb0:	f7fc fcae 	bl	1610 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4cb4:	2e08      	cmp	r6, #8
    4cb6:	d196      	bne.n	4be6 <am_hal_i2c_bit_bang_send+0xde>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    4cb8:	6926      	ldr	r6, [r4, #16]
    4cba:	69a2      	ldr	r2, [r4, #24]
    4cbc:	6032      	str	r2, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    4cbe:	2007      	movs	r0, #7
    4cc0:	f7fc fca6 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4cc4:	68e0      	ldr	r0, [r4, #12]
    4cc6:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4cc8:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4cca:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ccc:	681e      	ldr	r6, [r3, #0]
    4cce:	4231      	tst	r1, r6
    4cd0:	bf08      	it	eq
    4cd2:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4cd6:	d149      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4cd8:	2004      	movs	r0, #4
    4cda:	f7fc fc99 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4cde:	6962      	ldr	r2, [r4, #20]
    4ce0:	69a1      	ldr	r1, [r4, #24]
    4ce2:	6813      	ldr	r3, [r2, #0]
    4ce4:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ce6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4cea:	d13f      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4cec:	f7fc fc90 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4cf0:	6966      	ldr	r6, [r4, #20]
    4cf2:	69a1      	ldr	r1, [r4, #24]
    4cf4:	6832      	ldr	r2, [r6, #0]
    4cf6:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4cf8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4cfc:	d136      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4cfe:	f7fc fc87 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d02:	6966      	ldr	r6, [r4, #20]
    4d04:	69a3      	ldr	r3, [r4, #24]
    4d06:	6831      	ldr	r1, [r6, #0]
    4d08:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d0a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d0e:	d12d      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d10:	f7fc fc7e 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d14:	6962      	ldr	r2, [r4, #20]
    4d16:	69a6      	ldr	r6, [r4, #24]
    4d18:	6813      	ldr	r3, [r2, #0]
    4d1a:	4233      	tst	r3, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d1c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d20:	d124      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d22:	f7fc fc75 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d26:	6961      	ldr	r1, [r4, #20]
    4d28:	69a6      	ldr	r6, [r4, #24]
    4d2a:	680a      	ldr	r2, [r1, #0]
    4d2c:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d2e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d32:	d11b      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d34:	f7fc fc6c 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d38:	6961      	ldr	r1, [r4, #20]
    4d3a:	69a3      	ldr	r3, [r4, #24]
    4d3c:	680e      	ldr	r6, [r1, #0]
    4d3e:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d40:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d44:	d112      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d46:	f7fc fc63 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d4a:	6962      	ldr	r2, [r4, #20]
    4d4c:	69a1      	ldr	r1, [r4, #24]
    4d4e:	6813      	ldr	r3, [r2, #0]
    4d50:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d52:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d56:	d109      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4d58:	f7fc fc5a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4d5c:	6960      	ldr	r0, [r4, #20]
    4d5e:	69a6      	ldr	r6, [r4, #24]
    4d60:	6802      	ldr	r2, [r0, #0]
    4d62:	4232      	tst	r2, r6
    4d64:	d102      	bne.n	4d6c <am_hal_i2c_bit_bang_send+0x264>
    {
        if (--maxLoop == 0)
    4d66:	3d08      	subs	r5, #8
    4d68:	d1b6      	bne.n	4cd8 <am_hal_i2c_bit_bang_send+0x1d0>
    4d6a:	e72e      	b.n	4bca <am_hal_i2c_bit_bang_send+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    4d6c:	6a65      	ldr	r5, [r4, #36]	; 0x24
    4d6e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    4d70:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4d72:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    4d74:	400d      	ands	r5, r1
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4d76:	f7fc fc4b 	bl	1610 <am_hal_flash_delay>
    if ( data_naked )
    4d7a:	b11d      	cbz	r5, 4d84 <am_hal_i2c_bit_bang_send+0x27c>
    status = i2c_send_byte(address);
    if ( status != AM_HAL_I2C_BIT_BANG_SUCCESS )
    {
        if ( status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
        {
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    4d7c:	2001      	movs	r0, #1
    4d7e:	e725      	b.n	4bcc <am_hal_i2c_bit_bang_send+0xc4>
    4d80:	100011bc 	.word	0x100011bc
        }
        return status;
    }

    if ( bUseOffset )
    4d84:	9b03      	ldr	r3, [sp, #12]
    4d86:	2b00      	cmp	r3, #0
    4d88:	f040 8164 	bne.w	5054 <am_hal_i2c_bit_bang_send+0x54c>
    }

    //
    // send the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    4d8c:	9f01      	ldr	r7, [sp, #4]
    4d8e:	2f00      	cmp	r7, #0
    4d90:	f000 80de 	beq.w	4f50 <am_hal_i2c_bit_bang_send+0x448>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4d94:	4fa0      	ldr	r7, [pc, #640]	; (5018 <am_hal_i2c_bit_bang_send+0x510>)
    }

    //
    // send the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    4d96:	f04f 0a00 	mov.w	sl, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    4d9a:	f04f 0980 	mov.w	r9, #128	; 0x80
    4d9e:	f81b 8b01 	ldrb.w	r8, [fp], #1
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4da2:	2600      	movs	r6, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    4da4:	fa49 f306 	asr.w	r3, r9, r6
    4da8:	ea13 0f08 	tst.w	r3, r8
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4dac:	6920      	ldr	r0, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    4dae:	bf14      	ite	ne
    4db0:	69fb      	ldrne	r3, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    4db2:	6a3b      	ldreq	r3, [r7, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4db4:	69a2      	ldr	r2, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    4db6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    4db8:	6002      	str	r2, [r0, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    4dba:	6019      	str	r1, [r3, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    4dbc:	2007      	movs	r0, #7
    4dbe:	f7fc fc27 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4dc2:	68e0      	ldr	r0, [r4, #12]
    4dc4:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4dc6:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4dc8:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4dca:	6811      	ldr	r1, [r2, #0]
    4dcc:	420b      	tst	r3, r1
    4dce:	bf08      	it	eq
    4dd0:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4dd4:	d149      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4dd6:	2004      	movs	r0, #4
    4dd8:	f7fc fc1a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ddc:	6962      	ldr	r2, [r4, #20]
    4dde:	69a3      	ldr	r3, [r4, #24]
    4de0:	6811      	ldr	r1, [r2, #0]
    4de2:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4de4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4de8:	d13f      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4dea:	f7fc fc11 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4dee:	6962      	ldr	r2, [r4, #20]
    4df0:	69a3      	ldr	r3, [r4, #24]
    4df2:	6811      	ldr	r1, [r2, #0]
    4df4:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4df6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4dfa:	d136      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4dfc:	f7fc fc08 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e00:	6962      	ldr	r2, [r4, #20]
    4e02:	69a3      	ldr	r3, [r4, #24]
    4e04:	6811      	ldr	r1, [r2, #0]
    4e06:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e08:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e0c:	d12d      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e0e:	f7fc fbff 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e12:	6962      	ldr	r2, [r4, #20]
    4e14:	69a3      	ldr	r3, [r4, #24]
    4e16:	6811      	ldr	r1, [r2, #0]
    4e18:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e1a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e1e:	d124      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e20:	f7fc fbf6 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e24:	6962      	ldr	r2, [r4, #20]
    4e26:	69a3      	ldr	r3, [r4, #24]
    4e28:	6811      	ldr	r1, [r2, #0]
    4e2a:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e2c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e30:	d11b      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e32:	f7fc fbed 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e36:	6962      	ldr	r2, [r4, #20]
    4e38:	69a3      	ldr	r3, [r4, #24]
    4e3a:	6811      	ldr	r1, [r2, #0]
    4e3c:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e3e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e42:	d112      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e44:	f7fc fbe4 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e48:	6962      	ldr	r2, [r4, #20]
    4e4a:	69a3      	ldr	r3, [r4, #24]
    4e4c:	6811      	ldr	r1, [r2, #0]
    4e4e:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e50:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e54:	d109      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e56:	f7fc fbdb 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e5a:	6960      	ldr	r0, [r4, #20]
    4e5c:	69a3      	ldr	r3, [r4, #24]
    4e5e:	6802      	ldr	r2, [r0, #0]
    4e60:	421a      	tst	r2, r3
    4e62:	d102      	bne.n	4e6a <am_hal_i2c_bit_bang_send+0x362>
    {
        if (--maxLoop == 0)
    4e64:	3d08      	subs	r5, #8
    4e66:	d1b6      	bne.n	4dd6 <am_hal_i2c_bit_bang_send+0x2ce>
    4e68:	e6af      	b.n	4bca <am_hal_i2c_bit_bang_send+0xc2>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4e6a:	3601      	adds	r6, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    4e6c:	2005      	movs	r0, #5
    4e6e:	f7fc fbcf 	bl	1610 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    4e72:	2e08      	cmp	r6, #8
    4e74:	d196      	bne.n	4da4 <am_hal_i2c_bit_bang_send+0x29c>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    4e76:	6926      	ldr	r6, [r4, #16]
    4e78:	69a1      	ldr	r1, [r4, #24]
    4e7a:	6031      	str	r1, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    4e7c:	2007      	movs	r0, #7
    4e7e:	f7fc fbc7 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4e82:	68e0      	ldr	r0, [r4, #12]
    4e84:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e86:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4e88:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e8a:	6816      	ldr	r6, [r2, #0]
    4e8c:	4233      	tst	r3, r6
    4e8e:	bf08      	it	eq
    4e90:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    4e94:	d149      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4e96:	2004      	movs	r0, #4
    4e98:	f7fc fbba 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4e9c:	6961      	ldr	r1, [r4, #20]
    4e9e:	69a3      	ldr	r3, [r4, #24]
    4ea0:	680a      	ldr	r2, [r1, #0]
    4ea2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ea4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ea8:	d13f      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4eaa:	f7fc fbb1 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4eae:	6966      	ldr	r6, [r4, #20]
    4eb0:	69a1      	ldr	r1, [r4, #24]
    4eb2:	6833      	ldr	r3, [r6, #0]
    4eb4:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4eb6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4eba:	d136      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ebc:	f7fc fba8 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ec0:	6962      	ldr	r2, [r4, #20]
    4ec2:	69a6      	ldr	r6, [r4, #24]
    4ec4:	6811      	ldr	r1, [r2, #0]
    4ec6:	4231      	tst	r1, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ec8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ecc:	d12d      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ece:	f7fc fb9f 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ed2:	6962      	ldr	r2, [r4, #20]
    4ed4:	69a3      	ldr	r3, [r4, #24]
    4ed6:	6816      	ldr	r6, [r2, #0]
    4ed8:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4eda:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ede:	d124      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ee0:	f7fc fb96 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ee4:	6961      	ldr	r1, [r4, #20]
    4ee6:	69a3      	ldr	r3, [r4, #24]
    4ee8:	680a      	ldr	r2, [r1, #0]
    4eea:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4eec:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ef0:	d11b      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ef2:	f7fc fb8d 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ef6:	6966      	ldr	r6, [r4, #20]
    4ef8:	69a1      	ldr	r1, [r4, #24]
    4efa:	6833      	ldr	r3, [r6, #0]
    4efc:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4efe:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f02:	d112      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4f04:	f7fc fb84 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f08:	6962      	ldr	r2, [r4, #20]
    4f0a:	69a6      	ldr	r6, [r4, #24]
    4f0c:	6811      	ldr	r1, [r2, #0]
    4f0e:	4231      	tst	r1, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4f10:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f14:	d109      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4f16:	f7fc fb7b 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f1a:	6960      	ldr	r0, [r4, #20]
    4f1c:	69a3      	ldr	r3, [r4, #24]
    4f1e:	6802      	ldr	r2, [r0, #0]
    4f20:	421a      	tst	r2, r3
    4f22:	d102      	bne.n	4f2a <am_hal_i2c_bit_bang_send+0x422>
    {
        if (--maxLoop == 0)
    4f24:	3d08      	subs	r5, #8
    4f26:	d1b6      	bne.n	4e96 <am_hal_i2c_bit_bang_send+0x38e>
    4f28:	e64f      	b.n	4bca <am_hal_i2c_bit_bang_send+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    4f2a:	6a65      	ldr	r5, [r4, #36]	; 0x24
    4f2c:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    4f2e:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4f30:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    4f32:	4035      	ands	r5, r6
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    4f34:	f7fc fb6c 	bl	1610 <am_hal_flash_delay>
    if ( data_naked )
    4f38:	b125      	cbz	r5, 4f44 <am_hal_i2c_bit_bang_send+0x43c>
        status =  i2c_send_byte(*pData++);
        if (status != AM_HAL_I2C_BIT_BANG_SUCCESS)
        {
            if (status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
            {
                if (ui32I != (number_of_bytes-1))
    4f3a:	9901      	ldr	r1, [sp, #4]
    4f3c:	1e48      	subs	r0, r1, #1
    4f3e:	4550      	cmp	r0, sl
    4f40:	f040 814e 	bne.w	51e0 <am_hal_i2c_bit_bang_send+0x6d8>
    }

    //
    // send the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    4f44:	9b01      	ldr	r3, [sp, #4]
    4f46:	f10a 0a01 	add.w	sl, sl, #1
    4f4a:	4553      	cmp	r3, sl
    4f4c:	f47f af27 	bne.w	4d9e <am_hal_i2c_bit_bang_send+0x296>
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    uint32_t ui32I;
    am_hal_i2c_bit_bang_enum_e status;
    bool data_naked = false;
    4f50:	2700      	movs	r7, #0
    //********************

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    4f52:	6926      	ldr	r6, [r4, #16]
    4f54:	69a2      	ldr	r2, [r4, #24]
    4f56:	6032      	str	r2, [r6, #0]

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    4f58:	2004      	movs	r0, #4
    4f5a:	f7fc fb59 	bl	1610 <am_hal_flash_delay>


    if (!bNoStop)
    4f5e:	9902      	ldr	r1, [sp, #8]
    //********************

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    4f60:	4d2d      	ldr	r5, [pc, #180]	; (5018 <am_hal_i2c_bit_bang_send+0x510>)
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();


    if (!bNoStop)
    4f62:	2900      	cmp	r1, #0
    4f64:	d05a      	beq.n	501c <am_hal_i2c_bit_bang_send+0x514>
    else
    {
        //
        // Release data line with clock low itself, as we are not sending STOP
        //
        PULL_SDA_HI();
    4f66:	69e8      	ldr	r0, [r5, #28]
    4f68:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4f6a:	6003      	str	r3, [r0, #0]
    }

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    4f6c:	2004      	movs	r0, #4
    4f6e:	f7fc fb4f 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4f72:	68ee      	ldr	r6, [r5, #12]
    4f74:	69a9      	ldr	r1, [r5, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f76:	696a      	ldr	r2, [r5, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    4f78:	6031      	str	r1, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f7a:	6815      	ldr	r5, [r2, #0]
    4f7c:	4229      	tst	r1, r5
    4f7e:	d15d      	bne.n	503c <am_hal_i2c_bit_bang_send+0x534>
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    uint32_t ui32I;
    am_hal_i2c_bit_bang_enum_e status;
    bool data_naked = false;
    4f80:	f44f 76c8 	mov.w	r6, #400	; 0x190
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4f84:	2004      	movs	r0, #4
    4f86:	f7fc fb43 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f8a:	6961      	ldr	r1, [r4, #20]
    4f8c:	69a3      	ldr	r3, [r4, #24]
    4f8e:	680a      	ldr	r2, [r1, #0]
    4f90:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4f92:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f96:	d159      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4f98:	f7fc fb3a 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4f9c:	6965      	ldr	r5, [r4, #20]
    4f9e:	69a1      	ldr	r1, [r4, #24]
    4fa0:	682b      	ldr	r3, [r5, #0]
    4fa2:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fa4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fa8:	d150      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4faa:	f7fc fb31 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fae:	6962      	ldr	r2, [r4, #20]
    4fb0:	69a5      	ldr	r5, [r4, #24]
    4fb2:	6811      	ldr	r1, [r2, #0]
    4fb4:	4229      	tst	r1, r5
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fb6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fba:	d147      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fbc:	f7fc fb28 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fc0:	6962      	ldr	r2, [r4, #20]
    4fc2:	69a3      	ldr	r3, [r4, #24]
    4fc4:	6815      	ldr	r5, [r2, #0]
    4fc6:	421d      	tst	r5, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fc8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fcc:	d13e      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fce:	f7fc fb1f 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fd2:	6961      	ldr	r1, [r4, #20]
    4fd4:	69a3      	ldr	r3, [r4, #24]
    4fd6:	680a      	ldr	r2, [r1, #0]
    4fd8:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fda:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fde:	d135      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fe0:	f7fc fb16 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4fe4:	6965      	ldr	r5, [r4, #20]
    4fe6:	69a1      	ldr	r1, [r4, #24]
    4fe8:	682b      	ldr	r3, [r5, #0]
    4fea:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4fec:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ff0:	d12c      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ff2:	f7fc fb0d 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    4ff6:	6962      	ldr	r2, [r4, #20]
    4ff8:	69a5      	ldr	r5, [r4, #24]
    4ffa:	6811      	ldr	r1, [r2, #0]
    4ffc:	4229      	tst	r1, r5
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    4ffe:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5002:	d123      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    5004:	f7fc fb04 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5008:	6960      	ldr	r0, [r4, #20]
    500a:	69a3      	ldr	r3, [r4, #24]
    500c:	6802      	ldr	r2, [r0, #0]
    500e:	421a      	tst	r2, r3
    5010:	d11c      	bne.n	504c <am_hal_i2c_bit_bang_send+0x544>
    {
        if (--maxLoop == 0)
    5012:	3e08      	subs	r6, #8
    5014:	d1b6      	bne.n	4f84 <am_hal_i2c_bit_bang_send+0x47c>
    5016:	e5d8      	b.n	4bca <am_hal_i2c_bit_bang_send+0xc2>
    5018:	100011bc 	.word	0x100011bc
    if (!bNoStop)
    {
        //
        // Pull down on data line with clock low
        //
        WRITE_SDA_LO();
    501c:	6a28      	ldr	r0, [r5, #32]
    501e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    5020:	6003      	str	r3, [r0, #0]
    }

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    5022:	2004      	movs	r0, #4
    5024:	f7fc faf4 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    5028:	68ee      	ldr	r6, [r5, #12]
    502a:	69a9      	ldr	r1, [r5, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    502c:	696a      	ldr	r2, [r5, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    502e:	6031      	str	r1, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5030:	6815      	ldr	r5, [r2, #0]
    5032:	420d      	tst	r5, r1
    5034:	d0a4      	beq.n	4f80 <am_hal_i2c_bit_bang_send+0x478>
    if (!bNoStop)
    {
        //
        // release data line with clock high --> STOP CONDITION
        //
        PULL_SDA_HI();
    5036:	69e5      	ldr	r5, [r4, #28]
    5038:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    503a:	602c      	str	r4, [r5, #0]
    }

    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    503c:	2005      	movs	r0, #5
    503e:	f7fc fae7 	bl	1610 <am_hal_flash_delay>

    if ( data_naked )
    5042:	2f00      	cmp	r7, #0
    5044:	f000 80d9 	beq.w	51fa <am_hal_i2c_bit_bang_send+0x6f2>
    {
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;  // if it happens early
    5048:	2002      	movs	r0, #2
    504a:	e5bf      	b.n	4bcc <am_hal_i2c_bit_bang_send+0xc4>

    if (i2c_pull_and_wait_scl_hi())
    {
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    if (!bNoStop)
    504c:	9e02      	ldr	r6, [sp, #8]
    504e:	2e00      	cmp	r6, #0
    5050:	d0f1      	beq.n	5036 <am_hal_i2c_bit_bang_send+0x52e>
    5052:	e7f3      	b.n	503c <am_hal_i2c_bit_bang_send+0x534>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    5054:	4e6a      	ldr	r6, [pc, #424]	; (5200 <am_hal_i2c_bit_bang_send+0x6f8>)

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    5056:	f04f 0880 	mov.w	r8, #128	; 0x80
    505a:	fa48 f105 	asr.w	r1, r8, r5
    505e:	ea11 0f0a 	tst.w	r1, sl
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    5062:	6920      	ldr	r0, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    5064:	bf14      	ite	ne
    5066:	69f1      	ldrne	r1, [r6, #28]
        }
        else
        {
            WRITE_SDA_LO();
    5068:	6a31      	ldreq	r1, [r6, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    506a:	69a2      	ldr	r2, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    506c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    506e:	6002      	str	r2, [r0, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    5070:	600b      	str	r3, [r1, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    5072:	2007      	movs	r0, #7
    5074:	f7fc facc 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    5078:	68e0      	ldr	r0, [r4, #12]
    507a:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    507c:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    507e:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5080:	6813      	ldr	r3, [r2, #0]
    5082:	4219      	tst	r1, r3
    5084:	bf08      	it	eq
    5086:	f44f 77c8 	moveq.w	r7, #400	; 0x190
    508a:	d149      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    508c:	2004      	movs	r0, #4
    508e:	f7fc fabf 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5092:	6961      	ldr	r1, [r4, #20]
    5094:	69a3      	ldr	r3, [r4, #24]
    5096:	680a      	ldr	r2, [r1, #0]
    5098:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    509a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    509e:	d13f      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50a0:	f7fc fab6 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50a4:	6961      	ldr	r1, [r4, #20]
    50a6:	69a3      	ldr	r3, [r4, #24]
    50a8:	680a      	ldr	r2, [r1, #0]
    50aa:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50ac:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50b0:	d136      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50b2:	f7fc faad 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50b6:	6961      	ldr	r1, [r4, #20]
    50b8:	69a3      	ldr	r3, [r4, #24]
    50ba:	680a      	ldr	r2, [r1, #0]
    50bc:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50be:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50c2:	d12d      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50c4:	f7fc faa4 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50c8:	6961      	ldr	r1, [r4, #20]
    50ca:	69a3      	ldr	r3, [r4, #24]
    50cc:	680a      	ldr	r2, [r1, #0]
    50ce:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50d0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50d4:	d124      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50d6:	f7fc fa9b 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50da:	6961      	ldr	r1, [r4, #20]
    50dc:	69a3      	ldr	r3, [r4, #24]
    50de:	680a      	ldr	r2, [r1, #0]
    50e0:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50e2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50e6:	d11b      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50e8:	f7fc fa92 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50ec:	6961      	ldr	r1, [r4, #20]
    50ee:	69a3      	ldr	r3, [r4, #24]
    50f0:	680a      	ldr	r2, [r1, #0]
    50f2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50f4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50f8:	d112      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    50fa:	f7fc fa89 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    50fe:	6961      	ldr	r1, [r4, #20]
    5100:	69a3      	ldr	r3, [r4, #24]
    5102:	680a      	ldr	r2, [r1, #0]
    5104:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    5106:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    510a:	d109      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    510c:	f7fc fa80 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5110:	6960      	ldr	r0, [r4, #20]
    5112:	69a1      	ldr	r1, [r4, #24]
    5114:	6803      	ldr	r3, [r0, #0]
    5116:	420b      	tst	r3, r1
    5118:	d102      	bne.n	5120 <am_hal_i2c_bit_bang_send+0x618>
    {
        if (--maxLoop == 0)
    511a:	3f08      	subs	r7, #8
    511c:	d1b6      	bne.n	508c <am_hal_i2c_bit_bang_send+0x584>
    511e:	e554      	b.n	4bca <am_hal_i2c_bit_bang_send+0xc2>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    5120:	3501      	adds	r5, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    5122:	2005      	movs	r0, #5
    5124:	f7fc fa74 	bl	1610 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    5128:	2d08      	cmp	r5, #8
    512a:	d196      	bne.n	505a <am_hal_i2c_bit_bang_send+0x552>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    512c:	6926      	ldr	r6, [r4, #16]
    512e:	69a7      	ldr	r7, [r4, #24]
    5130:	6037      	str	r7, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    5132:	2007      	movs	r0, #7
    5134:	f7fc fa6c 	bl	1610 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    5138:	68e0      	ldr	r0, [r4, #12]
    513a:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    513c:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    513e:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5140:	6813      	ldr	r3, [r2, #0]
    5142:	4219      	tst	r1, r3
    5144:	bf08      	it	eq
    5146:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    514a:	d14b      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    514c:	2004      	movs	r0, #4
    514e:	f7fc fa5f 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5152:	6966      	ldr	r6, [r4, #20]
    5154:	69a7      	ldr	r7, [r4, #24]
    5156:	6831      	ldr	r1, [r6, #0]
    5158:	4239      	tst	r1, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    515a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    515e:	d141      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    5160:	f7fc fa56 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5164:	6962      	ldr	r2, [r4, #20]
    5166:	69a3      	ldr	r3, [r4, #24]
    5168:	6816      	ldr	r6, [r2, #0]
    516a:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    516c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5170:	d138      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    5172:	f7fc fa4d 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5176:	6967      	ldr	r7, [r4, #20]
    5178:	69a1      	ldr	r1, [r4, #24]
    517a:	683a      	ldr	r2, [r7, #0]
    517c:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    517e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5182:	d12f      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    5184:	f7fc fa44 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5188:	6966      	ldr	r6, [r4, #20]
    518a:	69a3      	ldr	r3, [r4, #24]
    518c:	6837      	ldr	r7, [r6, #0]
    518e:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    5190:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    5194:	d126      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    5196:	f7fc fa3b 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    519a:	6961      	ldr	r1, [r4, #20]
    519c:	69a6      	ldr	r6, [r4, #24]
    519e:	680a      	ldr	r2, [r1, #0]
    51a0:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    51a2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    51a6:	d11d      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    51a8:	f7fc fa32 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    51ac:	6967      	ldr	r7, [r4, #20]
    51ae:	69a3      	ldr	r3, [r4, #24]
    51b0:	6839      	ldr	r1, [r7, #0]
    51b2:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    51b4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    51b8:	d114      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    51ba:	f7fc fa29 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    51be:	6966      	ldr	r6, [r4, #20]
    51c0:	69a7      	ldr	r7, [r4, #24]
    51c2:	6832      	ldr	r2, [r6, #0]
    51c4:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    51c6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    51ca:	d10b      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    51cc:	f7fc fa20 	bl	1610 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    51d0:	6960      	ldr	r0, [r4, #20]
    51d2:	69a3      	ldr	r3, [r4, #24]
    51d4:	6801      	ldr	r1, [r0, #0]
    51d6:	4219      	tst	r1, r3
    51d8:	d104      	bne.n	51e4 <am_hal_i2c_bit_bang_send+0x6dc>
    {
        if (--maxLoop == 0)
    51da:	3d08      	subs	r5, #8
    51dc:	d1b6      	bne.n	514c <am_hal_i2c_bit_bang_send+0x644>
    51de:	e4f4      	b.n	4bca <am_hal_i2c_bit_bang_send+0xc2>
        {
            if (status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
            {
                if (ui32I != (number_of_bytes-1))
                {
                    data_naked = true;
    51e0:	2701      	movs	r7, #1
    51e2:	e6b6      	b.n	4f52 <am_hal_i2c_bit_bang_send+0x44a>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    51e4:	6a65      	ldr	r5, [r4, #36]	; 0x24
    51e6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    51e8:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    51ea:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    51ec:	4035      	ands	r5, r6
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    51ee:	f7fc fa0f 	bl	1610 <am_hal_flash_delay>
    if ( data_naked )
    51f2:	2d00      	cmp	r5, #0
    51f4:	f47f af28 	bne.w	5048 <am_hal_i2c_bit_bang_send+0x540>
    51f8:	e5c8      	b.n	4d8c <am_hal_i2c_bit_bang_send+0x284>
    }

    //
    // message successfully sent
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    51fa:	4638      	mov	r0, r7
    51fc:	e4e6      	b.n	4bcc <am_hal_i2c_bit_bang_send+0xc4>
    51fe:	bf00      	nop
    5200:	100011bc 	.word	0x100011bc

00005204 <memcpy>:
    5204:	b510      	push	{r4, lr}
    5206:	1e43      	subs	r3, r0, #1
    5208:	440a      	add	r2, r1
    520a:	4291      	cmp	r1, r2
    520c:	d004      	beq.n	5218 <memcpy+0x14>
    520e:	f811 4b01 	ldrb.w	r4, [r1], #1
    5212:	f803 4f01 	strb.w	r4, [r3, #1]!
    5216:	e7f8      	b.n	520a <memcpy+0x6>
    5218:	bd10      	pop	{r4, pc}
    521a:	0000      	movs	r0, r0
    521c:	20433249 	.word	0x20433249
    5220:	706f6f4c 	.word	0x706f6f4c
    5224:	6b636162 	.word	0x6b636162
    5228:	61784520 	.word	0x61784520
    522c:	656c706d 	.word	0x656c706d
    5230:	69737520 	.word	0x69737520
    5234:	4920676e 	.word	0x4920676e
    5238:	54534d4f 	.word	0x54534d4f
    523c:	34232052 	.word	0x34232052
    5240:	646e6120 	.word	0x646e6120
    5244:	534f4920 	.word	0x534f4920
    5248:	4556414c 	.word	0x4556414c
    524c:	00000000 	.word	0x00000000
    5250:	6f6c420a 	.word	0x6f6c420a
    5254:	6e696b63 	.word	0x6e696b63
    5258:	72542067 	.word	0x72542067
    525c:	66736e61 	.word	0x66736e61
    5260:	43207265 	.word	0x43207265
    5264:	6c706d6f 	.word	0x6c706d6f
    5268:	0a657465 	.word	0x0a657465
    526c:	00000000 	.word	0x00000000
    5270:	534f490a 	.word	0x534f490a
    5274:	74614420 	.word	0x74614420
    5278:	69642061 	.word	0x69642061
    527c:	6f6e2064 	.word	0x6f6e2064
    5280:	616d2074 	.word	0x616d2074
    5284:	20686374 	.word	0x20686374
    5288:	204d4f49 	.word	0x204d4f49
    528c:	61746164 	.word	0x61746164
    5290:	6e657320 	.word	0x6e657320
    5294:	21212174 	.word	0x21212174
    5298:	0000000a 	.word	0x0000000a
    529c:	6e6f4e0a 	.word	0x6e6f4e0a
    52a0:	6f6c422d 	.word	0x6f6c422d
    52a4:	6e696b63 	.word	0x6e696b63
    52a8:	72542067 	.word	0x72542067
    52ac:	66736e61 	.word	0x66736e61
    52b0:	43207265 	.word	0x43207265
    52b4:	6c706d6f 	.word	0x6c706d6f
    52b8:	0a657465 	.word	0x0a657465
    52bc:	00000000 	.word	0x00000000
    52c0:	0a0a0a0a 	.word	0x0a0a0a0a
    52c4:	0a0a0a0a 	.word	0x0a0a0a0a
    52c8:	0a0a0a0a 	.word	0x0a0a0a0a
    52cc:	0a0a0a0a 	.word	0x0a0a0a0a
    52d0:	00000a0a 	.word	0x00000a0a

000052d4 <g_SPIpins>:
    52d4:	00000006 0000000a 00000009 0000000a     ................
    52e4:	00000019 0000002a 0000002b 0000002a     ....*...+...*...
    52f4:	00000028 0000002a 00000031 0000002a     (...*...1...*...

00005304 <am_hal_cachectrl_defaults>:
    5304:	50000001 00010300 00010101 685f6d61     ...P........am_h
    5314:	635f6c61 65676b6c 79735f6e 6b6c6373     al_clkgen_sysclk
    5324:	6c65735f 28746365 69203a29 6c61766e     _select(): inval
    5334:	63206469 6b636f6c 74657320 676e6974     id clock setting
    5344:	0000002e 2e5c2e2e 6d615c2e 6c61685f     ......\..\am_hal
    5354:	6b6c635f 2e6e6567 00000063 20656854     _clkgen.c...The 
    5364:	6f666966 756f6320 276e646c 69662074     fifo couldn't fi
    5374:	68742074 65722065 73657571 20646574     t the requested 
    5384:	626d756e 6f207265 79622066 00736574     number of bytes.
    5394:	2e5c2e2e 6d615c2e 6c61685f 6d6f695f     ..\..\am_hal_iom
    53a4:	0000632e 69797254 7420676e 6e65206f     .c..Trying to en
    53b4:	656c6261 206e6120 204d4f49 75646f6d     able an IOM modu
    53c4:	7420656c 20746168 73656f64 2074276e     le that doesn't 
    53d4:	73697865 00002e74 69797254 7420676e     exist...Trying t
    53e4:	6964206f 6c626173 6e612065 4d4f4920     o disable an IOM
    53f4:	646f6d20 20656c75 74616874 656f6420      module that doe
    5404:	74276e73 69786520 002e7473 20495053     sn't exist..SPI 
    5414:	6e617274 72656673 6f6f7420 67696220     transfer too big
    5424:	0000002e 61766e49 2064696c 46206948     ....Invalid Hi F
    5434:	75716572 79636e65 726f6620 4d4f4920     requency for IOM
    5444:	0000002e 69797254 7420676e 6f64206f     ....Trying to do
    5454:	30206120 74796220 72742065 61736e61      a 0 byte transa
    5464:	6f697463 0000006e 20656854 6f666966     ction...The fifo
    5474:	656f6420 74276e73 6e6f6320 6e696174      doesn't contain
    5484:	65687420 71657220 74736575 6e206465      the requested n
    5494:	65626d75 666f2072 74796220 002e7365     umber of bytes..

000054a4 <i2c_bb_errmap>:
    54a4:	01060600 00000001 6e6e6143 6520746f     ........Cannot e
    54b4:	6c62616e 6f6d2065 74206572 206e6168     nable more than 
    54c4:	20656e6f 69726570 72656870 61206c61     one peripheral a
    54d4:	20612074 656d6974 0000002e 2e5c2e2e     t a time......\.
    54e4:	6d615c2e 6c61685f 7277705f 6c727463     .\am_hal_pwrctrl
    54f4:	0000632e                                .c..
