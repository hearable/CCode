
C:\jenkins\jobs\ambiqsuite-checkout\workspace\ambiqsuite-sdk\boards\apollo2_evb\examples\bc_boot_demo\atollic_gcc\bin\bc_boot_demo_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000220c  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00020000  2**2
                  ALLOC
  2 .data         00000084  10001000  0000a20c  00011000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000011c  10001084  0000a290  00011084  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00011084  2**0
                  CONTENTS, READONLY
  5 .debug_info   000066e5  00000000  00000000  000110bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001bdd  00000000  00000000  000177a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000838  00000000  00000000  0001937d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 00000e88  00000000  00000000  00019bb5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000420a  00000000  00000000  0001aa3d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002bfe  00000000  00000000  0001ec47  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007e  00000000  00000000  00021845  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00001740  00000000  00000000  000218c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00003837  00000000  00000000  00023004  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00008000 <g_am_pfnVectors>:
    8000:	00 10 00 10 a5 87 00 00 0d 88 00 00 1d 88 00 00     ................
    8010:	1d 88 00 00 1d 88 00 00 1d 88 00 00 00 00 00 00     ................
	...
    802c:	15 88 00 00 15 88 00 00 00 00 00 00 15 88 00 00     ................
    803c:	15 88 00 00 15 88 00 00 15 88 00 00 15 88 00 00     ................
    804c:	15 88 00 00 15 88 00 00 15 88 00 00 15 88 00 00     ................
    805c:	15 88 00 00 15 88 00 00 15 88 00 00 15 88 00 00     ................
    806c:	15 88 00 00 15 88 00 00 a9 86 00 00 15 88 00 00     ................
    807c:	15 88 00 00 15 88 00 00 15 88 00 00 15 88 00 00     ................
    808c:	15 88 00 00 15 88 00 00 15 88 00 00 15 88 00 00     ................
    809c:	15 88 00 00 15 88 00 00 15 88 00 00 15 88 00 00     ................
    80ac:	15 88 00 00 15 88 00 00 15 88 00 00 15 88 00 00     ................
    80bc:	15 88 00 00                                         ....

000080c0 <__aeabi_d2f>:
    80c0:	ea4f 0241 	mov.w	r2, r1, lsl #1
    80c4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    80c8:	bf24      	itt	cs
    80ca:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    80ce:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    80d2:	d90d      	bls.n	80f0 <__aeabi_d2f+0x30>
    80d4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    80d8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    80dc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    80e0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    80e4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    80e8:	bf08      	it	eq
    80ea:	f020 0001 	biceq.w	r0, r0, #1
    80ee:	4770      	bx	lr
    80f0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    80f4:	d121      	bne.n	813a <__aeabi_d2f+0x7a>
    80f6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    80fa:	bfbc      	itt	lt
    80fc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    8100:	4770      	bxlt	lr
    8102:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    8106:	ea4f 5252 	mov.w	r2, r2, lsr #21
    810a:	f1c2 0218 	rsb	r2, r2, #24
    810e:	f1c2 0c20 	rsb	ip, r2, #32
    8112:	fa10 f30c 	lsls.w	r3, r0, ip
    8116:	fa20 f002 	lsr.w	r0, r0, r2
    811a:	bf18      	it	ne
    811c:	f040 0001 	orrne.w	r0, r0, #1
    8120:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    8124:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    8128:	fa03 fc0c 	lsl.w	ip, r3, ip
    812c:	ea40 000c 	orr.w	r0, r0, ip
    8130:	fa23 f302 	lsr.w	r3, r3, r2
    8134:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8138:	e7cc      	b.n	80d4 <__aeabi_d2f+0x14>
    813a:	ea7f 5362 	mvns.w	r3, r2, asr #21
    813e:	d107      	bne.n	8150 <__aeabi_d2f+0x90>
    8140:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    8144:	bf1e      	ittt	ne
    8146:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    814a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    814e:	4770      	bxne	lr
    8150:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    8154:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    8158:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    815c:	4770      	bx	lr
    815e:	bf00      	nop

00008160 <am_devices_led_init>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_init(am_devices_led_t *psLED)
{
    8160:	b490      	push	{r4, r7}
    8162:	b084      	sub	sp, #16
    8164:	af00      	add	r7, sp, #0
    8166:	6078      	str	r0, [r7, #4]
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    8168:	687b      	ldr	r3, [r7, #4]
    816a:	685b      	ldr	r3, [r3, #4]
    816c:	f003 0302 	and.w	r3, r3, #2
    8170:	2b00      	cmp	r3, #0
    8172:	f000 80aa 	beq.w	82ca <am_devices_led_init+0x16a>
    {
        //
        // Configure the pin as a push-pull GPIO output.
        //
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT);
    8176:	687b      	ldr	r3, [r7, #4]
    8178:	681b      	ldr	r3, [r3, #0]
    817a:	2b31      	cmp	r3, #49	; 0x31
    817c:	d86d      	bhi.n	825a <am_devices_led_init+0xfa>
    817e:	f3ef 8310 	mrs	r3, PRIMASK
    8182:	60fb      	str	r3, [r7, #12]
    8184:	b672      	cpsid	i
    8186:	4ba8      	ldr	r3, [pc, #672]	; (8428 <am_devices_led_init+0x2c8>)
    8188:	2273      	movs	r2, #115	; 0x73
    818a:	601a      	str	r2, [r3, #0]
    818c:	687b      	ldr	r3, [r7, #4]
    818e:	681b      	ldr	r3, [r3, #0]
    8190:	085b      	lsrs	r3, r3, #1
    8192:	f003 027c 	and.w	r2, r3, #124	; 0x7c
    8196:	4ba5      	ldr	r3, [pc, #660]	; (842c <am_devices_led_init+0x2cc>)
    8198:	4413      	add	r3, r2
    819a:	461c      	mov	r4, r3
    819c:	687b      	ldr	r3, [r7, #4]
    819e:	681b      	ldr	r3, [r3, #0]
    81a0:	009b      	lsls	r3, r3, #2
    81a2:	f003 031c 	and.w	r3, r3, #28
    81a6:	2202      	movs	r2, #2
    81a8:	409a      	lsls	r2, r3
    81aa:	687b      	ldr	r3, [r7, #4]
    81ac:	681b      	ldr	r3, [r3, #0]
    81ae:	085b      	lsrs	r3, r3, #1
    81b0:	f003 017c 	and.w	r1, r3, #124	; 0x7c
    81b4:	4b9d      	ldr	r3, [pc, #628]	; (842c <am_devices_led_init+0x2cc>)
    81b6:	440b      	add	r3, r1
    81b8:	6819      	ldr	r1, [r3, #0]
    81ba:	687b      	ldr	r3, [r7, #4]
    81bc:	681b      	ldr	r3, [r3, #0]
    81be:	009b      	lsls	r3, r3, #2
    81c0:	f003 031c 	and.w	r3, r3, #28
    81c4:	2007      	movs	r0, #7
    81c6:	fa00 f303 	lsl.w	r3, r0, r3
    81ca:	43db      	mvns	r3, r3
    81cc:	400b      	ands	r3, r1
    81ce:	4313      	orrs	r3, r2
    81d0:	6023      	str	r3, [r4, #0]
    81d2:	687b      	ldr	r3, [r7, #4]
    81d4:	681b      	ldr	r3, [r3, #0]
    81d6:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    81da:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    81de:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    81e2:	461c      	mov	r4, r3
    81e4:	687b      	ldr	r3, [r7, #4]
    81e6:	681b      	ldr	r3, [r3, #0]
    81e8:	00db      	lsls	r3, r3, #3
    81ea:	f003 0318 	and.w	r3, r3, #24
    81ee:	2218      	movs	r2, #24
    81f0:	409a      	lsls	r2, r3
    81f2:	687b      	ldr	r3, [r7, #4]
    81f4:	681b      	ldr	r3, [r3, #0]
    81f6:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    81fa:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    81fe:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    8202:	6819      	ldr	r1, [r3, #0]
    8204:	687b      	ldr	r3, [r7, #4]
    8206:	681b      	ldr	r3, [r3, #0]
    8208:	00db      	lsls	r3, r3, #3
    820a:	f003 0318 	and.w	r3, r3, #24
    820e:	20ff      	movs	r0, #255	; 0xff
    8210:	fa00 f303 	lsl.w	r3, r0, r3
    8214:	43db      	mvns	r3, r3
    8216:	400b      	ands	r3, r1
    8218:	4313      	orrs	r3, r2
    821a:	6023      	str	r3, [r4, #0]
    821c:	687b      	ldr	r3, [r7, #4]
    821e:	681b      	ldr	r3, [r3, #0]
    8220:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    8224:	4b82      	ldr	r3, [pc, #520]	; (8430 <am_devices_led_init+0x2d0>)
    8226:	4413      	add	r3, r2
    8228:	4618      	mov	r0, r3
    822a:	687b      	ldr	r3, [r7, #4]
    822c:	681b      	ldr	r3, [r3, #0]
    822e:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    8232:	4b7f      	ldr	r3, [pc, #508]	; (8430 <am_devices_led_init+0x2d0>)
    8234:	4413      	add	r3, r2
    8236:	681a      	ldr	r2, [r3, #0]
    8238:	687b      	ldr	r3, [r7, #4]
    823a:	681b      	ldr	r3, [r3, #0]
    823c:	00db      	lsls	r3, r3, #3
    823e:	f003 0318 	and.w	r3, r3, #24
    8242:	21ff      	movs	r1, #255	; 0xff
    8244:	fa01 f303 	lsl.w	r3, r1, r3
    8248:	43db      	mvns	r3, r3
    824a:	4013      	ands	r3, r2
    824c:	6003      	str	r3, [r0, #0]
    824e:	4b76      	ldr	r3, [pc, #472]	; (8428 <am_devices_led_init+0x2c8>)
    8250:	2200      	movs	r2, #0
    8252:	601a      	str	r2, [r3, #0]
    8254:	68fb      	ldr	r3, [r7, #12]
    8256:	f383 8810 	msr	PRIMASK, r3

        //
        // Enable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_set(psLED->ui32GPIONumber);
    825a:	687b      	ldr	r3, [r7, #4]
    825c:	681b      	ldr	r3, [r3, #0]
    825e:	08db      	lsrs	r3, r3, #3
    8260:	f003 0204 	and.w	r2, r3, #4
    8264:	4b73      	ldr	r3, [pc, #460]	; (8434 <am_devices_led_init+0x2d4>)
    8266:	4413      	add	r3, r2
    8268:	4619      	mov	r1, r3
    826a:	687b      	ldr	r3, [r7, #4]
    826c:	681b      	ldr	r3, [r3, #0]
    826e:	f003 031f 	and.w	r3, r3, #31
    8272:	2201      	movs	r2, #1
    8274:	fa02 f303 	lsl.w	r3, r2, r3
    8278:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    827a:	687b      	ldr	r3, [r7, #4]
    827c:	685b      	ldr	r3, [r3, #4]
    827e:	f003 0301 	and.w	r3, r3, #1
    8282:	2b00      	cmp	r3, #0
    8284:	d010      	beq.n	82a8 <am_devices_led_init+0x148>
    8286:	687b      	ldr	r3, [r7, #4]
    8288:	681b      	ldr	r3, [r3, #0]
    828a:	08db      	lsrs	r3, r3, #3
    828c:	f003 0204 	and.w	r2, r3, #4
    8290:	4b69      	ldr	r3, [pc, #420]	; (8438 <am_devices_led_init+0x2d8>)
    8292:	4413      	add	r3, r2
    8294:	4619      	mov	r1, r3
    8296:	687b      	ldr	r3, [r7, #4]
    8298:	681b      	ldr	r3, [r3, #0]
    829a:	f003 031f 	and.w	r3, r3, #31
    829e:	2201      	movs	r2, #1
    82a0:	fa02 f303 	lsl.w	r3, r2, r3
    82a4:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
                                    psLED->ui32Polarity &
                                    AM_DEVICES_LED_POL_POLARITY_M );
    }
}
    82a6:	e0b9      	b.n	841c <am_devices_led_init+0x2bc>
        //
        // Enable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_set(psLED->ui32GPIONumber);
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    82a8:	687b      	ldr	r3, [r7, #4]
    82aa:	681b      	ldr	r3, [r3, #0]
    82ac:	08db      	lsrs	r3, r3, #3
    82ae:	f003 0204 	and.w	r2, r3, #4
    82b2:	4b62      	ldr	r3, [pc, #392]	; (843c <am_devices_led_init+0x2dc>)
    82b4:	4413      	add	r3, r2
    82b6:	4619      	mov	r1, r3
    82b8:	687b      	ldr	r3, [r7, #4]
    82ba:	681b      	ldr	r3, [r3, #0]
    82bc:	f003 031f 	and.w	r3, r3, #31
    82c0:	2201      	movs	r2, #1
    82c2:	fa02 f303 	lsl.w	r3, r2, r3
    82c6:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
                                    psLED->ui32Polarity &
                                    AM_DEVICES_LED_POL_POLARITY_M );
    }
}
    82c8:	e0a8      	b.n	841c <am_devices_led_init+0x2bc>
    else
    {
        //
        // Configure the pin as a tri-state GPIO.
        //
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_3STATE);
    82ca:	687b      	ldr	r3, [r7, #4]
    82cc:	681b      	ldr	r3, [r3, #0]
    82ce:	2b31      	cmp	r3, #49	; 0x31
    82d0:	d86d      	bhi.n	83ae <am_devices_led_init+0x24e>
    82d2:	f3ef 8310 	mrs	r3, PRIMASK
    82d6:	60bb      	str	r3, [r7, #8]
    82d8:	b672      	cpsid	i
    82da:	4b53      	ldr	r3, [pc, #332]	; (8428 <am_devices_led_init+0x2c8>)
    82dc:	2273      	movs	r2, #115	; 0x73
    82de:	601a      	str	r2, [r3, #0]
    82e0:	687b      	ldr	r3, [r7, #4]
    82e2:	681b      	ldr	r3, [r3, #0]
    82e4:	085b      	lsrs	r3, r3, #1
    82e6:	f003 027c 	and.w	r2, r3, #124	; 0x7c
    82ea:	4b50      	ldr	r3, [pc, #320]	; (842c <am_devices_led_init+0x2cc>)
    82ec:	4413      	add	r3, r2
    82ee:	461c      	mov	r4, r3
    82f0:	687b      	ldr	r3, [r7, #4]
    82f2:	681b      	ldr	r3, [r3, #0]
    82f4:	009b      	lsls	r3, r3, #2
    82f6:	f003 031c 	and.w	r3, r3, #28
    82fa:	2206      	movs	r2, #6
    82fc:	409a      	lsls	r2, r3
    82fe:	687b      	ldr	r3, [r7, #4]
    8300:	681b      	ldr	r3, [r3, #0]
    8302:	085b      	lsrs	r3, r3, #1
    8304:	f003 017c 	and.w	r1, r3, #124	; 0x7c
    8308:	4b48      	ldr	r3, [pc, #288]	; (842c <am_devices_led_init+0x2cc>)
    830a:	440b      	add	r3, r1
    830c:	6819      	ldr	r1, [r3, #0]
    830e:	687b      	ldr	r3, [r7, #4]
    8310:	681b      	ldr	r3, [r3, #0]
    8312:	009b      	lsls	r3, r3, #2
    8314:	f003 031c 	and.w	r3, r3, #28
    8318:	2007      	movs	r0, #7
    831a:	fa00 f303 	lsl.w	r3, r0, r3
    831e:	43db      	mvns	r3, r3
    8320:	400b      	ands	r3, r1
    8322:	4313      	orrs	r3, r2
    8324:	6023      	str	r3, [r4, #0]
    8326:	687b      	ldr	r3, [r7, #4]
    8328:	681b      	ldr	r3, [r3, #0]
    832a:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    832e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8332:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    8336:	461c      	mov	r4, r3
    8338:	687b      	ldr	r3, [r7, #4]
    833a:	681b      	ldr	r3, [r3, #0]
    833c:	00db      	lsls	r3, r3, #3
    833e:	f003 0318 	and.w	r3, r3, #24
    8342:	2218      	movs	r2, #24
    8344:	409a      	lsls	r2, r3
    8346:	687b      	ldr	r3, [r7, #4]
    8348:	681b      	ldr	r3, [r3, #0]
    834a:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    834e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8352:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    8356:	6819      	ldr	r1, [r3, #0]
    8358:	687b      	ldr	r3, [r7, #4]
    835a:	681b      	ldr	r3, [r3, #0]
    835c:	00db      	lsls	r3, r3, #3
    835e:	f003 0318 	and.w	r3, r3, #24
    8362:	20ff      	movs	r0, #255	; 0xff
    8364:	fa00 f303 	lsl.w	r3, r0, r3
    8368:	43db      	mvns	r3, r3
    836a:	400b      	ands	r3, r1
    836c:	4313      	orrs	r3, r2
    836e:	6023      	str	r3, [r4, #0]
    8370:	687b      	ldr	r3, [r7, #4]
    8372:	681b      	ldr	r3, [r3, #0]
    8374:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    8378:	4b2d      	ldr	r3, [pc, #180]	; (8430 <am_devices_led_init+0x2d0>)
    837a:	4413      	add	r3, r2
    837c:	4618      	mov	r0, r3
    837e:	687b      	ldr	r3, [r7, #4]
    8380:	681b      	ldr	r3, [r3, #0]
    8382:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    8386:	4b2a      	ldr	r3, [pc, #168]	; (8430 <am_devices_led_init+0x2d0>)
    8388:	4413      	add	r3, r2
    838a:	681a      	ldr	r2, [r3, #0]
    838c:	687b      	ldr	r3, [r7, #4]
    838e:	681b      	ldr	r3, [r3, #0]
    8390:	00db      	lsls	r3, r3, #3
    8392:	f003 0318 	and.w	r3, r3, #24
    8396:	21ff      	movs	r1, #255	; 0xff
    8398:	fa01 f303 	lsl.w	r3, r1, r3
    839c:	43db      	mvns	r3, r3
    839e:	4013      	ands	r3, r2
    83a0:	6003      	str	r3, [r0, #0]
    83a2:	4b21      	ldr	r3, [pc, #132]	; (8428 <am_devices_led_init+0x2c8>)
    83a4:	2200      	movs	r2, #0
    83a6:	601a      	str	r2, [r3, #0]
    83a8:	68bb      	ldr	r3, [r7, #8]
    83aa:	f383 8810 	msr	PRIMASK, r3

        //
        // Disable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
    83ae:	687b      	ldr	r3, [r7, #4]
    83b0:	681b      	ldr	r3, [r3, #0]
    83b2:	08db      	lsrs	r3, r3, #3
    83b4:	f003 0204 	and.w	r2, r3, #4
    83b8:	4b21      	ldr	r3, [pc, #132]	; (8440 <am_devices_led_init+0x2e0>)
    83ba:	4413      	add	r3, r2
    83bc:	4619      	mov	r1, r3
    83be:	687b      	ldr	r3, [r7, #4]
    83c0:	681b      	ldr	r3, [r3, #0]
    83c2:	f003 031f 	and.w	r3, r3, #31
    83c6:	2201      	movs	r2, #1
    83c8:	fa02 f303 	lsl.w	r3, r2, r3
    83cc:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    83ce:	687b      	ldr	r3, [r7, #4]
    83d0:	685b      	ldr	r3, [r3, #4]
    83d2:	f003 0301 	and.w	r3, r3, #1
    83d6:	2b00      	cmp	r3, #0
    83d8:	d010      	beq.n	83fc <am_devices_led_init+0x29c>
    83da:	687b      	ldr	r3, [r7, #4]
    83dc:	681b      	ldr	r3, [r3, #0]
    83de:	08db      	lsrs	r3, r3, #3
    83e0:	f003 0204 	and.w	r2, r3, #4
    83e4:	4b14      	ldr	r3, [pc, #80]	; (8438 <am_devices_led_init+0x2d8>)
    83e6:	4413      	add	r3, r2
    83e8:	4619      	mov	r1, r3
    83ea:	687b      	ldr	r3, [r7, #4]
    83ec:	681b      	ldr	r3, [r3, #0]
    83ee:	f003 031f 	and.w	r3, r3, #31
    83f2:	2201      	movs	r2, #1
    83f4:	fa02 f303 	lsl.w	r3, r2, r3
    83f8:	600b      	str	r3, [r1, #0]
                                    psLED->ui32Polarity &
                                    AM_DEVICES_LED_POL_POLARITY_M );
    }
}
    83fa:	e00f      	b.n	841c <am_devices_led_init+0x2bc>
        //
        // Disable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    83fc:	687b      	ldr	r3, [r7, #4]
    83fe:	681b      	ldr	r3, [r3, #0]
    8400:	08db      	lsrs	r3, r3, #3
    8402:	f003 0204 	and.w	r2, r3, #4
    8406:	4b0d      	ldr	r3, [pc, #52]	; (843c <am_devices_led_init+0x2dc>)
    8408:	4413      	add	r3, r2
    840a:	4619      	mov	r1, r3
    840c:	687b      	ldr	r3, [r7, #4]
    840e:	681b      	ldr	r3, [r3, #0]
    8410:	f003 031f 	and.w	r3, r3, #31
    8414:	2201      	movs	r2, #1
    8416:	fa02 f303 	lsl.w	r3, r2, r3
    841a:	600b      	str	r3, [r1, #0]
                                    psLED->ui32Polarity &
                                    AM_DEVICES_LED_POL_POLARITY_M );
    }
}
    841c:	bf00      	nop
    841e:	3710      	adds	r7, #16
    8420:	46bd      	mov	sp, r7
    8422:	bc90      	pop	{r4, r7}
    8424:	4770      	bx	lr
    8426:	bf00      	nop
    8428:	40010060 	.word	0x40010060
    842c:	40010040 	.word	0x40010040
    8430:	400100e0 	.word	0x400100e0
    8434:	400100a8 	.word	0x400100a8
    8438:	40010090 	.word	0x40010090
    843c:	40010098 	.word	0x40010098
    8440:	400100b4 	.word	0x400100b4

00008444 <am_devices_led_array_init>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    8444:	b580      	push	{r7, lr}
    8446:	b084      	sub	sp, #16
    8448:	af00      	add	r7, sp, #0
    844a:	6078      	str	r0, [r7, #4]
    844c:	6039      	str	r1, [r7, #0]
    uint32_t i;

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    844e:	2300      	movs	r3, #0
    8450:	60fb      	str	r3, [r7, #12]
    8452:	e009      	b.n	8468 <am_devices_led_array_init+0x24>
    {
        am_devices_led_init(psLEDs + i);
    8454:	68fb      	ldr	r3, [r7, #12]
    8456:	00db      	lsls	r3, r3, #3
    8458:	687a      	ldr	r2, [r7, #4]
    845a:	4413      	add	r3, r2
    845c:	4618      	mov	r0, r3
    845e:	f7ff fe7f 	bl	8160 <am_devices_led_init>
    uint32_t i;

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    8462:	68fb      	ldr	r3, [r7, #12]
    8464:	3301      	adds	r3, #1
    8466:	60fb      	str	r3, [r7, #12]
    8468:	68fa      	ldr	r2, [r7, #12]
    846a:	683b      	ldr	r3, [r7, #0]
    846c:	429a      	cmp	r2, r3
    846e:	d3f1      	bcc.n	8454 <am_devices_led_array_init+0x10>
    {
        am_devices_led_init(psLEDs + i);
    }
}
    8470:	bf00      	nop
    8472:	3710      	adds	r7, #16
    8474:	46bd      	mov	sp, r7
    8476:	bd80      	pop	{r7, pc}

00008478 <am_devices_led_on>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_on(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    8478:	b480      	push	{r7}
    847a:	b083      	sub	sp, #12
    847c:	af00      	add	r7, sp, #0
    847e:	6078      	str	r0, [r7, #4]
    8480:	6039      	str	r1, [r7, #0]
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    8482:	683b      	ldr	r3, [r7, #0]
    8484:	00db      	lsls	r3, r3, #3
    8486:	687a      	ldr	r2, [r7, #4]
    8488:	4413      	add	r3, r2
    848a:	685b      	ldr	r3, [r3, #4]
    848c:	f003 0302 	and.w	r3, r3, #2
    8490:	2b00      	cmp	r3, #0
    8492:	d036      	beq.n	8502 <am_devices_led_on+0x8a>
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    8494:	683b      	ldr	r3, [r7, #0]
    8496:	00db      	lsls	r3, r3, #3
    8498:	687a      	ldr	r2, [r7, #4]
    849a:	4413      	add	r3, r2
    849c:	685b      	ldr	r3, [r3, #4]
    849e:	f003 0301 	and.w	r3, r3, #1
    84a2:	2b00      	cmp	r3, #0
    84a4:	d016      	beq.n	84d4 <am_devices_led_on+0x5c>
    84a6:	683b      	ldr	r3, [r7, #0]
    84a8:	00db      	lsls	r3, r3, #3
    84aa:	687a      	ldr	r2, [r7, #4]
    84ac:	4413      	add	r3, r2
    84ae:	681b      	ldr	r3, [r3, #0]
    84b0:	08db      	lsrs	r3, r3, #3
    84b2:	f003 0204 	and.w	r2, r3, #4
    84b6:	4b21      	ldr	r3, [pc, #132]	; (853c <am_devices_led_on+0xc4>)
    84b8:	4413      	add	r3, r2
    84ba:	4619      	mov	r1, r3
    84bc:	683b      	ldr	r3, [r7, #0]
    84be:	00db      	lsls	r3, r3, #3
    84c0:	687a      	ldr	r2, [r7, #4]
    84c2:	4413      	add	r3, r2
    84c4:	681b      	ldr	r3, [r3, #0]
    84c6:	f003 031f 	and.w	r3, r3, #31
    84ca:	2201      	movs	r2, #1
    84cc:	fa02 f303 	lsl.w	r3, r2, r3
    84d0:	600b      	str	r3, [r1, #0]
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
}
    84d2:	e02c      	b.n	852e <am_devices_led_on+0xb6>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    84d4:	683b      	ldr	r3, [r7, #0]
    84d6:	00db      	lsls	r3, r3, #3
    84d8:	687a      	ldr	r2, [r7, #4]
    84da:	4413      	add	r3, r2
    84dc:	681b      	ldr	r3, [r3, #0]
    84de:	08db      	lsrs	r3, r3, #3
    84e0:	f003 0204 	and.w	r2, r3, #4
    84e4:	4b16      	ldr	r3, [pc, #88]	; (8540 <am_devices_led_on+0xc8>)
    84e6:	4413      	add	r3, r2
    84e8:	4619      	mov	r1, r3
    84ea:	683b      	ldr	r3, [r7, #0]
    84ec:	00db      	lsls	r3, r3, #3
    84ee:	687a      	ldr	r2, [r7, #4]
    84f0:	4413      	add	r3, r2
    84f2:	681b      	ldr	r3, [r3, #0]
    84f4:	f003 031f 	and.w	r3, r3, #31
    84f8:	2201      	movs	r2, #1
    84fa:	fa02 f303 	lsl.w	r3, r2, r3
    84fe:	600b      	str	r3, [r1, #0]
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
}
    8500:	e015      	b.n	852e <am_devices_led_on+0xb6>
    else
    {
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    8502:	683b      	ldr	r3, [r7, #0]
    8504:	00db      	lsls	r3, r3, #3
    8506:	687a      	ldr	r2, [r7, #4]
    8508:	4413      	add	r3, r2
    850a:	681b      	ldr	r3, [r3, #0]
    850c:	08db      	lsrs	r3, r3, #3
    850e:	f003 0204 	and.w	r2, r3, #4
    8512:	4b0c      	ldr	r3, [pc, #48]	; (8544 <am_devices_led_on+0xcc>)
    8514:	4413      	add	r3, r2
    8516:	4619      	mov	r1, r3
    8518:	683b      	ldr	r3, [r7, #0]
    851a:	00db      	lsls	r3, r3, #3
    851c:	687a      	ldr	r2, [r7, #4]
    851e:	4413      	add	r3, r2
    8520:	681b      	ldr	r3, [r3, #0]
    8522:	f003 031f 	and.w	r3, r3, #31
    8526:	2201      	movs	r2, #1
    8528:	fa02 f303 	lsl.w	r3, r2, r3
    852c:	600b      	str	r3, [r1, #0]
    }
}
    852e:	bf00      	nop
    8530:	370c      	adds	r7, #12
    8532:	46bd      	mov	sp, r7
    8534:	f85d 7b04 	ldr.w	r7, [sp], #4
    8538:	4770      	bx	lr
    853a:	bf00      	nop
    853c:	40010090 	.word	0x40010090
    8540:	40010098 	.word	0x40010098
    8544:	400100a8 	.word	0x400100a8

00008548 <am_devices_led_off>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_off(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    8548:	b480      	push	{r7}
    854a:	b083      	sub	sp, #12
    854c:	af00      	add	r7, sp, #0
    854e:	6078      	str	r0, [r7, #4]
    8550:	6039      	str	r1, [r7, #0]
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    8552:	683b      	ldr	r3, [r7, #0]
    8554:	00db      	lsls	r3, r3, #3
    8556:	687a      	ldr	r2, [r7, #4]
    8558:	4413      	add	r3, r2
    855a:	685b      	ldr	r3, [r3, #4]
    855c:	f003 0302 	and.w	r3, r3, #2
    8560:	2b00      	cmp	r3, #0
    8562:	d036      	beq.n	85d2 <am_devices_led_off+0x8a>
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    8564:	683b      	ldr	r3, [r7, #0]
    8566:	00db      	lsls	r3, r3, #3
    8568:	687a      	ldr	r2, [r7, #4]
    856a:	4413      	add	r3, r2
    856c:	685b      	ldr	r3, [r3, #4]
    856e:	f003 0301 	and.w	r3, r3, #1
    8572:	2b00      	cmp	r3, #0
    8574:	d116      	bne.n	85a4 <am_devices_led_off+0x5c>
    8576:	683b      	ldr	r3, [r7, #0]
    8578:	00db      	lsls	r3, r3, #3
    857a:	687a      	ldr	r2, [r7, #4]
    857c:	4413      	add	r3, r2
    857e:	681b      	ldr	r3, [r3, #0]
    8580:	08db      	lsrs	r3, r3, #3
    8582:	f003 0204 	and.w	r2, r3, #4
    8586:	4b21      	ldr	r3, [pc, #132]	; (860c <am_devices_led_off+0xc4>)
    8588:	4413      	add	r3, r2
    858a:	4619      	mov	r1, r3
    858c:	683b      	ldr	r3, [r7, #0]
    858e:	00db      	lsls	r3, r3, #3
    8590:	687a      	ldr	r2, [r7, #4]
    8592:	4413      	add	r3, r2
    8594:	681b      	ldr	r3, [r3, #0]
    8596:	f003 031f 	and.w	r3, r3, #31
    859a:	2201      	movs	r2, #1
    859c:	fa02 f303 	lsl.w	r3, r2, r3
    85a0:	600b      	str	r3, [r1, #0]
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
}
    85a2:	e02c      	b.n	85fe <am_devices_led_off+0xb6>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    85a4:	683b      	ldr	r3, [r7, #0]
    85a6:	00db      	lsls	r3, r3, #3
    85a8:	687a      	ldr	r2, [r7, #4]
    85aa:	4413      	add	r3, r2
    85ac:	681b      	ldr	r3, [r3, #0]
    85ae:	08db      	lsrs	r3, r3, #3
    85b0:	f003 0204 	and.w	r2, r3, #4
    85b4:	4b16      	ldr	r3, [pc, #88]	; (8610 <am_devices_led_off+0xc8>)
    85b6:	4413      	add	r3, r2
    85b8:	4619      	mov	r1, r3
    85ba:	683b      	ldr	r3, [r7, #0]
    85bc:	00db      	lsls	r3, r3, #3
    85be:	687a      	ldr	r2, [r7, #4]
    85c0:	4413      	add	r3, r2
    85c2:	681b      	ldr	r3, [r3, #0]
    85c4:	f003 031f 	and.w	r3, r3, #31
    85c8:	2201      	movs	r2, #1
    85ca:	fa02 f303 	lsl.w	r3, r2, r3
    85ce:	600b      	str	r3, [r1, #0]
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
}
    85d0:	e015      	b.n	85fe <am_devices_led_off+0xb6>
    else
    {
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    85d2:	683b      	ldr	r3, [r7, #0]
    85d4:	00db      	lsls	r3, r3, #3
    85d6:	687a      	ldr	r2, [r7, #4]
    85d8:	4413      	add	r3, r2
    85da:	681b      	ldr	r3, [r3, #0]
    85dc:	08db      	lsrs	r3, r3, #3
    85de:	f003 0204 	and.w	r2, r3, #4
    85e2:	4b0c      	ldr	r3, [pc, #48]	; (8614 <am_devices_led_off+0xcc>)
    85e4:	4413      	add	r3, r2
    85e6:	4619      	mov	r1, r3
    85e8:	683b      	ldr	r3, [r7, #0]
    85ea:	00db      	lsls	r3, r3, #3
    85ec:	687a      	ldr	r2, [r7, #4]
    85ee:	4413      	add	r3, r2
    85f0:	681b      	ldr	r3, [r3, #0]
    85f2:	f003 031f 	and.w	r3, r3, #31
    85f6:	2201      	movs	r2, #1
    85f8:	fa02 f303 	lsl.w	r3, r2, r3
    85fc:	600b      	str	r3, [r1, #0]
    }
}
    85fe:	bf00      	nop
    8600:	370c      	adds	r7, #12
    8602:	46bd      	mov	sp, r7
    8604:	f85d 7b04 	ldr.w	r7, [sp], #4
    8608:	4770      	bx	lr
    860a:	bf00      	nop
    860c:	40010090 	.word	0x40010090
    8610:	40010098 	.word	0x40010098
    8614:	400100b4 	.word	0x400100b4

00008618 <am_devices_led_array_out>:
//
//*****************************************************************************
void
am_devices_led_array_out(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs,
                         uint32_t ui32Value)
{
    8618:	b580      	push	{r7, lr}
    861a:	b086      	sub	sp, #24
    861c:	af00      	add	r7, sp, #0
    861e:	60f8      	str	r0, [r7, #12]
    8620:	60b9      	str	r1, [r7, #8]
    8622:	607a      	str	r2, [r7, #4]
    uint32_t i;

    for ( i = 0; i < ui32NumLEDs; i++ )
    8624:	2300      	movs	r3, #0
    8626:	617b      	str	r3, [r7, #20]
    8628:	e014      	b.n	8654 <am_devices_led_array_out+0x3c>
    {
        if ( ui32Value & (1 << i) )
    862a:	2201      	movs	r2, #1
    862c:	697b      	ldr	r3, [r7, #20]
    862e:	fa02 f303 	lsl.w	r3, r2, r3
    8632:	461a      	mov	r2, r3
    8634:	687b      	ldr	r3, [r7, #4]
    8636:	4013      	ands	r3, r2
    8638:	2b00      	cmp	r3, #0
    863a:	d004      	beq.n	8646 <am_devices_led_array_out+0x2e>
        {
            am_devices_led_on(psLEDs, i);
    863c:	6979      	ldr	r1, [r7, #20]
    863e:	68f8      	ldr	r0, [r7, #12]
    8640:	f7ff ff1a 	bl	8478 <am_devices_led_on>
    8644:	e003      	b.n	864e <am_devices_led_array_out+0x36>
        }
        else
        {
            am_devices_led_off(psLEDs, i);
    8646:	6979      	ldr	r1, [r7, #20]
    8648:	68f8      	ldr	r0, [r7, #12]
    864a:	f7ff ff7d 	bl	8548 <am_devices_led_off>
am_devices_led_array_out(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs,
                         uint32_t ui32Value)
{
    uint32_t i;

    for ( i = 0; i < ui32NumLEDs; i++ )
    864e:	697b      	ldr	r3, [r7, #20]
    8650:	3301      	adds	r3, #1
    8652:	617b      	str	r3, [r7, #20]
    8654:	697a      	ldr	r2, [r7, #20]
    8656:	68bb      	ldr	r3, [r7, #8]
    8658:	429a      	cmp	r2, r3
    865a:	d3e6      	bcc.n	862a <am_devices_led_array_out+0x12>
        else
        {
            am_devices_led_off(psLEDs, i);
        }
    }
}
    865c:	bf00      	nop
    865e:	3718      	adds	r7, #24
    8660:	46bd      	mov	sp, r7
    8662:	bd80      	pop	{r7, pc}

00008664 <timerA0_init>:
// Function to initialize Timer A0 to interrupt every 1/4 second.
//
//*****************************************************************************
void
timerA0_init(void)
{
    8664:	b580      	push	{r7, lr}
    8666:	b082      	sub	sp, #8
    8668:	af00      	add	r7, sp, #0
    uint32_t ui32Period;

    //
    // Enable the LFRC.
    //
    am_hal_clkgen_osc_start(AM_HAL_CLKGEN_OSC_LFRC);
    866a:	2002      	movs	r0, #2
    866c:	f001 f938 	bl	98e0 <am_hal_clkgen_osc_start>

    //
    // Set up timer A0.
    //
    am_hal_ctimer_clear(0, AM_HAL_CTIMER_TIMERA);
    8670:	f64f 71ff 	movw	r1, #65535	; 0xffff
    8674:	2000      	movs	r0, #0
    8676:	f001 f9d1 	bl	9a1c <am_hal_ctimer_clear>
    am_hal_ctimer_config(0, &g_sTimer0);
    867a:	490a      	ldr	r1, [pc, #40]	; (86a4 <timerA0_init+0x40>)
    867c:	2000      	movs	r0, #0
    867e:	f001 f943 	bl	9908 <am_hal_ctimer_config>

    //
    // Set up timerA0 to 32Hz from LFRC divided to 1 second period.
    //
    ui32Period = 8;
    8682:	2308      	movs	r3, #8
    8684:	607b      	str	r3, [r7, #4]
    am_hal_ctimer_period_set(0, AM_HAL_CTIMER_TIMERA, ui32Period,
    8686:	687b      	ldr	r3, [r7, #4]
    8688:	085b      	lsrs	r3, r3, #1
    868a:	687a      	ldr	r2, [r7, #4]
    868c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    8690:	2000      	movs	r0, #0
    8692:	f001 f9d7 	bl	9a44 <am_hal_ctimer_period_set>
                             (ui32Period >> 1));

    //
    // Clear the timer Interrupt
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    8696:	2001      	movs	r0, #1
    8698:	f001 fa28 	bl	9aec <am_hal_ctimer_int_clear>
}
    869c:	bf00      	nop
    869e:	3708      	adds	r7, #8
    86a0:	46bd      	mov	sp, r7
    86a2:	bd80      	pop	{r7, pc}
    86a4:	10001000 	.word	0x10001000

000086a8 <am_ctimer_isr>:
// Timer Interrupt Service Routine (ISR)
//
//*****************************************************************************
void
am_ctimer_isr(void)
{
    86a8:	b580      	push	{r7, lr}
    86aa:	af00      	add	r7, sp, #0
    //
    // Clear TimerA0 Interrupt (write to clear).
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    86ac:	2001      	movs	r0, #1
    86ae:	f001 fa1d 	bl	9aec <am_hal_ctimer_int_clear>

    //
    // Increment count and set limit based on the number of LEDs available.
    //
    if (++g_ui32TimerCount >= (1 << AM_BSP_NUM_LEDS))
    86b2:	4b06      	ldr	r3, [pc, #24]	; (86cc <am_ctimer_isr+0x24>)
    86b4:	681b      	ldr	r3, [r3, #0]
    86b6:	3301      	adds	r3, #1
    86b8:	4a04      	ldr	r2, [pc, #16]	; (86cc <am_ctimer_isr+0x24>)
    86ba:	6013      	str	r3, [r2, #0]
    86bc:	2b1f      	cmp	r3, #31
    86be:	d902      	bls.n	86c6 <am_ctimer_isr+0x1e>
    {
        //
        // Reset the global.
        //
        g_ui32TimerCount = 0;
    86c0:	4b02      	ldr	r3, [pc, #8]	; (86cc <am_ctimer_isr+0x24>)
    86c2:	2200      	movs	r2, #0
    86c4:	601a      	str	r2, [r3, #0]
    }
}
    86c6:	bf00      	nop
    86c8:	bd80      	pop	{r7, pc}
    86ca:	bf00      	nop
    86cc:	10001084 	.word	0x10001084

000086d0 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
    86d0:	b580      	push	{r7, lr}
    86d2:	b082      	sub	sp, #8
    86d4:	af00      	add	r7, sp, #0
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
    86d6:	2000      	movs	r0, #0
    86d8:	f001 f8da 	bl	9890 <am_hal_clkgen_sysclk_select>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);
    86dc:	4828      	ldr	r0, [pc, #160]	; (8780 <main+0xb0>)
    86de:	f001 f841 	bl	9764 <am_hal_cachectrl_enable>

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
    86e2:	f000 ffb5 	bl	9650 <am_bsp_low_power_init>

    //
    // Initialize the printf interface for ITM/SWO output.
    //
    am_util_stdio_printf_init((am_util_stdio_print_char_t) am_bsp_itm_string_print);
    86e6:	4827      	ldr	r0, [pc, #156]	; (8784 <main+0xb4>)
    86e8:	f000 f918 	bl	891c <am_util_stdio_printf_init>

    //
    // Initialize the SWO GPIO pin
    //
    am_bsp_pin_enable(ITM_SWO);
    86ec:	f3ef 8310 	mrs	r3, PRIMASK
    86f0:	607b      	str	r3, [r7, #4]
    86f2:	b672      	cpsid	i
    86f4:	4b24      	ldr	r3, [pc, #144]	; (8788 <main+0xb8>)
    86f6:	2273      	movs	r2, #115	; 0x73
    86f8:	601a      	str	r2, [r3, #0]
    86fa:	4a24      	ldr	r2, [pc, #144]	; (878c <main+0xbc>)
    86fc:	4b23      	ldr	r3, [pc, #140]	; (878c <main+0xbc>)
    86fe:	681b      	ldr	r3, [r3, #0]
    8700:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    8704:	6013      	str	r3, [r2, #0]
    8706:	4a22      	ldr	r2, [pc, #136]	; (8790 <main+0xc0>)
    8708:	4b21      	ldr	r3, [pc, #132]	; (8790 <main+0xc0>)
    870a:	681b      	ldr	r3, [r3, #0]
    870c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
    8710:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    8714:	6013      	str	r3, [r2, #0]
    8716:	4a1f      	ldr	r2, [pc, #124]	; (8794 <main+0xc4>)
    8718:	4b1e      	ldr	r3, [pc, #120]	; (8794 <main+0xc4>)
    871a:	681b      	ldr	r3, [r3, #0]
    871c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
    8720:	6013      	str	r3, [r2, #0]
    8722:	4b19      	ldr	r3, [pc, #100]	; (8788 <main+0xb8>)
    8724:	2200      	movs	r2, #0
    8726:	601a      	str	r2, [r3, #0]
    8728:	687b      	ldr	r3, [r7, #4]
    872a:	f383 8810 	msr	PRIMASK, r3
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    872e:	2105      	movs	r1, #5
    8730:	4819      	ldr	r0, [pc, #100]	; (8798 <main+0xc8>)
    8732:	f7ff fe87 	bl	8444 <am_devices_led_array_init>

    //
    // Enable the ITM.
    //
    am_hal_itm_enable();
    8736:	f001 fa1b 	bl	9b70 <am_hal_itm_enable>

    //
    // Enable debug printf messages using ITM on SWO pin
    //
    am_bsp_debug_printf_enable();
    873a:	f000 ff9b 	bl	9674 <am_bsp_debug_printf_enable>

    //
    // Clear the terminal and print the banner.
    //
    am_util_stdio_terminal_clear();
    873e:	f000 ff7d 	bl	963c <am_util_stdio_terminal_clear>
    am_util_stdio_printf("Binary Counter Example\n");
    8742:	4816      	ldr	r0, [pc, #88]	; (879c <main+0xcc>)
    8744:	f000 ff5c 	bl	9600 <am_util_stdio_printf>

    //
    // TimerA0 init.
    //
    timerA0_init();
    8748:	f7ff ff8c 	bl	8664 <timerA0_init>

    //
    // Enable the timer Interrupt.
    //
    am_hal_ctimer_int_enable(AM_HAL_CTIMER_INT_TIMERA0);
    874c:	2001      	movs	r0, #1
    874e:	f001 f9bd 	bl	9acc <am_hal_ctimer_int_enable>

    //
    // Enable the timer interrupt in the NVIC.
    //
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_CTIMER);
    8752:	201d      	movs	r0, #29
    8754:	f001 f9d8 	bl	9b08 <am_hal_interrupt_enable>
    am_hal_interrupt_master_enable();
    8758:	f001 f9fe 	bl	9b58 <am_hal_interrupt_master_enable>

    //
    // Start timer A0
    //
    am_hal_ctimer_start(0, AM_HAL_CTIMER_TIMERA);
    875c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    8760:	2000      	movs	r0, #0
    8762:	f001 f941 	bl	99e8 <am_hal_ctimer_start>

    //
    // We are done printing. Disable debug printf messages on ITM.
    //
    am_bsp_debug_printf_disable();
    8766:	f000 ffc5 	bl	96f4 <am_bsp_debug_printf_disable>
    while (1)
    {
        //
        // Go to Deep Sleep.
        //
        am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    876a:	2001      	movs	r0, #1
    876c:	f001 fc0e 	bl	9f8c <am_hal_sysctrl_sleep>

        //
        // Set the LEDs.
        //
        am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS,
    8770:	4b0b      	ldr	r3, [pc, #44]	; (87a0 <main+0xd0>)
    8772:	681b      	ldr	r3, [r3, #0]
    8774:	461a      	mov	r2, r3
    8776:	2105      	movs	r1, #5
    8778:	4807      	ldr	r0, [pc, #28]	; (8798 <main+0xc8>)
    877a:	f7ff ff4d 	bl	8618 <am_devices_led_array_out>
                         g_ui32TimerCount);
    }
    877e:	e7f4      	b.n	876a <main+0x9a>
    8780:	0000a1b0 	.word	0x0000a1b0
    8784:	00009761 	.word	0x00009761
    8788:	40010060 	.word	0x40010060
    878c:	40010054 	.word	0x40010054
    8790:	40010028 	.word	0x40010028
    8794:	40010108 	.word	0x40010108
    8798:	1000100c 	.word	0x1000100c
    879c:	0000a184 	.word	0x0000a184
    87a0:	10001084 	.word	0x10001084

000087a4 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
    87a4:	4811      	ldr	r0, [pc, #68]	; (87ec <zero_loop+0x12>)
    87a6:	4912      	ldr	r1, [pc, #72]	; (87f0 <zero_loop+0x16>)
    87a8:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
    87aa:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
    87ae:	4811      	ldr	r0, [pc, #68]	; (87f4 <zero_loop+0x1a>)
    87b0:	6801      	ldr	r1, [r0, #0]
    87b2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    87b6:	6001      	str	r1, [r0, #0]
    87b8:	f3bf 8f4f 	dsb	sy
    87bc:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
    87c0:	480d      	ldr	r0, [pc, #52]	; (87f8 <zero_loop+0x1e>)
    87c2:	490e      	ldr	r1, [pc, #56]	; (87fc <zero_loop+0x22>)
    87c4:	4a0e      	ldr	r2, [pc, #56]	; (8800 <zero_loop+0x26>)

000087c6 <copy_loop>:
    87c6:	f850 3b04 	ldr.w	r3, [r0], #4
    87ca:	f841 3b04 	str.w	r3, [r1], #4
    87ce:	4291      	cmp	r1, r2
    87d0:	dbf9      	blt.n	87c6 <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
    87d2:	480c      	ldr	r0, [pc, #48]	; (8804 <zero_loop+0x2a>)
    87d4:	490c      	ldr	r1, [pc, #48]	; (8808 <zero_loop+0x2e>)
    87d6:	f04f 0200 	mov.w	r2, #0

000087da <zero_loop>:
    87da:	4288      	cmp	r0, r1
    87dc:	bfb8      	it	lt
    87de:	f840 2b04 	strlt.w	r2, [r0], #4
    87e2:	dbfa      	blt.n	87da <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
    87e4:	f7ff ff74 	bl	86d0 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
    87e8:	be00      	bkpt	0x0000
}
    87ea:	bf00      	nop
    87ec:	e000ed08 	.word	0xe000ed08
    87f0:	00008000 	.word	0x00008000
    87f4:	e000ed88 	.word	0xe000ed88
    87f8:	0000a20c 	.word	0x0000a20c
    87fc:	10001000 	.word	0x10001000
    8800:	10001084 	.word	0x10001084
    8804:	10001084 	.word	0x10001084
    8808:	100011a0 	.word	0x100011a0

0000880c <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
    880c:	b480      	push	{r7}
    880e:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
    8810:	e7fe      	b.n	8810 <am_nmi_isr+0x4>
    8812:	bf00      	nop

00008814 <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    8814:	b480      	push	{r7}
    8816:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
    8818:	e7fe      	b.n	8818 <am_adc_isr+0x4>
    881a:	bf00      	nop

0000881c <am_fault_isr>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_fault_isr(void)
{
    __asm("    push    {r7,lr}");
    881c:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    881e:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    8820:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    8822:	f000 f809 	bl	8838 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    8826:	bd01      	pop	{r0, pc}
}
    8828:	bf00      	nop
    882a:	4618      	mov	r0, r3

0000882c <getStackedReg>:

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    882c:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    882e:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    8830:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    8832:	4770      	bx	lr
}
    8834:	bf00      	nop
    8836:	4618      	mov	r0, r3

00008838 <am_util_faultisr_collect_data>:
// am_fault_isr() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    8838:	b580      	push	{r7, lr}
    883a:	b096      	sub	sp, #88	; 0x58
    883c:	af00      	add	r7, sp, #0
    883e:	6078      	str	r0, [r7, #4]
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    8840:	f107 030c 	add.w	r3, r7, #12
    8844:	2200      	movs	r2, #0
    8846:	601a      	str	r2, [r3, #0]
    8848:	605a      	str	r2, [r3, #4]
    884a:	609a      	str	r2, [r3, #8]
    884c:	60da      	str	r2, [r3, #12]
    884e:	611a      	str	r2, [r3, #16]
    8850:	615a      	str	r2, [r3, #20]
    
    uint32_t u32Mask = 0;
    8852:	2300      	movs	r3, #0
    8854:	657b      	str	r3, [r7, #84]	; 0x54
    // u32Mask is used for 2 things: 1) in the print loop, 2) as a spot to set
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    8856:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    8858:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    885a:	4b2e      	ldr	r3, [pc, #184]	; (8914 <am_util_faultisr_collect_data+0xdc>)
    885c:	681b      	ldr	r3, [r3, #0]
    885e:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    8860:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8862:	b2db      	uxtb	r3, r3
    8864:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    8868:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    886a:	0a1b      	lsrs	r3, r3, #8
    886c:	b2db      	uxtb	r3, r3
    886e:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    8872:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8874:	0c1b      	lsrs	r3, r3, #16
    8876:	b29b      	uxth	r3, r3
    8878:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    887c:	4b26      	ldr	r3, [pc, #152]	; (8918 <am_util_faultisr_collect_data+0xe0>)
    887e:	681b      	ldr	r3, [r3, #0]
    8880:	64bb      	str	r3, [r7, #72]	; 0x48

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    8882:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
    8886:	b2db      	uxtb	r3, r3
    8888:	f003 0302 	and.w	r3, r3, #2
    888c:	2b00      	cmp	r3, #0
    888e:	d005      	beq.n	889c <am_util_faultisr_collect_data+0x64>
    8890:	6879      	ldr	r1, [r7, #4]
    8892:	2006      	movs	r0, #6
    8894:	f7ff ffca 	bl	882c <getStackedReg>
    8898:	4603      	mov	r3, r0
    889a:	e001      	b.n	88a0 <am_util_faultisr_collect_data+0x68>
    889c:	f04f 33ff 	mov.w	r3, #4294967295
    88a0:	647b      	str	r3, [r7, #68]	; 0x44

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    88a2:	6879      	ldr	r1, [r7, #4]
    88a4:	2000      	movs	r0, #0
    88a6:	f7ff ffc1 	bl	882c <getStackedReg>
    88aa:	4603      	mov	r3, r0
    88ac:	627b      	str	r3, [r7, #36]	; 0x24
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    88ae:	6879      	ldr	r1, [r7, #4]
    88b0:	2001      	movs	r0, #1
    88b2:	f7ff ffbb 	bl	882c <getStackedReg>
    88b6:	4603      	mov	r3, r0
    88b8:	62bb      	str	r3, [r7, #40]	; 0x28
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    88ba:	6879      	ldr	r1, [r7, #4]
    88bc:	2002      	movs	r0, #2
    88be:	f7ff ffb5 	bl	882c <getStackedReg>
    88c2:	4603      	mov	r3, r0
    88c4:	62fb      	str	r3, [r7, #44]	; 0x2c
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    88c6:	6879      	ldr	r1, [r7, #4]
    88c8:	2003      	movs	r0, #3
    88ca:	f7ff ffaf 	bl	882c <getStackedReg>
    88ce:	4603      	mov	r3, r0
    88d0:	633b      	str	r3, [r7, #48]	; 0x30
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    88d2:	6879      	ldr	r1, [r7, #4]
    88d4:	2004      	movs	r0, #4
    88d6:	f7ff ffa9 	bl	882c <getStackedReg>
    88da:	4603      	mov	r3, r0
    88dc:	637b      	str	r3, [r7, #52]	; 0x34
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    88de:	6879      	ldr	r1, [r7, #4]
    88e0:	2005      	movs	r0, #5
    88e2:	f7ff ffa3 	bl	882c <getStackedReg>
    88e6:	4603      	mov	r3, r0
    88e8:	63bb      	str	r3, [r7, #56]	; 0x38
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    88ea:	6879      	ldr	r1, [r7, #4]
    88ec:	2006      	movs	r0, #6
    88ee:	f7ff ff9d 	bl	882c <getStackedReg>
    88f2:	4603      	mov	r3, r0
    88f4:	63fb      	str	r3, [r7, #60]	; 0x3c
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    88f6:	6879      	ldr	r1, [r7, #4]
    88f8:	2007      	movs	r0, #7
    88fa:	f7ff ff97 	bl	882c <getStackedReg>
    88fe:	4603      	mov	r3, r0
    8900:	643b      	str	r3, [r7, #64]	; 0x40

    //
    // Use the HAL MCUCTRL functions to read the fault data.
    //
    am_hal_mcuctrl_fault_status(&sHalFaultData);
    8902:	f107 030c 	add.w	r3, r7, #12
    8906:	4618      	mov	r0, r3
    8908:	f001 f982 	bl	9c10 <am_hal_mcuctrl_fault_status>
    }


#endif

    u32Mask = 0;
    890c:	2300      	movs	r3, #0
    890e:	657b      	str	r3, [r7, #84]	; 0x54
    // We need to spin here inside the function so that we have access to
    // local data, i.e. sFaultData.
    //
    while(1)
    {
    }
    8910:	e7fe      	b.n	8910 <am_util_faultisr_collect_data+0xd8>
    8912:	bf00      	nop
    8914:	e000ed28 	.word	0xe000ed28
    8918:	e000ed38 	.word	0xe000ed38

0000891c <am_util_stdio_printf_init>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
{
    891c:	b480      	push	{r7}
    891e:	b083      	sub	sp, #12
    8920:	af00      	add	r7, sp, #0
    8922:	6078      	str	r0, [r7, #4]
    g_pfnCharPrint = pfnCharPrint;
    8924:	4a04      	ldr	r2, [pc, #16]	; (8938 <am_util_stdio_printf_init+0x1c>)
    8926:	687b      	ldr	r3, [r7, #4]
    8928:	6013      	str	r3, [r2, #0]
}
    892a:	bf00      	nop
    892c:	370c      	adds	r7, #12
    892e:	46bd      	mov	sp, r7
    8930:	f85d 7b04 	ldr.w	r7, [sp], #4
    8934:	4770      	bx	lr
    8936:	bf00      	nop
    8938:	1000119c 	.word	0x1000119c

0000893c <divu64_10>:
//  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
//
//*****************************************************************************
static uint64_t
divu64_10(uint64_t ui64Val)
{
    893c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    8940:	b096      	sub	sp, #88	; 0x58
    8942:	af00      	add	r7, sp, #0
    8944:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
    8948:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    894c:	0025      	movs	r5, r4
    894e:	2600      	movs	r6, #0
    8950:	ea55 0306 	orrs.w	r3, r5, r6
    8954:	f000 809e 	beq.w	8a94 <divu64_10+0x158>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
    8958:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    895c:	0862      	lsrs	r2, r4, #1
    895e:	ea4f 0133 	mov.w	r1, r3, rrx
    8962:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8966:	ea4f 0893 	mov.w	r8, r3, lsr #2
    896a:	ea48 7884 	orr.w	r8, r8, r4, lsl #30
    896e:	ea4f 0994 	mov.w	r9, r4, lsr #2
    8972:	eb11 0308 	adds.w	r3, r1, r8
    8976:	eb42 0409 	adc.w	r4, r2, r9
    897a:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 4);
    897e:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8982:	ea4f 1a13 	mov.w	sl, r3, lsr #4
    8986:	ea4a 7a04 	orr.w	sl, sl, r4, lsl #28
    898a:	ea4f 1b14 	mov.w	fp, r4, lsr #4
    898e:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8992:	eb13 030a 	adds.w	r3, r3, sl
    8996:	eb44 040b 	adc.w	r4, r4, fp
    899a:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 8);
    899e:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89a2:	0a1a      	lsrs	r2, r3, #8
    89a4:	62ba      	str	r2, [r7, #40]	; 0x28
    89a6:	6aba      	ldr	r2, [r7, #40]	; 0x28
    89a8:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
    89ac:	62ba      	str	r2, [r7, #40]	; 0x28
    89ae:	0a23      	lsrs	r3, r4, #8
    89b0:	62fb      	str	r3, [r7, #44]	; 0x2c
    89b2:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89b6:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
    89ba:	18c9      	adds	r1, r1, r3
    89bc:	eb42 0204 	adc.w	r2, r2, r4
    89c0:	460b      	mov	r3, r1
    89c2:	4614      	mov	r4, r2
    89c4:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 16);
    89c8:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89cc:	0c1a      	lsrs	r2, r3, #16
    89ce:	623a      	str	r2, [r7, #32]
    89d0:	6a3a      	ldr	r2, [r7, #32]
    89d2:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
    89d6:	623a      	str	r2, [r7, #32]
    89d8:	0c23      	lsrs	r3, r4, #16
    89da:	627b      	str	r3, [r7, #36]	; 0x24
    89dc:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89e0:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
    89e4:	18c9      	adds	r1, r1, r3
    89e6:	eb42 0204 	adc.w	r2, r2, r4
    89ea:	460b      	mov	r3, r1
    89ec:	4614      	mov	r4, r2
    89ee:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 32);
    89f2:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89f6:	0023      	movs	r3, r4
    89f8:	603b      	str	r3, [r7, #0]
    89fa:	2300      	movs	r3, #0
    89fc:	607b      	str	r3, [r7, #4]
    89fe:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a02:	e897 0006 	ldmia.w	r7, {r1, r2}
    8a06:	18c9      	adds	r1, r1, r3
    8a08:	eb42 0204 	adc.w	r2, r2, r4
    8a0c:	460b      	mov	r3, r1
    8a0e:	4614      	mov	r4, r2
    8a10:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 >>= 3;
    8a14:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a18:	08da      	lsrs	r2, r3, #3
    8a1a:	613a      	str	r2, [r7, #16]
    8a1c:	693a      	ldr	r2, [r7, #16]
    8a1e:	ea42 7244 	orr.w	r2, r2, r4, lsl #29
    8a22:	613a      	str	r2, [r7, #16]
    8a24:	08e3      	lsrs	r3, r4, #3
    8a26:	617b      	str	r3, [r7, #20]
    8a28:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
    8a2c:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        r64 = ui64Val - q64*10;
    8a30:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a34:	18db      	adds	r3, r3, r3
    8a36:	eb44 0404 	adc.w	r4, r4, r4
    8a3a:	00a2      	lsls	r2, r4, #2
    8a3c:	60fa      	str	r2, [r7, #12]
    8a3e:	68fa      	ldr	r2, [r7, #12]
    8a40:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
    8a44:	60fa      	str	r2, [r7, #12]
    8a46:	009a      	lsls	r2, r3, #2
    8a48:	60ba      	str	r2, [r7, #8]
    8a4a:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
    8a4e:	18c9      	adds	r1, r1, r3
    8a50:	eb42 0204 	adc.w	r2, r2, r4
    8a54:	460b      	mov	r3, r1
    8a56:	4614      	mov	r4, r2
    8a58:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
    8a5c:	1acb      	subs	r3, r1, r3
    8a5e:	eb62 0404 	sbc.w	r4, r2, r4
    8a62:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        return q64 + ((r64 + 6) >> 4);
    8a66:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
    8a6a:	3306      	adds	r3, #6
    8a6c:	f144 0400 	adc.w	r4, r4, #0
    8a70:	091a      	lsrs	r2, r3, #4
    8a72:	61ba      	str	r2, [r7, #24]
    8a74:	69ba      	ldr	r2, [r7, #24]
    8a76:	ea42 7204 	orr.w	r2, r2, r4, lsl #28
    8a7a:	61ba      	str	r2, [r7, #24]
    8a7c:	0923      	lsrs	r3, r4, #4
    8a7e:	61fb      	str	r3, [r7, #28]
    8a80:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a84:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
    8a88:	18c9      	adds	r1, r1, r3
    8a8a:	eb42 0204 	adc.w	r2, r2, r4
    8a8e:	460b      	mov	r3, r1
    8a90:	4614      	mov	r4, r2
    8a92:	e029      	b.n	8ae8 <divu64_10+0x1ac>
    }
    else
    {
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    8a94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8a96:	647b      	str	r3, [r7, #68]	; 0x44
        q32 = (ui32Val>>1) + (ui32Val>>2);
    8a98:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8a9a:	085a      	lsrs	r2, r3, #1
    8a9c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8a9e:	089b      	lsrs	r3, r3, #2
    8aa0:	4413      	add	r3, r2
    8aa2:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 4);
    8aa4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8aa6:	091b      	lsrs	r3, r3, #4
    8aa8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8aaa:	4413      	add	r3, r2
    8aac:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 8);
    8aae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8ab0:	0a1b      	lsrs	r3, r3, #8
    8ab2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8ab4:	4413      	add	r3, r2
    8ab6:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 16);
    8ab8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8aba:	0c1b      	lsrs	r3, r3, #16
    8abc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8abe:	4413      	add	r3, r2
    8ac0:	643b      	str	r3, [r7, #64]	; 0x40
        q32 >>= 3;
    8ac2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8ac4:	08db      	lsrs	r3, r3, #3
    8ac6:	643b      	str	r3, [r7, #64]	; 0x40
        r32 = ui32Val - q32*10;
    8ac8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8aca:	4613      	mov	r3, r2
    8acc:	009b      	lsls	r3, r3, #2
    8ace:	4413      	add	r3, r2
    8ad0:	005b      	lsls	r3, r3, #1
    8ad2:	461a      	mov	r2, r3
    8ad4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8ad6:	1a9b      	subs	r3, r3, r2
    8ad8:	63fb      	str	r3, [r7, #60]	; 0x3c
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    8ada:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8adc:	3306      	adds	r3, #6
    8ade:	091a      	lsrs	r2, r3, #4
    8ae0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8ae2:	4413      	add	r3, r2
    8ae4:	f04f 0400 	mov.w	r4, #0
    }
}
    8ae8:	4618      	mov	r0, r3
    8aea:	4621      	mov	r1, r4
    8aec:	3758      	adds	r7, #88	; 0x58
    8aee:	46bd      	mov	sp, r7
    8af0:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    8af4:	4770      	bx	lr
    8af6:	bf00      	nop

00008af8 <ndigits_in_u64>:
// example: 10000 return 5, 123 returns 3.
//
//*****************************************************************************
static int
ndigits_in_u64(uint64_t ui64Val)
{
    8af8:	b590      	push	{r4, r7, lr}
    8afa:	b085      	sub	sp, #20
    8afc:	af00      	add	r7, sp, #0
    8afe:	e9c7 0100 	strd	r0, r1, [r7]
    int iNDigits = ui64Val ? 0 : 1;
    8b02:	683a      	ldr	r2, [r7, #0]
    8b04:	687b      	ldr	r3, [r7, #4]
    8b06:	4313      	orrs	r3, r2
    8b08:	2b00      	cmp	r3, #0
    8b0a:	bf0c      	ite	eq
    8b0c:	2301      	moveq	r3, #1
    8b0e:	2300      	movne	r3, #0
    8b10:	b2db      	uxtb	r3, r3
    8b12:	60fb      	str	r3, [r7, #12]

    while ( ui64Val )
    8b14:	e008      	b.n	8b28 <ndigits_in_u64+0x30>
    {
        //
        // ui32Val /= 10;
        //
        ui64Val = divu64_10(ui64Val);
    8b16:	e9d7 0100 	ldrd	r0, r1, [r7]
    8b1a:	f7ff ff0f 	bl	893c <divu64_10>
    8b1e:	e9c7 0100 	strd	r0, r1, [r7]
        ++iNDigits;
    8b22:	68fb      	ldr	r3, [r7, #12]
    8b24:	3301      	adds	r3, #1
    8b26:	60fb      	str	r3, [r7, #12]
static int
ndigits_in_u64(uint64_t ui64Val)
{
    int iNDigits = ui64Val ? 0 : 1;

    while ( ui64Val )
    8b28:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b2c:	4323      	orrs	r3, r4
    8b2e:	d1f2      	bne.n	8b16 <ndigits_in_u64+0x1e>
        //
        ui64Val = divu64_10(ui64Val);
        ++iNDigits;
    }

    return iNDigits;
    8b30:	68fb      	ldr	r3, [r7, #12]
}
    8b32:	4618      	mov	r0, r3
    8b34:	3714      	adds	r7, #20
    8b36:	46bd      	mov	sp, r7
    8b38:	bd90      	pop	{r4, r7, pc}
    8b3a:	bf00      	nop

00008b3c <ndigits_in_i64>:
// example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
//
//*****************************************************************************
static int
ndigits_in_i64(int64_t i64Val)
{
    8b3c:	b590      	push	{r4, r7, lr}
    8b3e:	b083      	sub	sp, #12
    8b40:	af00      	add	r7, sp, #0
    8b42:	e9c7 0100 	strd	r0, r1, [r7]
    if ( i64Val < 0 )
    8b46:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b4a:	2b00      	cmp	r3, #0
    8b4c:	f174 0300 	sbcs.w	r3, r4, #0
    8b50:	da06      	bge.n	8b60 <ndigits_in_i64+0x24>
    {
        //
        // Get absolute value
        //
        i64Val = -i64Val;
    8b52:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b56:	425b      	negs	r3, r3
    8b58:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    8b5c:	e887 0018 	stmia.w	r7, {r3, r4}
    }

    return ndigits_in_u64((uint64_t) i64Val);
    8b60:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b64:	4618      	mov	r0, r3
    8b66:	4621      	mov	r1, r4
    8b68:	f7ff ffc6 	bl	8af8 <ndigits_in_u64>
    8b6c:	4603      	mov	r3, r0
}
    8b6e:	4618      	mov	r0, r3
    8b70:	370c      	adds	r7, #12
    8b72:	46bd      	mov	sp, r7
    8b74:	bd90      	pop	{r4, r7, pc}
    8b76:	bf00      	nop

00008b78 <ndigits_in_hex>:
// Return the number of hex digits in an uint64_t.
//
//*****************************************************************************
static int
ndigits_in_hex(uint64_t ui64Val)
{
    8b78:	b490      	push	{r4, r7}
    8b7a:	b084      	sub	sp, #16
    8b7c:	af00      	add	r7, sp, #0
    8b7e:	e9c7 0100 	strd	r0, r1, [r7]
    int iDigits = ui64Val ? 0 : 1;
    8b82:	6839      	ldr	r1, [r7, #0]
    8b84:	687a      	ldr	r2, [r7, #4]
    8b86:	430a      	orrs	r2, r1
    8b88:	2a00      	cmp	r2, #0
    8b8a:	bf0c      	ite	eq
    8b8c:	2201      	moveq	r2, #1
    8b8e:	2200      	movne	r2, #0
    8b90:	b2d2      	uxtb	r2, r2
    8b92:	60fa      	str	r2, [r7, #12]

    while ( ui64Val )
    8b94:	e00a      	b.n	8bac <ndigits_in_hex+0x34>
    {
        ui64Val >>= 4;
    8b96:	e897 0006 	ldmia.w	r7, {r1, r2}
    8b9a:	090b      	lsrs	r3, r1, #4
    8b9c:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
    8ba0:	0914      	lsrs	r4, r2, #4
    8ba2:	e887 0018 	stmia.w	r7, {r3, r4}
        ++iDigits;
    8ba6:	68fa      	ldr	r2, [r7, #12]
    8ba8:	3201      	adds	r2, #1
    8baa:	60fa      	str	r2, [r7, #12]
static int
ndigits_in_hex(uint64_t ui64Val)
{
    int iDigits = ui64Val ? 0 : 1;

    while ( ui64Val )
    8bac:	e897 0006 	ldmia.w	r7, {r1, r2}
    8bb0:	430a      	orrs	r2, r1
    8bb2:	d1f0      	bne.n	8b96 <ndigits_in_hex+0x1e>
    {
        ui64Val >>= 4;
        ++iDigits;
    }

    return iDigits;
    8bb4:	68fb      	ldr	r3, [r7, #12]
}
    8bb6:	4618      	mov	r0, r3
    8bb8:	3710      	adds	r7, #16
    8bba:	46bd      	mov	sp, r7
    8bbc:	bc90      	pop	{r4, r7}
    8bbe:	4770      	bx	lr

00008bc0 <decstr_to_int>:
// pui32CharCnt.
//
//*****************************************************************************
static uint32_t
decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
{
    8bc0:	b480      	push	{r7}
    8bc2:	b087      	sub	sp, #28
    8bc4:	af00      	add	r7, sp, #0
    8bc6:	6078      	str	r0, [r7, #4]
    8bc8:	6039      	str	r1, [r7, #0]
    bool bNeg = false;
    8bca:	2300      	movs	r3, #0
    8bcc:	75fb      	strb	r3, [r7, #23]
    uint32_t ui32Val = 0, uCnt = 0;
    8bce:	2300      	movs	r3, #0
    8bd0:	613b      	str	r3, [r7, #16]
    8bd2:	2300      	movs	r3, #0
    8bd4:	60fb      	str	r3, [r7, #12]

    if ( *pcStr == '-')
    8bd6:	687b      	ldr	r3, [r7, #4]
    8bd8:	781b      	ldrb	r3, [r3, #0]
    8bda:	2b2d      	cmp	r3, #45	; 0x2d
    8bdc:	d11b      	bne.n	8c16 <decstr_to_int+0x56>
    {
        bNeg = true;
    8bde:	2301      	movs	r3, #1
    8be0:	75fb      	strb	r3, [r7, #23]
        pcStr++;
    8be2:	687b      	ldr	r3, [r7, #4]
    8be4:	3301      	adds	r3, #1
    8be6:	607b      	str	r3, [r7, #4]
        uCnt++;
    8be8:	68fb      	ldr	r3, [r7, #12]
    8bea:	3301      	adds	r3, #1
    8bec:	60fb      	str	r3, [r7, #12]
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    8bee:	e012      	b.n	8c16 <decstr_to_int+0x56>
    {
        ++uCnt;
    8bf0:	68fb      	ldr	r3, [r7, #12]
    8bf2:	3301      	adds	r3, #1
    8bf4:	60fb      	str	r3, [r7, #12]

        //
        // Multiply accumulated value by 10.
        //
        ui32Val *= 10;
    8bf6:	693a      	ldr	r2, [r7, #16]
    8bf8:	4613      	mov	r3, r2
    8bfa:	009b      	lsls	r3, r3, #2
    8bfc:	4413      	add	r3, r2
    8bfe:	005b      	lsls	r3, r3, #1
    8c00:	613b      	str	r3, [r7, #16]

        //
        // Add in the new low digit.
        //
        ui32Val += (*pcStr - '0');
    8c02:	687b      	ldr	r3, [r7, #4]
    8c04:	781b      	ldrb	r3, [r3, #0]
    8c06:	461a      	mov	r2, r3
    8c08:	693b      	ldr	r3, [r7, #16]
    8c0a:	4413      	add	r3, r2
    8c0c:	3b30      	subs	r3, #48	; 0x30
    8c0e:	613b      	str	r3, [r7, #16]
        pcStr++;
    8c10:	687b      	ldr	r3, [r7, #4]
    8c12:	3301      	adds	r3, #1
    8c14:	607b      	str	r3, [r7, #4]
        bNeg = true;
        pcStr++;
        uCnt++;
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    8c16:	687b      	ldr	r3, [r7, #4]
    8c18:	781b      	ldrb	r3, [r3, #0]
    8c1a:	2b2f      	cmp	r3, #47	; 0x2f
    8c1c:	d903      	bls.n	8c26 <decstr_to_int+0x66>
    8c1e:	687b      	ldr	r3, [r7, #4]
    8c20:	781b      	ldrb	r3, [r3, #0]
    8c22:	2b39      	cmp	r3, #57	; 0x39
    8c24:	d9e4      	bls.n	8bf0 <decstr_to_int+0x30>
        //
        ui32Val += (*pcStr - '0');
        pcStr++;
    }

    if ( pui32CharCnt )
    8c26:	683b      	ldr	r3, [r7, #0]
    8c28:	2b00      	cmp	r3, #0
    8c2a:	d002      	beq.n	8c32 <decstr_to_int+0x72>
    {
        *pui32CharCnt = uCnt;
    8c2c:	683b      	ldr	r3, [r7, #0]
    8c2e:	68fa      	ldr	r2, [r7, #12]
    8c30:	601a      	str	r2, [r3, #0]
    }

    return bNeg ? -ui32Val : ui32Val;
    8c32:	7dfb      	ldrb	r3, [r7, #23]
    8c34:	2b00      	cmp	r3, #0
    8c36:	d002      	beq.n	8c3e <decstr_to_int+0x7e>
    8c38:	693b      	ldr	r3, [r7, #16]
    8c3a:	425b      	negs	r3, r3
    8c3c:	e000      	b.n	8c40 <decstr_to_int+0x80>
    8c3e:	693b      	ldr	r3, [r7, #16]
}
    8c40:	4618      	mov	r0, r3
    8c42:	371c      	adds	r7, #28
    8c44:	46bd      	mov	sp, r7
    8c46:	f85d 7b04 	ldr.w	r7, [sp], #4
    8c4a:	4770      	bx	lr

00008c4c <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    8c4c:	b590      	push	{r4, r7, lr}
    8c4e:	b091      	sub	sp, #68	; 0x44
    8c50:	af00      	add	r7, sp, #0
    8c52:	e9c7 0102 	strd	r0, r1, [r7, #8]
    8c56:	607a      	str	r2, [r7, #4]
    char tbuf[25];
    int ix = 0, iNumDig = 0;
    8c58:	2300      	movs	r3, #0
    8c5a:	63fb      	str	r3, [r7, #60]	; 0x3c
    8c5c:	2300      	movs	r3, #0
    8c5e:	63bb      	str	r3, [r7, #56]	; 0x38
    do
    {
        //
        // Divide by 10
        //
        u64Tmp = divu64_10(ui64Val);
    8c60:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
    8c64:	f7ff fe6a 	bl	893c <divu64_10>
    8c68:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);
    8c6c:	68b9      	ldr	r1, [r7, #8]
    8c6e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8c70:	4613      	mov	r3, r2
    8c72:	009b      	lsls	r3, r3, #2
    8c74:	4413      	add	r3, r2
    8c76:	005b      	lsls	r3, r3, #1
    8c78:	1acb      	subs	r3, r1, r3
    8c7a:	62fb      	str	r3, [r7, #44]	; 0x2c

        tbuf[ix++] = uMod + '0';
    8c7c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8c7e:	1c5a      	adds	r2, r3, #1
    8c80:	63fa      	str	r2, [r7, #60]	; 0x3c
    8c82:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8c84:	b2d2      	uxtb	r2, r2
    8c86:	3230      	adds	r2, #48	; 0x30
    8c88:	b2d2      	uxtb	r2, r2
    8c8a:	f107 0140 	add.w	r1, r7, #64	; 0x40
    8c8e:	440b      	add	r3, r1
    8c90:	f803 2c30 	strb.w	r2, [r3, #-48]
        ui64Val = u64Tmp;
    8c94:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8c98:	e9c7 3402 	strd	r3, r4, [r7, #8]
    } while ( ui64Val );
    8c9c:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    8ca0:	4323      	orrs	r3, r4
    8ca2:	d1dd      	bne.n	8c60 <uint64_to_str+0x14>

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    8ca4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8ca6:	63bb      	str	r3, [r7, #56]	; 0x38

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    8ca8:	687b      	ldr	r3, [r7, #4]
    8caa:	2b00      	cmp	r3, #0
    8cac:	d011      	beq.n	8cd2 <uint64_to_str+0x86>
    {
        while ( ix-- )
    8cae:	e008      	b.n	8cc2 <uint64_to_str+0x76>
        {
            *pcBuf++ = tbuf[ix];
    8cb0:	687b      	ldr	r3, [r7, #4]
    8cb2:	1c5a      	adds	r2, r3, #1
    8cb4:	607a      	str	r2, [r7, #4]
    8cb6:	f107 0110 	add.w	r1, r7, #16
    8cba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    8cbc:	440a      	add	r2, r1
    8cbe:	7812      	ldrb	r2, [r2, #0]
    8cc0:	701a      	strb	r2, [r3, #0]
    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    {
        while ( ix-- )
    8cc2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8cc4:	1e5a      	subs	r2, r3, #1
    8cc6:	63fa      	str	r2, [r7, #60]	; 0x3c
    8cc8:	2b00      	cmp	r3, #0
    8cca:	d1f1      	bne.n	8cb0 <uint64_to_str+0x64>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    8ccc:	687b      	ldr	r3, [r7, #4]
    8cce:	2200      	movs	r2, #0
    8cd0:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    8cd2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
    8cd4:	4618      	mov	r0, r3
    8cd6:	3744      	adds	r7, #68	; 0x44
    8cd8:	46bd      	mov	sp, r7
    8cda:	bd90      	pop	{r4, r7, pc}

00008cdc <uint64_to_hexstr>:
// written).
//
//*****************************************************************************
static int
uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
{
    8cdc:	b4b0      	push	{r4, r5, r7}
    8cde:	b08d      	sub	sp, #52	; 0x34
    8ce0:	af00      	add	r7, sp, #0
    8ce2:	e9c7 0102 	strd	r0, r1, [r7, #8]
    8ce6:	607a      	str	r2, [r7, #4]
    8ce8:	70fb      	strb	r3, [r7, #3]
    int iNumDig, ix = 0;
    8cea:	2300      	movs	r3, #0
    8cec:	62fb      	str	r3, [r7, #44]	; 0x2c
    char cCh, tbuf[20];

    if ( ui64Val == 0 )
    8cee:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8cf2:	4313      	orrs	r3, r2
    8cf4:	d131      	bne.n	8d5a <uint64_to_hexstr+0x7e>
    {
        tbuf[ix++] = '0';   // Print a '0'
    8cf6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8cf8:	1c5a      	adds	r2, r3, #1
    8cfa:	62fa      	str	r2, [r7, #44]	; 0x2c
    8cfc:	f107 0230 	add.w	r2, r7, #48	; 0x30
    8d00:	4413      	add	r3, r2
    8d02:	2230      	movs	r2, #48	; 0x30
    8d04:	f803 2c20 	strb.w	r2, [r3, #-32]
    }

    while ( ui64Val )
    8d08:	e027      	b.n	8d5a <uint64_to_hexstr+0x7e>
    {
        cCh = ui64Val & 0xf;
    8d0a:	7a3b      	ldrb	r3, [r7, #8]
    8d0c:	f003 030f 	and.w	r3, r3, #15
    8d10:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

        //
        // Alpha character
        //
        if ( cCh > 9 )
    8d14:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    8d18:	2b09      	cmp	r3, #9
    8d1a:	d90a      	bls.n	8d32 <uint64_to_hexstr+0x56>
        {
            cCh += bLower ? 0x27 : 0x7;
    8d1c:	78fb      	ldrb	r3, [r7, #3]
    8d1e:	2b00      	cmp	r3, #0
    8d20:	d001      	beq.n	8d26 <uint64_to_hexstr+0x4a>
    8d22:	2227      	movs	r2, #39	; 0x27
    8d24:	e000      	b.n	8d28 <uint64_to_hexstr+0x4c>
    8d26:	2207      	movs	r2, #7
    8d28:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    8d2c:	4413      	add	r3, r2
    8d2e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        }

        tbuf[ix++] = cCh + '0';
    8d32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d34:	1c5a      	adds	r2, r3, #1
    8d36:	62fa      	str	r2, [r7, #44]	; 0x2c
    8d38:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
    8d3c:	3230      	adds	r2, #48	; 0x30
    8d3e:	b2d2      	uxtb	r2, r2
    8d40:	f107 0130 	add.w	r1, r7, #48	; 0x30
    8d44:	440b      	add	r3, r1
    8d46:	f803 2c20 	strb.w	r2, [r3, #-32]
        ui64Val >>= 4;
    8d4a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8d4e:	0914      	lsrs	r4, r2, #4
    8d50:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
    8d54:	091d      	lsrs	r5, r3, #4
    8d56:	e9c7 4502 	strd	r4, r5, [r7, #8]
    if ( ui64Val == 0 )
    {
        tbuf[ix++] = '0';   // Print a '0'
    }

    while ( ui64Val )
    8d5a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8d5e:	4313      	orrs	r3, r2
    8d60:	d1d3      	bne.n	8d0a <uint64_to_hexstr+0x2e>
    }

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    8d62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d64:	627b      	str	r3, [r7, #36]	; 0x24

    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
    8d66:	687b      	ldr	r3, [r7, #4]
    8d68:	2b00      	cmp	r3, #0
    8d6a:	d011      	beq.n	8d90 <uint64_to_hexstr+0xb4>
    {
        while (ix--)
    8d6c:	e008      	b.n	8d80 <uint64_to_hexstr+0xa4>
        {
            *pcBuf++ = tbuf[ix];
    8d6e:	687b      	ldr	r3, [r7, #4]
    8d70:	1c5a      	adds	r2, r3, #1
    8d72:	607a      	str	r2, [r7, #4]
    8d74:	f107 0110 	add.w	r1, r7, #16
    8d78:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8d7a:	440a      	add	r2, r1
    8d7c:	7812      	ldrb	r2, [r2, #0]
    8d7e:	701a      	strb	r2, [r3, #0]
    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
    {
        while (ix--)
    8d80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d82:	1e5a      	subs	r2, r3, #1
    8d84:	62fa      	str	r2, [r7, #44]	; 0x2c
    8d86:	2b00      	cmp	r3, #0
    8d88:	d1f1      	bne.n	8d6e <uint64_to_hexstr+0x92>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0;
    8d8a:	687b      	ldr	r3, [r7, #4]
    8d8c:	2200      	movs	r2, #0
    8d8e:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    8d90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    8d92:	4618      	mov	r0, r3
    8d94:	3734      	adds	r7, #52	; 0x34
    8d96:	46bd      	mov	sp, r7
    8d98:	bcb0      	pop	{r4, r5, r7}
    8d9a:	4770      	bx	lr

00008d9c <simple_strlen>:
// Return length of the given string.
//
//*****************************************************************************
static uint32_t
simple_strlen(char *pcBuf)
{
    8d9c:	b480      	push	{r7}
    8d9e:	b085      	sub	sp, #20
    8da0:	af00      	add	r7, sp, #0
    8da2:	6078      	str	r0, [r7, #4]
    uint32_t ui32RetVal = 0;
    8da4:	2300      	movs	r3, #0
    8da6:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
    8da8:	687b      	ldr	r3, [r7, #4]
    8daa:	2b00      	cmp	r3, #0
    8dac:	d104      	bne.n	8db8 <simple_strlen+0x1c>
    {
        return ui32RetVal;
    8dae:	68fb      	ldr	r3, [r7, #12]
    8db0:	e009      	b.n	8dc6 <simple_strlen+0x2a>
    }

    while ( *pcBuf++ )
    {
        ui32RetVal++;
    8db2:	68fb      	ldr	r3, [r7, #12]
    8db4:	3301      	adds	r3, #1
    8db6:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
    {
        return ui32RetVal;
    }

    while ( *pcBuf++ )
    8db8:	687b      	ldr	r3, [r7, #4]
    8dba:	1c5a      	adds	r2, r3, #1
    8dbc:	607a      	str	r2, [r7, #4]
    8dbe:	781b      	ldrb	r3, [r3, #0]
    8dc0:	2b00      	cmp	r3, #0
    8dc2:	d1f6      	bne.n	8db2 <simple_strlen+0x16>
    {
        ui32RetVal++;
    }
    return ui32RetVal;
    8dc4:	68fb      	ldr	r3, [r7, #12]
}
    8dc6:	4618      	mov	r0, r3
    8dc8:	3714      	adds	r7, #20
    8dca:	46bd      	mov	sp, r7
    8dcc:	f85d 7b04 	ldr.w	r7, [sp], #4
    8dd0:	4770      	bx	lr
    8dd2:	bf00      	nop

00008dd4 <padbuffer>:
// Pad a string buffer with pad characters.
//
//*****************************************************************************
static int32_t
padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
{
    8dd4:	b480      	push	{r7}
    8dd6:	b087      	sub	sp, #28
    8dd8:	af00      	add	r7, sp, #0
    8dda:	60f8      	str	r0, [r7, #12]
    8ddc:	460b      	mov	r3, r1
    8dde:	607a      	str	r2, [r7, #4]
    8de0:	72fb      	strb	r3, [r7, #11]
    int32_t i32Cnt = 0;
    8de2:	2300      	movs	r3, #0
    8de4:	617b      	str	r3, [r7, #20]

    if ( i32NumChars <= 0 )
    8de6:	687b      	ldr	r3, [r7, #4]
    8de8:	2b00      	cmp	r3, #0
    8dea:	dc0c      	bgt.n	8e06 <padbuffer+0x32>
    {
        return i32Cnt;
    8dec:	697b      	ldr	r3, [r7, #20]
    8dee:	e010      	b.n	8e12 <padbuffer+0x3e>
    }

    while ( i32NumChars-- )
    {
        if ( pcBuf )
    8df0:	68fb      	ldr	r3, [r7, #12]
    8df2:	2b00      	cmp	r3, #0
    8df4:	d004      	beq.n	8e00 <padbuffer+0x2c>
        {
            *pcBuf++ = cPadChar;
    8df6:	68fb      	ldr	r3, [r7, #12]
    8df8:	1c5a      	adds	r2, r3, #1
    8dfa:	60fa      	str	r2, [r7, #12]
    8dfc:	7afa      	ldrb	r2, [r7, #11]
    8dfe:	701a      	strb	r2, [r3, #0]
        }
        i32Cnt++;
    8e00:	697b      	ldr	r3, [r7, #20]
    8e02:	3301      	adds	r3, #1
    8e04:	617b      	str	r3, [r7, #20]
    if ( i32NumChars <= 0 )
    {
        return i32Cnt;
    }

    while ( i32NumChars-- )
    8e06:	687b      	ldr	r3, [r7, #4]
    8e08:	1e5a      	subs	r2, r3, #1
    8e0a:	607a      	str	r2, [r7, #4]
    8e0c:	2b00      	cmp	r3, #0
    8e0e:	d1ef      	bne.n	8df0 <padbuffer+0x1c>
            *pcBuf++ = cPadChar;
        }
        i32Cnt++;
    }

    return i32Cnt;
    8e10:	697b      	ldr	r3, [r7, #20]
}
    8e12:	4618      	mov	r0, r3
    8e14:	371c      	adds	r7, #28
    8e16:	46bd      	mov	sp, r7
    8e18:	f85d 7b04 	ldr.w	r7, [sp], #4
    8e1c:	4770      	bx	lr
    8e1e:	bf00      	nop

00008e20 <ftoa>:
    int32_t I32;
    float F;
} i32fl_t;

static int ftoa(float fValue, char *pcBuf, int iPrecision)
{
    8e20:	b590      	push	{r4, r7, lr}
    8e22:	b08f      	sub	sp, #60	; 0x3c
    8e24:	af00      	add	r7, sp, #0
    8e26:	60f8      	str	r0, [r7, #12]
    8e28:	60b9      	str	r1, [r7, #8]
    8e2a:	607a      	str	r2, [r7, #4]
    i32fl_t unFloatValue;
    int iExp2, iBufSize;
    int32_t i32Mantissa, i32IntPart, i32FracPart;
    char *pcBufInitial;

    iBufSize = *(uint32_t*)pcBuf;
    8e2c:	68bb      	ldr	r3, [r7, #8]
    8e2e:	681b      	ldr	r3, [r3, #0]
    8e30:	62bb      	str	r3, [r7, #40]	; 0x28
    if (iBufSize < 4)
    8e32:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8e34:	2b03      	cmp	r3, #3
    8e36:	dc02      	bgt.n	8e3e <ftoa+0x1e>
    {
        return AM_FTOA_ERR_BUFSIZE;
    8e38:	f06f 0302 	mvn.w	r3, #2
    8e3c:	e0d4      	b.n	8fe8 <ftoa+0x1c8>
    }

    if (fValue == 0.0f)
    8e3e:	edd7 7a03 	vldr	s15, [r7, #12]
    8e42:	eef5 7a40 	vcmp.f32	s15, #0.0
    8e46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8e4a:	d104      	bne.n	8e56 <ftoa+0x36>
    {
        // "0.0"
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    8e4c:	68bb      	ldr	r3, [r7, #8]
    8e4e:	4a68      	ldr	r2, [pc, #416]	; (8ff0 <ftoa+0x1d0>)
    8e50:	601a      	str	r2, [r3, #0]
        return 3;
    8e52:	2303      	movs	r3, #3
    8e54:	e0c8      	b.n	8fe8 <ftoa+0x1c8>
    }

    pcBufInitial = pcBuf;
    8e56:	68bb      	ldr	r3, [r7, #8]
    8e58:	627b      	str	r3, [r7, #36]	; 0x24

    unFloatValue.F = fValue;
    8e5a:	68fb      	ldr	r3, [r7, #12]
    8e5c:	617b      	str	r3, [r7, #20]

    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    8e5e:	697b      	ldr	r3, [r7, #20]
    8e60:	15db      	asrs	r3, r3, #23
    8e62:	b2db      	uxtb	r3, r3
    8e64:	3b7f      	subs	r3, #127	; 0x7f
    8e66:	623b      	str	r3, [r7, #32]
    i32Mantissa = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    8e68:	697b      	ldr	r3, [r7, #20]
    8e6a:	f3c3 0316 	ubfx	r3, r3, #0, #23
    8e6e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    8e72:	61fb      	str	r3, [r7, #28]
    i32FracPart = 0;
    8e74:	2300      	movs	r3, #0
    8e76:	633b      	str	r3, [r7, #48]	; 0x30
    i32IntPart = 0;
    8e78:	2300      	movs	r3, #0
    8e7a:	637b      	str	r3, [r7, #52]	; 0x34

    if (iExp2 >= 31)
    8e7c:	6a3b      	ldr	r3, [r7, #32]
    8e7e:	2b1e      	cmp	r3, #30
    8e80:	dd02      	ble.n	8e88 <ftoa+0x68>
    {
        return AM_FTOA_ERR_VAL_TOO_LARGE;
    8e82:	f06f 0301 	mvn.w	r3, #1
    8e86:	e0af      	b.n	8fe8 <ftoa+0x1c8>
    }
    else if (iExp2 < -23)
    8e88:	6a3b      	ldr	r3, [r7, #32]
    8e8a:	f113 0f17 	cmn.w	r3, #23
    8e8e:	da02      	bge.n	8e96 <ftoa+0x76>
    {
        return AM_FTOA_ERR_VAL_TOO_SMALL;
    8e90:	f04f 33ff 	mov.w	r3, #4294967295
    8e94:	e0a8      	b.n	8fe8 <ftoa+0x1c8>
    }
    else if (iExp2 >= 23)
    8e96:	6a3b      	ldr	r3, [r7, #32]
    8e98:	2b16      	cmp	r3, #22
    8e9a:	dd06      	ble.n	8eaa <ftoa+0x8a>
    {
        i32IntPart = i32Mantissa << (iExp2 - 23);
    8e9c:	6a3b      	ldr	r3, [r7, #32]
    8e9e:	3b17      	subs	r3, #23
    8ea0:	69fa      	ldr	r2, [r7, #28]
    8ea2:	fa02 f303 	lsl.w	r3, r2, r3
    8ea6:	637b      	str	r3, [r7, #52]	; 0x34
    8ea8:	e01a      	b.n	8ee0 <ftoa+0xc0>
    }
    else if (iExp2 >= 0)
    8eaa:	6a3b      	ldr	r3, [r7, #32]
    8eac:	2b00      	cmp	r3, #0
    8eae:	db0f      	blt.n	8ed0 <ftoa+0xb0>
    {
        i32IntPart = i32Mantissa >> (23 - iExp2);
    8eb0:	6a3b      	ldr	r3, [r7, #32]
    8eb2:	f1c3 0317 	rsb	r3, r3, #23
    8eb6:	69fa      	ldr	r2, [r7, #28]
    8eb8:	fa42 f303 	asr.w	r3, r2, r3
    8ebc:	637b      	str	r3, [r7, #52]	; 0x34
        i32FracPart = (i32Mantissa << (iExp2 + 1)) & 0x00FFFFFF;
    8ebe:	6a3b      	ldr	r3, [r7, #32]
    8ec0:	3301      	adds	r3, #1
    8ec2:	69fa      	ldr	r2, [r7, #28]
    8ec4:	fa02 f303 	lsl.w	r3, r2, r3
    8ec8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8ecc:	633b      	str	r3, [r7, #48]	; 0x30
    8ece:	e007      	b.n	8ee0 <ftoa+0xc0>
    }
    else // if (iExp2 < 0)
    {
        i32FracPart = (i32Mantissa & 0x00FFFFFF) >> -(iExp2 + 1);
    8ed0:	69fb      	ldr	r3, [r7, #28]
    8ed2:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
    8ed6:	6a3b      	ldr	r3, [r7, #32]
    8ed8:	43db      	mvns	r3, r3
    8eda:	fa42 f303 	asr.w	r3, r2, r3
    8ede:	633b      	str	r3, [r7, #48]	; 0x30
    }

    if (unFloatValue.I32 < 0)
    8ee0:	697b      	ldr	r3, [r7, #20]
    8ee2:	2b00      	cmp	r3, #0
    8ee4:	da04      	bge.n	8ef0 <ftoa+0xd0>
    {
        *pcBuf++ = '-';
    8ee6:	68bb      	ldr	r3, [r7, #8]
    8ee8:	1c5a      	adds	r2, r3, #1
    8eea:	60ba      	str	r2, [r7, #8]
    8eec:	222d      	movs	r2, #45	; 0x2d
    8eee:	701a      	strb	r2, [r3, #0]
    }

    if (i32IntPart == 0)
    8ef0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ef2:	2b00      	cmp	r3, #0
    8ef4:	d105      	bne.n	8f02 <ftoa+0xe2>
    {
        *pcBuf++ = '0';
    8ef6:	68bb      	ldr	r3, [r7, #8]
    8ef8:	1c5a      	adds	r2, r3, #1
    8efa:	60ba      	str	r2, [r7, #8]
    8efc:	2230      	movs	r2, #48	; 0x30
    8efe:	701a      	strb	r2, [r3, #0]
    8f00:	e021      	b.n	8f46 <ftoa+0x126>
    }
    else
    {
        if (i32IntPart > 0)
    8f02:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f04:	2b00      	cmp	r3, #0
    8f06:	dd08      	ble.n	8f1a <ftoa+0xfa>
        {
            uint64_to_str(i32IntPart, pcBuf);
    8f08:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f0a:	ea4f 74e3 	mov.w	r4, r3, asr #31
    8f0e:	68ba      	ldr	r2, [r7, #8]
    8f10:	4618      	mov	r0, r3
    8f12:	4621      	mov	r1, r4
    8f14:	f7ff fe9a 	bl	8c4c <uint64_to_str>
    8f18:	e011      	b.n	8f3e <ftoa+0x11e>
        }
        else
        {
            *pcBuf++ = '-';
    8f1a:	68bb      	ldr	r3, [r7, #8]
    8f1c:	1c5a      	adds	r2, r3, #1
    8f1e:	60ba      	str	r2, [r7, #8]
    8f20:	222d      	movs	r2, #45	; 0x2d
    8f22:	701a      	strb	r2, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    8f24:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f26:	425b      	negs	r3, r3
    8f28:	ea4f 74e3 	mov.w	r4, r3, asr #31
    8f2c:	68ba      	ldr	r2, [r7, #8]
    8f2e:	4618      	mov	r0, r3
    8f30:	4621      	mov	r1, r4
    8f32:	f7ff fe8b 	bl	8c4c <uint64_to_str>
        }
        while (*pcBuf)    // Get to end of new string
    8f36:	e002      	b.n	8f3e <ftoa+0x11e>
        {
            pcBuf++;
    8f38:	68bb      	ldr	r3, [r7, #8]
    8f3a:	3301      	adds	r3, #1
    8f3c:	60bb      	str	r3, [r7, #8]
        else
        {
            *pcBuf++ = '-';
            uint64_to_str(-i32IntPart, pcBuf);
        }
        while (*pcBuf)    // Get to end of new string
    8f3e:	68bb      	ldr	r3, [r7, #8]
    8f40:	781b      	ldrb	r3, [r3, #0]
    8f42:	2b00      	cmp	r3, #0
    8f44:	d1f8      	bne.n	8f38 <ftoa+0x118>
    }

    //
    // Now, begin the fractional part
    //
    *pcBuf++ = '.';
    8f46:	68bb      	ldr	r3, [r7, #8]
    8f48:	1c5a      	adds	r2, r3, #1
    8f4a:	60ba      	str	r2, [r7, #8]
    8f4c:	222e      	movs	r2, #46	; 0x2e
    8f4e:	701a      	strb	r2, [r3, #0]

    if (i32FracPart == 0)
    8f50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8f52:	2b00      	cmp	r3, #0
    8f54:	d105      	bne.n	8f62 <ftoa+0x142>
    {
        *pcBuf++ = '0';
    8f56:	68bb      	ldr	r3, [r7, #8]
    8f58:	1c5a      	adds	r2, r3, #1
    8f5a:	60ba      	str	r2, [r7, #8]
    8f5c:	2230      	movs	r2, #48	; 0x30
    8f5e:	701a      	strb	r2, [r3, #0]
    8f60:	e03c      	b.n	8fdc <ftoa+0x1bc>
    }
    else
    {
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    8f62:	68ba      	ldr	r2, [r7, #8]
    8f64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8f66:	1ad3      	subs	r3, r2, r3
    8f68:	6aba      	ldr	r2, [r7, #40]	; 0x28
    8f6a:	1ad3      	subs	r3, r2, r3
    8f6c:	3b01      	subs	r3, #1
    8f6e:	61bb      	str	r3, [r7, #24]
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    8f70:	69ba      	ldr	r2, [r7, #24]
    8f72:	687b      	ldr	r3, [r7, #4]
    8f74:	4293      	cmp	r3, r2
    8f76:	bfa8      	it	ge
    8f78:	4613      	movge	r3, r2
    8f7a:	61bb      	str	r3, [r7, #24]

        for (jx = 0; jx < iMax; jx++)
    8f7c:	2300      	movs	r3, #0
    8f7e:	62fb      	str	r3, [r7, #44]	; 0x2c
    8f80:	e015      	b.n	8fae <ftoa+0x18e>
        {
            i32FracPart *= 10;
    8f82:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8f84:	4613      	mov	r3, r2
    8f86:	009b      	lsls	r3, r3, #2
    8f88:	4413      	add	r3, r2
    8f8a:	005b      	lsls	r3, r3, #1
    8f8c:	633b      	str	r3, [r7, #48]	; 0x30
            *pcBuf++ = (i32FracPart >> 24) + '0';
    8f8e:	68bb      	ldr	r3, [r7, #8]
    8f90:	1c5a      	adds	r2, r3, #1
    8f92:	60ba      	str	r2, [r7, #8]
    8f94:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8f96:	1612      	asrs	r2, r2, #24
    8f98:	b2d2      	uxtb	r2, r2
    8f9a:	3230      	adds	r2, #48	; 0x30
    8f9c:	b2d2      	uxtb	r2, r2
    8f9e:	701a      	strb	r2, [r3, #0]
            i32FracPart &= 0x00FFFFFF;
    8fa0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8fa2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8fa6:	633b      	str	r3, [r7, #48]	; 0x30
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
        iMax = (iMax > iPrecision) ? iPrecision : iMax;

        for (jx = 0; jx < iMax; jx++)
    8fa8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8faa:	3301      	adds	r3, #1
    8fac:	62fb      	str	r3, [r7, #44]	; 0x2c
    8fae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8fb0:	69bb      	ldr	r3, [r7, #24]
    8fb2:	429a      	cmp	r2, r3
    8fb4:	dbe5      	blt.n	8f82 <ftoa+0x162>
        }

        //
        // Remove trailing zeros
        //
        --pcBuf;
    8fb6:	68bb      	ldr	r3, [r7, #8]
    8fb8:	3b01      	subs	r3, #1
    8fba:	60bb      	str	r3, [r7, #8]
        while ((*pcBuf == '0')  &&  (*(pcBuf-1) != '.'))
    8fbc:	e002      	b.n	8fc4 <ftoa+0x1a4>
        {
            --pcBuf;
    8fbe:	68bb      	ldr	r3, [r7, #8]
    8fc0:	3b01      	subs	r3, #1
    8fc2:	60bb      	str	r3, [r7, #8]

        //
        // Remove trailing zeros
        //
        --pcBuf;
        while ((*pcBuf == '0')  &&  (*(pcBuf-1) != '.'))
    8fc4:	68bb      	ldr	r3, [r7, #8]
    8fc6:	781b      	ldrb	r3, [r3, #0]
    8fc8:	2b30      	cmp	r3, #48	; 0x30
    8fca:	d104      	bne.n	8fd6 <ftoa+0x1b6>
    8fcc:	68bb      	ldr	r3, [r7, #8]
    8fce:	3b01      	subs	r3, #1
    8fd0:	781b      	ldrb	r3, [r3, #0]
    8fd2:	2b2e      	cmp	r3, #46	; 0x2e
    8fd4:	d1f3      	bne.n	8fbe <ftoa+0x19e>
        {
            --pcBuf;
        }
        ++pcBuf;
    8fd6:	68bb      	ldr	r3, [r7, #8]
    8fd8:	3301      	adds	r3, #1
    8fda:	60bb      	str	r3, [r7, #8]
    }

    //
    // Terminate the string and we're done
    //
    *pcBuf = 0x00;
    8fdc:	68bb      	ldr	r3, [r7, #8]
    8fde:	2200      	movs	r2, #0
    8fe0:	701a      	strb	r2, [r3, #0]

    return (pcBuf - pcBufInitial);
    8fe2:	68ba      	ldr	r2, [r7, #8]
    8fe4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8fe6:	1ad3      	subs	r3, r2, r3
} // ftoa()
    8fe8:	4618      	mov	r0, r3
    8fea:	373c      	adds	r7, #60	; 0x3c
    8fec:	46bd      	mov	sp, r7
    8fee:	bd90      	pop	{r4, r7, pc}
    8ff0:	00302e30 	.word	0x00302e30

00008ff4 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    8ff4:	b590      	push	{r4, r7, lr}
    8ff6:	b095      	sub	sp, #84	; 0x54
    8ff8:	af00      	add	r7, sp, #0
    8ffa:	60f8      	str	r0, [r7, #12]
    8ffc:	60b9      	str	r1, [r7, #8]
    8ffe:	607a      	str	r2, [r7, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    9000:	2300      	movs	r3, #0
    9002:	63fb      	str	r3, [r7, #60]	; 0x3c
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;
    9004:	2300      	movs	r3, #0
    9006:	627b      	str	r3, [r7, #36]	; 0x24

    while ( *pcFmt != 0x0 )
    9008:	e2e3      	b.n	95d2 <am_util_stdio_vsprintf+0x5de>
    {
        iPrecision = 6;             // printf() default precision for %f is 6
    900a:	2306      	movs	r3, #6
    900c:	633b      	str	r3, [r7, #48]	; 0x30

        if ( *pcFmt != '%' )
    900e:	68bb      	ldr	r3, [r7, #8]
    9010:	781b      	ldrb	r3, [r3, #0]
    9012:	2b25      	cmp	r3, #37	; 0x25
    9014:	d01f      	beq.n	9056 <am_util_stdio_vsprintf+0x62>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    9016:	68fb      	ldr	r3, [r7, #12]
    9018:	2b00      	cmp	r3, #0
    901a:	d015      	beq.n	9048 <am_util_stdio_vsprintf+0x54>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    901c:	68bb      	ldr	r3, [r7, #8]
    901e:	781b      	ldrb	r3, [r3, #0]
    9020:	2b0a      	cmp	r3, #10
    9022:	d10b      	bne.n	903c <am_util_stdio_vsprintf+0x48>
    9024:	4bb1      	ldr	r3, [pc, #708]	; (92ec <am_util_stdio_vsprintf+0x2f8>)
    9026:	781b      	ldrb	r3, [r3, #0]
    9028:	2b00      	cmp	r3, #0
    902a:	d007      	beq.n	903c <am_util_stdio_vsprintf+0x48>
                {
                    *pcBuf++ = '\r';
    902c:	68fb      	ldr	r3, [r7, #12]
    902e:	1c5a      	adds	r2, r3, #1
    9030:	60fa      	str	r2, [r7, #12]
    9032:	220d      	movs	r2, #13
    9034:	701a      	strb	r2, [r3, #0]
                    ++ui32CharCnt;
    9036:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9038:	3301      	adds	r3, #1
    903a:	63fb      	str	r3, [r7, #60]	; 0x3c
                }
                *pcBuf++ = *pcFmt;
    903c:	68fb      	ldr	r3, [r7, #12]
    903e:	1c5a      	adds	r2, r3, #1
    9040:	60fa      	str	r2, [r7, #12]
    9042:	68ba      	ldr	r2, [r7, #8]
    9044:	7812      	ldrb	r2, [r2, #0]
    9046:	701a      	strb	r2, [r3, #0]
            }

            ++pcFmt;
    9048:	68bb      	ldr	r3, [r7, #8]
    904a:	3301      	adds	r3, #1
    904c:	60bb      	str	r3, [r7, #8]
            ++ui32CharCnt;
    904e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9050:	3301      	adds	r3, #1
    9052:	63fb      	str	r3, [r7, #60]	; 0x3c
            continue;
    9054:	e2bd      	b.n	95d2 <am_util_stdio_vsprintf+0x5de>
        }

        //
        // Handle the specifier.
        //
        ++pcFmt;
    9056:	68bb      	ldr	r3, [r7, #8]
    9058:	3301      	adds	r3, #1
    905a:	60bb      	str	r3, [r7, #8]
        bLower = bLongLong = false;
    905c:	2300      	movs	r3, #0
    905e:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    9062:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    9066:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';
    906a:	2320      	movs	r3, #32
    906c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        if ( *pcFmt == '0' )
    9070:	68bb      	ldr	r3, [r7, #8]
    9072:	781b      	ldrb	r3, [r3, #0]
    9074:	2b30      	cmp	r3, #48	; 0x30
    9076:	d105      	bne.n	9084 <am_util_stdio_vsprintf+0x90>
        {
            ui8PadChar = '0';
    9078:	2330      	movs	r3, #48	; 0x30
    907a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            ++pcFmt;
    907e:	68bb      	ldr	r3, [r7, #8]
    9080:	3301      	adds	r3, #1
    9082:	60bb      	str	r3, [r7, #8]
        }

        //
        // Width specifier
        //
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    9084:	f107 0310 	add.w	r3, r7, #16
    9088:	4619      	mov	r1, r3
    908a:	68b8      	ldr	r0, [r7, #8]
    908c:	f7ff fd98 	bl	8bc0 <decstr_to_int>
    9090:	4603      	mov	r3, r0
    9092:	63bb      	str	r3, [r7, #56]	; 0x38
        pcFmt += ui32NumChars;
    9094:	693b      	ldr	r3, [r7, #16]
    9096:	68ba      	ldr	r2, [r7, #8]
    9098:	4413      	add	r3, r2
    909a:	60bb      	str	r3, [r7, #8]

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    909c:	68bb      	ldr	r3, [r7, #8]
    909e:	781b      	ldrb	r3, [r3, #0]
    90a0:	2b73      	cmp	r3, #115	; 0x73
    90a2:	d005      	beq.n	90b0 <am_util_stdio_vsprintf+0xbc>
    90a4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    90a6:	2b00      	cmp	r3, #0
    90a8:	da02      	bge.n	90b0 <am_util_stdio_vsprintf+0xbc>
        {
            iWidth = -iWidth;
    90aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    90ac:	425b      	negs	r3, r3
    90ae:	63bb      	str	r3, [r7, #56]	; 0x38
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
    90b0:	68bb      	ldr	r3, [r7, #8]
    90b2:	781b      	ldrb	r3, [r3, #0]
    90b4:	2b2e      	cmp	r3, #46	; 0x2e
    90b6:	d10e      	bne.n	90d6 <am_util_stdio_vsprintf+0xe2>
        {
            ++pcFmt;
    90b8:	68bb      	ldr	r3, [r7, #8]
    90ba:	3301      	adds	r3, #1
    90bc:	60bb      	str	r3, [r7, #8]
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    90be:	f107 0310 	add.w	r3, r7, #16
    90c2:	4619      	mov	r1, r3
    90c4:	68b8      	ldr	r0, [r7, #8]
    90c6:	f7ff fd7b 	bl	8bc0 <decstr_to_int>
    90ca:	4603      	mov	r3, r0
    90cc:	633b      	str	r3, [r7, #48]	; 0x30
            pcFmt += ui32NumChars;
    90ce:	693b      	ldr	r3, [r7, #16]
    90d0:	68ba      	ldr	r2, [r7, #8]
    90d2:	4413      	add	r3, r2
    90d4:	60bb      	str	r3, [r7, #8]
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
    90d6:	68bb      	ldr	r3, [r7, #8]
    90d8:	781b      	ldrb	r3, [r3, #0]
    90da:	2b6c      	cmp	r3, #108	; 0x6c
    90dc:	d10c      	bne.n	90f8 <am_util_stdio_vsprintf+0x104>
        {
            pcFmt++;
    90de:	68bb      	ldr	r3, [r7, #8]
    90e0:	3301      	adds	r3, #1
    90e2:	60bb      	str	r3, [r7, #8]
            if ( *pcFmt == 'l' )    // "ll" (long long)
    90e4:	68bb      	ldr	r3, [r7, #8]
    90e6:	781b      	ldrb	r3, [r3, #0]
    90e8:	2b6c      	cmp	r3, #108	; 0x6c
    90ea:	d105      	bne.n	90f8 <am_util_stdio_vsprintf+0x104>
            {
                pcFmt++;
    90ec:	68bb      	ldr	r3, [r7, #8]
    90ee:	3301      	adds	r3, #1
    90f0:	60bb      	str	r3, [r7, #8]
                bLongLong = true;
    90f2:	2301      	movs	r3, #1
    90f4:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
            }
        }

        switch ( *pcFmt )
    90f8:	68bb      	ldr	r3, [r7, #8]
    90fa:	781b      	ldrb	r3, [r3, #0]
    90fc:	3b46      	subs	r3, #70	; 0x46
    90fe:	2b32      	cmp	r3, #50	; 0x32
    9100:	f200 8254 	bhi.w	95ac <am_util_stdio_vsprintf+0x5b8>
    9104:	a201      	add	r2, pc, #4	; (adr r2, 910c <am_util_stdio_vsprintf+0x118>)
    9106:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    910a:	bf00      	nop
    910c:	00009537 	.word	0x00009537
    9110:	000095ad 	.word	0x000095ad
    9114:	000095ad 	.word	0x000095ad
    9118:	000095ad 	.word	0x000095ad
    911c:	000095ad 	.word	0x000095ad
    9120:	000095ad 	.word	0x000095ad
    9124:	000095ad 	.word	0x000095ad
    9128:	000095ad 	.word	0x000095ad
    912c:	000095ad 	.word	0x000095ad
    9130:	000095ad 	.word	0x000095ad
    9134:	000095ad 	.word	0x000095ad
    9138:	000095ad 	.word	0x000095ad
    913c:	000095ad 	.word	0x000095ad
    9140:	000095ad 	.word	0x000095ad
    9144:	000095ad 	.word	0x000095ad
    9148:	000095ad 	.word	0x000095ad
    914c:	000095ad 	.word	0x000095ad
    9150:	000095ad 	.word	0x000095ad
    9154:	000092d3 	.word	0x000092d3
    9158:	000095ad 	.word	0x000095ad
    915c:	000095ad 	.word	0x000095ad
    9160:	000095ad 	.word	0x000095ad
    9164:	000095ad 	.word	0x000095ad
    9168:	000095ad 	.word	0x000095ad
    916c:	000095ad 	.word	0x000095ad
    9170:	000095ad 	.word	0x000095ad
    9174:	000095ad 	.word	0x000095ad
    9178:	000095ad 	.word	0x000095ad
    917c:	000095ad 	.word	0x000095ad
    9180:	000091d9 	.word	0x000091d9
    9184:	000093ff 	.word	0x000093ff
    9188:	000095ad 	.word	0x000095ad
    918c:	00009537 	.word	0x00009537
    9190:	000095ad 	.word	0x000095ad
    9194:	000095ad 	.word	0x000095ad
    9198:	000093ff 	.word	0x000093ff
    919c:	000095ad 	.word	0x000095ad
    91a0:	000095ad 	.word	0x000095ad
    91a4:	000095ad 	.word	0x000095ad
    91a8:	000095ad 	.word	0x000095ad
    91ac:	000095ad 	.word	0x000095ad
    91b0:	000095ad 	.word	0x000095ad
    91b4:	000095ad 	.word	0x000095ad
    91b8:	000095ad 	.word	0x000095ad
    91bc:	000095ad 	.word	0x000095ad
    91c0:	000091ff 	.word	0x000091ff
    91c4:	000095ad 	.word	0x000095ad
    91c8:	0000936d 	.word	0x0000936d
    91cc:	000095ad 	.word	0x000095ad
    91d0:	000095ad 	.word	0x000095ad
    91d4:	000092cd 	.word	0x000092cd
        {
            case 'c':
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    91d8:	687b      	ldr	r3, [r7, #4]
    91da:	1d1a      	adds	r2, r3, #4
    91dc:	607a      	str	r2, [r7, #4]
    91de:	681b      	ldr	r3, [r3, #0]
    91e0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

                if ( pcBuf )
    91e4:	68fb      	ldr	r3, [r7, #12]
    91e6:	2b00      	cmp	r3, #0
    91e8:	d005      	beq.n	91f6 <am_util_stdio_vsprintf+0x202>
                {
                    *pcBuf++ = ui8CharSpecifier;
    91ea:	68fb      	ldr	r3, [r7, #12]
    91ec:	1c5a      	adds	r2, r3, #1
    91ee:	60fa      	str	r2, [r7, #12]
    91f0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
    91f4:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    91f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    91f8:	3301      	adds	r3, #1
    91fa:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    91fc:	e1e6      	b.n	95cc <am_util_stdio_vsprintf+0x5d8>

            case 's':
                pcStr = va_arg(pArgs, char *);
    91fe:	687b      	ldr	r3, [r7, #4]
    9200:	1d1a      	adds	r2, r3, #4
    9202:	607a      	str	r2, [r7, #4]
    9204:	681b      	ldr	r3, [r3, #0]
    9206:	64fb      	str	r3, [r7, #76]	; 0x4c
                //
                // For %s, we support the width specifier. If iWidth is negative
                // the string is left-aligned (padding on the right).  Otherwise
                // the string is padded at the beginning with spaces.
                //
                ui32strlen = simple_strlen(pcStr);
    9208:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    920a:	f7ff fdc7 	bl	8d9c <simple_strlen>
    920e:	6278      	str	r0, [r7, #36]	; 0x24
                if ( iWidth > 0 )
    9210:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9212:	2b00      	cmp	r3, #0
    9214:	dd2e      	ble.n	9274 <am_util_stdio_vsprintf+0x280>
                {
                    // Pad the beginning of the string (right-aligned).
                    if ( ui32strlen < iWidth )
    9216:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9218:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    921a:	429a      	cmp	r2, r3
    921c:	d22a      	bcs.n	9274 <am_util_stdio_vsprintf+0x280>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    921e:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9220:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    9222:	1ad3      	subs	r3, r2, r3
    9224:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    9226:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    922a:	6bba      	ldr	r2, [r7, #56]	; 0x38
    922c:	4619      	mov	r1, r3
    922e:	68f8      	ldr	r0, [r7, #12]
    9230:	f7ff fdd0 	bl	8dd4 <padbuffer>
    9234:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    9236:	68fb      	ldr	r3, [r7, #12]
    9238:	2b00      	cmp	r3, #0
    923a:	d001      	beq.n	9240 <am_util_stdio_vsprintf+0x24c>
    923c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    923e:	e000      	b.n	9242 <am_util_stdio_vsprintf+0x24e>
    9240:	2300      	movs	r3, #0
    9242:	68fa      	ldr	r2, [r7, #12]
    9244:	4413      	add	r3, r2
    9246:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    9248:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    924a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    924c:	4413      	add	r3, r2
    924e:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    9250:	2300      	movs	r3, #0
    9252:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }

                while (*pcStr != 0x0)
    9254:	e00e      	b.n	9274 <am_util_stdio_vsprintf+0x280>
                {
                    if ( pcBuf )
    9256:	68fb      	ldr	r3, [r7, #12]
    9258:	2b00      	cmp	r3, #0
    925a:	d005      	beq.n	9268 <am_util_stdio_vsprintf+0x274>
                    {
                        *pcBuf++ = *pcStr;
    925c:	68fb      	ldr	r3, [r7, #12]
    925e:	1c5a      	adds	r2, r3, #1
    9260:	60fa      	str	r2, [r7, #12]
    9262:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    9264:	7812      	ldrb	r2, [r2, #0]
    9266:	701a      	strb	r2, [r3, #0]
                    }

                    ++pcStr;
    9268:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    926a:	3301      	adds	r3, #1
    926c:	64fb      	str	r3, [r7, #76]	; 0x4c
                    ++ui32CharCnt;
    926e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9270:	3301      	adds	r3, #1
    9272:	63fb      	str	r3, [r7, #60]	; 0x3c
                        ui32CharCnt += iWidth;
                        iWidth = 0;
                    }
                }

                while (*pcStr != 0x0)
    9274:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9276:	781b      	ldrb	r3, [r3, #0]
    9278:	2b00      	cmp	r3, #0
    927a:	d1ec      	bne.n	9256 <am_util_stdio_vsprintf+0x262>

                    ++pcStr;
                    ++ui32CharCnt;
                }

                if ( iWidth )
    927c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    927e:	2b00      	cmp	r3, #0
    9280:	f000 81a1 	beq.w	95c6 <am_util_stdio_vsprintf+0x5d2>
                {
                    iWidth = -iWidth;
    9284:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9286:	425b      	negs	r3, r3
    9288:	63bb      	str	r3, [r7, #56]	; 0x38

                    // Pad the end of the string (left-aligned).
                    if ( ui32strlen < iWidth )
    928a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    928c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    928e:	429a      	cmp	r2, r3
    9290:	f080 8199 	bcs.w	95c6 <am_util_stdio_vsprintf+0x5d2>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    9294:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9296:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    9298:	1ad3      	subs	r3, r2, r3
    929a:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    929c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    92a0:	6bba      	ldr	r2, [r7, #56]	; 0x38
    92a2:	4619      	mov	r1, r3
    92a4:	68f8      	ldr	r0, [r7, #12]
    92a6:	f7ff fd95 	bl	8dd4 <padbuffer>
    92aa:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    92ac:	68fb      	ldr	r3, [r7, #12]
    92ae:	2b00      	cmp	r3, #0
    92b0:	d001      	beq.n	92b6 <am_util_stdio_vsprintf+0x2c2>
    92b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92b4:	e000      	b.n	92b8 <am_util_stdio_vsprintf+0x2c4>
    92b6:	2300      	movs	r3, #0
    92b8:	68fa      	ldr	r2, [r7, #12]
    92ba:	4413      	add	r3, r2
    92bc:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    92be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    92c2:	4413      	add	r3, r2
    92c4:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    92c6:	2300      	movs	r3, #0
    92c8:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }
                break;
    92ca:	e17c      	b.n	95c6 <am_util_stdio_vsprintf+0x5d2>

            case 'x':
                bLower = true;
    92cc:	2301      	movs	r3, #1
    92ce:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    92d2:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    92d6:	2b00      	cmp	r3, #0
    92d8:	d00a      	beq.n	92f0 <am_util_stdio_vsprintf+0x2fc>
    92da:	687b      	ldr	r3, [r7, #4]
    92dc:	3307      	adds	r3, #7
    92de:	f023 0307 	bic.w	r3, r3, #7
    92e2:	f103 0208 	add.w	r2, r3, #8
    92e6:	607a      	str	r2, [r7, #4]
    92e8:	cb18      	ldmia	r3, {r3, r4}
    92ea:	e007      	b.n	92fc <am_util_stdio_vsprintf+0x308>
    92ec:	10001188 	.word	0x10001188
                                      va_arg(pArgs, uint32_t);
    92f0:	687b      	ldr	r3, [r7, #4]
    92f2:	1d1a      	adds	r2, r3, #4
    92f4:	607a      	str	r2, [r7, #4]
    92f6:	681b      	ldr	r3, [r3, #0]
                break;

            case 'x':
                bLower = true;
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    92f8:	f04f 0400 	mov.w	r4, #0
    92fc:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                                      va_arg(pArgs, uint32_t);

                if ( iWidth )
    9300:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9302:	2b00      	cmp	r3, #0
    9304:	d01e      	beq.n	9344 <am_util_stdio_vsprintf+0x350>
                {
                    //
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_hex(ui64Val);
    9306:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    930a:	f7ff fc35 	bl	8b78 <ndigits_in_hex>
    930e:	4602      	mov	r2, r0
    9310:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9312:	1a9b      	subs	r3, r3, r2
    9314:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    9316:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    931a:	6bba      	ldr	r2, [r7, #56]	; 0x38
    931c:	4619      	mov	r1, r3
    931e:	68f8      	ldr	r0, [r7, #12]
    9320:	f7ff fd58 	bl	8dd4 <padbuffer>
    9324:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    9326:	68fb      	ldr	r3, [r7, #12]
    9328:	2b00      	cmp	r3, #0
    932a:	d001      	beq.n	9330 <am_util_stdio_vsprintf+0x33c>
    932c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    932e:	e000      	b.n	9332 <am_util_stdio_vsprintf+0x33e>
    9330:	2300      	movs	r3, #0
    9332:	68fa      	ldr	r2, [r7, #12]
    9334:	4413      	add	r3, r2
    9336:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    9338:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    933a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    933c:	4413      	add	r3, r2
    933e:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    9340:	2300      	movs	r3, #0
    9342:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
    9344:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    9348:	68fa      	ldr	r2, [r7, #12]
    934a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    934e:	f7ff fcc5 	bl	8cdc <uint64_to_hexstr>
    9352:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    9354:	68fb      	ldr	r3, [r7, #12]
    9356:	2b00      	cmp	r3, #0
    9358:	d003      	beq.n	9362 <am_util_stdio_vsprintf+0x36e>
                {
                    pcBuf += iVal;
    935a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    935c:	68fa      	ldr	r2, [r7, #12]
    935e:	4413      	add	r3, r2
    9360:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    9362:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9364:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    9366:	4413      	add	r3, r2
    9368:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    936a:	e12f      	b.n	95cc <am_util_stdio_vsprintf+0x5d8>

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    936c:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    9370:	2b00      	cmp	r3, #0
    9372:	d008      	beq.n	9386 <am_util_stdio_vsprintf+0x392>
    9374:	687b      	ldr	r3, [r7, #4]
    9376:	3307      	adds	r3, #7
    9378:	f023 0307 	bic.w	r3, r3, #7
    937c:	f103 0208 	add.w	r2, r3, #8
    9380:	607a      	str	r2, [r7, #4]
    9382:	cb18      	ldmia	r3, {r3, r4}
    9384:	e005      	b.n	9392 <am_util_stdio_vsprintf+0x39e>
                                      va_arg(pArgs, uint32_t);
    9386:	687b      	ldr	r3, [r7, #4]
    9388:	1d1a      	adds	r2, r3, #4
    938a:	607a      	str	r2, [r7, #4]
    938c:	681b      	ldr	r3, [r3, #0]

                ui32CharCnt += iVal;
                break;

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    938e:	f04f 0400 	mov.w	r4, #0
    9392:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                                      va_arg(pArgs, uint32_t);

                if ( iWidth )
    9396:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9398:	2b00      	cmp	r3, #0
    939a:	d01e      	beq.n	93da <am_util_stdio_vsprintf+0x3e6>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_u64(ui64Val);
    939c:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    93a0:	f7ff fbaa 	bl	8af8 <ndigits_in_u64>
    93a4:	4602      	mov	r2, r0
    93a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    93a8:	1a9b      	subs	r3, r3, r2
    93aa:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    93ac:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    93b0:	6bba      	ldr	r2, [r7, #56]	; 0x38
    93b2:	4619      	mov	r1, r3
    93b4:	68f8      	ldr	r0, [r7, #12]
    93b6:	f7ff fd0d 	bl	8dd4 <padbuffer>
    93ba:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    93bc:	68fb      	ldr	r3, [r7, #12]
    93be:	2b00      	cmp	r3, #0
    93c0:	d001      	beq.n	93c6 <am_util_stdio_vsprintf+0x3d2>
    93c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    93c4:	e000      	b.n	93c8 <am_util_stdio_vsprintf+0x3d4>
    93c6:	2300      	movs	r3, #0
    93c8:	68fa      	ldr	r2, [r7, #12]
    93ca:	4413      	add	r3, r2
    93cc:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    93ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    93d0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    93d2:	4413      	add	r3, r2
    93d4:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    93d6:	2300      	movs	r3, #0
    93d8:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    93da:	68fa      	ldr	r2, [r7, #12]
    93dc:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    93e0:	f7ff fc34 	bl	8c4c <uint64_to_str>
    93e4:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    93e6:	68fb      	ldr	r3, [r7, #12]
    93e8:	2b00      	cmp	r3, #0
    93ea:	d003      	beq.n	93f4 <am_util_stdio_vsprintf+0x400>
                {
                    pcBuf += iVal;
    93ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    93ee:	68fa      	ldr	r2, [r7, #12]
    93f0:	4413      	add	r3, r2
    93f2:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    93f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    93f6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    93f8:	4413      	add	r3, r2
    93fa:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    93fc:	e0e6      	b.n	95cc <am_util_stdio_vsprintf+0x5d8>
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    93fe:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    9402:	2b00      	cmp	r3, #0
    9404:	d008      	beq.n	9418 <am_util_stdio_vsprintf+0x424>
    9406:	687b      	ldr	r3, [r7, #4]
    9408:	3307      	adds	r3, #7
    940a:	f023 0307 	bic.w	r3, r3, #7
    940e:	f103 0208 	add.w	r2, r3, #8
    9412:	607a      	str	r2, [r7, #4]
    9414:	cb18      	ldmia	r3, {r3, r4}
    9416:	e005      	b.n	9424 <am_util_stdio_vsprintf+0x430>
                                     va_arg(pArgs, int32_t);
    9418:	687b      	ldr	r3, [r7, #4]
    941a:	1d1a      	adds	r2, r3, #4
    941c:	607a      	str	r2, [r7, #4]
    941e:	681b      	ldr	r3, [r3, #0]
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    9420:	ea4f 74e3 	mov.w	r4, r3, asr #31
    9424:	e9c7 3406 	strd	r3, r4, [r7, #24]
                                     va_arg(pArgs, int32_t);

                //
                // Get absolute value
                //
                if ( i64Val < 0 )
    9428:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    942c:	2b00      	cmp	r3, #0
    942e:	f174 0300 	sbcs.w	r3, r4, #0
    9432:	da0a      	bge.n	944a <am_util_stdio_vsprintf+0x456>
                {
                    ui64Val = -i64Val;          // Get absolute value
    9434:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    9438:	425b      	negs	r3, r3
    943a:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    943e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = true;
    9442:	2301      	movs	r3, #1
    9444:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    9448:	e006      	b.n	9458 <am_util_stdio_vsprintf+0x464>
                }
                else
                {
                    ui64Val = i64Val;
    944a:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    944e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = false;
    9452:	2300      	movs	r3, #0
    9454:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
                }

                if ( iWidth )
    9458:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    945a:	2b00      	cmp	r3, #0
    945c:	d04a      	beq.n	94f4 <am_util_stdio_vsprintf+0x500>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_i64(ui64Val);
    945e:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
    9462:	4618      	mov	r0, r3
    9464:	4621      	mov	r1, r4
    9466:	f7ff fb69 	bl	8b3c <ndigits_in_i64>
    946a:	4602      	mov	r2, r0
    946c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    946e:	1a9b      	subs	r3, r3, r2
    9470:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg )
    9472:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    9476:	2b00      	cmp	r3, #0
    9478:	d011      	beq.n	949e <am_util_stdio_vsprintf+0x4aa>
                    {
                        --iWidth;
    947a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    947c:	3b01      	subs	r3, #1
    947e:	63bb      	str	r3, [r7, #56]	; 0x38

                        //
                        // Allow for the negative sign
                        //
                        if ( ui8PadChar == '0' )
    9480:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9484:	2b30      	cmp	r3, #48	; 0x30
    9486:	d10a      	bne.n	949e <am_util_stdio_vsprintf+0x4aa>
                        {
                            //
                            // Print the neg sign BEFORE the leading zeros
                            //
                            if ( pcBuf )
    9488:	68fb      	ldr	r3, [r7, #12]
    948a:	2b00      	cmp	r3, #0
    948c:	d004      	beq.n	9498 <am_util_stdio_vsprintf+0x4a4>
                            {
                                *pcBuf++ = '-';
    948e:	68fb      	ldr	r3, [r7, #12]
    9490:	1c5a      	adds	r2, r3, #1
    9492:	60fa      	str	r2, [r7, #12]
    9494:	222d      	movs	r2, #45	; 0x2d
    9496:	701a      	strb	r2, [r3, #0]
                            }

                            ++ui32CharCnt;
    9498:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    949a:	3301      	adds	r3, #1
    949c:	63fb      	str	r3, [r7, #60]	; 0x3c
                        }
                    }

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    949e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    94a2:	6bba      	ldr	r2, [r7, #56]	; 0x38
    94a4:	4619      	mov	r1, r3
    94a6:	68f8      	ldr	r0, [r7, #12]
    94a8:	f7ff fc94 	bl	8dd4 <padbuffer>
    94ac:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    94ae:	68fb      	ldr	r3, [r7, #12]
    94b0:	2b00      	cmp	r3, #0
    94b2:	d001      	beq.n	94b8 <am_util_stdio_vsprintf+0x4c4>
    94b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    94b6:	e000      	b.n	94ba <am_util_stdio_vsprintf+0x4c6>
    94b8:	2300      	movs	r3, #0
    94ba:	68fa      	ldr	r2, [r7, #12]
    94bc:	4413      	add	r3, r2
    94be:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    94c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    94c2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    94c4:	4413      	add	r3, r2
    94c6:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    94c8:	2300      	movs	r3, #0
    94ca:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg  &&  (ui8PadChar == ' ') )
    94cc:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    94d0:	2b00      	cmp	r3, #0
    94d2:	d01e      	beq.n	9512 <am_util_stdio_vsprintf+0x51e>
    94d4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    94d8:	2b20      	cmp	r3, #32
    94da:	d11a      	bne.n	9512 <am_util_stdio_vsprintf+0x51e>
                    {
                        //
                        // Print the neg sign AFTER the leading blanks
                        //
                        if ( pcBuf )
    94dc:	68fb      	ldr	r3, [r7, #12]
    94de:	2b00      	cmp	r3, #0
    94e0:	d004      	beq.n	94ec <am_util_stdio_vsprintf+0x4f8>
                        {
                            *pcBuf++ = '-';
    94e2:	68fb      	ldr	r3, [r7, #12]
    94e4:	1c5a      	adds	r2, r3, #1
    94e6:	60fa      	str	r2, [r7, #12]
    94e8:	222d      	movs	r2, #45	; 0x2d
    94ea:	701a      	strb	r2, [r3, #0]
                        }

                        ++ui32CharCnt;
    94ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    94ee:	3301      	adds	r3, #1
    94f0:	63fb      	str	r3, [r7, #60]	; 0x3c
    94f2:	e00e      	b.n	9512 <am_util_stdio_vsprintf+0x51e>
                    }
                }
                else
                {
                    if ( bNeg )
    94f4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    94f8:	2b00      	cmp	r3, #0
    94fa:	d00a      	beq.n	9512 <am_util_stdio_vsprintf+0x51e>
                    {
                        if ( pcBuf )
    94fc:	68fb      	ldr	r3, [r7, #12]
    94fe:	2b00      	cmp	r3, #0
    9500:	d004      	beq.n	950c <am_util_stdio_vsprintf+0x518>
                        {
                            *pcBuf++ = '-';
    9502:	68fb      	ldr	r3, [r7, #12]
    9504:	1c5a      	adds	r2, r3, #1
    9506:	60fa      	str	r2, [r7, #12]
    9508:	222d      	movs	r2, #45	; 0x2d
    950a:	701a      	strb	r2, [r3, #0]
                        }
                        ++ui32CharCnt;
    950c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    950e:	3301      	adds	r3, #1
    9510:	63fb      	str	r3, [r7, #60]	; 0x3c
                    }
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    9512:	68fa      	ldr	r2, [r7, #12]
    9514:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    9518:	f7ff fb98 	bl	8c4c <uint64_to_str>
    951c:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    951e:	68fb      	ldr	r3, [r7, #12]
    9520:	2b00      	cmp	r3, #0
    9522:	d003      	beq.n	952c <am_util_stdio_vsprintf+0x538>
                {
                    pcBuf += iVal;
    9524:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9526:	68fa      	ldr	r2, [r7, #12]
    9528:	4413      	add	r3, r2
    952a:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    952c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    952e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    9530:	4413      	add	r3, r2
    9532:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    9534:	e04a      	b.n	95cc <am_util_stdio_vsprintf+0x5d8>


            case 'f':
            case 'F':
                if ( pcBuf )
    9536:	68fb      	ldr	r3, [r7, #12]
    9538:	2b00      	cmp	r3, #0
    953a:	d046      	beq.n	95ca <am_util_stdio_vsprintf+0x5d6>
                {
                    float fValue = va_arg(pArgs, double);
    953c:	687b      	ldr	r3, [r7, #4]
    953e:	3307      	adds	r3, #7
    9540:	f023 0307 	bic.w	r3, r3, #7
    9544:	f103 0208 	add.w	r2, r3, #8
    9548:	607a      	str	r2, [r7, #4]
    954a:	cb18      	ldmia	r3, {r3, r4}
    954c:	4618      	mov	r0, r3
    954e:	4621      	mov	r1, r4
    9550:	f7fe fdb6 	bl	80c0 <__aeabi_d2f>
    9554:	4603      	mov	r3, r0
    9556:	617b      	str	r3, [r7, #20]

                    //
                    // pcBuf is an input (size of buffer) and also an output of ftoa()
                    //
                    *(uint32_t*)pcBuf = 20;
    9558:	68fb      	ldr	r3, [r7, #12]
    955a:	2214      	movs	r2, #20
    955c:	601a      	str	r2, [r3, #0]

                    iVal = ftoa(fValue, pcBuf, iPrecision);
    955e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    9560:	68f9      	ldr	r1, [r7, #12]
    9562:	6978      	ldr	r0, [r7, #20]
    9564:	f7ff fc5c 	bl	8e20 <ftoa>
    9568:	6378      	str	r0, [r7, #52]	; 0x34
                    if ( iVal < 0 )
    956a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    956c:	2b00      	cmp	r3, #0
    956e:	da14      	bge.n	959a <am_util_stdio_vsprintf+0x5a6>
                    {
                        uint32_t u32PrntErrVal;
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    9570:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9572:	f1b3 3fff 	cmp.w	r3, #4294967295
    9576:	d102      	bne.n	957e <am_util_stdio_vsprintf+0x58a>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    9578:	4b1e      	ldr	r3, [pc, #120]	; (95f4 <am_util_stdio_vsprintf+0x600>)
    957a:	62bb      	str	r3, [r7, #40]	; 0x28
    957c:	e008      	b.n	9590 <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('0' << 0);  // "0.0"
                        }
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    957e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9580:	f113 0f02 	cmn.w	r3, #2
    9584:	d102      	bne.n	958c <am_util_stdio_vsprintf+0x598>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    9586:	4b1c      	ldr	r3, [pc, #112]	; (95f8 <am_util_stdio_vsprintf+0x604>)
    9588:	62bb      	str	r3, [r7, #40]	; 0x28
    958a:	e001      	b.n	9590 <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('#' << 0);  // "#.#"
                        }
                        else
                        {
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    958c:	4b1b      	ldr	r3, [pc, #108]	; (95fc <am_util_stdio_vsprintf+0x608>)
    958e:	62bb      	str	r3, [r7, #40]	; 0x28
                                            ('.' << 8)   | ('?' << 0);  // "?.?"
                        }
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    9590:	68fb      	ldr	r3, [r7, #12]
    9592:	6aba      	ldr	r2, [r7, #40]	; 0x28
    9594:	601a      	str	r2, [r3, #0]
                        iVal = 3;
    9596:	2303      	movs	r3, #3
    9598:	637b      	str	r3, [r7, #52]	; 0x34
                    }
                    ui32CharCnt += iVal;
    959a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    959c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    959e:	4413      	add	r3, r2
    95a0:	63fb      	str	r3, [r7, #60]	; 0x3c
                    pcBuf += iVal;
    95a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    95a4:	68fa      	ldr	r2, [r7, #12]
    95a6:	4413      	add	r3, r2
    95a8:	60fb      	str	r3, [r7, #12]
                }
                break;
    95aa:	e00e      	b.n	95ca <am_util_stdio_vsprintf+0x5d6>
            // For non-handled specifiers, we'll just print the character.
            // e.g. this will allow the normal printing of a '%' using
            // "%%".
            //
            default:
                if ( pcBuf )
    95ac:	68fb      	ldr	r3, [r7, #12]
    95ae:	2b00      	cmp	r3, #0
    95b0:	d005      	beq.n	95be <am_util_stdio_vsprintf+0x5ca>
                {
                    *pcBuf++ = *pcFmt;
    95b2:	68fb      	ldr	r3, [r7, #12]
    95b4:	1c5a      	adds	r2, r3, #1
    95b6:	60fa      	str	r2, [r7, #12]
    95b8:	68ba      	ldr	r2, [r7, #8]
    95ba:	7812      	ldrb	r2, [r2, #0]
    95bc:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    95be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    95c0:	3301      	adds	r3, #1
    95c2:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    95c4:	e002      	b.n	95cc <am_util_stdio_vsprintf+0x5d8>
                        pcBuf += pcBuf ? iWidth : 0;
                        ui32CharCnt += iWidth;
                        iWidth = 0;
                    }
                }
                break;
    95c6:	bf00      	nop
    95c8:	e000      	b.n	95cc <am_util_stdio_vsprintf+0x5d8>
                        iVal = 3;
                    }
                    ui32CharCnt += iVal;
                    pcBuf += iVal;
                }
                break;
    95ca:	bf00      	nop
        } // switch()

        //
        // Bump the format specification to the next character
        //
        ++pcFmt;
    95cc:	68bb      	ldr	r3, [r7, #8]
    95ce:	3301      	adds	r3, #1
    95d0:	60bb      	str	r3, [r7, #8]
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    95d2:	68bb      	ldr	r3, [r7, #8]
    95d4:	781b      	ldrb	r3, [r3, #0]
    95d6:	2b00      	cmp	r3, #0
    95d8:	f47f ad17 	bne.w	900a <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    95dc:	68fb      	ldr	r3, [r7, #12]
    95de:	2b00      	cmp	r3, #0
    95e0:	d002      	beq.n	95e8 <am_util_stdio_vsprintf+0x5f4>
    {
        *pcBuf = 0x0;
    95e2:	68fb      	ldr	r3, [r7, #12]
    95e4:	2200      	movs	r2, #0
    95e6:	701a      	strb	r2, [r3, #0]
    }

    return (ui32CharCnt);
    95e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    95ea:	4618      	mov	r0, r3
    95ec:	3754      	adds	r7, #84	; 0x54
    95ee:	46bd      	mov	sp, r7
    95f0:	bd90      	pop	{r4, r7, pc}
    95f2:	bf00      	nop
    95f4:	00302e30 	.word	0x00302e30
    95f8:	00232e23 	.word	0x00232e23
    95fc:	003f2e3f 	.word	0x003f2e3f

00009600 <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    9600:	b40f      	push	{r0, r1, r2, r3}
    9602:	b580      	push	{r7, lr}
    9604:	b082      	sub	sp, #8
    9606:	af00      	add	r7, sp, #0

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    9608:	f107 0314 	add.w	r3, r7, #20
    960c:	603b      	str	r3, [r7, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    960e:	683a      	ldr	r2, [r7, #0]
    9610:	6939      	ldr	r1, [r7, #16]
    9612:	4808      	ldr	r0, [pc, #32]	; (9634 <am_util_stdio_printf+0x34>)
    9614:	f7ff fcee 	bl	8ff4 <am_util_stdio_vsprintf>
    9618:	6078      	str	r0, [r7, #4]
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    961a:	4b07      	ldr	r3, [pc, #28]	; (9638 <am_util_stdio_printf+0x38>)
    961c:	681b      	ldr	r3, [r3, #0]
    961e:	4805      	ldr	r0, [pc, #20]	; (9634 <am_util_stdio_printf+0x34>)
    9620:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
    9622:	687b      	ldr	r3, [r7, #4]
}
    9624:	4618      	mov	r0, r3
    9626:	3708      	adds	r7, #8
    9628:	46bd      	mov	sp, r7
    962a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    962e:	b004      	add	sp, #16
    9630:	4770      	bx	lr
    9632:	bf00      	nop
    9634:	10001088 	.word	0x10001088
    9638:	1000119c 	.word	0x1000119c

0000963c <am_util_stdio_terminal_clear>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_terminal_clear(void)
{
    963c:	b580      	push	{r7, lr}
    963e:	af00      	add	r7, sp, #0
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    9640:	4802      	ldr	r0, [pc, #8]	; (964c <am_util_stdio_terminal_clear+0x10>)
    9642:	f7ff ffdd 	bl	9600 <am_util_stdio_printf>
}
    9646:	bf00      	nop
    9648:	bd80      	pop	{r7, pc}
    964a:	bf00      	nop
    964c:	0000a19c 	.word	0x0000a19c

00009650 <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
    9650:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_pwrctrl_bucks_init();
    9652:	f000 fc07 	bl	9e64 <am_hal_pwrctrl_bucks_init>

    //
    // Initialize for low power in the power control block
    //
    am_hal_pwrctrl_low_power_init();
    9656:	f000 fc73 	bl	9f40 <am_hal_pwrctrl_low_power_init>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
    965a:	f000 fd8d 	bl	a178 <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
    965e:	2001      	movs	r0, #1
    9660:	f000 fc7e 	bl	9f60 <am_hal_rtc_osc_select>

    //
    // Stop the XT and LFRC.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
    9664:	2001      	movs	r0, #1
    9666:	f000 f945 	bl	98f4 <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
}
    966a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_LFRC);

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
    966e:	f000 bc85 	b.w	9f7c <am_hal_rtc_osc_disable>
    9672:	bf00      	nop

00009674 <am_bsp_debug_printf_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_enable(void)
{
    9674:	b530      	push	{r4, r5, lr}
    am_hal_tpiu_config_t TPIUcfg;

    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    9676:	4b17      	ldr	r3, [pc, #92]	; (96d4 <am_bsp_debug_printf_enable+0x60>)
    9678:	6818      	ldr	r0, [r3, #0]
    967a:	f010 0401 	ands.w	r4, r0, #1
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_enable(void)
{
    967e:	b087      	sub	sp, #28
    am_hal_tpiu_config_t TPIUcfg;

    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    9680:	d001      	beq.n	9686 <am_bsp_debug_printf_enable+0x12>
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    am_hal_tpiu_enable(&TPIUcfg);
    am_bsp_pin_enable(ITM_SWO);
}
    9682:	b007      	add	sp, #28
    9684:	bd30      	pop	{r4, r5, pc}
    }

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    9686:	4a14      	ldr	r2, [pc, #80]	; (96d8 <am_bsp_debug_printf_enable+0x64>)
    9688:	4914      	ldr	r1, [pc, #80]	; (96dc <am_bsp_debug_printf_enable+0x68>)
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

    //
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    968a:	4d15      	ldr	r5, [pc, #84]	; (96e0 <am_bsp_debug_printf_enable+0x6c>)
    }

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    968c:	6011      	str	r1, [r2, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

    //
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    968e:	a806      	add	r0, sp, #24
    9690:	f840 5d14 	str.w	r5, [r0, #-20]!
    am_hal_tpiu_enable(&TPIUcfg);
    9694:	f000 fd14 	bl	a0c0 <am_hal_tpiu_enable>
    am_bsp_pin_enable(ITM_SWO);
    9698:	f3ef 8310 	mrs	r3, PRIMASK
    969c:	9300      	str	r3, [sp, #0]
    969e:	b672      	cpsid	i
    96a0:	4a10      	ldr	r2, [pc, #64]	; (96e4 <am_bsp_debug_printf_enable+0x70>)
    96a2:	4d11      	ldr	r5, [pc, #68]	; (96e8 <am_bsp_debug_printf_enable+0x74>)
    96a4:	4811      	ldr	r0, [pc, #68]	; (96ec <am_bsp_debug_printf_enable+0x78>)
    96a6:	4912      	ldr	r1, [pc, #72]	; (96f0 <am_bsp_debug_printf_enable+0x7c>)
    96a8:	2373      	movs	r3, #115	; 0x73
    96aa:	6013      	str	r3, [r2, #0]
    96ac:	682b      	ldr	r3, [r5, #0]
    96ae:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    96b2:	602b      	str	r3, [r5, #0]
    96b4:	6805      	ldr	r5, [r0, #0]
    96b6:	f425 4c7f 	bic.w	ip, r5, #65280	; 0xff00
    96ba:	f44c 5380 	orr.w	r3, ip, #4096	; 0x1000
    96be:	6003      	str	r3, [r0, #0]
    96c0:	6808      	ldr	r0, [r1, #0]
    96c2:	f420 457f 	bic.w	r5, r0, #65280	; 0xff00
    96c6:	600d      	str	r5, [r1, #0]
    96c8:	6014      	str	r4, [r2, #0]
    96ca:	9c00      	ldr	r4, [sp, #0]
    96cc:	f384 8810 	msr	PRIMASK, r4
}
    96d0:	b007      	add	sp, #28
    96d2:	bd30      	pop	{r4, r5, pc}
    96d4:	1000118c 	.word	0x1000118c
    96d8:	e0000e80 	.word	0xe0000e80
    96dc:	00150511 	.word	0x00150511
    96e0:	000f4240 	.word	0x000f4240
    96e4:	40010060 	.word	0x40010060
    96e8:	40010054 	.word	0x40010054
    96ec:	40010028 	.word	0x40010028
    96f0:	40010108 	.word	0x40010108

000096f4 <am_bsp_debug_printf_disable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_disable(void)
{
    96f4:	b530      	push	{r4, r5, lr}
    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    96f6:	4b15      	ldr	r3, [pc, #84]	; (974c <am_bsp_debug_printf_disable+0x58>)
    96f8:	6818      	ldr	r0, [r3, #0]
    96fa:	f010 0401 	ands.w	r4, r0, #1
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_disable(void)
{
    96fe:	b083      	sub	sp, #12
    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    9700:	d121      	bne.n	9746 <am_bsp_debug_printf_disable+0x52>
    }

    //
    // Disable the TPIU
    //
    am_hal_itm_not_busy();
    9702:	f000 fa61 	bl	9bc8 <am_hal_itm_not_busy>
    am_hal_gpio_pin_config(AM_BSP_GPIO_ITM_SWO, AM_HAL_GPIO_OUTPUT);
    9706:	f3ef 8110 	mrs	r1, PRIMASK
    970a:	9101      	str	r1, [sp, #4]
    970c:	b672      	cpsid	i
    970e:	4a10      	ldr	r2, [pc, #64]	; (9750 <am_bsp_debug_printf_disable+0x5c>)
    9710:	4d10      	ldr	r5, [pc, #64]	; (9754 <am_bsp_debug_printf_disable+0x60>)
    9712:	4811      	ldr	r0, [pc, #68]	; (9758 <am_bsp_debug_printf_disable+0x64>)
    9714:	4911      	ldr	r1, [pc, #68]	; (975c <am_bsp_debug_printf_disable+0x68>)
    9716:	2373      	movs	r3, #115	; 0x73
    9718:	6013      	str	r3, [r2, #0]
    971a:	682b      	ldr	r3, [r5, #0]
    971c:	f023 0c70 	bic.w	ip, r3, #112	; 0x70
    9720:	f04c 0320 	orr.w	r3, ip, #32
    9724:	602b      	str	r3, [r5, #0]
    9726:	6805      	ldr	r5, [r0, #0]
    9728:	f425 4c7f 	bic.w	ip, r5, #65280	; 0xff00
    972c:	f44c 53c0 	orr.w	r3, ip, #6144	; 0x1800
    9730:	6003      	str	r3, [r0, #0]
    9732:	6808      	ldr	r0, [r1, #0]
    9734:	f420 457f 	bic.w	r5, r0, #65280	; 0xff00
    9738:	600d      	str	r5, [r1, #0]
    973a:	6014      	str	r4, [r2, #0]
    973c:	9c01      	ldr	r4, [sp, #4]
    973e:	f384 8810 	msr	PRIMASK, r4
    am_hal_tpiu_disable();
    9742:	f000 fd13 	bl	a16c <am_hal_tpiu_disable>
}
    9746:	b003      	add	sp, #12
    9748:	bd30      	pop	{r4, r5, pc}
    974a:	bf00      	nop
    974c:	1000118c 	.word	0x1000118c
    9750:	40010060 	.word	0x40010060
    9754:	40010054 	.word	0x40010054
    9758:	40010028 	.word	0x40010028
    975c:	40010108 	.word	0x40010108

00009760 <am_bsp_itm_string_print>:
//
//*****************************************************************************
void
am_bsp_itm_string_print(char *pcString)
{
    am_hal_itm_print(pcString);
    9760:	f000 ba3c 	b.w	9bdc <am_hal_itm_print>

00009764 <am_hal_cachectrl_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_cachectrl_enable(const am_hal_cachectrl_config_t *psConfig)
{
    9764:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9766:	4604      	mov	r4, r0
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
    9768:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
                       AM_REG_CACHECTRL_CACHECFG_LRU( psConfig->ui32LRU )                                   |
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC0( (psConfig->ui32EnableNCregions & 0x1) >> 0 )   |
    976c:	78a7      	ldrb	r7, [r4, #2]
    // workaround for a timing issue with early versions of Apollo2 that caused
    // the cache to incorrectly mark itself valid during the startup sequence.
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    976e:	7863      	ldrb	r3, [r4, #1]
    9770:	78e2      	ldrb	r2, [r4, #3]
    9772:	7925      	ldrb	r5, [r4, #4]
    9774:	79a1      	ldrb	r1, [r4, #6]
    9776:	00be      	lsls	r6, r7, #2
    9778:	ea4f 0e43 	mov.w	lr, r3, lsl #1
    977c:	f006 0304 	and.w	r3, r6, #4
    9780:	f00e 0602 	and.w	r6, lr, #2
    9784:	431e      	orrs	r6, r3
    9786:	f042 0201 	orr.w	r2, r2, #1
    978a:	79e3      	ldrb	r3, [r4, #7]
    978c:	01ed      	lsls	r5, r5, #7
    978e:	4316      	orrs	r6, r2
    9790:	b2ed      	uxtb	r5, r5
    9792:	7a22      	ldrb	r2, [r4, #8]
    9794:	0289      	lsls	r1, r1, #10
    9796:	432e      	orrs	r6, r5
    9798:	f401 6180 	and.w	r1, r1, #1024	; 0x400
    979c:	7a65      	ldrb	r5, [r4, #9]
    979e:	02db      	lsls	r3, r3, #11
    97a0:	430e      	orrs	r6, r1
    97a2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    97a6:	0312      	lsls	r2, r2, #12
    97a8:	7aa1      	ldrb	r1, [r4, #10]
    97aa:	431e      	orrs	r6, r3
    97ac:	042d      	lsls	r5, r5, #16
    97ae:	b293      	uxth	r3, r2
    97b0:	7ae2      	ldrb	r2, [r4, #11]
    97b2:	431e      	orrs	r6, r3
    97b4:	0509      	lsls	r1, r1, #20
    97b6:	f405 2370 	and.w	r3, r5, #983040	; 0xf0000
    97ba:	0612      	lsls	r2, r2, #24
    97bc:	4333      	orrs	r3, r6
    97be:	f401 1680 	and.w	r6, r1, #1048576	; 0x100000
    97c2:	00bf      	lsls	r7, r7, #2
    97c4:	f002 7180 	and.w	r1, r2, #16777216	; 0x1000000
    97c8:	4333      	orrs	r3, r6
    97ca:	430b      	orrs	r3, r1
    97cc:	f007 0508 	and.w	r5, r7, #8
    97d0:	431d      	orrs	r5, r3
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
    97d2:	f000 fa3f 	bl	9c54 <am_hal_pwrctrl_memory_enable>

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    97d6:	482c      	ldr	r0, [pc, #176]	; (9888 <am_hal_cachectrl_enable+0x124>)
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    97d8:	4b2c      	ldr	r3, [pc, #176]	; (988c <am_hal_cachectrl_enable+0x128>)
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    97da:	6005      	str	r5, [r0, #0]
    97dc:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    97de:	681e      	ldr	r6, [r3, #0]
    97e0:	0777      	lsls	r7, r6, #29
    97e2:	d41e      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    97e4:	681f      	ldr	r7, [r3, #0]
    97e6:	077e      	lsls	r6, r7, #29
    97e8:	f102 32ff 	add.w	r2, r2, #4294967295
    97ec:	d419      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    97ee:	6819      	ldr	r1, [r3, #0]
    97f0:	074f      	lsls	r7, r1, #29
    97f2:	d416      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    97f4:	6818      	ldr	r0, [r3, #0]
    97f6:	0746      	lsls	r6, r0, #29
    97f8:	d413      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    97fa:	681e      	ldr	r6, [r3, #0]
    97fc:	0770      	lsls	r0, r6, #29
    97fe:	d410      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    9800:	681f      	ldr	r7, [r3, #0]
    9802:	0779      	lsls	r1, r7, #29
    9804:	d40d      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    9806:	6819      	ldr	r1, [r3, #0]
    9808:	074f      	lsls	r7, r1, #29
    980a:	d40a      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    980c:	6818      	ldr	r0, [r3, #0]
    980e:	0746      	lsls	r6, r0, #29
    9810:	d407      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    9812:	681e      	ldr	r6, [r3, #0]
    9814:	0770      	lsls	r0, r6, #29
    9816:	d404      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    9818:	681f      	ldr	r7, [r3, #0]
    981a:	0779      	lsls	r1, r7, #29
    981c:	d401      	bmi.n	9822 <am_hal_cachectrl_enable+0xbe>
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;

    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    981e:	3a09      	subs	r2, #9
    9820:	d1dd      	bne.n	97de <am_hal_cachectrl_enable+0x7a>
    }

    //
    // Manually invalidate the cache (workaround for the issue described above.)
    //
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);
    9822:	4b1a      	ldr	r3, [pc, #104]	; (988c <am_hal_cachectrl_enable+0x128>)
    9824:	681a      	ldr	r2, [r3, #0]
    9826:	f042 0101 	orr.w	r1, r2, #1
    982a:	6019      	str	r1, [r3, #0]
    982c:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    982e:	6818      	ldr	r0, [r3, #0]
    9830:	0740      	lsls	r0, r0, #29
    9832:	d41e      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    9834:	681e      	ldr	r6, [r3, #0]
    9836:	0771      	lsls	r1, r6, #29
    9838:	f102 32ff 	add.w	r2, r2, #4294967295
    983c:	d419      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    983e:	681f      	ldr	r7, [r3, #0]
    9840:	077f      	lsls	r7, r7, #29
    9842:	d416      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    9844:	6819      	ldr	r1, [r3, #0]
    9846:	074e      	lsls	r6, r1, #29
    9848:	d413      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    984a:	6818      	ldr	r0, [r3, #0]
    984c:	0740      	lsls	r0, r0, #29
    984e:	d410      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    9850:	681e      	ldr	r6, [r3, #0]
    9852:	0771      	lsls	r1, r6, #29
    9854:	d40d      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    9856:	681f      	ldr	r7, [r3, #0]
    9858:	077f      	lsls	r7, r7, #29
    985a:	d40a      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    985c:	6819      	ldr	r1, [r3, #0]
    985e:	074e      	lsls	r6, r1, #29
    9860:	d407      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    9862:	6818      	ldr	r0, [r3, #0]
    9864:	0740      	lsls	r0, r0, #29
    9866:	d404      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    9868:	681e      	ldr	r6, [r3, #0]
    986a:	0771      	lsls	r1, r6, #29
    986c:	d401      	bmi.n	9872 <am_hal_cachectrl_enable+0x10e>
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);

    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    986e:	3a09      	subs	r2, #9
    9870:	d1dd      	bne.n	982e <am_hal_cachectrl_enable+0xca>

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
    9872:	7964      	ldrb	r4, [r4, #5]
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    9874:	4f04      	ldr	r7, [pc, #16]	; (9888 <am_hal_cachectrl_enable+0x124>)

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
    9876:	0223      	lsls	r3, r4, #8
    9878:	f403 7100 	and.w	r1, r3, #512	; 0x200
    987c:	f403 7280 	and.w	r2, r3, #256	; 0x100
    9880:	4311      	orrs	r1, r2
    9882:	4329      	orrs	r1, r5
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    9884:	6039      	str	r1, [r7, #0]
    9886:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9888:	40018000 	.word	0x40018000
    988c:	40018008 	.word	0x40018008

00009890 <am_hal_clkgen_sysclk_select>:
//! @return None.
//
//*****************************************************************************
void
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
    9890:	b510      	push	{r4, lr}
    am_hal_debug_assert_msg(ui32ClockSetting == AM_HAL_CLKGEN_SYSCLK_48MHZ,
    9892:	4604      	mov	r4, r0
    9894:	b120      	cbz	r0, 98a0 <am_hal_clkgen_sysclk_select+0x10>
    9896:	4a06      	ldr	r2, [pc, #24]	; (98b0 <am_hal_clkgen_sysclk_select+0x20>)
    9898:	4806      	ldr	r0, [pc, #24]	; (98b4 <am_hal_clkgen_sysclk_select+0x24>)
    989a:	2150      	movs	r1, #80	; 0x50
    989c:	f000 f92c 	bl	9af8 <am_hal_debug_error>
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    98a0:	4b05      	ldr	r3, [pc, #20]	; (98b8 <am_hal_clkgen_sysclk_select+0x28>)

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    98a2:	4906      	ldr	r1, [pc, #24]	; (98bc <am_hal_clkgen_sysclk_select+0x2c>)
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    98a4:	2047      	movs	r0, #71	; 0x47
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
    98a6:	2200      	movs	r2, #0
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    98a8:	6018      	str	r0, [r3, #0]

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    98aa:	600c      	str	r4, [r1, #0]

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
    98ac:	601a      	str	r2, [r3, #0]
    98ae:	bd10      	pop	{r4, pc}
    98b0:	0000a1bc 	.word	0x0000a1bc
    98b4:	0000a1f4 	.word	0x0000a1f4
    98b8:	40004014 	.word	0x40004014
    98bc:	40004018 	.word	0x40004018

000098c0 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
    98c0:	4b04      	ldr	r3, [pc, #16]	; (98d4 <am_hal_clkgen_sysclk_get+0x14>)

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
    98c2:	4905      	ldr	r1, [pc, #20]	; (98d8 <am_hal_clkgen_sysclk_get+0x18>)
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
    98c4:	681a      	ldr	r2, [r3, #0]

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
    98c6:	4805      	ldr	r0, [pc, #20]	; (98dc <am_hal_clkgen_sysclk_get+0x1c>)
    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;

    switch ( ui32ClockSetting )
    98c8:	f012 0f01 	tst.w	r2, #1
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC_DIV2:
            return 24000000;
        default:
            return 0xFFFFFFFF;
    }
}
    98cc:	bf08      	it	eq
    98ce:	4608      	moveq	r0, r1
    98d0:	4770      	bx	lr
    98d2:	bf00      	nop
    98d4:	40004018 	.word	0x40004018
    98d8:	02dc6c00 	.word	0x02dc6c00
    98dc:	016e3600 	.word	0x016e3600

000098e0 <am_hal_clkgen_osc_start>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_start(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    98e0:	0783      	lsls	r3, r0, #30
    98e2:	d004      	beq.n	98ee <am_hal_clkgen_osc_start+0xe>
    {
        //
        // Start the oscillator(s).
        // Note that these bits are cleared in order to enable the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) &= ~ui32OscFlags;
    98e4:	4a02      	ldr	r2, [pc, #8]	; (98f0 <am_hal_clkgen_osc_start+0x10>)
    98e6:	6813      	ldr	r3, [r2, #0]
    98e8:	ea23 0000 	bic.w	r0, r3, r0
    98ec:	6010      	str	r0, [r2, #0]
    98ee:	4770      	bx	lr
    98f0:	4000400c 	.word	0x4000400c

000098f4 <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    98f4:	0783      	lsls	r3, r0, #30
    98f6:	d003      	beq.n	9900 <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
    98f8:	4a02      	ldr	r2, [pc, #8]	; (9904 <am_hal_clkgen_osc_stop+0x10>)
    98fa:	6813      	ldr	r3, [r2, #0]
    98fc:	4318      	orrs	r0, r3
    98fe:	6010      	str	r0, [r2, #0]
    9900:	4770      	bx	lr
    9902:	bf00      	nop
    9904:	4000400c 	.word	0x4000400c

00009908 <am_hal_ctimer_config>:
//
//*****************************************************************************
void
am_hal_ctimer_config(uint32_t ui32TimerNumber,
                     am_hal_ctimer_config_t *psConfig)
{
    9908:	b410      	push	{r4}
                      (psConfig->ui32TimerBConfig << 16) );

    //
    // OR in the Link bit if the timers need to be linked.
    //
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    990a:	680c      	ldr	r4, [r1, #0]
    // Start preparing the configuration word for this timer. The configuration
    // values for Timer A and Timer B provided in the config structure should
    // match the register definitions already, so we will mostly just need to
    // OR them together.
    //
    ui32ConfigVal = ( (psConfig->ui32TimerAConfig)  |
    990c:	688b      	ldr	r3, [r1, #8]
    990e:	684a      	ldr	r2, [r1, #4]
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    9910:	f3ef 8110 	mrs	r1, PRIMASK
//
//*****************************************************************************
void
am_hal_ctimer_config(uint32_t ui32TimerNumber,
                     am_hal_ctimer_config_t *psConfig)
{
    9914:	b083      	sub	sp, #12
                      (psConfig->ui32TimerBConfig << 16) );

    //
    // OR in the Link bit if the timers need to be linked.
    //
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    9916:	2c00      	cmp	r4, #0
    9918:	bf18      	it	ne
    991a:	f04f 4400 	movne.w	r4, #2147483648	; 0x80000000
    // Start preparing the configuration word for this timer. The configuration
    // values for Timer A and Timer B provided in the config structure should
    // match the register definitions already, so we will mostly just need to
    // OR them together.
    //
    ui32ConfigVal = ( (psConfig->ui32TimerAConfig)  |
    991e:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
                      (psConfig->ui32TimerBConfig << 16) );

    //
    // OR in the Link bit if the timers need to be linked.
    //
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    9922:	4323      	orrs	r3, r4

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    9924:	9101      	str	r1, [sp, #4]
    9926:	b672      	cpsid	i

    //
    // Find the correct register to write.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    9928:	4c29      	ldr	r4, [pc, #164]	; (99d0 <am_hal_ctimer_config+0xc8>)
    uint32_t ui32TimerASrc, ui32CtimerNum;

    //
    // Check STimer to see if it is using HFRC.
    //
    ui32TimerASrc = AM_BFR(CTIMER, STCFG, CLKSEL);
    992a:	4a2a      	ldr	r2, [pc, #168]	; (99d4 <am_hal_ctimer_config+0xcc>)
    AM_CRITICAL_BEGIN_ASM

    //
    // Find the correct register to write.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    992c:	0100      	lsls	r0, r0, #4
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Write our configuration value.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    992e:	5103      	str	r3, [r0, r4]
    uint32_t ui32TimerASrc, ui32CtimerNum;

    //
    // Check STimer to see if it is using HFRC.
    //
    ui32TimerASrc = AM_BFR(CTIMER, STCFG, CLKSEL);
    9930:	6811      	ldr	r1, [r2, #0]
    if ( (ui32TimerASrc == AM_REG_CTIMER_STCFG_CLKSEL_HFRC_DIV16)   ||
    9932:	f001 0c0f 	and.w	ip, r1, #15
    9936:	f10c 33ff 	add.w	r3, ip, #4294967295
    993a:	2b01      	cmp	r3, #1
    993c:	d941      	bls.n	99c2 <am_hal_ctimer_config+0xba>
    //
    // Determine if this timer is using HFRC as the clock source.
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    993e:	6824      	ldr	r4, [r4, #0]
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9940:	f3c4 0244 	ubfx	r2, r4, #1, #5
    9944:	1e50      	subs	r0, r2, #1
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    9946:	f3c4 4144 	ubfx	r1, r4, #17, #5
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    994a:	2804      	cmp	r0, #4
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    994c:	f101 33ff 	add.w	r3, r1, #4294967295
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9950:	d937      	bls.n	99c2 <am_hal_ctimer_config+0xba>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    9952:	2b04      	cmp	r3, #4
    9954:	d935      	bls.n	99c2 <am_hal_ctimer_config+0xba>
    //
    // Determine if this timer is using HFRC as the clock source.
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    9956:	4c20      	ldr	r4, [pc, #128]	; (99d8 <am_hal_ctimer_config+0xd0>)
    9958:	6820      	ldr	r0, [r4, #0]
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    995a:	f3c0 0c44 	ubfx	ip, r0, #1, #5
    995e:	f10c 32ff 	add.w	r2, ip, #4294967295
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    9962:	f3c0 4144 	ubfx	r1, r0, #17, #5
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9966:	2a04      	cmp	r2, #4
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    9968:	f101 33ff 	add.w	r3, r1, #4294967295
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    996c:	d929      	bls.n	99c2 <am_hal_ctimer_config+0xba>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    996e:	2b04      	cmp	r3, #4
    9970:	d927      	bls.n	99c2 <am_hal_ctimer_config+0xba>
    //
    // Determine if this timer is using HFRC as the clock source.
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    9972:	4c1a      	ldr	r4, [pc, #104]	; (99dc <am_hal_ctimer_config+0xd4>)
    9974:	6820      	ldr	r0, [r4, #0]
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9976:	f3c0 0c44 	ubfx	ip, r0, #1, #5
    997a:	f10c 32ff 	add.w	r2, ip, #4294967295
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    997e:	f3c0 4144 	ubfx	r1, r0, #17, #5
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9982:	2a04      	cmp	r2, #4
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    9984:	f101 33ff 	add.w	r3, r1, #4294967295
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9988:	d91b      	bls.n	99c2 <am_hal_ctimer_config+0xba>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    998a:	2b04      	cmp	r3, #4
    998c:	d919      	bls.n	99c2 <am_hal_ctimer_config+0xba>
    //
    // Determine if this timer is using HFRC as the clock source.
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    998e:	4c14      	ldr	r4, [pc, #80]	; (99e0 <am_hal_ctimer_config+0xd8>)
    9990:	6820      	ldr	r0, [r4, #0]
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9992:	f3c0 0c44 	ubfx	ip, r0, #1, #5
    9996:	f10c 32ff 	add.w	r2, ip, #4294967295
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    999a:	f3c0 4144 	ubfx	r1, r0, #17, #5
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    999e:	2a04      	cmp	r2, #4
    // The value we are looking for is HFRC_DIV4 to HFRC_DIV4K.
    // Get the clock sources and 0-base the extracted value.
    //
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
                    AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4);
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    99a0:	f101 33ff 	add.w	r3, r1, #4294967295
                    AM_ENUMX(CTIMER, CTRL0, TMRB0CLK, HFRC_DIV4);

    //
    // If the source value is 0 to (HFRC_DIV4K - HFRC_DIV4), then it's HFRC.
    //
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    99a4:	d90d      	bls.n	99c2 <am_hal_ctimer_config+0xba>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    99a6:	2b04      	cmp	r3, #4
    99a8:	d90b      	bls.n	99c2 <am_hal_ctimer_config+0xba>
    {
        AM_BFW(PWRCTRL, MISCOPT, DIS_LDOLPMODE_TIMERS, 0);
    }
    else
    {
        AM_BFW(PWRCTRL, MISCOPT, DIS_LDOLPMODE_TIMERS, 1);
    99aa:	4c0e      	ldr	r4, [pc, #56]	; (99e4 <am_hal_ctimer_config+0xdc>)
    99ac:	6820      	ldr	r0, [r4, #0]
    99ae:	f040 0204 	orr.w	r2, r0, #4
    99b2:	6022      	str	r2, [r4, #0]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    99b4:	9801      	ldr	r0, [sp, #4]
    99b6:	f380 8810 	msr	PRIMASK, r0

} // am_hal_ctimer_config()
    99ba:	b003      	add	sp, #12
    99bc:	f85d 4b04 	ldr.w	r4, [sp], #4
    99c0:	4770      	bx	lr
    //
    // If all of the clock sources are not HRFC disable LDO when sleeping if timers are enabled.
    //
    if ( timers_use_hfrc() )
    {
        AM_BFW(PWRCTRL, MISCOPT, DIS_LDOLPMODE_TIMERS, 0);
    99c2:	4908      	ldr	r1, [pc, #32]	; (99e4 <am_hal_ctimer_config+0xdc>)
    99c4:	680b      	ldr	r3, [r1, #0]
    99c6:	f023 0404 	bic.w	r4, r3, #4
    99ca:	600c      	str	r4, [r1, #0]
    99cc:	e7f2      	b.n	99b4 <am_hal_ctimer_config+0xac>
    99ce:	bf00      	nop
    99d0:	4000800c 	.word	0x4000800c
    99d4:	40008100 	.word	0x40008100
    99d8:	4000801c 	.word	0x4000801c
    99dc:	4000802c 	.word	0x4000802c
    99e0:	4000803c 	.word	0x4000803c
    99e4:	40021020 	.word	0x40021020

000099e8 <am_hal_ctimer_start>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    99e8:	b410      	push	{r4}
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    99ea:	f3ef 8310 	mrs	r3, PRIMASK
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    99ee:	b083      	sub	sp, #12
    uint32_t ui32ConfigVal;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    99f0:	0100      	lsls	r0, r0, #4
    99f2:	4a09      	ldr	r2, [pc, #36]	; (9a18 <am_hal_ctimer_start+0x30>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    99f4:	9301      	str	r3, [sp, #4]
    99f6:	b672      	cpsid	i

    //
    // Read the current value.
    //
    ui32ConfigVal = *pui32ConfigReg;
    99f8:	5883      	ldr	r3, [r0, r2]

    //
    // Clear out the "clear" bit.
    //
    ui32ConfigVal &= ~(ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0CLR_M |
    99fa:	f001 2408 	and.w	r4, r1, #134219776	; 0x8000800
    99fe:	ea23 0304 	bic.w	r3, r3, r4
                                           AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Set the "enable bit"
    //
    ui32ConfigVal |= (ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0EN_M |
    9a02:	f001 1101 	and.w	r1, r1, #65537	; 0x10001
    9a06:	4319      	orrs	r1, r3
                                          AM_REG_CTIMER_CTRL0_TMRB0EN_M));

    //
    // Write the value back to the register.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    9a08:	5081      	str	r1, [r0, r2]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9a0a:	9801      	ldr	r0, [sp, #4]
    9a0c:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_start()
    9a10:	b003      	add	sp, #12
    9a12:	f85d 4b04 	ldr.w	r4, [sp], #4
    9a16:	4770      	bx	lr
    9a18:	4000800c 	.word	0x4000800c

00009a1c <am_hal_ctimer_clear>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_clear(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    9a1c:	b082      	sub	sp, #8
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9a1e:	f3ef 8310 	mrs	r3, PRIMASK
    volatile uint32_t *pui32ConfigReg;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    9a22:	0100      	lsls	r0, r0, #4
    9a24:	4a06      	ldr	r2, [pc, #24]	; (9a40 <am_hal_ctimer_clear+0x24>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9a26:	9301      	str	r3, [sp, #4]
    9a28:	b672      	cpsid	i

    //
    // Set the "clear" bit
    //
    AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
    9a2a:	5883      	ldr	r3, [r0, r2]
    9a2c:	f001 2108 	and.w	r1, r1, #134219776	; 0x8000800
    9a30:	4319      	orrs	r1, r3
    9a32:	5081      	str	r1, [r0, r2]
                                   AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9a34:	9801      	ldr	r0, [sp, #4]
    9a36:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_clear()
    9a3a:	b002      	add	sp, #8
    9a3c:	4770      	bx	lr
    9a3e:	bf00      	nop
    9a40:	4000800c 	.word	0x4000800c

00009a44 <am_hal_ctimer_period_set>:
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    9a44:	b4f0      	push	{r4, r5, r6, r7}
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9a46:	f3ef 8410 	mrs	r4, PRIMASK
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    9a4a:	b082      	sub	sp, #8
    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                   (ui32TimerNumber * TIMER_OFFSET));
    9a4c:	0100      	lsls	r0, r0, #4

    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    9a4e:	4d1c      	ldr	r5, [pc, #112]	; (9ac0 <am_hal_ctimer_period_set+0x7c>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9a50:	9401      	str	r4, [sp, #4]
                                   (ui32TimerNumber * TIMER_OFFSET));

    //
    // Find the correct compare registers to write.
    //
    pui32CompareRegA = (uint32_t *)(AM_REG_CTIMERn(0) +
    9a52:	4e1c      	ldr	r6, [pc, #112]	; (9ac4 <am_hal_ctimer_period_set+0x80>)
                                    AM_REG_CTIMER_CMPRA0_O +
                                    (ui32TimerNumber * TIMER_OFFSET));

    pui32CompareRegB = (uint32_t *)(AM_REG_CTIMERn(0) +
    9a54:	4f1c      	ldr	r7, [pc, #112]	; (9ac8 <am_hal_ctimer_period_set+0x84>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9a56:	b672      	cpsid	i
    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    9a58:	f511 3f80 	cmn.w	r1, #65536	; 0x10000

    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    9a5c:	5944      	ldr	r4, [r0, r5]
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    9a5e:	d01a      	beq.n	9a96 <am_hal_ctimer_period_set+0x52>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    9a60:	f404 75c0 	and.w	r5, r4, #384	; 0x180
    9a64:	2d80      	cmp	r5, #128	; 0x80
    9a66:	d01b      	beq.n	9aa0 <am_hal_ctimer_period_set+0x5c>

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    9a68:	f64f 73ff 	movw	r3, #65535	; 0xffff
    9a6c:	2500      	movs	r5, #0
    9a6e:	4299      	cmp	r1, r3
        ui32Comp1 = ui32Period;
    }
    else
    {
        ui32Comp0 = ui32Period;
        ui32Comp1 = 0;
    9a70:	462c      	mov	r4, r5

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    9a72:	d01c      	beq.n	9aae <am_hal_ctimer_period_set+0x6a>
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));
    }
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    9a74:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    9a78:	d01e      	beq.n	9ab8 <am_hal_ctimer_period_set+0x74>
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    9a7a:	0c21      	lsrs	r1, r4, #16
    9a7c:	040c      	lsls	r4, r1, #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9a7e:	b291      	uxth	r1, r2
    9a80:	430d      	orrs	r5, r1
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    9a82:	ea44 4212 	orr.w	r2, r4, r2, lsr #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9a86:	5185      	str	r5, [r0, r6]
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    9a88:	51c2      	str	r2, [r0, r7]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9a8a:	9801      	ldr	r0, [sp, #4]
    9a8c:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_period_set()
    9a90:	b002      	add	sp, #8
    9a92:	bcf0      	pop	{r4, r5, r6, r7}
    9a94:	4770      	bx	lr

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    9a96:	0c25      	lsrs	r5, r4, #16
    9a98:	f405 74c0 	and.w	r4, r5, #384	; 0x180
    9a9c:	2c80      	cmp	r4, #128	; 0x80
    9a9e:	d10a      	bne.n	9ab6 <am_hal_ctimer_period_set+0x72>
    9aa0:	0415      	lsls	r5, r2, #16
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
        ui32Comp1 = ui32Period;
    9aa2:	4614      	mov	r4, r2
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
    9aa4:	1ad2      	subs	r2, r2, r3

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    9aa6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    9aaa:	4299      	cmp	r1, r3
    9aac:	d1e2      	bne.n	9a74 <am_hal_ctimer_period_set+0x30>
    {
        //
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9aae:	b297      	uxth	r7, r2
    9ab0:	433d      	orrs	r5, r7
    9ab2:	5185      	str	r5, [r0, r6]
    9ab4:	e7e9      	b.n	9a8a <am_hal_ctimer_period_set+0x46>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    9ab6:	2500      	movs	r5, #0
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    {
        //
        // For timer B, write the values to the TIMERA compare register.
        //
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9ab8:	b296      	uxth	r6, r2
    9aba:	4335      	orrs	r5, r6
    9abc:	51c5      	str	r5, [r0, r7]
    9abe:	e7e4      	b.n	9a8a <am_hal_ctimer_period_set+0x46>
    9ac0:	4000800c 	.word	0x4000800c
    9ac4:	40008004 	.word	0x40008004
    9ac8:	40008008 	.word	0x40008008

00009acc <am_hal_ctimer_int_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_int_enable(uint32_t ui32Interrupt)
{
    9acc:	b082      	sub	sp, #8
    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9ace:	f3ef 8310 	mrs	r3, PRIMASK
    9ad2:	9301      	str	r3, [sp, #4]
    9ad4:	b672      	cpsid	i

    //
    // Enable the interrupt at the module level.
    //
    AM_REGn(CTIMER, 0, INTEN) |= ui32Interrupt;
    9ad6:	4904      	ldr	r1, [pc, #16]	; (9ae8 <am_hal_ctimer_int_enable+0x1c>)
    9ad8:	680a      	ldr	r2, [r1, #0]
    9ada:	4310      	orrs	r0, r2
    9adc:	6008      	str	r0, [r1, #0]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9ade:	9801      	ldr	r0, [sp, #4]
    9ae0:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_int_enable()
    9ae4:	b002      	add	sp, #8
    9ae6:	4770      	bx	lr
    9ae8:	40008200 	.word	0x40008200

00009aec <am_hal_ctimer_int_clear>:
am_hal_ctimer_int_clear(uint32_t ui32Interrupt)
{
    //
    // Disable the interrupt at the module level.
    //
    AM_REGn(CTIMER, 0, INTCLR) = ui32Interrupt;
    9aec:	4b01      	ldr	r3, [pc, #4]	; (9af4 <am_hal_ctimer_int_clear+0x8>)
    9aee:	6018      	str	r0, [r3, #0]
    9af0:	4770      	bx	lr
    9af2:	bf00      	nop
    9af4:	40008208 	.word	0x40008208

00009af8 <am_hal_debug_error>:
__weak void
#else
void __attribute__((weak))
#endif
am_hal_debug_error(const char *pcFile, uint32_t ui32Line, const char *pcMessage)
{
    9af8:	e7fe      	b.n	9af8 <am_hal_debug_error>
    9afa:	bf00      	nop

00009afc <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    9afc:	4b01      	ldr	r3, [pc, #4]	; (9b04 <am_hal_flash_delay+0x8>)
    9afe:	6b59      	ldr	r1, [r3, #52]	; 0x34
    9b00:	4708      	bx	r1
    9b02:	bf00      	nop
    9b04:	10001034 	.word	0x10001034

00009b08 <am_hal_interrupt_enable>:
am_hal_interrupt_enable(uint32_t ui32Interrupt)
{
    //
    // Check to see what type of interrupt this is.
    //
    if ( ui32Interrupt > 15 )
    9b08:	280f      	cmp	r0, #15
    9b0a:	d80b      	bhi.n	9b24 <am_hal_interrupt_enable+0x1c>
    {
        //
        // If this is an ARM internal interrupt number, route it to the
        // appropriate enable register.
        //
        switch(ui32Interrupt)
    9b0c:	2805      	cmp	r0, #5
    9b0e:	d013      	beq.n	9b38 <am_hal_interrupt_enable+0x30>
    9b10:	2806      	cmp	r0, #6
    9b12:	d017      	beq.n	9b44 <am_hal_interrupt_enable+0x3c>
    9b14:	2804      	cmp	r0, #4
    9b16:	d104      	bne.n	9b22 <am_hal_interrupt_enable+0x1a>
            case AM_HAL_INTERRUPT_USAGEFAULT:
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
            break;

            case AM_HAL_INTERRUPT_MPUFAULT:
                AM_BFW(SYSCTRL, SHCSR, MEMFAULTENA, 1);
    9b18:	4a0d      	ldr	r2, [pc, #52]	; (9b50 <am_hal_interrupt_enable+0x48>)
    9b1a:	6813      	ldr	r3, [r2, #0]
    9b1c:	f443 3080 	orr.w	r0, r3, #65536	; 0x10000
    9b20:	6010      	str	r0, [r2, #0]
    9b22:	4770      	bx	lr
    {
        //
        // If this ISR number corresponds to a "normal" peripheral interrupt,
        // enable it using the NVIC register.
        //
        AM_REG(NVIC, ISER0) = 0x1 << ((ui32Interrupt - 16) & 0x1F);
    9b24:	f1a0 0310 	sub.w	r3, r0, #16
    9b28:	f003 0c1f 	and.w	ip, r3, #31
    9b2c:	2001      	movs	r0, #1
    9b2e:	4909      	ldr	r1, [pc, #36]	; (9b54 <am_hal_interrupt_enable+0x4c>)
    9b30:	fa00 f20c 	lsl.w	r2, r0, ip
    9b34:	600a      	str	r2, [r1, #0]
    9b36:	4770      	bx	lr
        // appropriate enable register.
        //
        switch(ui32Interrupt)
        {
            case AM_HAL_INTERRUPT_BUSFAULT:
                AM_BFW(SYSCTRL, SHCSR, BUSFAULTENA, 1);
    9b38:	4805      	ldr	r0, [pc, #20]	; (9b50 <am_hal_interrupt_enable+0x48>)
    9b3a:	6801      	ldr	r1, [r0, #0]
    9b3c:	f441 3200 	orr.w	r2, r1, #131072	; 0x20000
    9b40:	6002      	str	r2, [r0, #0]
            break;
    9b42:	4770      	bx	lr

            case AM_HAL_INTERRUPT_USAGEFAULT:
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
    9b44:	4902      	ldr	r1, [pc, #8]	; (9b50 <am_hal_interrupt_enable+0x48>)
    9b46:	680a      	ldr	r2, [r1, #0]
    9b48:	f442 2380 	orr.w	r3, r2, #262144	; 0x40000
    9b4c:	600b      	str	r3, [r1, #0]
            break;
    9b4e:	4770      	bx	lr
    9b50:	e000ed24 	.word	0xe000ed24
    9b54:	e000e100 	.word	0xe000e100

00009b58 <am_hal_interrupt_master_enable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_enable(void)
{
    __asm("    mrs     r0, PRIMASK");
    9b58:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsie i");
    9b5c:	b662      	cpsie	i
    __asm("    bx lr");
    9b5e:	4770      	bx	lr

00009b60 <am_hal_interrupt_master_disable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
    9b60:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
    9b64:	b672      	cpsid	i
    __asm("    bx lr");
    9b66:	4770      	bx	lr

00009b68 <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
    9b68:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
    9b6c:	4770      	bx	lr
    9b6e:	bf00      	nop

00009b70 <am_hal_itm_enable>:
//
//*****************************************************************************
void
am_hal_itm_enable(void)
{
    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    9b70:	4b0d      	ldr	r3, [pc, #52]	; (9ba8 <am_hal_itm_enable+0x38>)
    9b72:	6818      	ldr	r0, [r3, #0]
    9b74:	07c2      	lsls	r2, r0, #31
    9b76:	d416      	bmi.n	9ba6 <am_hal_itm_enable+0x36>

    //
    // To be able to access ITM registers, set the Trace Enable bit
    // in the Debug Exception and Monitor Control Register (DEMCR).
    //
    AM_REG(SYSCTRL, DEMCR) |= AM_REG_SYSCTRL_DEMCR_TRCENA(1);
    9b78:	4a0c      	ldr	r2, [pc, #48]	; (9bac <am_hal_itm_enable+0x3c>)
    9b7a:	6811      	ldr	r1, [r2, #0]
    9b7c:	f041 7380 	orr.w	r3, r1, #16777216	; 0x1000000
    9b80:	6013      	str	r3, [r2, #0]
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );
    9b82:	6810      	ldr	r0, [r2, #0]
    9b84:	01c3      	lsls	r3, r0, #7
    9b86:	d5fc      	bpl.n	9b82 <am_hal_itm_enable+0x12>
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_enable(void)
{
    9b88:	b430      	push	{r4, r5}
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );

    //
    // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
    //
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    9b8a:	4809      	ldr	r0, [pc, #36]	; (9bb0 <am_hal_itm_enable+0x40>)

    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    9b8c:	4c09      	ldr	r4, [pc, #36]	; (9bb4 <am_hal_itm_enable+0x44>)
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );

    //
    // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
    //
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    9b8e:	4d0a      	ldr	r5, [pc, #40]	; (9bb8 <am_hal_itm_enable+0x48>)
    9b90:	6005      	str	r5, [r0, #0]

    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    9b92:	250f      	movs	r5, #15
    9b94:	6025      	str	r5, [r4, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_DWT_ENABLE, 0)     |
        AM_WRITE_SM(AM_REG_ITM_TCR_SYNC_ENABLE, 0)    |
        AM_WRITE_SM(AM_REG_ITM_TCR_TS_ENABLE, 0)      |
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

}
    9b96:	bc30      	pop	{r4, r5}
    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    9b98:	4908      	ldr	r1, [pc, #32]	; (9bbc <am_hal_itm_enable+0x4c>)

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    9b9a:	4b09      	ldr	r3, [pc, #36]	; (9bc0 <am_hal_itm_enable+0x50>)
    9b9c:	4a09      	ldr	r2, [pc, #36]	; (9bc4 <am_hal_itm_enable+0x54>)
    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    9b9e:	f04f 30ff 	mov.w	r0, #4294967295
    9ba2:	6008      	str	r0, [r1, #0]

    //
    // Write to the ITM control and status register.
    //
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    9ba4:	601a      	str	r2, [r3, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_DWT_ENABLE, 0)     |
        AM_WRITE_SM(AM_REG_ITM_TCR_SYNC_ENABLE, 0)    |
        AM_WRITE_SM(AM_REG_ITM_TCR_TS_ENABLE, 0)      |
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

}
    9ba6:	4770      	bx	lr
    9ba8:	1000118c 	.word	0x1000118c
    9bac:	e000edfc 	.word	0xe000edfc
    9bb0:	e0000fb0 	.word	0xe0000fb0
    9bb4:	e0000e40 	.word	0xe0000e40
    9bb8:	c5acce55 	.word	0xc5acce55
    9bbc:	e0000e00 	.word	0xe0000e00
    9bc0:	e0000e80 	.word	0xe0000e80
    9bc4:	00150511 	.word	0x00150511

00009bc8 <am_hal_itm_not_busy>:
am_hal_itm_not_busy(void)
{
    //
    // Make sure the ITM/TPIU is not busy.
    //
    while (AM_REG(ITM, TCR) & AM_REG_ITM_TCR_BUSY(1));
    9bc8:	4a03      	ldr	r2, [pc, #12]	; (9bd8 <am_hal_itm_not_busy+0x10>)
    9bca:	6813      	ldr	r3, [r2, #0]
    9bcc:	021b      	lsls	r3, r3, #8
    9bce:	d4fc      	bmi.n	9bca <am_hal_itm_not_busy+0x2>

    //
    // wait for 50us for the data to flush out
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    9bd0:	f44f 7047 	mov.w	r0, #796	; 0x31c
    9bd4:	f7ff bf92 	b.w	9afc <am_hal_flash_delay>
    9bd8:	e0000e80 	.word	0xe0000e80

00009bdc <am_hal_itm_print>:
    uint32_t ui32Length = 0;

    //
    // Determine the length of the string.
    //
    while (*(pcString + ui32Length))
    9bdc:	7803      	ldrb	r3, [r0, #0]
    9bde:	b1ab      	cbz	r3, 9c0c <am_hal_itm_print+0x30>
    9be0:	4602      	mov	r2, r0
    9be2:	2300      	movs	r3, #0
    9be4:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    {
        ui32Length++;
    9be8:	3301      	adds	r3, #1
    uint32_t ui32Length = 0;

    //
    // Determine the length of the string.
    //
    while (*(pcString + ui32Length))
    9bea:	2900      	cmp	r1, #0
    9bec:	d1fa      	bne.n	9be4 <am_hal_itm_print+0x8>
    ui32StimAddr = (AM_REG_ITM_STIM0_O + (4 * ui32StimReg));

    //
    // Busy waiting until it is available (non-zero means ready)
    //
    while (!AM_REGVAL(ui32StimAddr));
    9bee:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_print(char *pcString)
{
    9bf2:	b430      	push	{r4, r5}
    9bf4:	18c2      	adds	r2, r0, r3
    ui32StimAddr = (AM_REG_ITM_STIM0_O + (4 * ui32StimReg));

    //
    // Busy waiting until it is available (non-zero means ready)
    //
    while (!AM_REGVAL(ui32StimAddr));
    9bf6:	4665      	mov	r5, ip
    while (ui32Length)
    {
            //
            // Print string out the ITM.
            //
            am_hal_itm_stimulus_reg_byte_write(0, (uint8_t)*pcString++);
    9bf8:	f810 4b01 	ldrb.w	r4, [r0], #1
    ui32StimAddr = (AM_REG_ITM_STIM0_O + (4 * ui32StimReg));

    //
    // Busy waiting until it is available (non-zero means ready)
    //
    while (!AM_REGVAL(ui32StimAddr));
    9bfc:	f8dc 3000 	ldr.w	r3, [ip]
    9c00:	2b00      	cmp	r3, #0
    9c02:	d0fb      	beq.n	9bfc <am_hal_itm_print+0x20>
    }

    //
    // If there is no longer a word left, empty out the remaining characters.
    //
    while (ui32Length)
    9c04:	4290      	cmp	r0, r2
    while (!AM_REGVAL(ui32StimAddr));

    //
    // Write the register.
    //
    *((volatile uint8_t *) ui32StimAddr) = ui8Value;
    9c06:	702c      	strb	r4, [r5, #0]
    }

    //
    // If there is no longer a word left, empty out the remaining characters.
    //
    while (ui32Length)
    9c08:	d1f6      	bne.n	9bf8 <am_hal_itm_print+0x1c>
            //
            // Subtract from length.
            //
            ui32Length--;
    }
}
    9c0a:	bc30      	pop	{r4, r5}
    9c0c:	4770      	bx	lr
    9c0e:	bf00      	nop

00009c10 <am_hal_mcuctrl_fault_status>:
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);

    //
    // Read the DCODE fault capture address register.
    //
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    9c10:	4a0d      	ldr	r2, [pc, #52]	; (9c48 <am_hal_mcuctrl_fault_status+0x38>)
    uint32_t ui32FaultStat;

    //
    // Read the Fault Status Register.
    //
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    9c12:	4b0e      	ldr	r3, [pc, #56]	; (9c4c <am_hal_mcuctrl_fault_status+0x3c>)
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9c14:	490e      	ldr	r1, [pc, #56]	; (9c50 <am_hal_mcuctrl_fault_status+0x40>)
    uint32_t ui32FaultStat;

    //
    // Read the Fault Status Register.
    //
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    9c16:	681b      	ldr	r3, [r3, #0]
//! @return None
//
//*****************************************************************************
void
am_hal_mcuctrl_fault_status(am_hal_mcuctrl_fault_t *psFault)
{
    9c18:	b470      	push	{r4, r5, r6}
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);

    //
    // Read the DCODE fault capture address register.
    //
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    9c1a:	6814      	ldr	r4, [r2, #0]
    9c1c:	60c4      	str	r4, [r0, #12]

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9c1e:	6809      	ldr	r1, [r1, #0]
    9c20:	6845      	ldr	r5, [r0, #4]

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9c22:	6944      	ldr	r4, [r0, #20]
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9c24:	4329      	orrs	r1, r5

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9c26:	3204      	adds	r2, #4
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9c28:	6041      	str	r1, [r0, #4]

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9c2a:	6812      	ldr	r2, [r2, #0]

    //
    // Read the Fault Status Register.
    //
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    9c2c:	f003 0601 	and.w	r6, r3, #1
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9c30:	4322      	orrs	r2, r4

    //
    // Read the Fault Status Register.
    //
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    9c32:	7006      	strb	r6, [r0, #0]
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    9c34:	f3c3 0640 	ubfx	r6, r3, #1, #1
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    9c38:	f3c3 0380 	ubfx	r3, r3, #2, #1
    //
    // Read the Fault Status Register.
    //
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    9c3c:	7206      	strb	r6, [r0, #8]
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    9c3e:	7403      	strb	r3, [r0, #16]
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9c40:	6142      	str	r2, [r0, #20]
}
    9c42:	bc70      	pop	{r4, r5, r6}
    9c44:	4770      	bx	lr
    9c46:	bf00      	nop
    9c48:	400201c4 	.word	0x400201c4
    9c4c:	400201cc 	.word	0x400201cc
    9c50:	400201c0 	.word	0x400201c0

00009c54 <am_hal_pwrctrl_memory_enable>:
{
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    9c54:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    9c58:	b430      	push	{r4, r5}
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    9c5a:	d03a      	beq.n	9cd2 <am_hal_pwrctrl_memory_enable+0x7e>
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    9c5c:	f5b0 5fc0 	cmp.w	r0, #6144	; 0x1800
    9c60:	f000 809d 	beq.w	9d9e <am_hal_pwrctrl_memory_enable+0x14a>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    9c64:	2801      	cmp	r0, #1
    9c66:	f000 809d 	beq.w	9da4 <am_hal_pwrctrl_memory_enable+0x150>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    9c6a:	2803      	cmp	r0, #3
    9c6c:	f000 80a6 	beq.w	9dbc <am_hal_pwrctrl_memory_enable+0x168>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM24K )
    9c70:	2807      	cmp	r0, #7
    9c72:	f000 809c 	beq.w	9dae <am_hal_pwrctrl_memory_enable+0x15a>
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    9c76:	280f      	cmp	r0, #15
    9c78:	f000 80a5 	beq.w	9dc6 <am_hal_pwrctrl_memory_enable+0x172>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    9c7c:	281f      	cmp	r0, #31
    9c7e:	f000 80b1 	beq.w	9de4 <am_hal_pwrctrl_memory_enable+0x190>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    9c82:	283f      	cmp	r0, #63	; 0x3f
    9c84:	f000 80b5 	beq.w	9df2 <am_hal_pwrctrl_memory_enable+0x19e>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    9c88:	287f      	cmp	r0, #127	; 0x7f
    9c8a:	f000 80b9 	beq.w	9e00 <am_hal_pwrctrl_memory_enable+0x1ac>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    9c8e:	28ff      	cmp	r0, #255	; 0xff
    9c90:	f000 80a0 	beq.w	9dd4 <am_hal_pwrctrl_memory_enable+0x180>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    9c94:	f240 13ff 	movw	r3, #511	; 0x1ff
    9c98:	4298      	cmp	r0, r3
    9c9a:	f000 80b8 	beq.w	9e0e <am_hal_pwrctrl_memory_enable+0x1ba>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    9c9e:	f240 31ff 	movw	r1, #1023	; 0x3ff
    9ca2:	4288      	cmp	r0, r1
    9ca4:	f000 80b9 	beq.w	9e1a <am_hal_pwrctrl_memory_enable+0x1c6>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM256K )
    9ca8:	f240 72ff 	movw	r2, #2047	; 0x7ff
    9cac:	4290      	cmp	r0, r2
    9cae:	d00e      	beq.n	9cce <am_hal_pwrctrl_memory_enable+0x7a>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM256K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    9cb0:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
    9cb4:	f000 80b7 	beq.w	9e26 <am_hal_pwrctrl_memory_enable+0x1d2>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    9cb8:	f06f 4420 	mvn.w	r4, #2684354560	; 0xa0000000
    9cbc:	42a0      	cmp	r0, r4
    9cbe:	f000 80b5 	beq.w	9e2c <am_hal_pwrctrl_memory_enable+0x1d8>
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_ALL )
    9cc2:	f104 4580 	add.w	r5, r4, #1073741824	; 0x40000000
    9cc6:	f505 5c00 	add.w	ip, r5, #8192	; 0x2000
    9cca:	4560      	cmp	r0, ip
    9ccc:	d132      	bne.n	9d34 <am_hal_pwrctrl_memory_enable+0xe0>
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_ALL;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
    9cce:	495c      	ldr	r1, [pc, #368]	; (9e40 <am_hal_pwrctrl_memory_enable+0x1ec>)
    9cd0:	e066      	b.n	9da0 <am_hal_pwrctrl_memory_enable+0x14c>
    9cd2:	f46f 5580 	mvn.w	r5, #4096	; 0x1000
    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    9cd6:	2340      	movs	r3, #64	; 0x40

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
    9cd8:	2120      	movs	r1, #32
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    9cda:	4c5a      	ldr	r4, [pc, #360]	; (9e44 <am_hal_pwrctrl_memory_enable+0x1f0>)
    9cdc:	6822      	ldr	r2, [r4, #0]
    9cde:	402a      	ands	r2, r5
    9ce0:	6022      	str	r2, [r4, #0]
    //
    // Enable the required memory.
    //
    if ( ui32MemEnMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) |= ui32MemEnMask;
    9ce2:	4d58      	ldr	r5, [pc, #352]	; (9e44 <am_hal_pwrctrl_memory_enable+0x1f0>)
    9ce4:	682c      	ldr	r4, [r5, #0]
    9ce6:	4320      	orrs	r0, r4
    9ce8:	6028      	str	r0, [r5, #0]
    //
    // Wait for the power to be turned on.
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    9cea:	2b00      	cmp	r3, #0
    9cec:	d029      	beq.n	9d42 <am_hal_pwrctrl_memory_enable+0xee>
    {
        while ( --i32TOcnt              &&
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9cee:	4a56      	ldr	r2, [pc, #344]	; (9e48 <am_hal_pwrctrl_memory_enable+0x1f4>)
    9cf0:	6810      	ldr	r0, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9cf2:	4203      	tst	r3, r0
    9cf4:	bf18      	it	ne
    9cf6:	20c6      	movne	r0, #198	; 0xc6
    9cf8:	d01f      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9cfa:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9cfc:	422b      	tst	r3, r5
    9cfe:	d01c      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d00:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d02:	4223      	tst	r3, r4
    9d04:	d019      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d06:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d08:	422b      	tst	r3, r5
    9d0a:	d016      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d0c:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d0e:	4223      	tst	r3, r4
    9d10:	d013      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d12:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d14:	422b      	tst	r3, r5
    9d16:	d010      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d18:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d1a:	4223      	tst	r3, r4
    9d1c:	d00d      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d1e:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d20:	422b      	tst	r3, r5
    9d22:	d00a      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d24:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d26:	4223      	tst	r3, r4
    9d28:	d007      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d2a:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    9d2c:	422b      	tst	r3, r5
    9d2e:	d004      	beq.n	9d3a <am_hal_pwrctrl_memory_enable+0xe6>
    9d30:	3809      	subs	r0, #9
    9d32:	d1e2      	bne.n	9cfa <am_hal_pwrctrl_memory_enable+0xa6>
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
        ui32PwrStatDisMask = 0;
    }
    else
    {
        return false;
    9d34:	2000      	movs	r0, #0
    {
        return false;
    }

    return true;
}
    9d36:	bc30      	pop	{r4, r5}
    9d38:	4770      	bx	lr
    {
        return false;
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    9d3a:	b911      	cbnz	r1, 9d42 <am_hal_pwrctrl_memory_enable+0xee>
    if ( i32TOcnt <= 0 )
    {
        return false;
    }

    return true;
    9d3c:	2001      	movs	r0, #1
}
    9d3e:	bc30      	pop	{r4, r5}
    9d40:	4770      	bx	lr

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d42:	4b41      	ldr	r3, [pc, #260]	; (9e48 <am_hal_pwrctrl_memory_enable+0x1f4>)
    9d44:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d46:	ea31 0402 	bics.w	r4, r1, r2
    9d4a:	bf18      	it	ne
    9d4c:	24c6      	movne	r4, #198	; 0xc6
    9d4e:	d0f5      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d50:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d52:	ea31 0000 	bics.w	r0, r1, r0
    9d56:	d0f1      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d58:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d5a:	ea31 0005 	bics.w	r0, r1, r5
    9d5e:	d0ed      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d60:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d62:	ea31 0002 	bics.w	r0, r1, r2
    9d66:	d0e9      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d68:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d6a:	ea31 0000 	bics.w	r0, r1, r0
    9d6e:	d0e5      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d70:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d72:	ea31 0005 	bics.w	r0, r1, r5
    9d76:	d0e1      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d78:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d7a:	ea31 0002 	bics.w	r0, r1, r2
    9d7e:	d0dd      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d80:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d82:	ea31 0000 	bics.w	r0, r1, r0
    9d86:	d0d9      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d88:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d8a:	ea31 0005 	bics.w	r0, r1, r5
    9d8e:	d0d5      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9d90:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    9d92:	ea31 0002 	bics.w	r0, r1, r2
    9d96:	d0d1      	beq.n	9d3c <am_hal_pwrctrl_memory_enable+0xe8>
    9d98:	3c09      	subs	r4, #9
    9d9a:	d1d9      	bne.n	9d50 <am_hal_pwrctrl_memory_enable+0xfc>
    9d9c:	e7ca      	b.n	9d34 <am_hal_pwrctrl_memory_enable+0xe0>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN |
                         AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
    9d9e:	2160      	movs	r1, #96	; 0x60
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    9da0:	2300      	movs	r3, #0
    9da2:	e79e      	b.n	9ce2 <am_hal_pwrctrl_memory_enable+0x8e>
    9da4:	4d29      	ldr	r5, [pc, #164]	; (9e4c <am_hal_pwrctrl_memory_enable+0x1f8>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9da6:	4b2a      	ldr	r3, [pc, #168]	; (9e50 <am_hal_pwrctrl_memory_enable+0x1fc>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    9da8:	f44f 7180 	mov.w	r1, #256	; 0x100
    9dac:	e795      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9dae:	f46f 65ff 	mvn.w	r5, #2040	; 0x7f8
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9db2:	f44f 23ff 	mov.w	r3, #522240	; 0x7f800
                         AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    9db6:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    9dba:	e78e      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9dbc:	4d25      	ldr	r5, [pc, #148]	; (9e54 <am_hal_pwrctrl_memory_enable+0x200>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9dbe:	4b26      	ldr	r3, [pc, #152]	; (9e58 <am_hal_pwrctrl_memory_enable+0x204>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    9dc0:	f44f 7140 	mov.w	r1, #768	; 0x300
    9dc4:	e789      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9dc6:	f46f 65fe 	mvn.w	r5, #2032	; 0x7f0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9dca:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    9dce:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    9dd2:	e782      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9dd4:	f46f 65e0 	mvn.w	r5, #1792	; 0x700
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9dd8:	f44f 23e0 	mov.w	r3, #458752	; 0x70000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    9ddc:	f44f 417f 	mov.w	r1, #65280	; 0xff00
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
    9de0:	20ff      	movs	r0, #255	; 0xff
    9de2:	e77a      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9de4:	f46f 65fc 	mvn.w	r5, #2016	; 0x7e0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9de8:	f44f 23fc 	mov.w	r3, #516096	; 0x7e000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    9dec:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
    9df0:	e773      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9df2:	f46f 65f8 	mvn.w	r5, #1984	; 0x7c0
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9df6:	f44f 23f8 	mov.w	r3, #507904	; 0x7c000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    9dfa:	f44f 517c 	mov.w	r1, #16128	; 0x3f00
    9dfe:	e76c      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9e00:	f46f 65f0 	mvn.w	r5, #1920	; 0x780
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e04:	f44f 23f0 	mov.w	r3, #491520	; 0x78000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    9e08:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
    9e0c:	e765      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    9e0e:	f46f 65c0 	mvn.w	r5, #1536	; 0x600
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e12:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    9e16:	4911      	ldr	r1, [pc, #68]	; (9e5c <am_hal_pwrctrl_memory_enable+0x208>)
    9e18:	e75f      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    9e1a:	4911      	ldr	r1, [pc, #68]	; (9e60 <am_hal_pwrctrl_memory_enable+0x20c>)
    9e1c:	f46f 6580 	mvn.w	r5, #1024	; 0x400
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e20:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    9e24:	e759      	b.n	9cda <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN    |
                         AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    9e26:	f44f 1120 	mov.w	r1, #2621440	; 0x280000
    9e2a:	e7b9      	b.n	9da0 <am_hal_pwrctrl_memory_enable+0x14c>
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    9e2c:	4805      	ldr	r0, [pc, #20]	; (9e44 <am_hal_pwrctrl_memory_enable+0x1f0>)
    9e2e:	6803      	ldr	r3, [r0, #0]
    9e30:	f023 4120 	bic.w	r1, r3, #2684354560	; 0xa0000000
    9e34:	6001      	str	r1, [r0, #0]
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    9e36:	f44f 1320 	mov.w	r3, #2621440	; 0x280000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
    9e3a:	2100      	movs	r1, #0
    9e3c:	e757      	b.n	9cee <am_hal_pwrctrl_memory_enable+0x9a>
    9e3e:	bf00      	nop
    9e40:	0007ff00 	.word	0x0007ff00
    9e44:	40021010 	.word	0x40021010
    9e48:	40021014 	.word	0x40021014
    9e4c:	fffff801 	.word	0xfffff801
    9e50:	0007fe00 	.word	0x0007fe00
    9e54:	fffff803 	.word	0xfffff803
    9e58:	0007fc00 	.word	0x0007fc00
    9e5c:	0001ff00 	.word	0x0001ff00
    9e60:	0003ff00 	.word	0x0003ff00

00009e64 <am_hal_pwrctrl_bucks_init>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9e64:	4b0f      	ldr	r3, [pc, #60]	; (9ea4 <am_hal_pwrctrl_bucks_init+0x40>)
    9e66:	681a      	ldr	r2, [r3, #0]
    9e68:	0792      	lsls	r2, r2, #30
    9e6a:	d502      	bpl.n	9e72 <am_hal_pwrctrl_bucks_init+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    9e6c:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9e6e:	07c3      	lsls	r3, r0, #31
    9e70:	d40e      	bmi.n	9e90 <am_hal_pwrctrl_bucks_init+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9e72:	4b0d      	ldr	r3, [pc, #52]	; (9ea8 <am_hal_pwrctrl_bucks_init+0x44>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9e74:	4a0b      	ldr	r2, [pc, #44]	; (9ea4 <am_hal_pwrctrl_bucks_init+0x40>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9e76:	6819      	ldr	r1, [r3, #0]
    9e78:	f041 0002 	orr.w	r0, r1, #2
    9e7c:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    9e7e:	6819      	ldr	r1, [r3, #0]
    9e80:	f041 0001 	orr.w	r0, r1, #1
    9e84:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9e86:	6813      	ldr	r3, [r2, #0]
    9e88:	f003 0103 	and.w	r1, r3, #3
    9e8c:	2903      	cmp	r1, #3
    9e8e:	d1fa      	bne.n	9e86 <am_hal_pwrctrl_bucks_init+0x22>
void
am_hal_pwrctrl_bucks_init(void)
{
    am_hal_pwrctrl_bucks_enable();

    while ( ( AM_REG(PWRCTRL, POWERSTATUS) &
    9e90:	4a04      	ldr	r2, [pc, #16]	; (9ea4 <am_hal_pwrctrl_bucks_init+0x40>)
    9e92:	6810      	ldr	r0, [r2, #0]
    9e94:	f000 0303 	and.w	r3, r0, #3
    9e98:	2b03      	cmp	r3, #3
    9e9a:	d1fa      	bne.n	9e92 <am_hal_pwrctrl_bucks_init+0x2e>
                AM_REG_PWRCTRL_POWERSTATUS_MEMBUCKON_M ) );

    //
    // Additional delay to make sure BUCKs are initialized.
    //
    am_hal_flash_delay(200 / 3);
    9e9c:	2042      	movs	r0, #66	; 0x42
    9e9e:	f7ff be2d 	b.w	9afc <am_hal_flash_delay>
    9ea2:	bf00      	nop
    9ea4:	40021004 	.word	0x40021004
    9ea8:	40021000 	.word	0x40021000

00009eac <am_hal_pwrctrl_bucks_enable>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9eac:	4b0b      	ldr	r3, [pc, #44]	; (9edc <am_hal_pwrctrl_bucks_enable+0x30>)
    9eae:	681a      	ldr	r2, [r3, #0]
    9eb0:	0792      	lsls	r2, r2, #30
    9eb2:	d502      	bpl.n	9eba <am_hal_pwrctrl_bucks_enable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    9eb4:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9eb6:	07c3      	lsls	r3, r0, #31
    9eb8:	d40e      	bmi.n	9ed8 <am_hal_pwrctrl_bucks_enable+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9eba:	4b09      	ldr	r3, [pc, #36]	; (9ee0 <am_hal_pwrctrl_bucks_enable+0x34>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9ebc:	4a07      	ldr	r2, [pc, #28]	; (9edc <am_hal_pwrctrl_bucks_enable+0x30>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9ebe:	6819      	ldr	r1, [r3, #0]
    9ec0:	f041 0002 	orr.w	r0, r1, #2
    9ec4:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    9ec6:	6819      	ldr	r1, [r3, #0]
    9ec8:	f041 0001 	orr.w	r0, r1, #1
    9ecc:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9ece:	6813      	ldr	r3, [r2, #0]
    9ed0:	f003 0103 	and.w	r1, r3, #3
    9ed4:	2903      	cmp	r1, #3
    9ed6:	d1fa      	bne.n	9ece <am_hal_pwrctrl_bucks_enable+0x22>
    9ed8:	4770      	bx	lr
    9eda:	bf00      	nop
    9edc:	40021004 	.word	0x40021004
    9ee0:	40021000 	.word	0x40021000

00009ee4 <am_hal_pwrctrl_bucks_disable>:
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    9ee4:	4b12      	ldr	r3, [pc, #72]	; (9f30 <am_hal_pwrctrl_bucks_disable+0x4c>)
    9ee6:	681a      	ldr	r2, [r3, #0]
    9ee8:	0792      	lsls	r2, r2, #30
    9eea:	d402      	bmi.n	9ef2 <am_hal_pwrctrl_bucks_disable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) == 0)
    9eec:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    9eee:	07c3      	lsls	r3, r0, #31
    9ef0:	d51c      	bpl.n	9f2c <am_hal_pwrctrl_bucks_disable+0x48>
//
//*****************************************************************************
static bool
isRev_ADC(void)
{
    return AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    9ef2:	4910      	ldr	r1, [pc, #64]	; (9f34 <am_hal_pwrctrl_bucks_disable+0x50>)
    9ef4:	680b      	ldr	r3, [r1, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    9ef6:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    9efa:	2a20      	cmp	r2, #32
    9efc:	d00b      	beq.n	9f16 <am_hal_pwrctrl_bucks_disable+0x32>
    else
    {
        //
        // Power them down
        //
        AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 0);
    9efe:	4b0e      	ldr	r3, [pc, #56]	; (9f38 <am_hal_pwrctrl_bucks_disable+0x54>)
    9f00:	681a      	ldr	r2, [r3, #0]
    9f02:	f022 0002 	bic.w	r0, r2, #2
    9f06:	6018      	str	r0, [r3, #0]
        AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 0);
    9f08:	6819      	ldr	r1, [r3, #0]
    9f0a:	f021 0201 	bic.w	r2, r1, #1
    9f0e:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait until BUCKs are disabled.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_BUCKDIS_DELAYCYCLES / 3);
    9f10:	200a      	movs	r0, #10
    9f12:	f7ff bdf3 	b.w	9afc <am_hal_flash_delay>

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    9f16:	4809      	ldr	r0, [pc, #36]	; (9f3c <am_hal_pwrctrl_bucks_disable+0x58>)
    9f18:	6801      	ldr	r1, [r0, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    9f1a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    9f1e:	d1ee      	bne.n	9efe <am_hal_pwrctrl_bucks_disable+0x1a>
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    {
            //
            // Set SUPPLYSRC to handle this case
            //
            AM_REG(PWRCTRL, SUPPLYSRC) &=
    9f20:	4805      	ldr	r0, [pc, #20]	; (9f38 <am_hal_pwrctrl_bucks_disable+0x54>)
    9f22:	6803      	ldr	r3, [r0, #0]
    9f24:	f003 0105 	and.w	r1, r3, #5
    9f28:	6001      	str	r1, [r0, #0]
    9f2a:	e7f1      	b.n	9f10 <am_hal_pwrctrl_bucks_disable+0x2c>
    9f2c:	4770      	bx	lr
    9f2e:	bf00      	nop
    9f30:	40021004 	.word	0x40021004
    9f34:	4002000c 	.word	0x4002000c
    9f38:	40021000 	.word	0x40021000
    9f3c:	40021008 	.word	0x40021008

00009f40 <am_hal_pwrctrl_low_power_init>:
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    9f40:	4905      	ldr	r1, [pc, #20]	; (9f58 <am_hal_pwrctrl_low_power_init+0x18>)
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    9f42:	4a06      	ldr	r2, [pc, #24]	; (9f5c <am_hal_pwrctrl_low_power_init+0x1c>)
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    9f44:	680b      	ldr	r3, [r1, #0]
    9f46:	f043 0006 	orr.w	r0, r3, #6
    9f4a:	6008      	str	r0, [r1, #0]
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    9f4c:	6811      	ldr	r1, [r2, #0]
    9f4e:	f021 0304 	bic.w	r3, r1, #4
    9f52:	6013      	str	r3, [r2, #0]
    9f54:	4770      	bx	lr
    9f56:	bf00      	nop
    9f58:	40021018 	.word	0x40021018
    9f5c:	40021000 	.word	0x40021000

00009f60 <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    9f60:	4a05      	ldr	r2, [pc, #20]	; (9f78 <am_hal_rtc_osc_select+0x18>)
    9f62:	6813      	ldr	r3, [r2, #0]
{
    //
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    9f64:	b918      	cbnz	r0, 9f6e <am_hal_rtc_osc_select+0xe>
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    9f66:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    9f6a:	6010      	str	r0, [r2, #0]
    9f6c:	4770      	bx	lr
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    9f6e:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    9f72:	6011      	str	r1, [r2, #0]
    9f74:	4770      	bx	lr
    9f76:	bf00      	nop
    9f78:	4000400c 	.word	0x4000400c

00009f7c <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_REG(RTC, RTCCTL) |= AM_REG_RTC_RTCCTL_RSTOP(1);
    9f7c:	4a02      	ldr	r2, [pc, #8]	; (9f88 <am_hal_rtc_osc_disable+0xc>)
    9f7e:	6813      	ldr	r3, [r2, #0]
    9f80:	f043 0010 	orr.w	r0, r3, #16
    9f84:	6010      	str	r0, [r2, #0]
    9f86:	4770      	bx	lr
    9f88:	40004050 	.word	0x40004050

00009f8c <am_hal_sysctrl_sleep>:
//! @return None.
//
//*****************************************************************************
void
am_hal_sysctrl_sleep(bool bSleepDeep)
{
    9f8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    9f8e:	b083      	sub	sp, #12
    9f90:	4605      	mov	r5, r0
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    9f92:	f7ff fde5 	bl	9b60 <am_hal_interrupt_master_disable>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    9f96:	4a41      	ldr	r2, [pc, #260]	; (a09c <am_hal_sysctrl_sleep+0x110>)
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    9f98:	4604      	mov	r4, r0

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    9f9a:	b11d      	cbz	r5, 9fa4 <am_hal_sysctrl_sleep+0x18>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    9f9c:	4b40      	ldr	r3, [pc, #256]	; (a0a0 <am_hal_sysctrl_sleep+0x114>)
    9f9e:	6818      	ldr	r0, [r3, #0]

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    9fa0:	07c3      	lsls	r3, r0, #31
    9fa2:	d509      	bpl.n	9fb8 <am_hal_sysctrl_sleep+0x2c>
    else
    {
        //
        // Prepare the core for normal sleep (write 0 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 0);
    9fa4:	6811      	ldr	r1, [r2, #0]
    9fa6:	f021 0604 	bic.w	r6, r1, #4
    9faa:	6016      	str	r6, [r2, #0]

        //
        // Go to sleep.
        //
        AM_ASM_WFI;
    9fac:	bf30      	wfi
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    9fae:	4620      	mov	r0, r4
    9fb0:	f7ff fdda 	bl	9b68 <am_hal_interrupt_master_set>
}
    9fb4:	b003      	add	sp, #12
    9fb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    9fb8:	6813      	ldr	r3, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    9fba:	493a      	ldr	r1, [pc, #232]	; (a0a4 <am_hal_sysctrl_sleep+0x118>)
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    9fbc:	4f3a      	ldr	r7, [pc, #232]	; (a0a8 <am_hal_sysctrl_sleep+0x11c>)
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    9fbe:	4d3b      	ldr	r5, [pc, #236]	; (a0ac <am_hal_sysctrl_sleep+0x120>)

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    9fc0:	483b      	ldr	r0, [pc, #236]	; (a0b0 <am_hal_sysctrl_sleep+0x124>)
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    9fc2:	f043 0604 	orr.w	r6, r3, #4
    9fc6:	6016      	str	r6, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    9fc8:	6809      	ldr	r1, [r1, #0]
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    9fca:	683b      	ldr	r3, [r7, #0]
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    9fcc:	682a      	ldr	r2, [r5, #0]

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    9fce:	6800      	ldr	r0, [r0, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    9fd0:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
    9fd4:	2920      	cmp	r1, #32

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    9fd6:	f103 36ff 	add.w	r6, r3, #4294967295
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    9fda:	bf14      	ite	ne
    9fdc:	2500      	movne	r5, #0
    9fde:	2502      	moveq	r5, #2

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    9fe0:	2e03      	cmp	r6, #3
    9fe2:	bf8c      	ite	hi
    9fe4:	2100      	movhi	r1, #0
    9fe6:	2104      	movls	r1, #4
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    9fe8:	f012 0303 	ands.w	r3, r2, #3
    9fec:	bf18      	it	ne
    9fee:	2301      	movne	r3, #1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    9ff0:	f240 56ff 	movw	r6, #1535	; 0x5ff
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    9ff4:	432b      	orrs	r3, r5
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    9ff6:	4006      	ands	r6, r0
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    9ff8:	ea43 0501 	orr.w	r5, r3, r1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    9ffc:	b91e      	cbnz	r6, a006 <am_hal_sysctrl_sleep+0x7a>
    9ffe:	f045 0508 	orr.w	r5, r5, #8
        //
        // Check if special buck handling is needed
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
    a002:	2d0f      	cmp	r5, #15
    a004:	d00a      	beq.n	a01c <am_hal_sysctrl_sleep+0x90>
        }

        //
        // Execute the sleep instruction.
        //
        AM_ASM_WFI;
    a006:	bf30      	wfi

        //
        // Return from sleep
        //
        if ( bBuckZX_chk )
    a008:	2d0f      	cmp	r5, #15
    a00a:	d01a      	beq.n	a042 <am_hal_sysctrl_sleep+0xb6>
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    a00c:	4f29      	ldr	r7, [pc, #164]	; (a0b4 <am_hal_sysctrl_sleep+0x128>)
    a00e:	2101      	movs	r1, #1
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    a010:	4620      	mov	r0, r4
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    a012:	7039      	strb	r1, [r7, #0]
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    a014:	f7ff fda8 	bl	9b68 <am_hal_interrupt_master_set>
}
    a018:	b003      	add	sp, #12
    a01a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
        {
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a01c:	683a      	ldr	r2, [r7, #0]
    a01e:	1e50      	subs	r0, r2, #1
    a020:	9000      	str	r0, [sp, #0]
            //
            // Before going to sleep, clear the buck timers.
            // This will also handle the case where we're going back to
            // sleep before the buck sequence has even completed.
            //
            am_hal_ctimer_clear(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    a022:	9800      	ldr	r0, [sp, #0]
    a024:	f04f 31ff 	mov.w	r1, #4294967295
    a028:	f7ff fcf8 	bl	9a1c <am_hal_ctimer_clear>

            //
            // Set CMPR0 of both timerA and timerB to the period value
            //
            #define     TIMER_PERIOD_BUCKS  1
            am_hal_ctimer_period_set(ui32BuckTimer,
    a02c:	9800      	ldr	r0, [sp, #0]
    a02e:	4633      	mov	r3, r6
    a030:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    a034:	f04f 31ff 	mov.w	r1, #4294967295
    a038:	f7ff fd04 	bl	9a44 <am_hal_ctimer_period_set>
                                     0);

            //
            // Disable bucks before going to sleep.
            //
            am_hal_pwrctrl_bucks_disable();
    a03c:	f7ff ff52 	bl	9ee4 <am_hal_pwrctrl_bucks_disable>
    a040:	e7e1      	b.n	a006 <am_hal_sysctrl_sleep+0x7a>
    bool bDoRestore = false;

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    a042:	f3ef 8310 	mrs	r3, PRIMASK
    a046:	9301      	str	r3, [sp, #4]
    a048:	b672      	cpsid	i

    //
    // Get the current zero cross trim values.
    //
    ui32SaveCore = AM_BFR(MCUCTRL, BUCK3, COREBUCKZXTRIM);
    a04a:	4e1b      	ldr	r6, [pc, #108]	; (a0b8 <am_hal_sysctrl_sleep+0x12c>)
    a04c:	6832      	ldr	r2, [r6, #0]
    ui32SaveMem  = AM_BFR(MCUCTRL, BUCK3, MEMBUCKZXTRIM);
    a04e:	6832      	ldr	r2, [r6, #0]
    //
    if ( bDoRestore )
    {
        if ( ui32Flags & SETBUCKZX_RESTORE_CORE_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, COREBUCKZXTRIM, ui32NewCore);
    a050:	6835      	ldr	r5, [r6, #0]
    a052:	f025 0c3c 	bic.w	ip, r5, #60	; 0x3c
    a056:	f04c 021c 	orr.w	r2, ip, #28
    a05a:	6032      	str	r2, [r6, #0]
        }

        if ( ui32Flags & SETBUCKZX_RESTORE_MEM_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, MEMBUCKZXTRIM,  ui32NewMem);
    a05c:	6830      	ldr	r0, [r6, #0]
    a05e:	f420 31f0 	bic.w	r1, r0, #122880	; 0x1e000
    a062:	f441 4360 	orr.w	r3, r1, #57344	; 0xe000
    a066:	6033      	str	r3, [r6, #0]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    a068:	9e01      	ldr	r6, [sp, #4]
    a06a:	f386 8810 	msr	PRIMASK, r6
                      SETBUCKZX_RESTORE_BOTH );

            //
            // Delay for 2us before enabling bucks.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(2) );
    a06e:	201c      	movs	r0, #28
    a070:	f7ff fd44 	bl	9afc <am_hal_flash_delay>

            //
            // Turn on the bucks
            //
            am_hal_pwrctrl_bucks_enable();
    a074:	f7ff ff1a 	bl	9eac <am_hal_pwrctrl_bucks_enable>

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a078:	683f      	ldr	r7, [r7, #0]
            g_bBuckRestoreComplete = false;

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    a07a:	4910      	ldr	r1, [pc, #64]	; (a0bc <am_hal_sysctrl_sleep+0x130>)
            ui32BuckTimer = g_ui32BuckTimer - 1;

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    a07c:	4d0d      	ldr	r5, [pc, #52]	; (a0b4 <am_hal_sysctrl_sleep+0x128>)
    a07e:	2200      	movs	r2, #0
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a080:	1e7b      	subs	r3, r7, #1
            g_ui32BuckInputs = 0;

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    a082:	204c      	movs	r0, #76	; 0x4c
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a084:	9300      	str	r3, [sp, #0]

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    a086:	702a      	strb	r2, [r5, #0]

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    a088:	600a      	str	r2, [r1, #0]

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    a08a:	f7ff fd37 	bl	9afc <am_hal_flash_delay>

            //
            // Start timers (set the enable bit, clear the clear bit)
            //
            am_hal_ctimer_start(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    a08e:	9800      	ldr	r0, [sp, #0]
    a090:	f04f 31ff 	mov.w	r1, #4294967295
    a094:	f7ff fca8 	bl	99e8 <am_hal_ctimer_start>
    a098:	e789      	b.n	9fae <am_hal_sysctrl_sleep+0x22>
    a09a:	bf00      	nop
    a09c:	e000ed10 	.word	0xe000ed10
    a0a0:	40020250 	.word	0x40020250
    a0a4:	4002000c 	.word	0x4002000c
    a0a8:	10001198 	.word	0x10001198
    a0ac:	40021000 	.word	0x40021000
    a0b0:	40021008 	.word	0x40021008
    a0b4:	10001190 	.word	0x10001190
    a0b8:	40020068 	.word	0x40020068
    a0bc:	10001194 	.word	0x10001194

0000a0c0 <am_hal_tpiu_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_tpiu_enable(am_hal_tpiu_config_t *psConfig)
{
    a0c0:	b538      	push	{r3, r4, r5, lr}
    ui32ITMbitrate = psConfig->ui32SetItmBaud;

    //
    // TPIU formatter & flush control register.
    //
    AM_REG(TPIU, FFCR) = 0;
    a0c2:	4a22      	ldr	r2, [pc, #136]	; (a14c <am_hal_tpiu_enable+0x8c>)
void
am_hal_tpiu_enable(am_hal_tpiu_config_t *psConfig)
{
    uint32_t ui32HFRC, ui32SWOscaler, ui32ITMbitrate;

    ui32ITMbitrate = psConfig->ui32SetItmBaud;
    a0c4:	6803      	ldr	r3, [r0, #0]

    //
    // TPIU formatter & flush control register.
    //
    AM_REG(TPIU, FFCR) = 0;
    a0c6:	2100      	movs	r1, #0
    a0c8:	6011      	str	r1, [r2, #0]

    if ( ui32ITMbitrate )
    a0ca:	b333      	cbz	r3, a11a <am_hal_tpiu_enable+0x5a>
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    a0cc:	4d20      	ldr	r5, [pc, #128]	; (a150 <am_hal_tpiu_enable+0x90>)

        //
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    a0ce:	4921      	ldr	r1, [pc, #132]	; (a154 <am_hal_tpiu_enable+0x94>)
             (ui32ITMbitrate > AM_HAL_TPIU_BAUD_2M ) )
        {
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    a0d0:	4a21      	ldr	r2, [pc, #132]	; (a158 <am_hal_tpiu_enable+0x98>)
    if ( ui32ITMbitrate )
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    a0d2:	2401      	movs	r4, #1

        //
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    a0d4:	f5a3 4c61 	sub.w	ip, r3, #57600	; 0xe100
    if ( ui32ITMbitrate )
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    a0d8:	602c      	str	r4, [r5, #0]
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
             (ui32ITMbitrate > AM_HAL_TPIU_BAUD_2M ) )
        {
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    a0da:	458c      	cmp	ip, r1
    a0dc:	bf94      	ite	ls
    a0de:	461d      	movls	r5, r3
    a0e0:	4615      	movhi	r5, r2
        }

        //
        // Get the current HFRC frequency.
        //
        ui32HFRC = am_hal_clkgen_sysclk_get();
    a0e2:	f7ff fbed 	bl	98c0 <am_hal_clkgen_sysclk_get>

        //
        // Compute the SWO scaler value.
        //
        if ( ui32HFRC != 0xFFFFFFFF )
    a0e6:	1c43      	adds	r3, r0, #1
    a0e8:	d02e      	beq.n	a148 <am_hal_tpiu_enable+0x88>
    a0ea:	08c3      	lsrs	r3, r0, #3
    a0ec:	fbb3 fef5 	udiv	lr, r3, r5
    a0f0:	f10e 31ff 	add.w	r1, lr, #4294967295
    a0f4:	b288      	uxth	r0, r1
        }

        //
        // Set the scaler value.
        //
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    a0f6:	4a19      	ldr	r2, [pc, #100]	; (a15c <am_hal_tpiu_enable+0x9c>)

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    a0f8:	4c19      	ldr	r4, [pc, #100]	; (a160 <am_hal_tpiu_enable+0xa0>)

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6 or 3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    a0fa:	4b1a      	ldr	r3, [pc, #104]	; (a164 <am_hal_tpiu_enable+0xa4>)

        //
        // Make sure we are not in test mode (important for proper deep sleep
        // operation).
        //
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    a0fc:	491a      	ldr	r1, [pc, #104]	; (a168 <am_hal_tpiu_enable+0xa8>)
        }

        //
        // Set the scaler value.
        //
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    a0fe:	6010      	str	r0, [r2, #0]

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    a100:	2502      	movs	r5, #2

        //
        // Make sure we are not in test mode (important for proper deep sleep
        // operation).
        //
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    a102:	2000      	movs	r0, #0

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6 or 3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    a104:	f240 2201 	movw	r2, #513	; 0x201
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    a108:	6025      	str	r5, [r4, #0]

        //
        // Make sure we are not in test mode (important for proper deep sleep
        // operation).
        //
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    a10a:	6008      	str	r0, [r1, #0]

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6 or 3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    a10c:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    a10e:	f44f 7047 	mov.w	r0, #796	; 0x31c
}
    a112:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    a116:	f7ff bcf1 	b.w	9afc <am_hal_flash_delay>
        //

        //
        // Set the Asynchronous Clock Prescaler Register.
        //
        AM_REG(TPIU, ACPR) = psConfig->ui32ClockPrescaler;
    a11a:	4c10      	ldr	r4, [pc, #64]	; (a15c <am_hal_tpiu_enable+0x9c>)
    a11c:	6905      	ldr	r5, [r0, #16]
    a11e:	6025      	str	r5, [r4, #0]

        //
        // Set the Selected Pin Protocol Register.
        //  e.g. AM_REG_TPIU_SPPR_TXMODE_UART
        //
        AM_REG(TPIU, SPPR) = psConfig->ui32PinProtocol;
    a120:	6882      	ldr	r2, [r0, #8]
    a122:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        // This may be redundant if the user has selected a serial protocol,
        // but we'll set it anyway.
        //
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    a126:	68c3      	ldr	r3, [r0, #12]
    a128:	4c09      	ldr	r4, [pc, #36]	; (a150 <am_hal_tpiu_enable+0x90>)

        //
        // Set the clock freq in the MCUCTRL register.
        //
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    a12a:	490e      	ldr	r1, [pc, #56]	; (a164 <am_hal_tpiu_enable+0xa4>)
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        // This may be redundant if the user has selected a serial protocol,
        // but we'll set it anyway.
        //
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    a12c:	1e5d      	subs	r5, r3, #1
    a12e:	2201      	movs	r2, #1
    a130:	40aa      	lsls	r2, r5
    a132:	6022      	str	r2, [r4, #0]

        //
        // Set the clock freq in the MCUCTRL register.
        //
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    a134:	680b      	ldr	r3, [r1, #0]
    a136:	6840      	ldr	r0, [r0, #4]
    a138:	4318      	orrs	r0, r3
    a13a:	6008      	str	r0, [r1, #0]

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
}
    a13c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    a140:	f44f 7047 	mov.w	r0, #796	; 0x31c
    a144:	f7ff bcda 	b.w	9afc <am_hal_flash_delay>
    a148:	2005      	movs	r0, #5
    a14a:	e7d4      	b.n	a0f6 <am_hal_tpiu_enable+0x36>
    a14c:	e0040304 	.word	0xe0040304
    a150:	e0040004 	.word	0xe0040004
    a154:	001da380 	.word	0x001da380
    a158:	000f4240 	.word	0x000f4240
    a15c:	e0040010 	.word	0xe0040010
    a160:	e00400f0 	.word	0xe00400f0
    a164:	40020250 	.word	0x40020250
    a168:	e0040f00 	.word	0xe0040f00

0000a16c <am_hal_tpiu_disable>:
am_hal_tpiu_disable(void)
{
    //
    // Disable the TPIU clock source in MCU control.
    //
    AM_REG(MCUCTRL, TPIUCTRL) = AM_REG_MCUCTRL_TPIUCTRL_CLKSEL_0MHz |
    a16c:	4b01      	ldr	r3, [pc, #4]	; (a174 <am_hal_tpiu_disable+0x8>)
    a16e:	2200      	movs	r2, #0
    a170:	601a      	str	r2, [r3, #0]
    a172:	4770      	bx	lr
    a174:	40020250 	.word	0x40020250

0000a178 <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    a178:	4b01      	ldr	r3, [pc, #4]	; (a180 <am_hal_vcomp_disable+0x8>)
    a17a:	2237      	movs	r2, #55	; 0x37
    a17c:	601a      	str	r2, [r3, #0]
    a17e:	4770      	bx	lr
    a180:	4000c008 	.word	0x4000c008
    a184:	616e6942 	.word	0x616e6942
    a188:	43207972 	.word	0x43207972
    a18c:	746e756f 	.word	0x746e756f
    a190:	45207265 	.word	0x45207265
    a194:	706d6178 	.word	0x706d6178
    a198:	000a656c 	.word	0x000a656c
    a19c:	0a0a0a0a 	.word	0x0a0a0a0a
    a1a0:	0a0a0a0a 	.word	0x0a0a0a0a
    a1a4:	0a0a0a0a 	.word	0x0a0a0a0a
    a1a8:	0a0a0a0a 	.word	0x0a0a0a0a
    a1ac:	00000a0a 	.word	0x00000a0a

0000a1b0 <am_hal_cachectrl_defaults>:
    a1b0:	50000001 00010300 00010101 685f6d61     ...P........am_h
    a1c0:	635f6c61 65676b6c 79735f6e 6b6c6373     al_clkgen_sysclk
    a1d0:	6c65735f 28746365 69203a29 6c61766e     _select(): inval
    a1e0:	63206469 6b636f6c 74657320 676e6974     id clock setting
    a1f0:	0000002e 2e5c2e2e 6d615c2e 6c61685f     ......\..\am_hal
    a200:	6b6c635f 2e6e6567 00000063              _clkgen.c...
