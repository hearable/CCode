
C:\jenkins\jobs\ambiqsuite-checkout\workspace\ambiqsuite-sdk\boards\apollo2_evb\examples\i2c_boot_host\atollic_gcc\bin\i2c_boot_host_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005174  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00030000  2**2
                  ALLOC
  2 .data         00000054  10001000  00005174  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000004cc  10001054  000051c8  00021054  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00021054  2**0
                  CONTENTS, READONLY
  5 .debug_info   0000dd58  00000000  00000000  0002108b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001d12  00000000  00000000  0002ede3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000900  00000000  00000000  00030af5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 00001b90  00000000  00000000  000313f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00005737  00000000  00000000  00032f85  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003528  00000000  00000000  000386bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007e  00000000  00000000  0003bbe4  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00001c64  00000000  00000000  0003bc64  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00010c09  00000000  00000000  0003d8c8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <g_am_pfnVectors>:
       0:	00 10 00 10 99 05 00 00 01 06 00 00 09 06 00 00     ................
      10:	09 06 00 00 09 06 00 00 09 06 00 00 00 00 00 00     ................
	...
      2c:	11 06 00 00 11 06 00 00 00 00 00 00 11 06 00 00     ................
      3c:	11 06 00 00 11 06 00 00 11 06 00 00 11 06 00 00     ................
      4c:	11 06 00 00 11 06 00 00 11 06 00 00 11 06 00 00     ................
      5c:	11 06 00 00 11 06 00 00 11 06 00 00 11 06 00 00     ................
      6c:	11 06 00 00 b9 01 00 00 11 06 00 00 11 06 00 00     ................
      7c:	11 06 00 00 11 06 00 00 11 06 00 00 11 06 00 00     ................
      8c:	11 06 00 00 11 06 00 00 11 06 00 00 11 06 00 00     ................
      9c:	11 06 00 00 11 06 00 00 11 06 00 00 11 06 00 00     ................
      ac:	11 06 00 00 11 06 00 00 11 06 00 00 11 06 00 00     ................
      bc:	11 06 00 00                                         ....

000000c0 <configure_pins>:
// Configure GPIOs for this example
//
//*****************************************************************************
void
configure_pins(void)
{
      c0:	b480      	push	{r7}
      c2:	b085      	sub	sp, #20
      c4:	af00      	add	r7, sp, #0
    //
    // Configure I/O Master 0 as I2C
    //
    am_hal_gpio_pin_config(5, AM_HAL_PIN_5_M0SCL | AM_HAL_GPIO_PULLUP);
      c6:	f3ef 8310 	mrs	r3, PRIMASK
      ca:	60fb      	str	r3, [r7, #12]
      cc:	b672      	cpsid	i
      ce:	4b34      	ldr	r3, [pc, #208]	; (1a0 <configure_pins+0xe0>)
      d0:	2273      	movs	r2, #115	; 0x73
      d2:	601a      	str	r2, [r3, #0]
      d4:	4a33      	ldr	r2, [pc, #204]	; (1a4 <configure_pins+0xe4>)
      d6:	4b33      	ldr	r3, [pc, #204]	; (1a4 <configure_pins+0xe4>)
      d8:	681b      	ldr	r3, [r3, #0]
      da:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
      de:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
      e2:	6013      	str	r3, [r2, #0]
      e4:	4a30      	ldr	r2, [pc, #192]	; (1a8 <configure_pins+0xe8>)
      e6:	4b30      	ldr	r3, [pc, #192]	; (1a8 <configure_pins+0xe8>)
      e8:	681b      	ldr	r3, [r3, #0]
      ea:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
      ee:	f443 7340 	orr.w	r3, r3, #768	; 0x300
      f2:	6013      	str	r3, [r2, #0]
      f4:	4a2d      	ldr	r2, [pc, #180]	; (1ac <configure_pins+0xec>)
      f6:	4b2d      	ldr	r3, [pc, #180]	; (1ac <configure_pins+0xec>)
      f8:	681b      	ldr	r3, [r3, #0]
      fa:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
      fe:	6013      	str	r3, [r2, #0]
     100:	4b27      	ldr	r3, [pc, #156]	; (1a0 <configure_pins+0xe0>)
     102:	2200      	movs	r2, #0
     104:	601a      	str	r2, [r3, #0]
     106:	68fb      	ldr	r3, [r7, #12]
     108:	f383 8810 	msr	PRIMASK, r3
    am_hal_gpio_pin_config(6, AM_HAL_PIN_6_M0SDA | AM_HAL_GPIO_PULLUP);
     10c:	f3ef 8310 	mrs	r3, PRIMASK
     110:	60bb      	str	r3, [r7, #8]
     112:	b672      	cpsid	i
     114:	4b22      	ldr	r3, [pc, #136]	; (1a0 <configure_pins+0xe0>)
     116:	2273      	movs	r2, #115	; 0x73
     118:	601a      	str	r2, [r3, #0]
     11a:	4a22      	ldr	r2, [pc, #136]	; (1a4 <configure_pins+0xe4>)
     11c:	4b21      	ldr	r3, [pc, #132]	; (1a4 <configure_pins+0xe4>)
     11e:	681b      	ldr	r3, [r3, #0]
     120:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
     124:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
     128:	6013      	str	r3, [r2, #0]
     12a:	4a1f      	ldr	r2, [pc, #124]	; (1a8 <configure_pins+0xe8>)
     12c:	4b1e      	ldr	r3, [pc, #120]	; (1a8 <configure_pins+0xe8>)
     12e:	681b      	ldr	r3, [r3, #0]
     130:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     134:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
     138:	6013      	str	r3, [r2, #0]
     13a:	4a1c      	ldr	r2, [pc, #112]	; (1ac <configure_pins+0xec>)
     13c:	4b1b      	ldr	r3, [pc, #108]	; (1ac <configure_pins+0xec>)
     13e:	681b      	ldr	r3, [r3, #0]
     140:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     144:	6013      	str	r3, [r2, #0]
     146:	4b16      	ldr	r3, [pc, #88]	; (1a0 <configure_pins+0xe0>)
     148:	2200      	movs	r2, #0
     14a:	601a      	str	r2, [r3, #0]
     14c:	68bb      	ldr	r3, [r7, #8]
     14e:	f383 8810 	msr	PRIMASK, r3

    //
    // Configure the I/O Slave interrupt pin
    //
    am_hal_gpio_pin_config(BOOTLOADER_HANDSHAKE_PIN, AM_HAL_PIN_INPUT | AM_HAL_GPIO_PULLUP);
     152:	f3ef 8310 	mrs	r3, PRIMASK
     156:	607b      	str	r3, [r7, #4]
     158:	b672      	cpsid	i
     15a:	4b11      	ldr	r3, [pc, #68]	; (1a0 <configure_pins+0xe0>)
     15c:	2273      	movs	r2, #115	; 0x73
     15e:	601a      	str	r2, [r3, #0]
     160:	4a10      	ldr	r2, [pc, #64]	; (1a4 <configure_pins+0xe4>)
     162:	4b10      	ldr	r3, [pc, #64]	; (1a4 <configure_pins+0xe4>)
     164:	681b      	ldr	r3, [r3, #0]
     166:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
     16a:	6013      	str	r3, [r2, #0]
     16c:	4a10      	ldr	r2, [pc, #64]	; (1b0 <configure_pins+0xf0>)
     16e:	4b10      	ldr	r3, [pc, #64]	; (1b0 <configure_pins+0xf0>)
     170:	681b      	ldr	r3, [r3, #0]
     172:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     176:	f443 13d8 	orr.w	r3, r3, #1769472	; 0x1b0000
     17a:	6013      	str	r3, [r2, #0]
     17c:	4a0d      	ldr	r2, [pc, #52]	; (1b4 <configure_pins+0xf4>)
     17e:	4b0d      	ldr	r3, [pc, #52]	; (1b4 <configure_pins+0xf4>)
     180:	681b      	ldr	r3, [r3, #0]
     182:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     186:	6013      	str	r3, [r2, #0]
     188:	4b05      	ldr	r3, [pc, #20]	; (1a0 <configure_pins+0xe0>)
     18a:	2200      	movs	r2, #0
     18c:	601a      	str	r2, [r3, #0]
     18e:	687b      	ldr	r3, [r7, #4]
     190:	f383 8810 	msr	PRIMASK, r3
}
     194:	bf00      	nop
     196:	3714      	adds	r7, #20
     198:	46bd      	mov	sp, r7
     19a:	f85d 7b04 	ldr.w	r7, [sp], #4
     19e:	4770      	bx	lr
     1a0:	40010060 	.word	0x40010060
     1a4:	40010040 	.word	0x40010040
     1a8:	40010004 	.word	0x40010004
     1ac:	400100e4 	.word	0x400100e4
     1b0:	40010000 	.word	0x40010000
     1b4:	400100e0 	.word	0x400100e0

000001b8 <am_gpio_isr>:
// Interrupt handler for the GPIO pins.
//
//*****************************************************************************
void
am_gpio_isr(void)
{
     1b8:	b580      	push	{r7, lr}
     1ba:	b082      	sub	sp, #8
     1bc:	af00      	add	r7, sp, #0
    uint64_t ui64Status;

    //
    // Read and clear the GPIO interrupt status.
    //
    ui64Status = am_hal_gpio_int_status_get(false);
     1be:	2000      	movs	r0, #0
     1c0:	f000 fc5c 	bl	a7c <am_hal_gpio_int_status_get>
     1c4:	e9c7 0100 	strd	r0, r1, [r7]
    am_hal_gpio_int_clear(ui64Status);
     1c8:	e9d7 0100 	ldrd	r0, r1, [r7]
     1cc:	f000 fc44 	bl	a58 <am_hal_gpio_int_clear>
}
     1d0:	bf00      	nop
     1d2:	3708      	adds	r7, #8
     1d4:	46bd      	mov	sp, r7
     1d6:	bd80      	pop	{r7, pc}

000001d8 <start_boot_mode>:
// Reset the slave device and force it into boot mode.
//
//*****************************************************************************
void
start_boot_mode(void)
{
     1d8:	b580      	push	{r7, lr}
     1da:	b082      	sub	sp, #8
     1dc:	af00      	add	r7, sp, #0
    //
    // Drive RESET low.
    //
    am_hal_gpio_out_bit_clear(DRIVE_SLAVE_RESET_PIN);
     1de:	4b2f      	ldr	r3, [pc, #188]	; (29c <start_boot_mode+0xc4>)
     1e0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     1e4:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(DRIVE_SLAVE_RESET_PIN, AM_HAL_PIN_OUTPUT);
     1e6:	f3ef 8310 	mrs	r3, PRIMASK
     1ea:	607b      	str	r3, [r7, #4]
     1ec:	b672      	cpsid	i
     1ee:	4b2c      	ldr	r3, [pc, #176]	; (2a0 <start_boot_mode+0xc8>)
     1f0:	2273      	movs	r2, #115	; 0x73
     1f2:	601a      	str	r2, [r3, #0]
     1f4:	4a2b      	ldr	r2, [pc, #172]	; (2a4 <start_boot_mode+0xcc>)
     1f6:	4b2b      	ldr	r3, [pc, #172]	; (2a4 <start_boot_mode+0xcc>)
     1f8:	681b      	ldr	r3, [r3, #0]
     1fa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
     1fe:	f043 0320 	orr.w	r3, r3, #32
     202:	6013      	str	r3, [r2, #0]
     204:	4a28      	ldr	r2, [pc, #160]	; (2a8 <start_boot_mode+0xd0>)
     206:	4b28      	ldr	r3, [pc, #160]	; (2a8 <start_boot_mode+0xd0>)
     208:	681b      	ldr	r3, [r3, #0]
     20a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     20e:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
     212:	6013      	str	r3, [r2, #0]
     214:	4a25      	ldr	r2, [pc, #148]	; (2ac <start_boot_mode+0xd4>)
     216:	4b25      	ldr	r3, [pc, #148]	; (2ac <start_boot_mode+0xd4>)
     218:	681b      	ldr	r3, [r3, #0]
     21a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     21e:	6013      	str	r3, [r2, #0]
     220:	4b1f      	ldr	r3, [pc, #124]	; (2a0 <start_boot_mode+0xc8>)
     222:	2200      	movs	r2, #0
     224:	601a      	str	r2, [r3, #0]
     226:	687b      	ldr	r3, [r7, #4]
     228:	f383 8810 	msr	PRIMASK, r3

    //
    // Drive the override pin low to force the slave into boot mode.
    //
    am_hal_gpio_out_bit_clear(DRIVE_SLAVE_OVERRIDE_PIN);
     22c:	4b1b      	ldr	r3, [pc, #108]	; (29c <start_boot_mode+0xc4>)
     22e:	2210      	movs	r2, #16
     230:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(DRIVE_SLAVE_OVERRIDE_PIN, AM_HAL_PIN_OUTPUT);
     232:	f3ef 8310 	mrs	r3, PRIMASK
     236:	603b      	str	r3, [r7, #0]
     238:	b672      	cpsid	i
     23a:	4b19      	ldr	r3, [pc, #100]	; (2a0 <start_boot_mode+0xc8>)
     23c:	2273      	movs	r2, #115	; 0x73
     23e:	601a      	str	r2, [r3, #0]
     240:	4a1b      	ldr	r2, [pc, #108]	; (2b0 <start_boot_mode+0xd8>)
     242:	4b1b      	ldr	r3, [pc, #108]	; (2b0 <start_boot_mode+0xd8>)
     244:	681b      	ldr	r3, [r3, #0]
     246:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
     24a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     24e:	6013      	str	r3, [r2, #0]
     250:	4a18      	ldr	r2, [pc, #96]	; (2b4 <start_boot_mode+0xdc>)
     252:	4b18      	ldr	r3, [pc, #96]	; (2b4 <start_boot_mode+0xdc>)
     254:	681b      	ldr	r3, [r3, #0]
     256:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     25a:	f043 0318 	orr.w	r3, r3, #24
     25e:	6013      	str	r3, [r2, #0]
     260:	4a15      	ldr	r2, [pc, #84]	; (2b8 <start_boot_mode+0xe0>)
     262:	4b15      	ldr	r3, [pc, #84]	; (2b8 <start_boot_mode+0xe0>)
     264:	681b      	ldr	r3, [r3, #0]
     266:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     26a:	6013      	str	r3, [r2, #0]
     26c:	4b0c      	ldr	r3, [pc, #48]	; (2a0 <start_boot_mode+0xc8>)
     26e:	2200      	movs	r2, #0
     270:	601a      	str	r2, [r3, #0]
     272:	683b      	ldr	r3, [r7, #0]
     274:	f383 8810 	msr	PRIMASK, r3

    //
    // Short delay.
    //
    am_util_delay_us(5);
     278:	2005      	movs	r0, #5
     27a:	f000 f9cd 	bl	618 <am_util_delay_us>

    //
    // Release RESET.
    //
    am_hal_gpio_out_bit_set(DRIVE_SLAVE_RESET_PIN);
     27e:	4b0f      	ldr	r3, [pc, #60]	; (2bc <start_boot_mode+0xe4>)
     280:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     284:	601a      	str	r2, [r3, #0]

    //
    // Wait for the slave to Set the handshake pin
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     286:	bf00      	nop
     288:	4b0d      	ldr	r3, [pc, #52]	; (2c0 <start_boot_mode+0xe8>)
     28a:	681b      	ldr	r3, [r3, #0]
     28c:	f003 0304 	and.w	r3, r3, #4
     290:	2b00      	cmp	r3, #0
     292:	d0f9      	beq.n	288 <start_boot_mode+0xb0>
}
     294:	bf00      	nop
     296:	3708      	adds	r7, #8
     298:	46bd      	mov	sp, r7
     29a:	bd80      	pop	{r7, pc}
     29c:	40010098 	.word	0x40010098
     2a0:	40010060 	.word	0x40010060
     2a4:	40010048 	.word	0x40010048
     2a8:	40010010 	.word	0x40010010
     2ac:	400100f0 	.word	0x400100f0
     2b0:	40010040 	.word	0x40010040
     2b4:	40010004 	.word	0x40010004
     2b8:	400100e4 	.word	0x400100e4
     2bc:	40010090 	.word	0x40010090
     2c0:	40010080 	.word	0x40010080

000002c4 <start_new_image>:
// Send the commands to start a new boot download.
//
//*****************************************************************************
void
start_new_image(void)
{
     2c4:	b580      	push	{r7, lr}
     2c6:	b082      	sub	sp, #8
     2c8:	af02      	add	r7, sp, #8
    //
    // Wait for the slave to send the ready signal
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     2ca:	bf00      	nop
     2cc:	4b25      	ldr	r3, [pc, #148]	; (364 <start_new_image+0xa0>)
     2ce:	681b      	ldr	r3, [r3, #0]
     2d0:	f003 0304 	and.w	r3, r3, #4
     2d4:	2b00      	cmp	r3, #0
     2d6:	d1f9      	bne.n	2cc <start_new_image+0x8>
    //
    // Make sure the override pin is high so the slave will reboot into
    // application mode when our boot procedure is complete.
    //
    am_hal_gpio_out_bit_set(DRIVE_SLAVE_OVERRIDE_PIN);
     2d8:	4b23      	ldr	r3, [pc, #140]	; (368 <start_new_image+0xa4>)
     2da:	2210      	movs	r2, #16
     2dc:	601a      	str	r2, [r3, #0]
    // Clear any interrupts that may have happened while Slave is coming up
    am_hal_iom_int_clear(0, 0xFFFFFFFF);
     2de:	f04f 31ff 	mov.w	r1, #4294967295
     2e2:	2000      	movs	r0, #0
     2e4:	f001 fcc0 	bl	1c68 <am_hal_iom_int_clear>
    am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     2e8:	2300      	movs	r3, #0
     2ea:	9300      	str	r3, [sp, #0]
     2ec:	2304      	movs	r3, #4
     2ee:	4a1f      	ldr	r2, [pc, #124]	; (36c <start_new_image+0xa8>)
     2f0:	2110      	movs	r1, #16
     2f2:	2000      	movs	r0, #0
     2f4:	f001 fc0c 	bl	1b10 <am_hal_iom_i2c_read>

    //
    // ACK the ready signal to have slave pull the interrupt line high.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     2f8:	4b1d      	ldr	r3, [pc, #116]	; (370 <start_new_image+0xac>)
     2fa:	2200      	movs	r2, #0
     2fc:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     2fe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     302:	9300      	str	r3, [sp, #0]
     304:	2304      	movs	r3, #4
     306:	4a1a      	ldr	r2, [pc, #104]	; (370 <start_new_image+0xac>)
     308:	2110      	movs	r1, #16
     30a:	2000      	movs	r0, #0
     30c:	f001 fb56 	bl	19bc <am_hal_iom_i2c_write>
    //
    // Wait for the slave to read the ACK
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     310:	bf00      	nop
     312:	4b14      	ldr	r3, [pc, #80]	; (364 <start_new_image+0xa0>)
     314:	681b      	ldr	r3, [r3, #0]
     316:	f003 0304 	and.w	r3, r3, #4
     31a:	2b00      	cmp	r3, #0
     31c:	d0f9      	beq.n	312 <start_new_image+0x4e>

    //
    // Write the image parameters to the I2C FIFO
    //
    g_psTxBuffer.words[0] = IMAGE_LINK_ADDRESS;
     31e:	4b14      	ldr	r3, [pc, #80]	; (370 <start_new_image+0xac>)
     320:	f44f 4200 	mov.w	r2, #32768	; 0x8000
     324:	601a      	str	r2, [r3, #0]
    g_psTxBuffer.words[1] = IMAGE_SIZE;
     326:	4b12      	ldr	r3, [pc, #72]	; (370 <start_new_image+0xac>)
     328:	f641 420a 	movw	r2, #7178	; 0x1c0a
     32c:	605a      	str	r2, [r3, #4]
    g_psTxBuffer.words[2] = IMAGE_CRC;
     32e:	4b10      	ldr	r3, [pc, #64]	; (370 <start_new_image+0xac>)
     330:	4a10      	ldr	r2, [pc, #64]	; (374 <start_new_image+0xb0>)
     332:	609a      	str	r2, [r3, #8]

    //
    // Send the image parameters to the slave.
    //
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 12, AM_HAL_IOM_OFFSET(0x84));
     334:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     338:	9300      	str	r3, [sp, #0]
     33a:	230c      	movs	r3, #12
     33c:	4a0c      	ldr	r2, [pc, #48]	; (370 <start_new_image+0xac>)
     33e:	2110      	movs	r1, #16
     340:	2000      	movs	r0, #0
     342:	f001 fb3b 	bl	19bc <am_hal_iom_i2c_write>

    //
    // Finish out the image start routine with the "New Image" packet.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_NEW_IMAGE;
     346:	4b0a      	ldr	r3, [pc, #40]	; (370 <start_new_image+0xac>)
     348:	2202      	movs	r2, #2
     34a:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     34c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     350:	9300      	str	r3, [sp, #0]
     352:	2304      	movs	r3, #4
     354:	4a06      	ldr	r2, [pc, #24]	; (370 <start_new_image+0xac>)
     356:	2110      	movs	r1, #16
     358:	2000      	movs	r0, #0
     35a:	f001 fb2f 	bl	19bc <am_hal_iom_i2c_write>
}
     35e:	bf00      	nop
     360:	46bd      	mov	sp, r7
     362:	bd80      	pop	{r7, pc}
     364:	40010080 	.word	0x40010080
     368:	40010090 	.word	0x40010090
     36c:	10001288 	.word	0x10001288
     370:	10001098 	.word	0x10001098
     374:	160b7b17 	.word	0x160b7b17

00000378 <override_pin_set>:
// Set override pin.
//
//*****************************************************************************
void
override_pin_set(uint32_t ui32OverridePin, uint32_t ui32OverridePolarity)
{
     378:	b580      	push	{r7, lr}
     37a:	b084      	sub	sp, #16
     37c:	af02      	add	r7, sp, #8
     37e:	6078      	str	r0, [r7, #4]
     380:	6039      	str	r1, [r7, #0]
    //
    // Wait for the slave to send the ready signal
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     382:	bf00      	nop
     384:	4b1f      	ldr	r3, [pc, #124]	; (404 <override_pin_set+0x8c>)
     386:	681b      	ldr	r3, [r3, #0]
     388:	f003 0304 	and.w	r3, r3, #4
     38c:	2b00      	cmp	r3, #0
     38e:	d1f9      	bne.n	384 <override_pin_set+0xc>
    am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     390:	2300      	movs	r3, #0
     392:	9300      	str	r3, [sp, #0]
     394:	2304      	movs	r3, #4
     396:	4a1c      	ldr	r2, [pc, #112]	; (408 <override_pin_set+0x90>)
     398:	2110      	movs	r1, #16
     39a:	2000      	movs	r0, #0
     39c:	f001 fbb8 	bl	1b10 <am_hal_iom_i2c_read>

    //
    // ACK the ready signal to have slave pull the interrupt line high.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     3a0:	4b1a      	ldr	r3, [pc, #104]	; (40c <override_pin_set+0x94>)
     3a2:	2200      	movs	r2, #0
     3a4:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     3a6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     3aa:	9300      	str	r3, [sp, #0]
     3ac:	2304      	movs	r3, #4
     3ae:	4a17      	ldr	r2, [pc, #92]	; (40c <override_pin_set+0x94>)
     3b0:	2110      	movs	r1, #16
     3b2:	2000      	movs	r0, #0
     3b4:	f001 fb02 	bl	19bc <am_hal_iom_i2c_write>
    //
    // Wait for the slave to read the ACK
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     3b8:	bf00      	nop
     3ba:	4b12      	ldr	r3, [pc, #72]	; (404 <override_pin_set+0x8c>)
     3bc:	681b      	ldr	r3, [r3, #0]
     3be:	f003 0304 	and.w	r3, r3, #4
     3c2:	2b00      	cmp	r3, #0
     3c4:	d0f9      	beq.n	3ba <override_pin_set+0x42>

    //
    // Write the image parameters to the I2C FIFO
    //
    g_psTxBuffer.words[0] = ui32OverridePin;
     3c6:	4a11      	ldr	r2, [pc, #68]	; (40c <override_pin_set+0x94>)
     3c8:	687b      	ldr	r3, [r7, #4]
     3ca:	6013      	str	r3, [r2, #0]
    g_psTxBuffer.words[1] = ui32OverridePolarity;
     3cc:	4a0f      	ldr	r2, [pc, #60]	; (40c <override_pin_set+0x94>)
     3ce:	683b      	ldr	r3, [r7, #0]
     3d0:	6053      	str	r3, [r2, #4]

    //
    // Send the image parameters to the slave.
    //
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 8, AM_HAL_IOM_OFFSET(0x84));
     3d2:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     3d6:	9300      	str	r3, [sp, #0]
     3d8:	2308      	movs	r3, #8
     3da:	4a0c      	ldr	r2, [pc, #48]	; (40c <override_pin_set+0x94>)
     3dc:	2110      	movs	r1, #16
     3de:	2000      	movs	r0, #0
     3e0:	f001 faec 	bl	19bc <am_hal_iom_i2c_write>

    //
    // Finish out the image start routine with the "New Image" packet.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_SET_OVERRIDE_CMD;
     3e4:	4b09      	ldr	r3, [pc, #36]	; (40c <override_pin_set+0x94>)
     3e6:	2205      	movs	r2, #5
     3e8:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     3ea:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     3ee:	9300      	str	r3, [sp, #0]
     3f0:	2304      	movs	r3, #4
     3f2:	4a06      	ldr	r2, [pc, #24]	; (40c <override_pin_set+0x94>)
     3f4:	2110      	movs	r1, #16
     3f6:	2000      	movs	r0, #0
     3f8:	f001 fae0 	bl	19bc <am_hal_iom_i2c_write>
}
     3fc:	bf00      	nop
     3fe:	3708      	adds	r7, #8
     400:	46bd      	mov	sp, r7
     402:	bd80      	pop	{r7, pc}
     404:	40010080 	.word	0x40010080
     408:	10001288 	.word	0x10001288
     40c:	10001098 	.word	0x10001098

00000410 <transfer_image>:
// Send the actual firmware image over to the boot slave.
//
//*****************************************************************************
void
transfer_image(void)
{
     410:	b580      	push	{r7, lr}
     412:	b086      	sub	sp, #24
     414:	af02      	add	r7, sp, #8
    uint32_t i;

    //
    // Send the firmware image across.
    //
    ui32BytesRemaining = IMAGE_SIZE;
     416:	f641 430a 	movw	r3, #7178	; 0x1c0a
     41a:	60fb      	str	r3, [r7, #12]
    ui32Offset = 0;
     41c:	2300      	movs	r3, #0
     41e:	60bb      	str	r3, [r7, #8]

    while ( ui32BytesRemaining )
     420:	e05b      	b.n	4da <transfer_image+0xca>
    {
        //
        // Wait for another ready signal.
        //
        while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     422:	bf00      	nop
     424:	4b30      	ldr	r3, [pc, #192]	; (4e8 <transfer_image+0xd8>)
     426:	681b      	ldr	r3, [r3, #0]
     428:	f003 0304 	and.w	r3, r3, #4
     42c:	2b00      	cmp	r3, #0
     42e:	d1f9      	bne.n	424 <transfer_image+0x14>
        am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     430:	2300      	movs	r3, #0
     432:	9300      	str	r3, [sp, #0]
     434:	2304      	movs	r3, #4
     436:	4a2d      	ldr	r2, [pc, #180]	; (4ec <transfer_image+0xdc>)
     438:	2110      	movs	r1, #16
     43a:	2000      	movs	r0, #0
     43c:	f001 fb68 	bl	1b10 <am_hal_iom_i2c_read>
        //
        // ACK the ready signal to have slave pull the interrupt line high.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     440:	4b2b      	ldr	r3, [pc, #172]	; (4f0 <transfer_image+0xe0>)
     442:	2200      	movs	r2, #0
     444:	601a      	str	r2, [r3, #0]
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     446:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     44a:	9300      	str	r3, [sp, #0]
     44c:	2304      	movs	r3, #4
     44e:	4a28      	ldr	r2, [pc, #160]	; (4f0 <transfer_image+0xe0>)
     450:	2110      	movs	r1, #16
     452:	2000      	movs	r0, #0
     454:	f001 fab2 	bl	19bc <am_hal_iom_i2c_write>
        //
        // Wait for the slave to read the ACK
        //
        while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     458:	bf00      	nop
     45a:	4b23      	ldr	r3, [pc, #140]	; (4e8 <transfer_image+0xd8>)
     45c:	681b      	ldr	r3, [r3, #0]
     45e:	f003 0304 	and.w	r3, r3, #4
     462:	2b00      	cmp	r3, #0
     464:	d0f9      	beq.n	45a <transfer_image+0x4a>

        //
        // We can't transfer more than a few bytes at a time. Limit the
        // transaction to 112 bytes max.
        //
        ui32TransferSize = ui32BytesRemaining > 112 ? 112 : ui32BytesRemaining;
     466:	68fb      	ldr	r3, [r7, #12]
     468:	2b70      	cmp	r3, #112	; 0x70
     46a:	bf28      	it	cs
     46c:	2370      	movcs	r3, #112	; 0x70
     46e:	603b      	str	r3, [r7, #0]

        //
        // Start the packet with the packet length.
        //
        g_psTxBuffer.words[0] = ui32TransferSize;
     470:	4a1f      	ldr	r2, [pc, #124]	; (4f0 <transfer_image+0xe0>)
     472:	683b      	ldr	r3, [r7, #0]
     474:	6013      	str	r3, [r2, #0]

        //
        // Fill in the packet contents.
        //
        for ( i = 0; i < ui32TransferSize; i++ )
     476:	2300      	movs	r3, #0
     478:	607b      	str	r3, [r7, #4]
     47a:	e00b      	b.n	494 <transfer_image+0x84>
        {
            g_psTxBuffer.bytes[4 + i] = IMAGE_ARRAY[ui32Offset + i];
     47c:	687b      	ldr	r3, [r7, #4]
     47e:	3304      	adds	r3, #4
     480:	68b9      	ldr	r1, [r7, #8]
     482:	687a      	ldr	r2, [r7, #4]
     484:	440a      	add	r2, r1
     486:	491b      	ldr	r1, [pc, #108]	; (4f4 <transfer_image+0xe4>)
     488:	5c89      	ldrb	r1, [r1, r2]
     48a:	4a19      	ldr	r2, [pc, #100]	; (4f0 <transfer_image+0xe0>)
     48c:	54d1      	strb	r1, [r2, r3]
        g_psTxBuffer.words[0] = ui32TransferSize;

        //
        // Fill in the packet contents.
        //
        for ( i = 0; i < ui32TransferSize; i++ )
     48e:	687b      	ldr	r3, [r7, #4]
     490:	3301      	adds	r3, #1
     492:	607b      	str	r3, [r7, #4]
     494:	687a      	ldr	r2, [r7, #4]
     496:	683b      	ldr	r3, [r7, #0]
     498:	429a      	cmp	r2, r3
     49a:	d3ef      	bcc.n	47c <transfer_image+0x6c>
        }

        //
        // Send the data over to the slave.
        //
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, ui32TransferSize + 4,
     49c:	683b      	ldr	r3, [r7, #0]
     49e:	1d1a      	adds	r2, r3, #4
     4a0:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     4a4:	9300      	str	r3, [sp, #0]
     4a6:	4613      	mov	r3, r2
     4a8:	4a11      	ldr	r2, [pc, #68]	; (4f0 <transfer_image+0xe0>)
     4aa:	2110      	movs	r1, #16
     4ac:	2000      	movs	r0, #0
     4ae:	f001 fa85 	bl	19bc <am_hal_iom_i2c_write>
                             AM_HAL_IOM_OFFSET(0x84));

        //
        // Finish with the "New Packet" boot command.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_NEW_PACKET;
     4b2:	4b0f      	ldr	r3, [pc, #60]	; (4f0 <transfer_image+0xe0>)
     4b4:	2203      	movs	r2, #3
     4b6:	601a      	str	r2, [r3, #0]
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     4b8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     4bc:	9300      	str	r3, [sp, #0]
     4be:	2304      	movs	r3, #4
     4c0:	4a0b      	ldr	r2, [pc, #44]	; (4f0 <transfer_image+0xe0>)
     4c2:	2110      	movs	r1, #16
     4c4:	2000      	movs	r0, #0
     4c6:	f001 fa79 	bl	19bc <am_hal_iom_i2c_write>

        //
        // Update the loop variables.
        //
        ui32BytesRemaining -= ui32TransferSize;
     4ca:	68fa      	ldr	r2, [r7, #12]
     4cc:	683b      	ldr	r3, [r7, #0]
     4ce:	1ad3      	subs	r3, r2, r3
     4d0:	60fb      	str	r3, [r7, #12]
        ui32Offset += ui32TransferSize;
     4d2:	68ba      	ldr	r2, [r7, #8]
     4d4:	683b      	ldr	r3, [r7, #0]
     4d6:	4413      	add	r3, r2
     4d8:	60bb      	str	r3, [r7, #8]
    // Send the firmware image across.
    //
    ui32BytesRemaining = IMAGE_SIZE;
    ui32Offset = 0;

    while ( ui32BytesRemaining )
     4da:	68fb      	ldr	r3, [r7, #12]
     4dc:	2b00      	cmp	r3, #0
     4de:	d1a0      	bne.n	422 <transfer_image+0x12>
        // Update the loop variables.
        //
        ui32BytesRemaining -= ui32TransferSize;
        ui32Offset += ui32TransferSize;
    }
}
     4e0:	bf00      	nop
     4e2:	3710      	adds	r7, #16
     4e4:	46bd      	mov	sp, r7
     4e6:	bd80      	pop	{r7, pc}
     4e8:	40010080 	.word	0x40010080
     4ec:	10001288 	.word	0x10001288
     4f0:	10001098 	.word	0x10001098
     4f4:	00003338 	.word	0x00003338

000004f8 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
     4f8:	b580      	push	{r7, lr}
     4fa:	b082      	sub	sp, #8
     4fc:	af02      	add	r7, sp, #8
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
     4fe:	2000      	movs	r0, #0
     500:	f000 f9ae 	bl	860 <am_hal_clkgen_sysclk_select>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);
     504:	481e      	ldr	r0, [pc, #120]	; (580 <main+0x88>)
     506:	f000 f915 	bl	734 <am_hal_cachectrl_enable>

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
     50a:	f000 f901 	bl	710 <am_bsp_low_power_init>

    //
    // Setup the pins for IO Master Example.
    //
    configure_pins();
     50e:	f7ff fdd7 	bl	c0 <configure_pins>

    //
    // Initialize IOM 0 in I2C mode at 100KHz
    //
#ifndef AM_PART_APOLLO
    am_hal_iom_pwrctrl_enable(0);
     512:	2000      	movs	r0, #0
     514:	f000 fd64 	bl	fe0 <am_hal_iom_pwrctrl_enable>
#endif
    am_hal_iom_config(0, &g_sIOMConfig);
     518:	491a      	ldr	r1, [pc, #104]	; (584 <main+0x8c>)
     51a:	2000      	movs	r0, #0
     51c:	f000 fd8a 	bl	1034 <am_hal_iom_config>
    //
    // Turn on the IOM for this operation.
    //
    am_bsp_iom_enable(0);
     520:	2000      	movs	r0, #0
     522:	f000 f891 	bl	648 <am_bsp_iom_enable>

    //
    // Force the slave into boot mode.
    //
    start_boot_mode();
     526:	f7ff fe57 	bl	1d8 <start_boot_mode>

    //
    // Wait for the 'READY' from the boot slave, and then send the packet
    // information.
    //
    start_new_image();
     52a:	f7ff fecb 	bl	2c4 <start_new_image>

    //
    // Change the override pin to correspond to a button on the Apollo EVK
    //
    override_pin_set(TARGET_BOARD_OVERRIDE_PIN, 0);
     52e:	2100      	movs	r1, #0
     530:	2012      	movs	r0, #18
     532:	f7ff ff21 	bl	378 <override_pin_set>

    //
    // Wait for another 'READY', and send the actual image across.
    //
    transfer_image();
     536:	f7ff ff6b 	bl	410 <transfer_image>
    //
    // At this point, the slave should send back a either 'CRC OK' or some sort
    // of error. If the CRC was good, we should tell the slave to reset itself
    // and run the new image.
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     53a:	bf00      	nop
     53c:	4b12      	ldr	r3, [pc, #72]	; (588 <main+0x90>)
     53e:	681b      	ldr	r3, [r3, #0]
     540:	f003 0304 	and.w	r3, r3, #4
     544:	2b00      	cmp	r3, #0
     546:	d1f9      	bne.n	53c <main+0x44>
    am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     548:	2300      	movs	r3, #0
     54a:	9300      	str	r3, [sp, #0]
     54c:	2304      	movs	r3, #4
     54e:	4a0f      	ldr	r2, [pc, #60]	; (58c <main+0x94>)
     550:	2110      	movs	r1, #16
     552:	2000      	movs	r0, #0
     554:	f001 fadc 	bl	1b10 <am_hal_iom_i2c_read>

    if ( g_psRxBuffer.words[0] == AM_BOOTLOADER_IMAGE_COMPLETE )
     558:	4b0c      	ldr	r3, [pc, #48]	; (58c <main+0x94>)
     55a:	681b      	ldr	r3, [r3, #0]
     55c:	2b03      	cmp	r3, #3
     55e:	d10e      	bne.n	57e <main+0x86>
    {
        //
        // Make sure the override pin is high so the slave will reboot into
        // application mode when our boot procedure is complete.
        //
        am_hal_gpio_out_bit_set(DRIVE_SLAVE_OVERRIDE_PIN);
     560:	4b0b      	ldr	r3, [pc, #44]	; (590 <main+0x98>)
     562:	2210      	movs	r2, #16
     564:	601a      	str	r2, [r3, #0]
        //
        // If the CRC is correct, send a RESET command.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_RESET;
     566:	4b0b      	ldr	r3, [pc, #44]	; (594 <main+0x9c>)
     568:	2204      	movs	r2, #4
     56a:	601a      	str	r2, [r3, #0]
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     56c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     570:	9300      	str	r3, [sp, #0]
     572:	2304      	movs	r3, #4
     574:	4a07      	ldr	r2, [pc, #28]	; (594 <main+0x9c>)
     576:	2110      	movs	r1, #16
     578:	2000      	movs	r0, #0
     57a:	f001 fa1f 	bl	19bc <am_hal_iom_i2c_write>
    //
    // Loop forever.
    //
    while (1)
    {
    }
     57e:	e7fe      	b.n	57e <main+0x86>
     580:	00004f80 	.word	0x00004f80
     584:	00004f44 	.word	0x00004f44
     588:	40010080 	.word	0x40010080
     58c:	10001288 	.word	0x10001288
     590:	40010090 	.word	0x40010090
     594:	10001098 	.word	0x10001098

00000598 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
     598:	4811      	ldr	r0, [pc, #68]	; (5e0 <zero_loop+0x12>)
     59a:	4912      	ldr	r1, [pc, #72]	; (5e4 <zero_loop+0x16>)
     59c:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
     59e:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
     5a2:	4811      	ldr	r0, [pc, #68]	; (5e8 <zero_loop+0x1a>)
     5a4:	6801      	ldr	r1, [r0, #0]
     5a6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     5aa:	6001      	str	r1, [r0, #0]
     5ac:	f3bf 8f4f 	dsb	sy
     5b0:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
     5b4:	480d      	ldr	r0, [pc, #52]	; (5ec <zero_loop+0x1e>)
     5b6:	490e      	ldr	r1, [pc, #56]	; (5f0 <zero_loop+0x22>)
     5b8:	4a0e      	ldr	r2, [pc, #56]	; (5f4 <zero_loop+0x26>)

000005ba <copy_loop>:
     5ba:	f850 3b04 	ldr.w	r3, [r0], #4
     5be:	f841 3b04 	str.w	r3, [r1], #4
     5c2:	4291      	cmp	r1, r2
     5c4:	dbf9      	blt.n	5ba <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
     5c6:	480c      	ldr	r0, [pc, #48]	; (5f8 <zero_loop+0x2a>)
     5c8:	490c      	ldr	r1, [pc, #48]	; (5fc <zero_loop+0x2e>)
     5ca:	f04f 0200 	mov.w	r2, #0

000005ce <zero_loop>:
     5ce:	4288      	cmp	r0, r1
     5d0:	bfb8      	it	lt
     5d2:	f840 2b04 	strlt.w	r2, [r0], #4
     5d6:	dbfa      	blt.n	5ce <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
     5d8:	f7ff ff8e 	bl	4f8 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
     5dc:	be00      	bkpt	0x0000
}
     5de:	bf00      	nop
     5e0:	e000ed08 	.word	0xe000ed08
     5e4:	00000000 	.word	0x00000000
     5e8:	e000ed88 	.word	0xe000ed88
     5ec:	00005174 	.word	0x00005174
     5f0:	10001000 	.word	0x10001000
     5f4:	10001054 	.word	0x10001054
     5f8:	10001054 	.word	0x10001054
     5fc:	10001520 	.word	0x10001520

00000600 <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
     600:	b480      	push	{r7}
     602:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     604:	e7fe      	b.n	604 <am_nmi_isr+0x4>
     606:	bf00      	nop

00000608 <am_busfault_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_fault_isr(void)
{
     608:	b480      	push	{r7}
     60a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     60c:	e7fe      	b.n	60c <am_busfault_isr+0x4>
     60e:	bf00      	nop

00000610 <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
     610:	b480      	push	{r7}
     612:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     614:	e7fe      	b.n	614 <am_adc_isr+0x4>
     616:	bf00      	nop

00000618 <am_util_delay_us>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_us(uint32_t ui32MicroSeconds)
{
     618:	b580      	push	{r7, lr}
     61a:	b084      	sub	sp, #16
     61c:	af00      	add	r7, sp, #0
     61e:	6078      	str	r0, [r7, #4]
    uint32_t ui32Loops = ui32MicroSeconds *
                          (am_hal_clkgen_sysclk_get() / 3000000);
     620:	f000 f936 	bl	890 <am_hal_clkgen_sysclk_get>
     624:	4602      	mov	r2, r0
     626:	4b07      	ldr	r3, [pc, #28]	; (644 <am_util_delay_us+0x2c>)
     628:	fba3 2302 	umull	r2, r3, r3, r2
     62c:	0c9b      	lsrs	r3, r3, #18
//
//*****************************************************************************
void
am_util_delay_us(uint32_t ui32MicroSeconds)
{
    uint32_t ui32Loops = ui32MicroSeconds *
     62e:	687a      	ldr	r2, [r7, #4]
     630:	fb02 f303 	mul.w	r3, r2, r3
     634:	60fb      	str	r3, [r7, #12]
                          (am_hal_clkgen_sysclk_get() / 3000000);

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
     636:	68f8      	ldr	r0, [r7, #12]
     638:	f000 f946 	bl	8c8 <am_hal_flash_delay>
}
     63c:	bf00      	nop
     63e:	3710      	adds	r7, #16
     640:	46bd      	mov	sp, r7
     642:	bd80      	pop	{r7, pc}
     644:	165e9f81 	.word	0x165e9f81

00000648 <am_bsp_iom_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_iom_enable(uint32_t ui32Module)
{
     648:	b5f0      	push	{r4, r5, r6, r7, lr}
     64a:	b083      	sub	sp, #12
     64c:	4604      	mov	r4, r0
    am_hal_iom_enable(ui32Module);
     64e:	f000 fcdb 	bl	1008 <am_hal_iom_enable>

    //
    // Check that the MISO pin is defined in BSP and we are in SPI mode.
    //
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
     652:	492a      	ldr	r1, [pc, #168]	; (6fc <am_bsp_iom_enable+0xb4>)
     654:	4a2a      	ldr	r2, [pc, #168]	; (700 <am_bsp_iom_enable+0xb8>)
     656:	f851 3034 	ldr.w	r3, [r1, r4, lsl #3]
     65a:	4293      	cmp	r3, r2
     65c:	d04c      	beq.n	6f8 <am_bsp_iom_enable+0xb0>
         (1 == AM_BFRn(IOMSTR, ui32Module, CFG, IFCSEL) ) )
     65e:	f504 20a0 	add.w	r0, r4, #327680	; 0x50000
     662:	3004      	adds	r0, #4
     664:	0305      	lsls	r5, r0, #12
     666:	f8d5 611c 	ldr.w	r6, [r5, #284]	; 0x11c
    am_hal_iom_enable(ui32Module);

    //
    // Check that the MISO pin is defined in BSP and we are in SPI mode.
    //
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
     66a:	07f2      	lsls	r2, r6, #31
     66c:	d544      	bpl.n	6f8 <am_bsp_iom_enable+0xb0>
         (1 == AM_BFRn(IOMSTR, ui32Module, CFG, IFCSEL) ) )
    {
        am_hal_gpio_pin_config(g_SPIpins[ui32Module][0],
     66e:	2b31      	cmp	r3, #49	; 0x31
     670:	d842      	bhi.n	6f8 <am_bsp_iom_enable+0xb0>
     672:	f3ef 8710 	mrs	r7, PRIMASK
     676:	9701      	str	r7, [sp, #4]
     678:	b672      	cpsid	i
     67a:	eb01 0ec4 	add.w	lr, r1, r4, lsl #3
     67e:	4821      	ldr	r0, [pc, #132]	; (704 <am_bsp_iom_enable+0xbc>)
     680:	f8de 2004 	ldr.w	r2, [lr, #4]
     684:	f8df c084 	ldr.w	ip, [pc, #132]	; 70c <am_bsp_iom_enable+0xc4>
     688:	4d1f      	ldr	r5, [pc, #124]	; (708 <am_bsp_iom_enable+0xc0>)
     68a:	085c      	lsrs	r4, r3, #1
     68c:	f004 077c 	and.w	r7, r4, #124	; 0x7c
     690:	009e      	lsls	r6, r3, #2
     692:	2173      	movs	r1, #115	; 0x73
     694:	6001      	str	r1, [r0, #0]
     696:	f006 041c 	and.w	r4, r6, #28
     69a:	f3c2 2102 	ubfx	r1, r2, #8, #3
     69e:	2607      	movs	r6, #7
     6a0:	fa01 fe04 	lsl.w	lr, r1, r4
     6a4:	40a6      	lsls	r6, r4
     6a6:	f857 400c 	ldr.w	r4, [r7, ip]
     6aa:	ea24 0106 	bic.w	r1, r4, r6
     6ae:	f003 06fc 	and.w	r6, r3, #252	; 0xfc
     6b2:	ea4e 0401 	orr.w	r4, lr, r1
     6b6:	f106 4e80 	add.w	lr, r6, #1073741824	; 0x40000000
     6ba:	f847 400c 	str.w	r4, [r7, ip]
     6be:	f50e 3e80 	add.w	lr, lr, #65536	; 0x10000
     6c2:	00db      	lsls	r3, r3, #3
     6c4:	f003 0318 	and.w	r3, r3, #24
     6c8:	21ff      	movs	r1, #255	; 0xff
     6ca:	f8de 7000 	ldr.w	r7, [lr]
     6ce:	4099      	lsls	r1, r3
     6d0:	43c9      	mvns	r1, r1
     6d2:	b2d4      	uxtb	r4, r2
     6d4:	400f      	ands	r7, r1
     6d6:	409c      	lsls	r4, r3
     6d8:	433c      	orrs	r4, r7
     6da:	f8ce 4000 	str.w	r4, [lr]
     6de:	5977      	ldr	r7, [r6, r5]
     6e0:	f3c2 4c07 	ubfx	ip, r2, #16, #8
     6e4:	fa0c f303 	lsl.w	r3, ip, r3
     6e8:	4039      	ands	r1, r7
     6ea:	430b      	orrs	r3, r1
     6ec:	2200      	movs	r2, #0
     6ee:	5173      	str	r3, [r6, r5]
     6f0:	6002      	str	r2, [r0, #0]
     6f2:	9801      	ldr	r0, [sp, #4]
     6f4:	f380 8810 	msr	PRIMASK, r0
                               g_SPIpins[ui32Module][1]);
    }
}
     6f8:	b003      	add	sp, #12
     6fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
     6fc:	00004f50 	.word	0x00004f50
     700:	deadbeef 	.word	0xdeadbeef
     704:	40010060 	.word	0x40010060
     708:	400100e0 	.word	0x400100e0
     70c:	40010040 	.word	0x40010040

00000710 <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
     710:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_pwrctrl_bucks_init();
     712:	f001 fbff 	bl	1f14 <am_hal_pwrctrl_bucks_init>

    //
    // Initialize for low power in the power control block
    //
    am_hal_pwrctrl_low_power_init();
     716:	f001 fc6b 	bl	1ff0 <am_hal_pwrctrl_low_power_init>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
     71a:	f001 fdb7 	bl	228c <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
     71e:	2001      	movs	r0, #1
     720:	f001 fd04 	bl	212c <am_hal_rtc_osc_select>

    //
    // Stop the XT and LFRC.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
     724:	2001      	movs	r0, #1
     726:	f000 f8c3 	bl	8b0 <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
}
     72a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_LFRC);

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
     72e:	f001 bd0b 	b.w	2148 <am_hal_rtc_osc_disable>
     732:	bf00      	nop

00000734 <am_hal_cachectrl_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_cachectrl_enable(const am_hal_cachectrl_config_t *psConfig)
{
     734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     736:	4604      	mov	r4, r0
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
     738:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
                       AM_REG_CACHECTRL_CACHECFG_LRU( psConfig->ui32LRU )                                   |
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC0( (psConfig->ui32EnableNCregions & 0x1) >> 0 )   |
     73c:	78a7      	ldrb	r7, [r4, #2]
    // workaround for a timing issue with early versions of Apollo2 that caused
    // the cache to incorrectly mark itself valid during the startup sequence.
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
     73e:	7863      	ldrb	r3, [r4, #1]
     740:	78e2      	ldrb	r2, [r4, #3]
     742:	7925      	ldrb	r5, [r4, #4]
     744:	79a1      	ldrb	r1, [r4, #6]
     746:	00be      	lsls	r6, r7, #2
     748:	ea4f 0e43 	mov.w	lr, r3, lsl #1
     74c:	f006 0304 	and.w	r3, r6, #4
     750:	f00e 0602 	and.w	r6, lr, #2
     754:	431e      	orrs	r6, r3
     756:	f042 0201 	orr.w	r2, r2, #1
     75a:	79e3      	ldrb	r3, [r4, #7]
     75c:	01ed      	lsls	r5, r5, #7
     75e:	4316      	orrs	r6, r2
     760:	b2ed      	uxtb	r5, r5
     762:	7a22      	ldrb	r2, [r4, #8]
     764:	0289      	lsls	r1, r1, #10
     766:	432e      	orrs	r6, r5
     768:	f401 6180 	and.w	r1, r1, #1024	; 0x400
     76c:	7a65      	ldrb	r5, [r4, #9]
     76e:	02db      	lsls	r3, r3, #11
     770:	430e      	orrs	r6, r1
     772:	f403 6300 	and.w	r3, r3, #2048	; 0x800
     776:	0312      	lsls	r2, r2, #12
     778:	7aa1      	ldrb	r1, [r4, #10]
     77a:	431e      	orrs	r6, r3
     77c:	042d      	lsls	r5, r5, #16
     77e:	b293      	uxth	r3, r2
     780:	7ae2      	ldrb	r2, [r4, #11]
     782:	431e      	orrs	r6, r3
     784:	0509      	lsls	r1, r1, #20
     786:	f405 2370 	and.w	r3, r5, #983040	; 0xf0000
     78a:	0612      	lsls	r2, r2, #24
     78c:	4333      	orrs	r3, r6
     78e:	f401 1680 	and.w	r6, r1, #1048576	; 0x100000
     792:	00bf      	lsls	r7, r7, #2
     794:	f002 7180 	and.w	r1, r2, #16777216	; 0x1000000
     798:	4333      	orrs	r3, r6
     79a:	430b      	orrs	r3, r1
     79c:	f007 0508 	and.w	r5, r7, #8
     7a0:	431d      	orrs	r5, r3
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
     7a2:	f001 faaf 	bl	1d04 <am_hal_pwrctrl_memory_enable>

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     7a6:	482c      	ldr	r0, [pc, #176]	; (858 <am_hal_cachectrl_enable+0x124>)
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
     7a8:	4b2c      	ldr	r3, [pc, #176]	; (85c <am_hal_cachectrl_enable+0x128>)
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     7aa:	6005      	str	r5, [r0, #0]
     7ac:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
     7ae:	681e      	ldr	r6, [r3, #0]
     7b0:	0777      	lsls	r7, r6, #29
     7b2:	d41e      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7b4:	681f      	ldr	r7, [r3, #0]
     7b6:	077e      	lsls	r6, r7, #29
     7b8:	f102 32ff 	add.w	r2, r2, #4294967295
     7bc:	d419      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7be:	6819      	ldr	r1, [r3, #0]
     7c0:	074f      	lsls	r7, r1, #29
     7c2:	d416      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7c4:	6818      	ldr	r0, [r3, #0]
     7c6:	0746      	lsls	r6, r0, #29
     7c8:	d413      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7ca:	681e      	ldr	r6, [r3, #0]
     7cc:	0770      	lsls	r0, r6, #29
     7ce:	d410      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7d0:	681f      	ldr	r7, [r3, #0]
     7d2:	0779      	lsls	r1, r7, #29
     7d4:	d40d      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7d6:	6819      	ldr	r1, [r3, #0]
     7d8:	074f      	lsls	r7, r1, #29
     7da:	d40a      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7dc:	6818      	ldr	r0, [r3, #0]
     7de:	0746      	lsls	r6, r0, #29
     7e0:	d407      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7e2:	681e      	ldr	r6, [r3, #0]
     7e4:	0770      	lsls	r0, r6, #29
     7e6:	d404      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
     7e8:	681f      	ldr	r7, [r3, #0]
     7ea:	0779      	lsls	r1, r7, #29
     7ec:	d401      	bmi.n	7f2 <am_hal_cachectrl_enable+0xbe>
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;

    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
     7ee:	3a09      	subs	r2, #9
     7f0:	d1dd      	bne.n	7ae <am_hal_cachectrl_enable+0x7a>
    }

    //
    // Manually invalidate the cache (workaround for the issue described above.)
    //
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);
     7f2:	4b1a      	ldr	r3, [pc, #104]	; (85c <am_hal_cachectrl_enable+0x128>)
     7f4:	681a      	ldr	r2, [r3, #0]
     7f6:	f042 0101 	orr.w	r1, r2, #1
     7fa:	6019      	str	r1, [r3, #0]
     7fc:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
     7fe:	6818      	ldr	r0, [r3, #0]
     800:	0740      	lsls	r0, r0, #29
     802:	d41e      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     804:	681e      	ldr	r6, [r3, #0]
     806:	0771      	lsls	r1, r6, #29
     808:	f102 32ff 	add.w	r2, r2, #4294967295
     80c:	d419      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     80e:	681f      	ldr	r7, [r3, #0]
     810:	077f      	lsls	r7, r7, #29
     812:	d416      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     814:	6819      	ldr	r1, [r3, #0]
     816:	074e      	lsls	r6, r1, #29
     818:	d413      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     81a:	6818      	ldr	r0, [r3, #0]
     81c:	0740      	lsls	r0, r0, #29
     81e:	d410      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     820:	681e      	ldr	r6, [r3, #0]
     822:	0771      	lsls	r1, r6, #29
     824:	d40d      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     826:	681f      	ldr	r7, [r3, #0]
     828:	077f      	lsls	r7, r7, #29
     82a:	d40a      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     82c:	6819      	ldr	r1, [r3, #0]
     82e:	074e      	lsls	r6, r1, #29
     830:	d407      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     832:	6818      	ldr	r0, [r3, #0]
     834:	0740      	lsls	r0, r0, #29
     836:	d404      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
     838:	681e      	ldr	r6, [r3, #0]
     83a:	0771      	lsls	r1, r6, #29
     83c:	d401      	bmi.n	842 <am_hal_cachectrl_enable+0x10e>
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);

    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
     83e:	3a09      	subs	r2, #9
     840:	d1dd      	bne.n	7fe <am_hal_cachectrl_enable+0xca>

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
     842:	7964      	ldrb	r4, [r4, #5]
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     844:	4f04      	ldr	r7, [pc, #16]	; (858 <am_hal_cachectrl_enable+0x124>)

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
     846:	0223      	lsls	r3, r4, #8
     848:	f403 7100 	and.w	r1, r3, #512	; 0x200
     84c:	f403 7280 	and.w	r2, r3, #256	; 0x100
     850:	4311      	orrs	r1, r2
     852:	4329      	orrs	r1, r5
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     854:	6039      	str	r1, [r7, #0]
     856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     858:	40018000 	.word	0x40018000
     85c:	40018008 	.word	0x40018008

00000860 <am_hal_clkgen_sysclk_select>:
//! @return None.
//
//*****************************************************************************
void
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
     860:	b510      	push	{r4, lr}
    am_hal_debug_assert_msg(ui32ClockSetting == AM_HAL_CLKGEN_SYSCLK_48MHZ,
     862:	4604      	mov	r4, r0
     864:	b120      	cbz	r0, 870 <am_hal_clkgen_sysclk_select+0x10>
     866:	4a06      	ldr	r2, [pc, #24]	; (880 <am_hal_clkgen_sysclk_select+0x20>)
     868:	4806      	ldr	r0, [pc, #24]	; (884 <am_hal_clkgen_sysclk_select+0x24>)
     86a:	2150      	movs	r1, #80	; 0x50
     86c:	f000 f82a 	bl	8c4 <am_hal_debug_error>
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     870:	4b05      	ldr	r3, [pc, #20]	; (888 <am_hal_clkgen_sysclk_select+0x28>)

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
     872:	4906      	ldr	r1, [pc, #24]	; (88c <am_hal_clkgen_sysclk_select+0x2c>)
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     874:	2047      	movs	r0, #71	; 0x47
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
     876:	2200      	movs	r2, #0
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     878:	6018      	str	r0, [r3, #0]

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
     87a:	600c      	str	r4, [r1, #0]

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
     87c:	601a      	str	r2, [r3, #0]
     87e:	bd10      	pop	{r4, pc}
     880:	00004f8c 	.word	0x00004f8c
     884:	00004fc4 	.word	0x00004fc4
     888:	40004014 	.word	0x40004014
     88c:	40004018 	.word	0x40004018

00000890 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
     890:	4b04      	ldr	r3, [pc, #16]	; (8a4 <am_hal_clkgen_sysclk_get+0x14>)

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
     892:	4905      	ldr	r1, [pc, #20]	; (8a8 <am_hal_clkgen_sysclk_get+0x18>)
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
     894:	681a      	ldr	r2, [r3, #0]

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
     896:	4805      	ldr	r0, [pc, #20]	; (8ac <am_hal_clkgen_sysclk_get+0x1c>)
    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;

    switch ( ui32ClockSetting )
     898:	f012 0f01 	tst.w	r2, #1
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC_DIV2:
            return 24000000;
        default:
            return 0xFFFFFFFF;
    }
}
     89c:	bf08      	it	eq
     89e:	4608      	moveq	r0, r1
     8a0:	4770      	bx	lr
     8a2:	bf00      	nop
     8a4:	40004018 	.word	0x40004018
     8a8:	02dc6c00 	.word	0x02dc6c00
     8ac:	016e3600 	.word	0x016e3600

000008b0 <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
     8b0:	0783      	lsls	r3, r0, #30
     8b2:	d003      	beq.n	8bc <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
     8b4:	4a02      	ldr	r2, [pc, #8]	; (8c0 <am_hal_clkgen_osc_stop+0x10>)
     8b6:	6813      	ldr	r3, [r2, #0]
     8b8:	4318      	orrs	r0, r3
     8ba:	6010      	str	r0, [r2, #0]
     8bc:	4770      	bx	lr
     8be:	bf00      	nop
     8c0:	4000400c 	.word	0x4000400c

000008c4 <am_hal_debug_error>:
__weak void
#else
void __attribute__((weak))
#endif
am_hal_debug_error(const char *pcFile, uint32_t ui32Line, const char *pcMessage)
{
     8c4:	e7fe      	b.n	8c4 <am_hal_debug_error>
     8c6:	bf00      	nop

000008c8 <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     8c8:	4b01      	ldr	r3, [pc, #4]	; (8d0 <am_hal_flash_delay+0x8>)
     8ca:	6b59      	ldr	r1, [r3, #52]	; 0x34
     8cc:	4708      	bx	r1
     8ce:	bf00      	nop
     8d0:	10001000 	.word	0x10001000

000008d4 <am_hal_flash_delay_status_change>:
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
     8d4:	2800      	cmp	r0, #0
     8d6:	f000 80bb 	beq.w	a50 <am_hal_flash_delay_status_change+0x17c>
//
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
     8da:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     8de:	f100 3aff 	add.w	sl, r0, #4294967295
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     8e2:	6808      	ldr	r0, [r1, #0]
     8e4:	4010      	ands	r0, r2
     8e6:	4283      	cmp	r3, r0
     8e8:	f000 80ac 	beq.w	a44 <am_hal_flash_delay_status_change+0x170>
     8ec:	f01a 0907 	ands.w	r9, sl, #7
     8f0:	461c      	mov	r4, r3
     8f2:	4615      	mov	r5, r2
     8f4:	460e      	mov	r6, r1
     8f6:	f04f 0700 	mov.w	r7, #0
     8fa:	f8df 8158 	ldr.w	r8, [pc, #344]	; a54 <am_hal_flash_delay_status_change+0x180>
     8fe:	d056      	beq.n	9ae <am_hal_flash_delay_status_change+0xda>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     900:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     904:	200c      	movs	r0, #12
     906:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     908:	6831      	ldr	r1, [r6, #0]
     90a:	4029      	ands	r1, r5
     90c:	42a1      	cmp	r1, r4
     90e:	f04f 0701 	mov.w	r7, #1
     912:	f000 8097 	beq.w	a44 <am_hal_flash_delay_status_change+0x170>
     916:	45b9      	cmp	r9, r7
     918:	d049      	beq.n	9ae <am_hal_flash_delay_status_change+0xda>
     91a:	f1b9 0f02 	cmp.w	r9, #2
     91e:	d03c      	beq.n	99a <am_hal_flash_delay_status_change+0xc6>
     920:	f1b9 0f03 	cmp.w	r9, #3
     924:	d02f      	beq.n	986 <am_hal_flash_delay_status_change+0xb2>
     926:	f1b9 0f04 	cmp.w	r9, #4
     92a:	d022      	beq.n	972 <am_hal_flash_delay_status_change+0x9e>
     92c:	f1b9 0f05 	cmp.w	r9, #5
     930:	d015      	beq.n	95e <am_hal_flash_delay_status_change+0x8a>
     932:	f1b9 0f06 	cmp.w	r9, #6
     936:	d008      	beq.n	94a <am_hal_flash_delay_status_change+0x76>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     938:	200c      	movs	r0, #12
     93a:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     93e:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     940:	6830      	ldr	r0, [r6, #0]
     942:	4028      	ands	r0, r5
     944:	42a0      	cmp	r0, r4
     946:	443f      	add	r7, r7
     948:	d07c      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     94a:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     94e:	200c      	movs	r0, #12
     950:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     952:	6831      	ldr	r1, [r6, #0]
     954:	4029      	ands	r1, r5
     956:	42a1      	cmp	r1, r4
     958:	f107 0701 	add.w	r7, r7, #1
     95c:	d072      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     95e:	200c      	movs	r0, #12
     960:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     964:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     966:	6830      	ldr	r0, [r6, #0]
     968:	4028      	ands	r0, r5
     96a:	42a0      	cmp	r0, r4
     96c:	f107 0701 	add.w	r7, r7, #1
     970:	d068      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     972:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     976:	200c      	movs	r0, #12
     978:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     97a:	6831      	ldr	r1, [r6, #0]
     97c:	4029      	ands	r1, r5
     97e:	42a1      	cmp	r1, r4
     980:	f107 0701 	add.w	r7, r7, #1
     984:	d05e      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     986:	200c      	movs	r0, #12
     988:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     98c:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     98e:	6830      	ldr	r0, [r6, #0]
     990:	4028      	ands	r0, r5
     992:	42a0      	cmp	r0, r4
     994:	f107 0701 	add.w	r7, r7, #1
     998:	d054      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     99a:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     99e:	200c      	movs	r0, #12
     9a0:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9a2:	6831      	ldr	r1, [r6, #0]
     9a4:	4029      	ands	r1, r5
     9a6:	42a1      	cmp	r1, r4
     9a8:	f107 0701 	add.w	r7, r7, #1
     9ac:	d04a      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9ae:	200c      	movs	r0, #12
     9b0:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     9b4:	4790      	blx	r2
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
     9b6:	4557      	cmp	r7, sl
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9b8:	f04f 000c 	mov.w	r0, #12
     9bc:	f107 0708 	add.w	r7, r7, #8
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
     9c0:	d043      	beq.n	a4a <am_hal_flash_delay_status_change+0x176>
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9c2:	6833      	ldr	r3, [r6, #0]
     9c4:	402b      	ands	r3, r5
     9c6:	42a3      	cmp	r3, r4
     9c8:	d03c      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9ca:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
     9ce:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9d0:	6832      	ldr	r2, [r6, #0]
     9d2:	402a      	ands	r2, r5
     9d4:	42a2      	cmp	r2, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9d6:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9da:	d033      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9dc:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     9e0:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9e2:	6831      	ldr	r1, [r6, #0]
     9e4:	4029      	ands	r1, r5
     9e6:	42a1      	cmp	r1, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9e8:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9ec:	d02a      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9ee:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     9f2:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9f4:	6833      	ldr	r3, [r6, #0]
     9f6:	402b      	ands	r3, r5
     9f8:	42a3      	cmp	r3, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9fa:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9fe:	d021      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a00:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
     a04:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a06:	6832      	ldr	r2, [r6, #0]
     a08:	402a      	ands	r2, r5
     a0a:	42a2      	cmp	r2, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a0c:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a10:	d018      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a12:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     a16:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a18:	6831      	ldr	r1, [r6, #0]
     a1a:	4029      	ands	r1, r5
     a1c:	42a1      	cmp	r1, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a1e:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a22:	d00f      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a24:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     a28:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a2a:	6833      	ldr	r3, [r6, #0]
     a2c:	402b      	ands	r3, r5
     a2e:	42a3      	cmp	r3, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a30:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a34:	d006      	beq.n	a44 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a36:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
     a3a:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a3c:	6830      	ldr	r0, [r6, #0]
     a3e:	4028      	ands	r0, r5
     a40:	42a0      	cmp	r0, r4
     a42:	d1b4      	bne.n	9ae <am_hal_flash_delay_status_change+0xda>
        {
            return 1;
     a44:	2001      	movs	r0, #1
     a46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        // Call the BOOTROM cycle function to delay for about 1 microsecond.
        //
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
    }

    return 0;
     a4a:	2000      	movs	r0, #0
     a4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     a50:	2000      	movs	r0, #0
} // am_hal_flash_delay_status_change()
     a52:	4770      	bx	lr
     a54:	10001000 	.word	0x10001000

00000a58 <am_hal_gpio_int_clear>:
//! @return None
//
//*****************************************************************************
void
am_hal_gpio_int_clear(uint64_t ui64InterruptMask)
{
     a58:	b082      	sub	sp, #8
    //
    // Clear the interrupts.
    //
    AM_CRITICAL_BEGIN_ASM
     a5a:	f3ef 8310 	mrs	r3, PRIMASK
     a5e:	9301      	str	r3, [sp, #4]
     a60:	b672      	cpsid	i
    AM_REG(GPIO, INT1CLR) = (ui64InterruptMask >> 32);
     a62:	4a04      	ldr	r2, [pc, #16]	; (a74 <am_hal_gpio_int_clear+0x1c>)
    AM_REG(GPIO, INT0CLR) = (ui64InterruptMask & 0xFFFFFFFF);
     a64:	4b04      	ldr	r3, [pc, #16]	; (a78 <am_hal_gpio_int_clear+0x20>)
{
    //
    // Clear the interrupts.
    //
    AM_CRITICAL_BEGIN_ASM
    AM_REG(GPIO, INT1CLR) = (ui64InterruptMask >> 32);
     a66:	6011      	str	r1, [r2, #0]
    AM_REG(GPIO, INT0CLR) = (ui64InterruptMask & 0xFFFFFFFF);
     a68:	6018      	str	r0, [r3, #0]
    AM_CRITICAL_END_ASM
     a6a:	9801      	ldr	r0, [sp, #4]
     a6c:	f380 8810 	msr	PRIMASK, r0
}
     a70:	b002      	add	sp, #8
     a72:	4770      	bx	lr
     a74:	40010218 	.word	0x40010218
     a78:	40010208 	.word	0x40010208

00000a7c <am_hal_gpio_int_status_get>:
//! @return None
//
//*****************************************************************************
uint64_t
am_hal_gpio_int_status_get(bool bEnabledOnly)
{
     a7c:	b4f0      	push	{r4, r5, r6, r7}
    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
     a7e:	f3ef 8310 	mrs	r3, PRIMASK
//! @return None
//
//*****************************************************************************
uint64_t
am_hal_gpio_int_status_get(bool bEnabledOnly)
{
     a82:	b082      	sub	sp, #8
    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
     a84:	9301      	str	r3, [sp, #4]
     a86:	b672      	cpsid	i
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     a88:	4a0e      	ldr	r2, [pc, #56]	; (ac4 <am_hal_gpio_int_status_get+0x48>)
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     a8a:	490f      	ldr	r1, [pc, #60]	; (ac8 <am_hal_gpio_int_status_get+0x4c>)
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     a8c:	6814      	ldr	r4, [r2, #0]
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     a8e:	680d      	ldr	r5, [r1, #0]
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     a90:	f04f 0c00 	mov.w	ip, #0
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     a94:	ea4c 0605 	orr.w	r6, ip, r5
     a98:	4627      	mov	r7, r4

    if ( bEnabledOnly )
     a9a:	b170      	cbz	r0, aba <am_hal_gpio_int_status_get+0x3e>
    {
        ui64Mask    = ((uint64_t) AM_REGn(GPIO, 0, INT1EN)) << 32;
     a9c:	480b      	ldr	r0, [pc, #44]	; (acc <am_hal_gpio_int_status_get+0x50>)
        ui64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0EN)) << 0;
     a9e:	4b0c      	ldr	r3, [pc, #48]	; (ad0 <am_hal_gpio_int_status_get+0x54>)
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;

    if ( bEnabledOnly )
    {
        ui64Mask    = ((uint64_t) AM_REGn(GPIO, 0, INT1EN)) << 32;
     aa0:	6802      	ldr	r2, [r0, #0]
        ui64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0EN)) << 0;
     aa2:	6819      	ldr	r1, [r3, #0]
     aa4:	ea4c 0001 	orr.w	r0, ip, r1
     aa8:	4611      	mov	r1, r2
    }

    ui64RetVal &= ui64Mask;
    AM_CRITICAL_END_ASM
     aaa:	9b01      	ldr	r3, [sp, #4]
     aac:	f383 8810 	msr	PRIMASK, r3

    return ui64RetVal;
}
     ab0:	4030      	ands	r0, r6
     ab2:	4039      	ands	r1, r7
     ab4:	b002      	add	sp, #8
     ab6:	bcf0      	pop	{r4, r5, r6, r7}
     ab8:	4770      	bx	lr
    uint64_t ui64RetVal, ui64Mask;

    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;
     aba:	f04f 30ff 	mov.w	r0, #4294967295
     abe:	f04f 31ff 	mov.w	r1, #4294967295
     ac2:	e7f2      	b.n	aaa <am_hal_gpio_int_status_get+0x2e>
     ac4:	40010214 	.word	0x40010214
     ac8:	40010204 	.word	0x40010204
     acc:	40010210 	.word	0x40010210
     ad0:	40010200 	.word	0x40010200

00000ad4 <am_hal_iom_sleeping_queue_flush>:
    uint32_t ui32Critical;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     ad4:	2805      	cmp	r0, #5
     ad6:	d819      	bhi.n	b0c <am_hal_iom_sleeping_queue_flush+0x38>
//! implementations expect to control sleep behavior).
//
//*****************************************************************************
void
am_hal_iom_sleeping_queue_flush(uint32_t ui32Module)
{
     ad8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     ada:	4b0d      	ldr	r3, [pc, #52]	; (b10 <am_hal_iom_sleeping_queue_flush+0x3c>)
     adc:	4e0d      	ldr	r6, [pc, #52]	; (b14 <am_hal_iom_sleeping_queue_flush+0x40>)

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
            am_hal_queue_empty(&g_psIOMQueue[ui32Module]) )
     ade:	eb00 0740 	add.w	r7, r0, r0, lsl #1
     ae2:	4604      	mov	r4, r0
     ae4:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
    while ( bWaiting )
    {
        //
        // Start a critical section.
        //
        ui32Critical = am_hal_interrupt_master_disable();
     ae8:	f002 fc1e 	bl	3328 <am_hal_interrupt_master_disable>

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
     aec:	5d31      	ldrb	r1, [r6, r4]
    while ( bWaiting )
    {
        //
        // Start a critical section.
        //
        ui32Critical = am_hal_interrupt_master_disable();
     aee:	4605      	mov	r5, r0

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
     af0:	b929      	cbnz	r1, afe <am_hal_iom_sleeping_queue_flush+0x2a>
     af2:	68ba      	ldr	r2, [r7, #8]
     af4:	b91a      	cbnz	r2, afe <am_hal_iom_sleeping_queue_flush+0x2a>
        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
    }
}
     af6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        }

        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
     afa:	f002 bc19 	b.w	3330 <am_hal_interrupt_master_set>
        else
        {
            //
            // Otherwise, we should sleep until the interface is actually free.
            //
            am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_NORMAL);
     afe:	2000      	movs	r0, #0
     b00:	f001 fb2a 	bl	2158 <am_hal_sysctrl_sleep>
        }

        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
     b04:	4628      	mov	r0, r5
     b06:	f002 fc13 	bl	3330 <am_hal_interrupt_master_set>
     b0a:	e7ed      	b.n	ae8 <am_hal_iom_sleeping_queue_flush+0x14>
     b0c:	4770      	bx	lr
     b0e:	bf00      	nop
     b10:	10001418 	.word	0x10001418
     b14:	1000105c 	.word	0x1000105c

00000b18 <am_hal_iom_i2c_cmd_run.part.1>:
//!
//! @return 0 on success
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_cmd_run(uint32_t ui32Operation, uint32_t ui32Module,
     b18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     b1c:	b089      	sub	sp, #36	; 0x24
    for ( index = 0; index < (sizeof(g_I2CPads) / sizeof(I2CPad_t)); index++ )
    {
        //
        //  Is this for the IOM that we are using?
        //
        if ( g_I2CPads[index].module == ui32Module )
     b1e:	2900      	cmp	r1, #0
     b20:	d06a      	beq.n	bf8 <am_hal_iom_i2c_cmd_run.part.1+0xe0>
     b22:	2901      	cmp	r1, #1
     b24:	d00d      	beq.n	b42 <am_hal_iom_i2c_cmd_run.part.1+0x2a>
     b26:	2902      	cmp	r1, #2
     b28:	d01a      	beq.n	b60 <am_hal_iom_i2c_cmd_run.part.1+0x48>
     b2a:	2903      	cmp	r1, #3
     b2c:	d030      	beq.n	b90 <am_hal_iom_i2c_cmd_run.part.1+0x78>
     b2e:	2904      	cmp	r1, #4
     b30:	d040      	beq.n	bb4 <am_hal_iom_i2c_cmd_run.part.1+0x9c>
     b32:	2905      	cmp	r1, #5
     b34:	d050      	beq.n	bd8 <am_hal_iom_i2c_cmd_run.part.1+0xc0>
     b36:	2902      	cmp	r1, #2
     b38:	d019      	beq.n	b6e <am_hal_iom_i2c_cmd_run.part.1+0x56>
        }
    }
    if (0xDEADBEEF == ui32IOMGPIO)
    {
        // SCL has not been configured
        return AM_HAL_IOM_ERR_INVALID_CFG;
     b3a:	2004      	movs	r0, #4
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    }
    return ui32Status;
}
     b3c:	b009      	add	sp, #36	; 0x24
     b3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     b42:	4d6f      	ldr	r5, [pc, #444]	; (d00 <am_hal_iom_i2c_cmd_run.part.1+0x1e8>)
     b44:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
     b46:	f3c7 04c2 	ubfx	r4, r7, #3, #3
     b4a:	2c00      	cmp	r4, #0
     b4c:	d1f5      	bne.n	b3a <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     b4e:	f04f 0e08 	mov.w	lr, #8
     b52:	26ff      	movs	r6, #255	; 0xff
     b54:	9403      	str	r4, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     b56:	46f3      	mov	fp, lr
     b58:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     b5c:	9604      	str	r6, [sp, #16]
     b5e:	e05b      	b.n	c18 <am_hal_iom_i2c_cmd_run.part.1+0x100>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     b60:	4d68      	ldr	r5, [pc, #416]	; (d04 <am_hal_iom_i2c_cmd_run.part.1+0x1ec>)
     b62:	682c      	ldr	r4, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
     b64:	f3c4 06c2 	ubfx	r6, r4, #3, #3
     b68:	2e07      	cmp	r6, #7
     b6a:	f000 80c1 	beq.w	cf0 <am_hal_iom_i2c_cmd_run.part.1+0x1d8>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     b6e:	4d66      	ldr	r5, [pc, #408]	; (d08 <am_hal_iom_i2c_cmd_run.part.1+0x1f0>)
     b70:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
     b72:	f3c7 64c2 	ubfx	r4, r7, #27, #3
     b76:	2c04      	cmp	r4, #4
     b78:	d1df      	bne.n	b3a <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     b7a:	2618      	movs	r6, #24
     b7c:	f04f 0e1b 	mov.w	lr, #27
     b80:	f04f 477f 	mov.w	r7, #4278190080	; 0xff000000
     b84:	9603      	str	r6, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     b86:	46b3      	mov	fp, r6
     b88:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     b8c:	9704      	str	r7, [sp, #16]
     b8e:	e043      	b.n	c18 <am_hal_iom_i2c_cmd_run.part.1+0x100>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     b90:	4d5e      	ldr	r5, [pc, #376]	; (d0c <am_hal_iom_i2c_cmd_run.part.1+0x1f4>)
     b92:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
     b94:	f3c7 44c2 	ubfx	r4, r7, #19, #3
     b98:	2c04      	cmp	r4, #4
     b9a:	d1ce      	bne.n	b3a <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     b9c:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
     ba0:	f44f 067f 	mov.w	r6, #16711680	; 0xff0000
     ba4:	2710      	movs	r7, #16
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     ba6:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     baa:	9604      	str	r6, [sp, #16]
     bac:	9703      	str	r7, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     bae:	f04f 0b28 	mov.w	fp, #40	; 0x28
     bb2:	e031      	b.n	c18 <am_hal_iom_i2c_cmd_run.part.1+0x100>
     bb4:	4d56      	ldr	r5, [pc, #344]	; (d10 <am_hal_iom_i2c_cmd_run.part.1+0x1f8>)
     bb6:	682e      	ldr	r6, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
     bb8:	f3c6 67c2 	ubfx	r7, r6, #27, #3
     bbc:	2f04      	cmp	r7, #4
     bbe:	d1bc      	bne.n	b3a <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     bc0:	f04f 0e27 	mov.w	lr, #39	; 0x27
     bc4:	f04f 447f 	mov.w	r4, #4278190080	; 0xff000000
     bc8:	2618      	movs	r6, #24
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     bca:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     bce:	9404      	str	r4, [sp, #16]
     bd0:	9603      	str	r6, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     bd2:	f04f 0b24 	mov.w	fp, #36	; 0x24
     bd6:	e01f      	b.n	c18 <am_hal_iom_i2c_cmd_run.part.1+0x100>
     bd8:	4d4e      	ldr	r5, [pc, #312]	; (d14 <am_hal_iom_i2c_cmd_run.part.1+0x1fc>)
     bda:	682c      	ldr	r4, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
     bdc:	f3c4 06c2 	ubfx	r6, r4, #3, #3
     be0:	2e04      	cmp	r6, #4
     be2:	d1aa      	bne.n	b3a <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     be4:	f04f 0e30 	mov.w	lr, #48	; 0x30
     be8:	27ff      	movs	r7, #255	; 0xff
     bea:	2400      	movs	r4, #0
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     bec:	46f3      	mov	fp, lr
     bee:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     bf2:	9704      	str	r7, [sp, #16]
     bf4:	9403      	str	r4, [sp, #12]
     bf6:	e00f      	b.n	c18 <am_hal_iom_i2c_cmd_run.part.1+0x100>
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     bf8:	4d47      	ldr	r5, [pc, #284]	; (d18 <am_hal_iom_i2c_cmd_run.part.1+0x200>)
     bfa:	682f      	ldr	r7, [r5, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_I2CPads[index].funcsel )
     bfc:	f417 5f60 	tst.w	r7, #14336	; 0x3800
     c00:	d19b      	bne.n	b3a <am_hal_iom_i2c_cmd_run.part.1+0x22>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     c02:	f04f 0e05 	mov.w	lr, #5
     c06:	f44f 447f 	mov.w	r4, #65280	; 0xff00
     c0a:	2608      	movs	r6, #8
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     c0c:	f8cd e014 	str.w	lr, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     c10:	9404      	str	r4, [sp, #16]
     c12:	9603      	str	r6, [sp, #12]
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     c14:	f04f 0b04 	mov.w	fp, #4
     c18:	461e      	mov	r6, r3
    //
    // Save the locations and values of the SCL pin configuration
    // information.
    //
    pui32SCLPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32SCLPadregVal = *pui32SCLPadreg;
     c1a:	682b      	ldr	r3, [r5, #0]
     c1c:	9001      	str	r0, [sp, #4]
     c1e:	460c      	mov	r4, r1
    //
    // Temporarily configure the override pin as an input.
    //
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_PIN_INPUT);
     c20:	f3ef 8010 	mrs	r0, PRIMASK
     c24:	4690      	mov	r8, r2
    //
    // Save the locations and values of the SCL pin configuration
    // information.
    //
    pui32SCLPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32SCLPadregVal = *pui32SCLPadreg;
     c26:	9302      	str	r3, [sp, #8]
    //
    // Temporarily configure the override pin as an input.
    //
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_PIN_INPUT);
     c28:	9007      	str	r0, [sp, #28]
     c2a:	b672      	cpsid	i
     c2c:	f8df 90fc 	ldr.w	r9, [pc, #252]	; d2c <am_hal_iom_i2c_cmd_run.part.1+0x214>
     c30:	4f3a      	ldr	r7, [pc, #232]	; (d1c <am_hal_iom_i2c_cmd_run.part.1+0x204>)
     c32:	f8df c0fc 	ldr.w	ip, [pc, #252]	; d30 <am_hal_iom_i2c_cmd_run.part.1+0x218>
     c36:	ea4f 015e 	mov.w	r1, lr, lsr #1
     c3a:	f001 037c 	and.w	r3, r1, #124	; 0x7c
     c3e:	f04f 0a73 	mov.w	sl, #115	; 0x73
     c42:	f8c9 a000 	str.w	sl, [r9]
     c46:	ea4f 008e 	mov.w	r0, lr, lsl #2
     c4a:	59da      	ldr	r2, [r3, r7]
     c4c:	f000 001c 	and.w	r0, r0, #28
     c50:	2107      	movs	r1, #7
     c52:	4081      	lsls	r1, r0
     c54:	ea22 0201 	bic.w	r2, r2, r1
     c58:	51da      	str	r2, [r3, r7]
     c5a:	9b04      	ldr	r3, [sp, #16]
     c5c:	682f      	ldr	r7, [r5, #0]
     c5e:	9803      	ldr	r0, [sp, #12]
     c60:	43da      	mvns	r2, r3
     c62:	211a      	movs	r1, #26
     c64:	4017      	ands	r7, r2
     c66:	4081      	lsls	r1, r0
     c68:	4339      	orrs	r1, r7
     c6a:	6029      	str	r1, [r5, #0]
     c6c:	f85b 300c 	ldr.w	r3, [fp, ip]
     c70:	2700      	movs	r7, #0
     c72:	401a      	ands	r2, r3
     c74:	f84b 200c 	str.w	r2, [fp, ip]
     c78:	f8c9 7000 	str.w	r7, [r9]
     c7c:	9a07      	ldr	r2, [sp, #28]
     c7e:	f382 8810 	msr	PRIMASK, r2

    //
    // Make sure SCL is high within standard timeout
    //
    waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
     c82:	9b05      	ldr	r3, [sp, #20]
     c84:	4926      	ldr	r1, [pc, #152]	; (d20 <am_hal_iom_i2c_cmd_run.part.1+0x208>)
     c86:	4827      	ldr	r0, [pc, #156]	; (d24 <am_hal_iom_i2c_cmd_run.part.1+0x20c>)
     c88:	f003 021f 	and.w	r2, r3, #31
     c8c:	f04f 0b01 	mov.w	fp, #1
     c90:	ea4f 03de 	mov.w	r3, lr, lsr #3
     c94:	f003 0e04 	and.w	lr, r3, #4
     c98:	fa0b f302 	lsl.w	r3, fp, r2
     c9c:	4471      	add	r1, lr
     c9e:	461a      	mov	r2, r3
     ca0:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
     ca4:	f7ff fe16 	bl	8d4 <am_hal_flash_delay_status_change>
    //
    // Write the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    // Revert back the original settings
    *pui32SCLPadreg = ui32SCLPadregVal;
     ca8:	9902      	ldr	r1, [sp, #8]
                 AM_HAL_GPIO_RD_M(ui32IOMGPIO));

    //
    // Write the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
     caa:	f8c9 a000 	str.w	sl, [r9]
    //
    // Re-lock the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = 0;

    if (waitStatus != 1)
     cae:	4558      	cmp	r0, fp
    //
    // Write the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    // Revert back the original settings
    *pui32SCLPadreg = ui32SCLPadregVal;
     cb0:	6029      	str	r1, [r5, #0]
    //
    // Re-lock the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = 0;
     cb2:	f8c9 7000 	str.w	r7, [r9]

    if (waitStatus != 1)
     cb6:	d003      	beq.n	cc0 <am_hal_iom_i2c_cmd_run.part.1+0x1a8>
    {
        return AM_HAL_IOM_ERR_TIMEOUT;
     cb8:	4658      	mov	r0, fp
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    }
    return ui32Status;
}
     cba:	b009      	add	sp, #36	; 0x24
     cbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= (ui32Options & 0x5C00FF00);
     cc0:	9812      	ldr	r0, [sp, #72]	; 0x48
     cc2:	4d19      	ldr	r5, [pc, #100]	; (d28 <am_hal_iom_i2c_cmd_run.part.1+0x210>)
     cc4:	f020 4223 	bic.w	r2, r0, #2734686208	; 0xa3000000
     cc8:	9801      	ldr	r0, [sp, #4]
     cca:	ea4f 4308 	mov.w	r3, r8, lsl #16
     cce:	f002 21ff 	and.w	r1, r2, #4278255360	; 0xff00ff00
    if (ui32Status == AM_HAL_IOM_SUCCESS)
    {
        //
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
     cd2:	f504 24a0 	add.w	r4, r4, #327680	; 0x50000
     cd6:	3404      	adds	r4, #4
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= (ui32Options & 0x5C00FF00);
     cd8:	401d      	ands	r5, r3
     cda:	4301      	orrs	r1, r0
    if (ui32Status == AM_HAL_IOM_SUCCESS)
    {
        //
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
     cdc:	0322      	lsls	r2, r4, #12
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= (ui32Options & 0x5C00FF00);
     cde:	4329      	orrs	r1, r5
     ce0:	b2f6      	uxtb	r6, r6
     ce2:	430e      	orrs	r6, r1
    if (ui32Status == AM_HAL_IOM_SUCCESS)
    {
        //
        // Write the complete command word to the IOM command register.
        //
        AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
     ce4:	4638      	mov	r0, r7
     ce6:	f8c2 6110 	str.w	r6, [r2, #272]	; 0x110
    }
    return ui32Status;
}
     cea:	b009      	add	sp, #36	; 0x24
     cec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     cf0:	2400      	movs	r4, #0
     cf2:	26ff      	movs	r6, #255	; 0xff
     cf4:	9403      	str	r4, [sp, #12]
     cf6:	46a6      	mov	lr, r4
        if ( g_I2CPads[index].module == ui32Module )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_I2CPads[index].pad))) &
     cf8:	46a3      	mov	fp, r4
     cfa:	9405      	str	r4, [sp, #20]
                             AM_HAL_GPIO_PADREG_M(g_I2CPads[index].pad)) >>
     cfc:	9604      	str	r6, [sp, #16]
     cfe:	e78b      	b.n	c18 <am_hal_iom_i2c_cmd_run.part.1+0x100>
     d00:	40010008 	.word	0x40010008
     d04:	40010000 	.word	0x40010000
     d08:	40010018 	.word	0x40010018
     d0c:	40010028 	.word	0x40010028
     d10:	40010024 	.word	0x40010024
     d14:	40010030 	.word	0x40010030
     d18:	40010004 	.word	0x40010004
     d1c:	40010040 	.word	0x40010040
     d20:	40010080 	.word	0x40010080
     d24:	10001388 	.word	0x10001388
     d28:	03ff0000 	.word	0x03ff0000
     d2c:	40010060 	.word	0x40010060
     d30:	400100e0 	.word	0x400100e0

00000d34 <am_hal_iom_i2c_read_nb.part.9>:
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_read_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
     d34:	b5f0      	push	{r4, r5, r6, r7, lr}

    //
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     d36:	2806      	cmp	r0, #6
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_read_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
     d38:	b083      	sub	sp, #12
     d3a:	461d      	mov	r5, r3

    //
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     d3c:	d02b      	beq.n	d96 <am_hal_iom_i2c_read_nb.part.9+0x62>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
     d3e:	2bff      	cmp	r3, #255	; 0xff
     d40:	4604      	mov	r4, r0
     d42:	d904      	bls.n	d4e <am_hal_iom_i2c_read_nb.part.9+0x1a>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
     d44:	492d      	ldr	r1, [pc, #180]	; (dfc <am_hal_iom_i2c_read_nb.part.9+0xc8>)
     d46:	2003      	movs	r0, #3
     d48:	5508      	strb	r0, [r1, r4]
    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    }
    return ui32Status;
}
     d4a:	b003      	add	sp, #12
     d4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
     d4e:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
     d52:	4e2b      	ldr	r6, [pc, #172]	; (e00 <am_hal_iom_i2c_read_nb.part.9+0xcc>)
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     d54:	4f2b      	ldr	r7, [pc, #172]	; (e04 <am_hal_iom_i2c_read_nb.part.9+0xd0>)
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
     d56:	3004      	adds	r0, #4
     d58:	4696      	mov	lr, r2
     d5a:	0300      	lsls	r0, r0, #12

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
     d5c:	f04f 0c01 	mov.w	ip, #1
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     d60:	eb04 0284 	add.w	r2, r4, r4, lsl #2

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
     d64:	f806 c004 	strb.w	ip, [r6, r4]
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     d68:	0092      	lsls	r2, r2, #2
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
     d6a:	f240 76ff 	movw	r6, #2047	; 0x7ff
     d6e:	f8c0 6208 	str.w	r6, [r0, #520]	; 0x208

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     d72:	18be      	adds	r6, r7, r2
     d74:	f04f 0c02 	mov.w	ip, #2
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
     d78:	9809      	ldr	r0, [sp, #36]	; 0x24

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
     d7a:	f8c6 e004 	str.w	lr, [r6, #4]
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     d7e:	2c05      	cmp	r4, #5
    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
     d80:	60b3      	str	r3, [r6, #8]
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
     d82:	6130      	str	r0, [r6, #16]
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     d84:	f847 c002 	str.w	ip, [r7, r2]
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     d88:	d829      	bhi.n	dde <am_hal_iom_i2c_read_nb.part.9+0xaa>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    if (ui32NumBytes == 0)
     d8a:	bb63      	cbnz	r3, de6 <am_hal_iom_i2c_read_nb.part.9+0xb2>
    {
        return AM_HAL_IOM_ERR_INVALID_PARAM;
     d8c:	2003      	movs	r0, #3
    //
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_READ, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);
    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
     d8e:	4b1b      	ldr	r3, [pc, #108]	; (dfc <am_hal_iom_i2c_read_nb.part.9+0xc8>)
     d90:	5518      	strb	r0, [r3, r4]
    }
    return ui32Status;
}
     d92:	b003      	add	sp, #12
     d94:	bdf0      	pop	{r4, r5, r6, r7, pc}
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
     d96:	9f08      	ldr	r7, [sp, #32]
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
     d98:	004c      	lsls	r4, r1, #1
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
     d9a:	007b      	lsls	r3, r7, #1
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
     d9c:	f044 0601 	orr.w	r6, r4, #1
     da0:	f3c7 7400 	ubfx	r4, r7, #28, #1
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
     da4:	d413      	bmi.n	dce <am_hal_iom_i2c_read_nb.part.9+0x9a>
                                        (uint8_t *)pui32Data, 0, false,
                                        (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
     da6:	4629      	mov	r1, r5
     da8:	9d08      	ldr	r5, [sp, #32]
     daa:	2301      	movs	r3, #1
     dac:	e88d 0018 	stmia.w	sp, {r3, r4}
     db0:	b2f0      	uxtb	r0, r6
     db2:	f3c5 2307 	ubfx	r3, r5, #8, #8
     db6:	f001 fae1 	bl	237c <am_hal_i2c_bit_bang_receive>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
     dba:	4a13      	ldr	r2, [pc, #76]	; (e08 <am_hal_iom_i2c_read_nb.part.9+0xd4>)
     dbc:	4b0f      	ldr	r3, [pc, #60]	; (dfc <am_hal_iom_i2c_read_nb.part.9+0xc8>)
     dbe:	5c17      	ldrb	r7, [r2, r0]
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
     dc0:	9809      	ldr	r0, [sp, #36]	; 0x24
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
     dc2:	719f      	strb	r7, [r3, #6]
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
     dc4:	b168      	cbz	r0, de2 <am_hal_iom_i2c_read_nb.part.9+0xae>
        {
            pfnCallback();
     dc6:	4780      	blx	r0
        }

        return ui32Status;
     dc8:	4638      	mov	r0, r7
    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    }
    return ui32Status;
}
     dca:	b003      	add	sp, #12
     dcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
     dce:	2300      	movs	r3, #0
     dd0:	b2f0      	uxtb	r0, r6
     dd2:	4629      	mov	r1, r5
     dd4:	e88d 0018 	stmia.w	sp, {r3, r4}
     dd8:	f001 fad0 	bl	237c <am_hal_i2c_bit_bang_receive>
     ddc:	e7ed      	b.n	dba <am_hal_iom_i2c_read_nb.part.9+0x86>
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
     dde:	4660      	mov	r0, ip
     de0:	e7d5      	b.n	d8e <am_hal_iom_i2c_read_nb.part.9+0x5a>
        if ( pfnCallback )
        {
            pfnCallback();
        }

        return ui32Status;
     de2:	4638      	mov	r0, r7
     de4:	e7b1      	b.n	d4a <am_hal_iom_i2c_read_nb.part.9+0x16>
     de6:	9d08      	ldr	r5, [sp, #32]
     de8:	9500      	str	r5, [sp, #0]
     dea:	460a      	mov	r2, r1
     dec:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
     df0:	4621      	mov	r1, r4
     df2:	f7ff fe91 	bl	b18 <am_hal_iom_i2c_cmd_run.part.1>
    //
    // Start the read transaction on the bus.
    //
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_READ, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);
    if (ui32Status != AM_HAL_IOM_SUCCESS)
     df6:	2800      	cmp	r0, #0
     df8:	d0a7      	beq.n	d4a <am_hal_iom_i2c_read_nb.part.9+0x16>
     dfa:	e7c8      	b.n	d8e <am_hal_iom_i2c_read_nb.part.9+0x5a>
     dfc:	10001054 	.word	0x10001054
     e00:	1000105c 	.word	0x1000105c
     e04:	100013a0 	.word	0x100013a0
     e08:	00005120 	.word	0x00005120

00000e0c <am_hal_iom_i2c_write_nb.part.8>:
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
     e0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    //
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     e10:	2806      	cmp	r0, #6
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
     e12:	b084      	sub	sp, #16
     e14:	460e      	mov	r6, r1

    //
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     e16:	d024      	beq.n	e62 <am_hal_iom_i2c_write_nb.part.8+0x56>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
     e18:	2bff      	cmp	r3, #255	; 0xff
     e1a:	4604      	mov	r4, r0
     e1c:	d905      	bls.n	e2a <am_hal_iom_i2c_write_nb.part.8+0x1e>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
     e1e:	4e6a      	ldr	r6, [pc, #424]	; (fc8 <am_hal_iom_i2c_write_nb.part.8+0x1bc>)
     e20:	2003      	movs	r0, #3
     e22:	5530      	strb	r0, [r6, r4]
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
     e24:	b004      	add	sp, #16
     e26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
     e2a:	f500 25a0 	add.w	r5, r0, #327680	; 0x50000
     e2e:	3504      	adds	r5, #4
     e30:	032d      	lsls	r5, r5, #12
     e32:	4617      	mov	r7, r2
     e34:	f8d5 211c 	ldr.w	r2, [r5, #284]	; 0x11c
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
     e38:	4964      	ldr	r1, [pc, #400]	; (fcc <am_hal_iom_i2c_write_nb.part.8+0x1c0>)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
     e3a:	f012 0f08 	tst.w	r2, #8
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
     e3e:	f04f 0001 	mov.w	r0, #1

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
     e42:	f240 72ff 	movw	r2, #2047	; 0x7ff
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
     e46:	bf0c      	ite	eq
     e48:	f04f 0880 	moveq.w	r8, #128	; 0x80
     e4c:	f04f 0840 	movne.w	r8, #64	; 0x40
    uint32_t ui32Index;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     e50:	2c05      	cmp	r4, #5
                        ui32MaxFifoSize);

    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    g_bIomBusy[ui32Module] = true;
     e52:	5508      	strb	r0, [r1, r4]

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
     e54:	f8c5 2208 	str.w	r2, [r5, #520]	; 0x208
    uint32_t ui32Index;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     e58:	d92b      	bls.n	eb2 <am_hal_iom_i2c_write_nb.part.8+0xa6>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
     e5a:	2000      	movs	r0, #0
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
     e5c:	b004      	add	sp, #16
     e5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
     e62:	9c0a      	ldr	r4, [sp, #40]	; 0x28
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     e64:	0048      	lsls	r0, r1, #1
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
     e66:	0061      	lsls	r1, r4, #1
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     e68:	f3c4 7500 	ubfx	r5, r4, #28, #1
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
     e6c:	d415      	bmi.n	e9a <am_hal_iom_i2c_write_nb.part.8+0x8e>
                                     (uint8_t *)pui32Data, 0, false,
                                     (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     e6e:	2401      	movs	r4, #1
     e70:	e88d 0030 	stmia.w	sp, {r4, r5}
     e74:	9d0a      	ldr	r5, [sp, #40]	; 0x28
     e76:	4619      	mov	r1, r3
     e78:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
     e7c:	f3c5 2307 	ubfx	r3, r5, #8, #8
     e80:	f001 fed4 	bl	2c2c <am_hal_i2c_bit_bang_send>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
     e84:	4952      	ldr	r1, [pc, #328]	; (fd0 <am_hal_iom_i2c_write_nb.part.8+0x1c4>)
     e86:	4a50      	ldr	r2, [pc, #320]	; (fc8 <am_hal_iom_i2c_write_nb.part.8+0x1bc>)
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
     e88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
     e8a:	5c0f      	ldrb	r7, [r1, r0]
     e8c:	7197      	strb	r7, [r2, #6]
        //
        // The I2C bit-bang interface is actually a blocking transfer, and it
        // doesn't trigger the interrupt handler, so we have to call the
        // callback function manually.
        //
        if ( pfnCallback )
     e8e:	b173      	cbz	r3, eae <am_hal_iom_i2c_write_nb.part.8+0xa2>
        {
            pfnCallback();
     e90:	4798      	blx	r3
        }
        return ui32Status;
     e92:	4638      	mov	r0, r7
        {
            g_iom_error_status[ui32Module] = ui32Status;
        }
    }
    return ui32Status;
}
     e94:	b004      	add	sp, #16
     e96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    {
        // Reset the error status for non-blocking transfer
        g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
        if ( ui32Options & AM_HAL_IOM_RAW )
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     e9a:	2400      	movs	r4, #0
     e9c:	4619      	mov	r1, r3
     e9e:	e88d 0030 	stmia.w	sp, {r4, r5}
     ea2:	4623      	mov	r3, r4
     ea4:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
     ea8:	f001 fec0 	bl	2c2c <am_hal_i2c_bit_bang_send>
     eac:	e7ea      	b.n	e84 <am_hal_iom_i2c_write_nb.part.8+0x78>
        //
        if ( pfnCallback )
        {
            pfnCallback();
        }
        return ui32Status;
     eae:	4638      	mov	r0, r7
     eb0:	e7b8      	b.n	e24 <am_hal_iom_i2c_write_nb.part.8+0x18>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
     eb2:	f8d5 011c 	ldr.w	r0, [r5, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
     eb6:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
     eba:	f010 0f08 	tst.w	r0, #8
     ebe:	bf14      	ite	ne
     ec0:	2040      	movne	r0, #64	; 0x40
     ec2:	2080      	moveq	r0, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     ec4:	1a42      	subs	r2, r0, r1
                       AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);

    //
    // Figure out how many bytes we can write to the FIFO immediately.
    //
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
     ec6:	4598      	cmp	r8, r3
     ec8:	bf28      	it	cs
     eca:	4698      	movcs	r8, r3
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     ecc:	f002 00fc 	and.w	r0, r2, #252	; 0xfc
     ed0:	4540      	cmp	r0, r8
     ed2:	d370      	bcc.n	fb6 <am_hal_iom_i2c_write_nb.part.8+0x1aa>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     ed4:	f1b8 0f00 	cmp.w	r8, #0
     ed8:	d0bf      	beq.n	e5a <am_hal_iom_i2c_write_nb.part.8+0x4e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     eda:	463a      	mov	r2, r7
     edc:	43f9      	mvns	r1, r7
     ede:	f852 0b04 	ldr.w	r0, [r2], #4
     ee2:	6028      	str	r0, [r5, #0]
     ee4:	4439      	add	r1, r7

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     ee6:	1bd0      	subs	r0, r2, r7
     ee8:	4441      	add	r1, r8
     eea:	4540      	cmp	r0, r8
     eec:	f3c1 0182 	ubfx	r1, r1, #2, #3
     ef0:	d241      	bcs.n	f76 <am_hal_iom_i2c_write_nb.part.8+0x16a>
     ef2:	b319      	cbz	r1, f3c <am_hal_iom_i2c_write_nb.part.8+0x130>
     ef4:	2901      	cmp	r1, #1
     ef6:	d01b      	beq.n	f30 <am_hal_iom_i2c_write_nb.part.8+0x124>
     ef8:	2902      	cmp	r1, #2
     efa:	d016      	beq.n	f2a <am_hal_iom_i2c_write_nb.part.8+0x11e>
     efc:	2903      	cmp	r1, #3
     efe:	d011      	beq.n	f24 <am_hal_iom_i2c_write_nb.part.8+0x118>
     f00:	2904      	cmp	r1, #4
     f02:	d00c      	beq.n	f1e <am_hal_iom_i2c_write_nb.part.8+0x112>
     f04:	2905      	cmp	r1, #5
     f06:	d007      	beq.n	f18 <am_hal_iom_i2c_write_nb.part.8+0x10c>
     f08:	2906      	cmp	r1, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     f0a:	bf1c      	itt	ne
     f0c:	f852 1b04 	ldrne.w	r1, [r2], #4
     f10:	6029      	strne	r1, [r5, #0]
     f12:	f852 0b04 	ldr.w	r0, [r2], #4
     f16:	6028      	str	r0, [r5, #0]
     f18:	f852 1b04 	ldr.w	r1, [r2], #4
     f1c:	6029      	str	r1, [r5, #0]
     f1e:	f852 0b04 	ldr.w	r0, [r2], #4
     f22:	6028      	str	r0, [r5, #0]
     f24:	f852 1b04 	ldr.w	r1, [r2], #4
     f28:	6029      	str	r1, [r5, #0]
     f2a:	f852 0b04 	ldr.w	r0, [r2], #4
     f2e:	6028      	str	r0, [r5, #0]
     f30:	f852 1b04 	ldr.w	r1, [r2], #4
     f34:	6029      	str	r1, [r5, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     f36:	1bd0      	subs	r0, r2, r7
     f38:	4540      	cmp	r0, r8
     f3a:	d21c      	bcs.n	f76 <am_hal_iom_i2c_write_nb.part.8+0x16a>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     f3c:	4694      	mov	ip, r2
     f3e:	3220      	adds	r2, #32
     f40:	f85c 1b04 	ldr.w	r1, [ip], #4
     f44:	6029      	str	r1, [r5, #0]
     f46:	f852 0c1c 	ldr.w	r0, [r2, #-28]
     f4a:	6028      	str	r0, [r5, #0]
     f4c:	f8dc 1004 	ldr.w	r1, [ip, #4]
     f50:	6029      	str	r1, [r5, #0]
     f52:	f852 0c14 	ldr.w	r0, [r2, #-20]
     f56:	6028      	str	r0, [r5, #0]
     f58:	f852 1c10 	ldr.w	r1, [r2, #-16]
     f5c:	6029      	str	r1, [r5, #0]
     f5e:	f852 0c0c 	ldr.w	r0, [r2, #-12]
     f62:	6028      	str	r0, [r5, #0]
     f64:	f852 1c08 	ldr.w	r1, [r2, #-8]
     f68:	6029      	str	r1, [r5, #0]
     f6a:	f852 0c04 	ldr.w	r0, [r2, #-4]
     f6e:	6028      	str	r0, [r5, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     f70:	1bd1      	subs	r1, r2, r7
     f72:	4541      	cmp	r1, r8
     f74:	d3e2      	bcc.n	f3c <am_hal_iom_i2c_write_nb.part.8+0x130>
    if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
    {
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
     f76:	4817      	ldr	r0, [pc, #92]	; (fd4 <am_hal_iom_i2c_write_nb.part.8+0x1c8>)
     f78:	eb04 0584 	add.w	r5, r4, r4, lsl #2
     f7c:	00aa      	lsls	r2, r5, #2
     f7e:	1881      	adds	r1, r0, r2
     f80:	2501      	movs	r5, #1
        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
     f82:	f028 0c03 	bic.w	ip, r8, #3
    if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
    {
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
     f86:	5085      	str	r5, [r0, r2]
        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
     f88:	4467      	add	r7, ip

        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
     f8a:	ebc8 0003 	rsb	r0, r8, r3
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
     f8e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
     f90:	610a      	str	r2, [r1, #16]

        //
        // Update the pointer and the byte counter based on the portion of the
        // transfer we just sent to the fifo.
        //
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
     f92:	6088      	str	r0, [r1, #8]
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
     f94:	604f      	str	r7, [r1, #4]
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    if (ui32NumBytes == 0)
     f96:	b91b      	cbnz	r3, fa0 <am_hal_iom_i2c_write_nb.part.8+0x194>
     f98:	2003      	movs	r0, #3
        //
        ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                               ui32NumBytes, ui32Options);
        if (ui32Status != AM_HAL_IOM_SUCCESS)
        {
            g_iom_error_status[ui32Module] = ui32Status;
     f9a:	4b0b      	ldr	r3, [pc, #44]	; (fc8 <am_hal_iom_i2c_write_nb.part.8+0x1bc>)
     f9c:	5518      	strb	r0, [r3, r4]
     f9e:	e741      	b.n	e24 <am_hal_iom_i2c_write_nb.part.8+0x18>
     fa0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
     fa2:	9700      	str	r7, [sp, #0]
     fa4:	4632      	mov	r2, r6
     fa6:	4621      	mov	r1, r4
     fa8:	2000      	movs	r0, #0
     faa:	f7ff fdb5 	bl	b18 <am_hal_iom_i2c_cmd_run.part.1>
        //
        // Start the write on the bus.
        //
        ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                               ui32NumBytes, ui32Options);
        if (ui32Status != AM_HAL_IOM_SUCCESS)
     fae:	2800      	cmp	r0, #0
     fb0:	f43f af53 	beq.w	e5a <am_hal_iom_i2c_write_nb.part.8+0x4e>
     fb4:	e7f1      	b.n	f9a <am_hal_iom_i2c_write_nb.part.8+0x18e>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     fb6:	4a08      	ldr	r2, [pc, #32]	; (fd8 <am_hal_iom_i2c_write_nb.part.8+0x1cc>)
     fb8:	4808      	ldr	r0, [pc, #32]	; (fdc <am_hal_iom_i2c_write_nb.part.8+0x1d0>)
     fba:	9303      	str	r3, [sp, #12]
     fbc:	f640 7107 	movw	r1, #3847	; 0xf07
     fc0:	f7ff fc80 	bl	8c4 <am_hal_debug_error>
     fc4:	9b03      	ldr	r3, [sp, #12]
     fc6:	e788      	b.n	eda <am_hal_iom_i2c_write_nb.part.8+0xce>
     fc8:	10001054 	.word	0x10001054
     fcc:	1000105c 	.word	0x1000105c
     fd0:	00005120 	.word	0x00005120
     fd4:	100013a0 	.word	0x100013a0
     fd8:	00004fdc 	.word	0x00004fdc
     fdc:	00005010 	.word	0x00005010

00000fe0 <am_hal_iom_pwrctrl_enable>:
//
//*****************************************************************************
void
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
     fe0:	2805      	cmp	r0, #5
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
     fe2:	b510      	push	{r4, lr}
     fe4:	4604      	mov	r4, r0
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
     fe6:	d905      	bls.n	ff4 <am_hal_iom_pwrctrl_enable+0x14>
     fe8:	4a05      	ldr	r2, [pc, #20]	; (1000 <am_hal_iom_pwrctrl_enable+0x20>)
     fea:	4806      	ldr	r0, [pc, #24]	; (1004 <am_hal_iom_pwrctrl_enable+0x24>)
     fec:	f240 21d2 	movw	r1, #722	; 0x2d2
     ff0:	f7ff fc68 	bl	8c4 <am_hal_debug_error>
                            "Trying to enable an IOM module that doesn't exist.");

    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOM0 << ui32Module);
     ff4:	2002      	movs	r0, #2
     ff6:	40a0      	lsls	r0, r4
}
     ff8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
                            "Trying to enable an IOM module that doesn't exist.");

    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOM0 << ui32Module);
     ffc:	f000 be3e 	b.w	1c7c <am_hal_pwrctrl_periph_enable>
    1000:	00005024 	.word	0x00005024
    1004:	00005010 	.word	0x00005010

00001008 <am_hal_iom_enable>:
//
//*****************************************************************************
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    1008:	2805      	cmp	r0, #5
    100a:	d80f      	bhi.n	102c <am_hal_iom_enable+0x24>
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    100c:	f500 23a0 	add.w	r3, r0, #327680	; 0x50000
    1010:	3304      	adds	r3, #4
    1012:	031b      	lsls	r3, r3, #12
        g_bIomBusy[ui32Module] = false;
    1014:	4906      	ldr	r1, [pc, #24]	; (1030 <am_hal_iom_enable+0x28>)
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    1016:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_enable(uint32_t ui32Module)
{
    101a:	b410      	push	{r4}
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    101c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
        g_bIomBusy[ui32Module] = false;
    1020:	2400      	movs	r4, #0
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    1022:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
        g_bIomBusy[ui32Module] = false;
    1026:	540c      	strb	r4, [r1, r0]
    }
}
    1028:	f85d 4b04 	ldr.w	r4, [sp], #4
    102c:	4770      	bx	lr
    102e:	bf00      	nop
    1030:	1000105c 	.word	0x1000105c

00001034 <am_hal_iom_config>:
    // Start by checking the interface mode (I2C or SPI), and writing it to the
    // configuration word.
    //
    ui32Config = psConfig->ui32InterfaceMode;

    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1034:	2805      	cmp	r0, #5
    1036:	f200 80ec 	bhi.w	1212 <am_hal_iom_config+0x1de>
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_config(uint32_t ui32Module, const am_hal_iom_config_t *psConfig)
{
    103a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    //
    // Check the SPI format, and OR in the bits for SPHA (clock phase) and SPOL
    // (polarity). These shouldn't have any effect in I2C mode, so it should be
    // ok to write them without checking exactly which mode we're in.
    //
    if ( psConfig->bSPHA )
    103e:	7a0d      	ldrb	r5, [r1, #8]

    //
    // Start by checking the interface mode (I2C or SPI), and writing it to the
    // configuration word.
    //
    ui32Config = psConfig->ui32InterfaceMode;
    1040:	680b      	ldr	r3, [r1, #0]
    //
    // Check the SPI format, and OR in the bits for SPHA (clock phase) and SPOL
    // (polarity). These shouldn't have any effect in I2C mode, so it should be
    // ok to write them without checking exactly which mode we're in.
    //
    if ( psConfig->bSPHA )
    1042:	b10d      	cbz	r5, 1048 <am_hal_iom_config+0x14>
    {
        ui32Config |= AM_REG_IOMSTR_CFG_SPHA(1);
    1044:	f043 0304 	orr.w	r3, r3, #4
    }

    if ( psConfig->bSPOL )
    1048:	7a4a      	ldrb	r2, [r1, #9]
    104a:	b10a      	cbz	r2, 1050 <am_hal_iom_config+0x1c>
    {
        ui32Config |= AM_REG_IOMSTR_CFG_SPOL(1);
    104c:	f043 0302 	orr.w	r3, r3, #2
    // For all I2C frequencies and SPI frequencies below 16 MHz, the STARTRD
    // field should be set to 0 to minimize the potential of the IO transfer
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
    1050:	684c      	ldr	r4, [r1, #4]
    1052:	4a8d      	ldr	r2, [pc, #564]	; (1288 <am_hal_iom_config+0x254>)

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
    1054:	f500 26a0 	add.w	r6, r0, #327680	; 0x50000
    1058:	3604      	adds	r6, #4
    // For all I2C frequencies and SPI frequencies below 16 MHz, the STARTRD
    // field should be set to 0 to minimize the potential of the IO transfer
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
    105a:	4294      	cmp	r4, r2

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
    105c:	ea4f 3406 	mov.w	r4, r6, lsl #12
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
    {
        ui32Config |= AM_REG_IOMSTR_CFG_STARTRD(2);
    1060:	bf88      	it	hi
    1062:	f043 0320 	orrhi.w	r3, r3, #32

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
    1066:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
    106a:	7a8f      	ldrb	r7, [r1, #10]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
    106c:	2f03      	cmp	r7, #3
    106e:	f240 80c8 	bls.w	1202 <am_hal_iom_config+0x1ce>
    {
        corrected_threshold = MIN_RW_THRESHOLD;
    }

    if ( corrected_threshold > MAX_RW_THRESHOLD )
    1072:	2f7c      	cmp	r7, #124	; 0x7c
    1074:	bf88      	it	hi
    1076:	f44f 42f8 	movhi.w	r2, #31744	; 0x7c00
    107a:	f240 8101 	bls.w	1280 <am_hal_iom_config+0x24c>
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(check_iom_threshold(psConfig->ui8ReadThreshold)));
    107e:	7acb      	ldrb	r3, [r1, #11]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
    1080:	2b03      	cmp	r3, #3
    1082:	f240 80c4 	bls.w	120e <am_hal_iom_config+0x1da>
    1086:	2b7c      	cmp	r3, #124	; 0x7c
    1088:	bf28      	it	cs
    108a:	237c      	movcs	r3, #124	; 0x7c
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
    108c:	4313      	orrs	r3, r2

    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
    108e:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108

    // Apply I2C clock stretching workaround if B2 silicon and IOM 1,2,3, or 5
    // Note: Only I2C clock speeds of AM_HAL_IOM_800KHZ, AM_HAL_IOM_400KHZ,
    // AM_HAL_IOM_200KHZ, and AM_HAL_IOM_100KHZ are allowed.  Other values will
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
    1092:	f030 0304 	bics.w	r3, r0, #4
    1096:	d005      	beq.n	10a4 <am_hal_iom_config+0x70>
isRevB2(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) ==
    1098:	4e7c      	ldr	r6, [pc, #496]	; (128c <am_hal_iom_config+0x258>)
    109a:	6837      	ldr	r7, [r6, #0]
    109c:	b2fa      	uxtb	r2, r7
    109e:	2a22      	cmp	r2, #34	; 0x22
    10a0:	f000 80bc 	beq.w	121c <am_hal_iom_config+0x1e8>
      //  is being selected.
      // If SPHA=0 the low period must be 60%. If SPHA=1 high period must be 60%.
      // Note that the predetermined frequency parameters use the formula
      //  lowper = (totper-1)/2, which results in a 60% low period.
      //
      ui32ClkCfg = iom_get_interface_clock_cfg(psConfig->ui32ClockFrequency,
    10a4:	f8d1 e004 	ldr.w	lr, [r1, #4]
    uint32_t ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer, ui32LowPer;
    uint32_t ui32Denom, ui32v1, ui32Denomfinal, ui32ClkFreq, ui32ClkCfg;
    uint32_t ui32HFRCfreqHz;
    int32_t i32Div, i32N;

    if ( ui32FreqHz == 0 )
    10a8:	f1be 0f00 	cmp.w	lr, #0
    10ac:	f000 8099 	beq.w	11e2 <am_hal_iom_config+0x1ae>
    ui32HFRCfreqHz = AM_HAL_CLKGEN_FREQ_MAX_HZ;

    //
    // Compute various parameters used for computing the optimal CLKCFG setting.
    //
    i32Div = (ui32HFRCfreqHz / ui32FreqHz) + ((ui32HFRCfreqHz % ui32FreqHz) ? 1 : 0);    // Round up (ceiling)
    10b0:	4e77      	ldr	r6, [pc, #476]	; (1290 <am_hal_iom_config+0x25c>)
    10b2:	fbb6 f7fe 	udiv	r7, r6, lr
    10b6:	fb0e f207 	mul.w	r2, lr, r7
    10ba:	f1c2 7937 	rsb	r9, r2, #47972352	; 0x2dc0000
    10be:	f509 4ad8 	add.w	sl, r9, #27648	; 0x6c00
    10c2:	f1ba 0f00 	cmp.w	sl, #0
    10c6:	bf18      	it	ne
    10c8:	3701      	addne	r7, #1

    //
    // Compute N (count the number of LS zeros of Div) = ctz(Div) = log2(Div & (-Div))
    //
    i32N = 31 - AM_INSTR_CLZ((i32Div & (-i32Div)));
    10ca:	427b      	negs	r3, r7
    10cc:	403b      	ands	r3, r7
    10ce:	fab3 f683 	clz	r6, r3
    10d2:	f1c6 031f 	rsb	r3, r6, #31
    10d6:	2b06      	cmp	r3, #6
    10d8:	bfa8      	it	ge
    10da:	2306      	movge	r3, #6
        i32N = 6;
    }

    ui32Div3 = ( (ui32FreqHz < (ui32HFRCfreqHz / 16384))            ||
                 ( ((ui32FreqHz >= (ui32HFRCfreqHz / 3))    &&
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
    10dc:	f5be 6f37 	cmp.w	lr, #2928	; 0xb70
    10e0:	f240 8098 	bls.w	1214 <am_hal_iom_config+0x1e0>
    10e4:	4e6b      	ldr	r6, [pc, #428]	; (1294 <am_hal_iom_config+0x260>)
    10e6:	f5ae 0b74 	sub.w	fp, lr, #15990784	; 0xf40000
    10ea:	f5ab 5c10 	sub.w	ip, fp, #9216	; 0x2400
    10ee:	45b4      	cmp	ip, r6
    10f0:	bf8b      	itete	hi
    10f2:	f04f 0800 	movhi.w	r8, #0
    10f6:	f44f 6800 	movls.w	r8, #2048	; 0x800
    10fa:	2601      	movhi	r6, #1
    10fc:	2603      	movls	r6, #3
    ui32Denom = ( 1 << i32N ) * ( 1 + (ui32Div3 * 2) );
    10fe:	fa06 f903 	lsl.w	r9, r6, r3
    ui32TotPer = i32Div / ui32Denom;
    1102:	fbb7 f2f9 	udiv	r2, r7, r9
    ui32TotPer += (i32Div % ui32Denom) ? 1 : 0;
    1106:	fb09 7a12 	mls	sl, r9, r2, r7
    110a:	f1ba 0f00 	cmp.w	sl, #0
    110e:	bf18      	it	ne
    1110:	3201      	addne	r2, #1
    ui32v1 = 31 - AM_INSTR_CLZ(ui32TotPer);     // v1 = log2(TotPer)
    1112:	fab2 fb82 	clz	fp, r2
    1116:	f1cb 0c1f 	rsb	ip, fp, #31
    ui32Fsel = (ui32v1 > 7) ? ui32v1 + i32N - 7 : i32N;
    111a:	f1bc 0f07 	cmp.w	ip, #7
    111e:	f240 809b 	bls.w	1258 <am_hal_iom_config+0x224>
    1122:	3b07      	subs	r3, #7
    1124:	4463      	add	r3, ip
    ui32Fsel++;
    1126:	f103 0901 	add.w	r9, r3, #1

    if ( ui32Fsel > 7 )
    112a:	f1b9 0f07 	cmp.w	r9, #7
    112e:	d858      	bhi.n	11e2 <am_hal_iom_config+0x1ae>
    }

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
    1130:	f1ac 0b07 	sub.w	fp, ip, #7
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    1134:	f04f 0a01 	mov.w	sl, #1
    1138:	fa0a fc0b 	lsl.w	ip, sl, fp
    113c:	f10c 3aff 	add.w	sl, ip, #4294967295
    1140:	ea0a 0c02 	and.w	ip, sl, r2
    }

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
    1144:	fa22 f20b 	lsr.w	r2, r2, fp
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1148:	f8df b16c 	ldr.w	fp, [pc, #364]	; 12b8 <am_hal_iom_config+0x284>

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    114c:	f1bc 0f00 	cmp.w	ip, #0
    1150:	bf18      	it	ne
    1152:	3201      	addne	r2, #1
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1154:	45de      	cmp	lr, fp
    1156:	f200 8086 	bhi.w	1266 <am_hal_iom_config+0x232>
    115a:	f04f 0e01 	mov.w	lr, #1
    115e:	fa0e fa03 	lsl.w	sl, lr, r3
    1162:	4557      	cmp	r7, sl
    1164:	d07f      	beq.n	1266 <am_hal_iom_config+0x232>
    1166:	f102 3eff 	add.w	lr, r2, #4294967295
    116a:	4694      	mov	ip, r2
    116c:	f44f 5780 	mov.w	r7, #4096	; 0x1000

    if (ui32Phase == 1)
    1170:	2d00      	cmp	r5, #0
    1172:	d17e      	bne.n	1272 <am_hal_iom_config+0x23e>
    {
        ui32LowPer = (ui32TotPer - 2) / 2;          // Longer high phase
    }
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    1174:	ea4f 025e 	mov.w	r2, lr, lsr #1
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1178:	409e      	lsls	r6, r3
    117a:	fb0c f606 	mul.w	r6, ip, r6
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    117e:	f8df b110 	ldr.w	fp, [pc, #272]	; 1290 <am_hal_iom_config+0x25c>
    1182:	fbbb f3f6 	udiv	r3, fp, r6
    1186:	fb06 fa03 	mul.w	sl, r6, r3
    118a:	f1ca 7c37 	rsb	ip, sl, #47972352	; 0x2dc0000
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    118e:	ea4f 2509 	mov.w	r5, r9, lsl #8
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    1192:	f50c 4bd8 	add.w	fp, ip, #27648	; 0x6c00
    1196:	0876      	lsrs	r6, r6, #1
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    1198:	f8df a120 	ldr.w	sl, [pc, #288]	; 12bc <am_hal_iom_config+0x288>
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    119c:	455e      	cmp	r6, fp
    119e:	bf38      	it	cc
    11a0:	3301      	addcc	r3, #1
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    11a2:	f405 69e0 	and.w	r9, r5, #1792	; 0x700
    11a6:	ea49 0608 	orr.w	r6, r9, r8
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    11aa:	fbaa bc03 	umull	fp, ip, sl, r3
    11ae:	4d3a      	ldr	r5, [pc, #232]	; (1298 <am_hal_iom_config+0x264>)
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    11b0:	433e      	orrs	r6, r7
    11b2:	0412      	lsls	r2, r2, #16
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    11b4:	ea4f 471c 	mov.w	r7, ip, lsr #16
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    11b8:	ea46 680e 	orr.w	r8, r6, lr, lsl #24
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    11bc:	fb05 3317 	mls	r3, r5, r7, r3
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
    11c0:	f402 0e7f 	and.w	lr, r2, #16711680	; 0xff0000
    11c4:	ea48 060e 	orr.w	r6, r8, lr
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
    11c8:	b91b      	cbnz	r3, 11d2 <am_hal_iom_config+0x19e>
// A power of 2?
// Return true if ui32Value has exactly 1 bit set, otherwise false.
//
static bool onebit(uint32_t ui32Value)
{
    return ui32Value  &&  !(ui32Value & (ui32Value - 1));
    11ca:	b117      	cbz	r7, 11d2 <am_hal_iom_config+0x19e>
    11cc:	1e7d      	subs	r5, r7, #1
    11ce:	423d      	tst	r5, r7
    11d0:	d03f      	beq.n	1252 <am_hal_iom_config+0x21e>
      //  is being selected.
      // If SPHA=0 the low period must be 60%. If SPHA=1 high period must be 60%.
      // Note that the predetermined frequency parameters use the formula
      //  lowper = (totper-1)/2, which results in a 60% low period.
      //
      ui32ClkCfg = iom_get_interface_clock_cfg(psConfig->ui32ClockFrequency,
    11d2:	f04f 0b00 	mov.w	fp, #0
    11d6:	ea4b 0206 	orr.w	r2, fp, r6
    11da:	4617      	mov	r7, r2
                                               psConfig->bSPHA );
    }

    if ( ui32ClkCfg )
    11dc:	b10a      	cbz	r2, 11e2 <am_hal_iom_config+0x1ae>
    {
        AM_REGn(IOMSTR, ui32Module, CLKCFG) = (uint32_t)ui32ClkCfg;
    11de:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
    11e2:	4688      	mov	r8, r1
    11e4:	4604      	mov	r4, r0

    //
    // Compute the status timeout value.
    //
    ui32StatusTimeout[ui32Module] = MAX_IOM_BITS * AM_HAL_IOM_MAX_FIFO_SIZE *
      IOM_OVERHEAD_FACTOR * (am_hal_clkgen_sysclk_get() / psConfig->ui32ClockFrequency);
    11e6:	f7ff fb53 	bl	890 <am_hal_clkgen_sysclk_get>
    }

    //
    // Compute the status timeout value.
    //
    ui32StatusTimeout[ui32Module] = MAX_IOM_BITS * AM_HAL_IOM_MAX_FIFO_SIZE *
    11ea:	4f2c      	ldr	r7, [pc, #176]	; (129c <am_hal_iom_config+0x268>)
    11ec:	f8d8 1004 	ldr.w	r1, [r8, #4]
    11f0:	fbb0 f0f1 	udiv	r0, r0, r1
    11f4:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
    11f8:	0215      	lsls	r5, r2, #8
    11fa:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
    11fe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(check_iom_threshold(psConfig->ui8ReadThreshold)));
    1202:	7acb      	ldrb	r3, [r1, #11]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
    1204:	2b03      	cmp	r3, #3
    1206:	f44f 6280 	mov.w	r2, #1024	; 0x400
    120a:	f63f af3c 	bhi.w	1086 <am_hal_iom_config+0x52>
    120e:	2304      	movs	r3, #4
    1210:	e73c      	b.n	108c <am_hal_iom_config+0x58>
    1212:	4770      	bx	lr
        i32N = 6;
    }

    ui32Div3 = ( (ui32FreqHz < (ui32HFRCfreqHz / 16384))            ||
                 ( ((ui32FreqHz >= (ui32HFRCfreqHz / 3))    &&
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
    1214:	f44f 6800 	mov.w	r8, #2048	; 0x800
    1218:	2603      	movs	r6, #3
    121a:	e770      	b.n	10fe <am_hal_iom_config+0xca>
    // Apply I2C clock stretching workaround if B2 silicon and IOM 1,2,3, or 5
    // Note: Only I2C clock speeds of AM_HAL_IOM_800KHZ, AM_HAL_IOM_400KHZ,
    // AM_HAL_IOM_200KHZ, and AM_HAL_IOM_100KHZ are allowed.  Other values will
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
			isRevB2() && (AM_HAL_IOM_I2CMODE == psConfig->ui32InterfaceMode))
    121c:	680b      	ldr	r3, [r1, #0]
    121e:	2b00      	cmp	r3, #0
    1220:	f47f af40 	bne.w	10a4 <am_hal_iom_config+0x70>
    {
      // Set SPHA field to 1 on B2 silicon to enable the feature;
      AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_SPHA_M;
    1224:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
    1228:	4a1d      	ldr	r2, [pc, #116]	; (12a0 <am_hal_iom_config+0x26c>)
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
			isRevB2() && (AM_HAL_IOM_I2CMODE == psConfig->ui32InterfaceMode))
    {
      // Set SPHA field to 1 on B2 silicon to enable the feature;
      AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_SPHA_M;
    122a:	f043 0504 	orr.w	r5, r3, #4
    122e:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
      ui32ClkCfg = iom_get_i2c_workaround_clock_cfg(psConfig->ui32ClockFrequency);
    1232:	684d      	ldr	r5, [r1, #4]
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
    1234:	4295      	cmp	r5, r2
    1236:	d01f      	beq.n	1278 <am_hal_iom_config+0x244>
  {
    ui32Fsel = 2;
  }
  else if (ui32FreqHz == AM_HAL_IOM_400KHZ)
    1238:	4e1a      	ldr	r6, [pc, #104]	; (12a4 <am_hal_iom_config+0x270>)
    123a:	42b5      	cmp	r5, r6
    123c:	d01e      	beq.n	127c <am_hal_iom_config+0x248>
  {
    ui32Fsel = 3;
  }
  else if (ui32FreqHz == AM_HAL_IOM_200KHZ)
    123e:	4b1a      	ldr	r3, [pc, #104]	; (12a8 <am_hal_iom_config+0x274>)
    1240:	4f1a      	ldr	r7, [pc, #104]	; (12ac <am_hal_iom_config+0x278>)
    1242:	f102 59e8 	add.w	r9, r2, #486539264	; 0x1d000000
    1246:	f509 3af0 	add.w	sl, r9, #122880	; 0x1e000
    124a:	429d      	cmp	r5, r3
    124c:	bf18      	it	ne
    124e:	4657      	movne	r7, sl
    1250:	e7c5      	b.n	11de <am_hal_iom_config+0x1aa>
            //
            // Now, compute the return values.
            //
            ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer);

            ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)    |
    1252:	f449 6600 	orr.w	r6, r9, #2048	; 0x800
    1256:	e7bc      	b.n	11d2 <am_hal_iom_config+0x19e>
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1258:	f8df b05c 	ldr.w	fp, [pc, #92]	; 12b8 <am_hal_iom_config+0x284>
    125c:	45de      	cmp	lr, fp
    ui32Denom = ( 1 << i32N ) * ( 1 + (ui32Div3 * 2) );
    ui32TotPer = i32Div / ui32Denom;
    ui32TotPer += (i32Div % ui32Denom) ? 1 : 0;
    ui32v1 = 31 - AM_INSTR_CLZ(ui32TotPer);     // v1 = log2(TotPer)
    ui32Fsel = (ui32v1 > 7) ? ui32v1 + i32N - 7 : i32N;
    ui32Fsel++;
    125e:	f103 0901 	add.w	r9, r3, #1
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    1262:	f67f af7a 	bls.w	115a <am_hal_iom_config+0x126>
    1266:	f102 3eff 	add.w	lr, r2, #4294967295
    126a:	f04f 0c01 	mov.w	ip, #1
    126e:	2700      	movs	r7, #0
    1270:	e77e      	b.n	1170 <am_hal_iom_config+0x13c>

    if (ui32Phase == 1)
    {
        ui32LowPer = (ui32TotPer - 2) / 2;          // Longer high phase
    1272:	1e95      	subs	r5, r2, #2
    1274:	086a      	lsrs	r2, r5, #1
    1276:	e77f      	b.n	1178 <am_hal_iom_config+0x144>
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
    1278:	4f0d      	ldr	r7, [pc, #52]	; (12b0 <am_hal_iom_config+0x27c>)
    127a:	e7b0      	b.n	11de <am_hal_iom_config+0x1aa>
  {
    ui32Fsel = 2;
  }
  else if (ui32FreqHz == AM_HAL_IOM_400KHZ)
    127c:	4f0d      	ldr	r7, [pc, #52]	; (12b4 <am_hal_iom_config+0x280>)
    127e:	e7ae      	b.n	11de <am_hal_iom_config+0x1aa>
    1280:	023a      	lsls	r2, r7, #8
    1282:	f402 42fe 	and.w	r2, r2, #32512	; 0x7f00
    1286:	e6fa      	b.n	107e <am_hal_iom_config+0x4a>
    1288:	00f423ff 	.word	0x00f423ff
    128c:	4002000c 	.word	0x4002000c
    1290:	02dc6c00 	.word	0x02dc6c00
    1294:	007a11ff 	.word	0x007a11ff
    1298:	0003d090 	.word	0x0003d090
    129c:	10001388 	.word	0x10001388
    12a0:	000c3500 	.word	0x000c3500
    12a4:	00061a80 	.word	0x00061a80
    12a8:	00030d40 	.word	0x00030d40
    12ac:	1d0e1400 	.word	0x1d0e1400
    12b0:	1d0e1200 	.word	0x1d0e1200
    12b4:	1d0e1300 	.word	0x1d0e1300
    12b8:	00b71aff 	.word	0x00b71aff
    12bc:	431bde83 	.word	0x431bde83

000012c0 <am_hal_iom_i2c_write_nq>:
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;

    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    12c0:	2806      	cmp	r0, #6
    12c2:	d901      	bls.n	12c8 <am_hal_iom_i2c_write_nq+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    12c4:	2002      	movs	r0, #2
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    return ui32Status;
}
    12c6:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write_nq(uint32_t ui32Module, uint32_t ui32BusAddress,
                        uint32_t *pui32Data, uint32_t ui32NumBytes,
                        uint32_t ui32Options)
{
    12c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    12cc:	461e      	mov	r6, r3
    12ce:	b085      	sub	sp, #20
    12d0:	460b      	mov	r3, r1
    12d2:	4604      	mov	r4, r0
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    12d4:	d013      	beq.n	12fe <am_hal_iom_i2c_write_nq+0x3e>
    12d6:	48be      	ldr	r0, [pc, #760]	; (15d0 <am_hal_iom_i2c_write_nq+0x310>)
    12d8:	4615      	mov	r5, r2
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    12da:	5d02      	ldrb	r2, [r0, r4]
    12dc:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    12e0:	2a00      	cmp	r2, #0
    12e2:	d1fa      	bne.n	12da <am_hal_iom_i2c_write_nq+0x1a>
    // Wait until any earlier transactions have completed.
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    12e4:	f8df 82fc 	ldr.w	r8, [pc, #764]	; 15e4 <am_hal_iom_i2c_write_nq+0x324>
    12e8:	f808 1004 	strb.w	r1, [r8, r4]
    if (ui32NumBytes == 0)
    12ec:	b10e      	cbz	r6, 12f2 <am_hal_iom_i2c_write_nq+0x32>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    12ee:	2eff      	cmp	r6, #255	; 0xff
    12f0:	d923      	bls.n	133a <am_hal_iom_i2c_write_nq+0x7a>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    12f2:	2003      	movs	r0, #3
    12f4:	f808 0004 	strb.w	r0, [r8, r4]
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    return ui32Status;
}
    12f8:	b005      	add	sp, #20
    12fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Wait until any earlier transactions have completed.
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    12fe:	f8df 82e4 	ldr.w	r8, [pc, #740]	; 15e4 <am_hal_iom_i2c_write_nq+0x324>
    1302:	2700      	movs	r7, #0
    1304:	f888 7006 	strb.w	r7, [r8, #6]
    if (ui32NumBytes == 0)
    1308:	2e00      	cmp	r6, #0
    130a:	d0f2      	beq.n	12f2 <am_hal_iom_i2c_write_nq+0x32>
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    130c:	980e      	ldr	r0, [sp, #56]	; 0x38
    130e:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    1312:	ea4f 0143 	mov.w	r1, r3, lsl #1
    1316:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    1318:	f000 8131 	beq.w	157e <am_hal_iom_i2c_write_nq+0x2be>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    131c:	f3c3 7500 	ubfx	r5, r3, #28, #1
    1320:	f001 00fe 	and.w	r0, r1, #254	; 0xfe
    1324:	9700      	str	r7, [sp, #0]
    1326:	463b      	mov	r3, r7
    1328:	4631      	mov	r1, r6
    132a:	9501      	str	r5, [sp, #4]
    132c:	f001 fc7e 	bl	2c2c <am_hal_i2c_bit_bang_send>
        }

        //
        // Return. convert BB retCode to proper retCode here
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    1330:	4ca8      	ldr	r4, [pc, #672]	; (15d4 <am_hal_iom_i2c_write_nq+0x314>)
    1332:	5c20      	ldrb	r0, [r4, r0]
    1334:	f888 0006 	strb.w	r0, [r8, #6]
    1338:	e7de      	b.n	12f8 <am_hal_iom_i2c_write_nq+0x38>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    133a:	f504 27a0 	add.w	r7, r4, #327680	; 0x50000
    133e:	3704      	adds	r7, #4
    1340:	033f      	lsls	r7, r7, #12
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1342:	f240 7eff 	movw	lr, #2047	; 0x7ff
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1346:	f8d7 011c 	ldr.w	r0, [r7, #284]	; 0x11c
                      AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    134a:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    134e:	f8c7 1200 	str.w	r1, [r7, #512]	; 0x200

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1352:	f8c7 e208 	str.w	lr, [r7, #520]	; 0x208
                      AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    1356:	9202      	str	r2, [sp, #8]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1358:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    135c:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1360:	f010 0f08 	tst.w	r0, #8
    1364:	bf14      	ite	ne
    1366:	f04f 0940 	movne.w	r9, #64	; 0x40
    136a:	f04f 0980 	moveq.w	r9, #128	; 0x80
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    136e:	f012 0f08 	tst.w	r2, #8
    1372:	bf14      	ite	ne
    1374:	2240      	movne	r2, #64	; 0x40
    1376:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1378:	1a50      	subs	r0, r2, r1
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Figure out how many bytes we can write to the FIFO immediately.
    //
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    137a:	45b1      	cmp	r9, r6
    137c:	bf28      	it	cs
    137e:	46b1      	movcs	r9, r6
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1380:	f000 0cfc 	and.w	ip, r0, #252	; 0xfc
    1384:	45e1      	cmp	r9, ip
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1386:	f507 7a8e 	add.w	sl, r7, #284	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    138a:	f507 7b80 	add.w	fp, r7, #256	; 0x100
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    138e:	f200 8116 	bhi.w	15be <am_hal_iom_i2c_write_nq+0x2fe>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1392:	462a      	mov	r2, r5
    1394:	43e9      	mvns	r1, r5
    1396:	f852 0b04 	ldr.w	r0, [r2], #4
    139a:	6038      	str	r0, [r7, #0]
    139c:	4429      	add	r1, r5

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    139e:	1b50      	subs	r0, r2, r5
    13a0:	4449      	add	r1, r9
    13a2:	4581      	cmp	r9, r0
    13a4:	f3c1 0182 	ubfx	r1, r1, #2, #3
    13a8:	d941      	bls.n	142e <am_hal_iom_i2c_write_nq+0x16e>
    13aa:	b319      	cbz	r1, 13f4 <am_hal_iom_i2c_write_nq+0x134>
    13ac:	2901      	cmp	r1, #1
    13ae:	d01b      	beq.n	13e8 <am_hal_iom_i2c_write_nq+0x128>
    13b0:	2902      	cmp	r1, #2
    13b2:	d016      	beq.n	13e2 <am_hal_iom_i2c_write_nq+0x122>
    13b4:	2903      	cmp	r1, #3
    13b6:	d011      	beq.n	13dc <am_hal_iom_i2c_write_nq+0x11c>
    13b8:	2904      	cmp	r1, #4
    13ba:	d00c      	beq.n	13d6 <am_hal_iom_i2c_write_nq+0x116>
    13bc:	2905      	cmp	r1, #5
    13be:	d007      	beq.n	13d0 <am_hal_iom_i2c_write_nq+0x110>
    13c0:	2906      	cmp	r1, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    13c2:	bf1c      	itt	ne
    13c4:	f852 1b04 	ldrne.w	r1, [r2], #4
    13c8:	6039      	strne	r1, [r7, #0]
    13ca:	f852 0b04 	ldr.w	r0, [r2], #4
    13ce:	6038      	str	r0, [r7, #0]
    13d0:	f852 1b04 	ldr.w	r1, [r2], #4
    13d4:	6039      	str	r1, [r7, #0]
    13d6:	f852 0b04 	ldr.w	r0, [r2], #4
    13da:	6038      	str	r0, [r7, #0]
    13dc:	f852 1b04 	ldr.w	r1, [r2], #4
    13e0:	6039      	str	r1, [r7, #0]
    13e2:	f852 0b04 	ldr.w	r0, [r2], #4
    13e6:	6038      	str	r0, [r7, #0]
    13e8:	f852 1b04 	ldr.w	r1, [r2], #4
    13ec:	6039      	str	r1, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    13ee:	1b50      	subs	r0, r2, r5
    13f0:	4581      	cmp	r9, r0
    13f2:	d91c      	bls.n	142e <am_hal_iom_i2c_write_nq+0x16e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    13f4:	4696      	mov	lr, r2
    13f6:	3220      	adds	r2, #32
    13f8:	f85e 1b04 	ldr.w	r1, [lr], #4
    13fc:	6039      	str	r1, [r7, #0]
    13fe:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    1402:	6038      	str	r0, [r7, #0]
    1404:	f8de 1004 	ldr.w	r1, [lr, #4]
    1408:	6039      	str	r1, [r7, #0]
    140a:	f852 0c14 	ldr.w	r0, [r2, #-20]
    140e:	6038      	str	r0, [r7, #0]
    1410:	f852 1c10 	ldr.w	r1, [r2, #-16]
    1414:	6039      	str	r1, [r7, #0]
    1416:	f852 0c0c 	ldr.w	r0, [r2, #-12]
    141a:	6038      	str	r0, [r7, #0]
    141c:	f852 1c08 	ldr.w	r1, [r2, #-8]
    1420:	6039      	str	r1, [r7, #0]
    1422:	f852 0c04 	ldr.w	r0, [r2, #-4]
    1426:	6038      	str	r0, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1428:	1b51      	subs	r1, r2, r5
    142a:	4589      	cmp	r9, r1
    142c:	d8e2      	bhi.n	13f4 <am_hal_iom_i2c_write_nq+0x134>
    142e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    1430:	9200      	str	r2, [sp, #0]
    1432:	4621      	mov	r1, r4
    1434:	461a      	mov	r2, r3
    1436:	2000      	movs	r0, #0
    1438:	4633      	mov	r3, r6
    143a:	f7ff fb6d 	bl	b18 <am_hal_iom_i2c_cmd_run.part.1>
    // Start the write on the bus.
    //
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    143e:	2800      	cmp	r0, #0
    1440:	f040 80b3 	bne.w	15aa <am_hal_iom_i2c_write_nq+0x2ea>
    }
    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += ui32TransferSize >> 2;
    1444:	f029 0303 	bic.w	r3, r9, #3

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    1448:	ebb6 0609 	subs.w	r6, r6, r9
    }
    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += ui32TransferSize >> 2;
    144c:	441d      	add	r5, r3

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    144e:	f000 80e0 	beq.w	1612 <am_hal_iom_i2c_write_nq+0x352>
    1452:	f8d7 0204 	ldr.w	r0, [r7, #516]	; 0x204
    1456:	07c1      	lsls	r1, r0, #31
    1458:	f507 7901 	add.w	r9, r7, #516	; 0x204
    145c:	d47a      	bmi.n	1554 <am_hal_iom_i2c_write_nq+0x294>
    145e:	46a4      	mov	ip, r4
    1460:	4663      	mov	r3, ip
    1462:	465c      	mov	r4, fp
    1464:	46d3      	mov	fp, sl
    1466:	46b2      	mov	sl, r6
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1468:	f8db 1000 	ldr.w	r1, [fp]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    146c:	6826      	ldr	r6, [r4, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    146e:	f8db 2000 	ldr.w	r2, [fp]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    1472:	6820      	ldr	r0, [r4, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1474:	f011 0f08 	tst.w	r1, #8
    1478:	bf14      	ite	ne
    147a:	2140      	movne	r1, #64	; 0x40
    147c:	2180      	moveq	r1, #128	; 0x80
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    {
        //
        // This will always return a multiple of four.
        //
        ui32SpaceInFifo =  am_hal_iom_fifo_empty_slots(ui32Module);
    147e:	1b89      	subs	r1, r1, r6
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1480:	f012 0f08 	tst.w	r2, #8
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    {
        //
        // This will always return a multiple of four.
        //
        ui32SpaceInFifo =  am_hal_iom_fifo_empty_slots(ui32Module);
    1484:	f001 06fc 	and.w	r6, r1, #252	; 0xfc
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1488:	bf14      	ite	ne
    148a:	2240      	movne	r2, #64	; 0x40
    148c:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    148e:	1a12      	subs	r2, r2, r0
    1490:	4556      	cmp	r6, sl
    1492:	bf28      	it	cs
    1494:	4656      	movcs	r6, sl
    1496:	f002 00fc 	and.w	r0, r2, #252	; 0xfc
    149a:	4286      	cmp	r6, r0
    149c:	d87c      	bhi.n	1598 <am_hal_iom_i2c_write_nq+0x2d8>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    149e:	2e00      	cmp	r6, #0
    14a0:	d04d      	beq.n	153e <am_hal_iom_i2c_write_nq+0x27e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    14a2:	462a      	mov	r2, r5
    14a4:	43e9      	mvns	r1, r5
    14a6:	f852 0b04 	ldr.w	r0, [r2], #4
    14aa:	6038      	str	r0, [r7, #0]
    14ac:	4429      	add	r1, r5

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    14ae:	1b50      	subs	r0, r2, r5
    14b0:	4431      	add	r1, r6
    14b2:	4286      	cmp	r6, r0
    14b4:	f3c1 0182 	ubfx	r1, r1, #2, #3
    14b8:	d941      	bls.n	153e <am_hal_iom_i2c_write_nq+0x27e>
    14ba:	b319      	cbz	r1, 1504 <am_hal_iom_i2c_write_nq+0x244>
    14bc:	2901      	cmp	r1, #1
    14be:	d01b      	beq.n	14f8 <am_hal_iom_i2c_write_nq+0x238>
    14c0:	2902      	cmp	r1, #2
    14c2:	d016      	beq.n	14f2 <am_hal_iom_i2c_write_nq+0x232>
    14c4:	2903      	cmp	r1, #3
    14c6:	d011      	beq.n	14ec <am_hal_iom_i2c_write_nq+0x22c>
    14c8:	2904      	cmp	r1, #4
    14ca:	d00c      	beq.n	14e6 <am_hal_iom_i2c_write_nq+0x226>
    14cc:	2905      	cmp	r1, #5
    14ce:	d007      	beq.n	14e0 <am_hal_iom_i2c_write_nq+0x220>
    14d0:	2906      	cmp	r1, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    14d2:	bf1c      	itt	ne
    14d4:	f852 1b04 	ldrne.w	r1, [r2], #4
    14d8:	6039      	strne	r1, [r7, #0]
    14da:	f852 0b04 	ldr.w	r0, [r2], #4
    14de:	6038      	str	r0, [r7, #0]
    14e0:	f852 1b04 	ldr.w	r1, [r2], #4
    14e4:	6039      	str	r1, [r7, #0]
    14e6:	f852 0b04 	ldr.w	r0, [r2], #4
    14ea:	6038      	str	r0, [r7, #0]
    14ec:	f852 1b04 	ldr.w	r1, [r2], #4
    14f0:	6039      	str	r1, [r7, #0]
    14f2:	f852 0b04 	ldr.w	r0, [r2], #4
    14f6:	6038      	str	r0, [r7, #0]
    14f8:	f852 1b04 	ldr.w	r1, [r2], #4
    14fc:	6039      	str	r1, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    14fe:	1b50      	subs	r0, r2, r5
    1500:	4286      	cmp	r6, r0
    1502:	d91c      	bls.n	153e <am_hal_iom_i2c_write_nq+0x27e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1504:	4696      	mov	lr, r2
    1506:	3220      	adds	r2, #32
    1508:	f85e 1b04 	ldr.w	r1, [lr], #4
    150c:	6039      	str	r1, [r7, #0]
    150e:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    1512:	6038      	str	r0, [r7, #0]
    1514:	f8de 1004 	ldr.w	r1, [lr, #4]
    1518:	6039      	str	r1, [r7, #0]
    151a:	f852 0c14 	ldr.w	r0, [r2, #-20]
    151e:	6038      	str	r0, [r7, #0]
    1520:	f852 1c10 	ldr.w	r1, [r2, #-16]
    1524:	6039      	str	r1, [r7, #0]
    1526:	f852 0c0c 	ldr.w	r0, [r2, #-12]
    152a:	6038      	str	r0, [r7, #0]
    152c:	f852 1c08 	ldr.w	r1, [r2, #-8]
    1530:	6039      	str	r1, [r7, #0]
    1532:	f852 0c04 	ldr.w	r0, [r2, #-4]
    1536:	6038      	str	r0, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1538:	1b51      	subs	r1, r2, r5
    153a:	428e      	cmp	r6, r1
    153c:	d8e2      	bhi.n	1504 <am_hal_iom_i2c_write_nq+0x244>

        //
        // Update the data pointer and bytes-left count.
        //
        ui32NumBytes -= ui32TransferSize;
        pui32Data += ui32TransferSize >> 2;
    153e:	f026 0c03 	bic.w	ip, r6, #3
    pui32Data += ui32TransferSize >> 2;

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    1542:	ebba 0a06 	subs.w	sl, sl, r6

        //
        // Update the data pointer and bytes-left count.
        //
        ui32NumBytes -= ui32TransferSize;
        pui32Data += ui32TransferSize >> 2;
    1546:	4465      	add	r5, ip
    pui32Data += ui32TransferSize >> 2;

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    1548:	d003      	beq.n	1552 <am_hal_iom_i2c_write_nq+0x292>
    154a:	f8d9 2000 	ldr.w	r2, [r9]
    154e:	07d2      	lsls	r2, r2, #31
    1550:	d58a      	bpl.n	1468 <am_hal_iom_i2c_write_nq+0x1a8>
    1552:	461c      	mov	r4, r3
    }

    //
    // Make sure CMDCMP was raised,
    //
    waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    1554:	4d20      	ldr	r5, [pc, #128]	; (15d8 <am_hal_iom_i2c_write_nq+0x318>)
    1556:	2301      	movs	r3, #1
    1558:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
    155c:	461a      	mov	r2, r3
    155e:	4649      	mov	r1, r9
    1560:	f7ff f9b8 	bl	8d4 <am_hal_flash_delay_status_change>
                 AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                 AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

    if (waitStatus != 1)
    1564:	2801      	cmp	r0, #1
    1566:	d03f      	beq.n	15e8 <am_hal_iom_i2c_write_nq+0x328>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    1568:	2001      	movs	r0, #1
    156a:	f808 0004 	strb.w	r0, [r8, r4]

    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    156e:	f240 74ff 	movw	r4, #2047	; 0x7ff
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1572:	9e02      	ldr	r6, [sp, #8]

    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1574:	f8c7 4208 	str.w	r4, [r7, #520]	; 0x208
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1578:	f8c7 6200 	str.w	r6, [r7, #512]	; 0x200
    157c:	e6bc      	b.n	12f8 <am_hal_iom_i2c_write_nq+0x38>
                                     (uint8_t *)pui32Data, 0, false,
                                     (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    157e:	f3c3 7500 	ubfx	r5, r3, #28, #1
    1582:	2401      	movs	r4, #1
    1584:	f001 00fe 	and.w	r0, r1, #254	; 0xfe
    1588:	e88d 0030 	stmia.w	sp, {r4, r5}
    158c:	4631      	mov	r1, r6
    158e:	f3c3 2307 	ubfx	r3, r3, #8, #8
    1592:	f001 fb4b 	bl	2c2c <am_hal_i2c_bit_bang_send>
    1596:	e6cb      	b.n	1330 <am_hal_iom_i2c_write_nq+0x70>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1598:	4a10      	ldr	r2, [pc, #64]	; (15dc <am_hal_iom_i2c_write_nq+0x31c>)
    159a:	4811      	ldr	r0, [pc, #68]	; (15e0 <am_hal_iom_i2c_write_nq+0x320>)
    159c:	9303      	str	r3, [sp, #12]
    159e:	f640 7107 	movw	r1, #3847	; 0xf07
    15a2:	f7ff f98f 	bl	8c4 <am_hal_debug_error>
    15a6:	9b03      	ldr	r3, [sp, #12]
    15a8:	e77b      	b.n	14a2 <am_hal_iom_i2c_write_nq+0x1e2>
        g_iom_error_status[ui32Module] = ui32Status = ui32Status;
        //
        // Re-enable IOM interrupts.
        //
        // Clear interrupts
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    15aa:	f240 71ff 	movw	r1, #2047	; 0x7ff
        AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    15ae:	9a02      	ldr	r2, [sp, #8]
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status = ui32Status;
    15b0:	f808 0004 	strb.w	r0, [r8, r4]
        //
        // Re-enable IOM interrupts.
        //
        // Clear interrupts
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    15b4:	f8c7 1208 	str.w	r1, [r7, #520]	; 0x208
        AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    15b8:	f8c7 2200 	str.w	r2, [r7, #512]	; 0x200
    15bc:	e69c      	b.n	12f8 <am_hal_iom_i2c_write_nq+0x38>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    15be:	4a07      	ldr	r2, [pc, #28]	; (15dc <am_hal_iom_i2c_write_nq+0x31c>)
    15c0:	4807      	ldr	r0, [pc, #28]	; (15e0 <am_hal_iom_i2c_write_nq+0x320>)
    15c2:	9303      	str	r3, [sp, #12]
    15c4:	f640 7107 	movw	r1, #3847	; 0xf07
    15c8:	f7ff f97c 	bl	8c4 <am_hal_debug_error>
    15cc:	9b03      	ldr	r3, [sp, #12]
    15ce:	e6e0      	b.n	1392 <am_hal_iom_i2c_write_nq+0xd2>
    15d0:	1000105c 	.word	0x1000105c
    15d4:	00005120 	.word	0x00005120
    15d8:	10001388 	.word	0x10001388
    15dc:	00004fdc 	.word	0x00004fdc
    15e0:	00005010 	.word	0x00005010
    15e4:	10001054 	.word	0x10001054
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    15e8:	f8d9 3000 	ldr.w	r3, [r9]
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    15ec:	f013 0fcc 	tst.w	r3, #204	; 0xcc
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    15f0:	bf18      	it	ne
    15f2:	2005      	movne	r0, #5
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    15f4:	d002      	beq.n	15fc <am_hal_iom_i2c_write_nq+0x33c>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    }
    else
    {
        g_iom_error_status[ui32Module] = ui32Status = internal_iom_get_int_err(ui32Module, 0);
    15f6:	f808 0004 	strb.w	r0, [r8, r4]
    15fa:	e7b8      	b.n	156e <am_hal_iom_i2c_write_nq+0x2ae>
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    15fc:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    1600:	d105      	bne.n	160e <am_hal_iom_i2c_write_nq+0x34e>
//!
//*****************************************************************************
static am_hal_iom_status_e
internal_iom_get_int_err(uint32_t ui32Module, uint32_t ui32IntStatus)
{
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;
    1602:	f013 0f10 	tst.w	r3, #16
    1606:	bf14      	ite	ne
    1608:	2006      	movne	r0, #6
    160a:	2000      	moveq	r0, #0
    160c:	e7f3      	b.n	15f6 <am_hal_iom_i2c_write_nq+0x336>
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    {
        // Loss of I2C multi-master arbitration
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    160e:	2007      	movs	r0, #7
    1610:	e7f1      	b.n	15f6 <am_hal_iom_i2c_write_nq+0x336>
    1612:	f507 7901 	add.w	r9, r7, #516	; 0x204
    1616:	e79d      	b.n	1554 <am_hal_iom_i2c_write_nq+0x294>

00001618 <am_hal_iom_i2c_read_nq>:
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;

    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    1618:	2806      	cmp	r0, #6
    161a:	d901      	bls.n	1620 <am_hal_iom_i2c_read_nq+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    161c:	2002      	movs	r0, #2
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    return ui32Status;
}
    161e:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_read_nq(uint32_t ui32Module, uint32_t ui32BusAddress,
                       uint32_t *pui32Data, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    1620:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1624:	4604      	mov	r4, r0
    1626:	b087      	sub	sp, #28
    1628:	461e      	mov	r6, r3
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    162a:	d013      	beq.n	1654 <am_hal_iom_i2c_read_nq+0x3c>
    162c:	4617      	mov	r7, r2
    162e:	4acc      	ldr	r2, [pc, #816]	; (1960 <am_hal_iom_i2c_read_nq+0x348>)
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    1630:	5d13      	ldrb	r3, [r2, r4]
    1632:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    1636:	2b00      	cmp	r3, #0
    1638:	d1fa      	bne.n	1630 <am_hal_iom_i2c_read_nq+0x18>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    163a:	f8df 8338 	ldr.w	r8, [pc, #824]	; 1974 <am_hal_iom_i2c_read_nq+0x35c>
    163e:	f808 0004 	strb.w	r0, [r8, r4]
    if (ui32NumBytes == 0)
    1642:	b10e      	cbz	r6, 1648 <am_hal_iom_i2c_read_nq+0x30>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    1644:	2eff      	cmp	r6, #255	; 0xff
    1646:	d921      	bls.n	168c <am_hal_iom_i2c_read_nq+0x74>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    1648:	2003      	movs	r0, #3
    164a:	f808 0004 	strb.w	r0, [r8, r4]
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    return ui32Status;
}
    164e:	b007      	add	sp, #28
    1650:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1654:	f8df 831c 	ldr.w	r8, [pc, #796]	; 1974 <am_hal_iom_i2c_read_nq+0x35c>
    1658:	2300      	movs	r3, #0
    165a:	f888 3006 	strb.w	r3, [r8, #6]
    if (ui32NumBytes == 0)
    165e:	2e00      	cmp	r6, #0
    1660:	d0f2      	beq.n	1648 <am_hal_iom_i2c_read_nq+0x30>
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    1662:	9f10      	ldr	r7, [sp, #64]	; 0x40
    1664:	007c      	lsls	r4, r7, #1
    1666:	f140 8161 	bpl.w	192c <am_hal_iom_i2c_read_nq+0x314>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    166a:	0048      	lsls	r0, r1, #1
    166c:	9910      	ldr	r1, [sp, #64]	; 0x40
    166e:	9300      	str	r3, [sp, #0]
    1670:	f3c1 7400 	ubfx	r4, r1, #28, #1
    1674:	f040 0701 	orr.w	r7, r0, #1
    1678:	b2f8      	uxtb	r0, r7
    167a:	4631      	mov	r1, r6
    167c:	9401      	str	r4, [sp, #4]
    167e:	f000 fe7d 	bl	237c <am_hal_i2c_bit_bang_receive>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    1682:	4eb8      	ldr	r6, [pc, #736]	; (1964 <am_hal_iom_i2c_read_nq+0x34c>)
    1684:	5c30      	ldrb	r0, [r6, r0]
    1686:	f888 0006 	strb.w	r0, [r8, #6]
    168a:	e7e0      	b.n	164e <am_hal_iom_i2c_read_nq+0x36>
    }

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    168c:	f504 29a0 	add.w	r9, r4, #327680	; 0x50000
    1690:	f109 0504 	add.w	r5, r9, #4
    1694:	ea4f 3905 	mov.w	r9, r5, lsl #12
    1698:	460a      	mov	r2, r1
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    169a:	f240 75ff 	movw	r5, #2047	; 0x7ff
    }

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    169e:	f8d9 1200 	ldr.w	r1, [r9, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    16a2:	f8c9 0200 	str.w	r0, [r9, #512]	; 0x200
    16a6:	9810      	ldr	r0, [sp, #64]	; 0x40
    }

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    16a8:	9104      	str	r1, [sp, #16]
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    16aa:	f8c9 5208 	str.w	r5, [r9, #520]	; 0x208
    16ae:	4633      	mov	r3, r6
    16b0:	9000      	str	r0, [sp, #0]
    16b2:	4621      	mov	r1, r4
    16b4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    16b8:	f7ff fa2e 	bl	b18 <am_hal_iom_i2c_cmd_run.part.1>

    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_READ, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    16bc:	2800      	cmp	r0, #0
    16be:	f040 8146 	bne.w	194e <am_hal_iom_i2c_read_nq+0x336>
    16c2:	4605      	mov	r5, r0
    16c4:	f509 7b01 	add.w	fp, r9, #516	; 0x204
    16c8:	f509 7a80 	add.w	sl, r9, #256	; 0x100
    16cc:	9403      	str	r4, [sp, #12]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    16ce:	f8da 4000 	ldr.w	r4, [sl]
    16d2:	b2e2      	uxtb	r2, r4
    //
    while ( ui32NumBytes )
    {
        ui32BytesInFifo =  am_hal_iom_fifo_full_slots(ui32Module);

        if ( ui32BytesInFifo >= ui32NumBytes )
    16d4:	42b2      	cmp	r2, r6
    16d6:	f080 80a1 	bcs.w	181c <am_hal_iom_i2c_read_nq+0x204>
            // thing out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32NumBytes);
            ui32NumBytes = 0;
        }
        else if ( ui32BytesInFifo >= 4 )
    16da:	2a03      	cmp	r2, #3
    16dc:	d97e      	bls.n	17dc <am_hal_iom_i2c_read_nq+0x1c4>

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    16de:	f8d9 111c 	ldr.w	r1, [r9, #284]	; 0x11c
    16e2:	070a      	lsls	r2, r1, #28
        {
            //
            // If the fifo has at least one 32-bit word in it, copy whole
            // words out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);
    16e4:	f004 03fc 	and.w	r3, r4, #252	; 0xfc

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    16e8:	d406      	bmi.n	16f8 <am_hal_iom_i2c_read_nq+0xe0>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    16ea:	f8da 0000 	ldr.w	r0, [sl]
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    16ee:	fa5f fc80 	uxtb.w	ip, r0
    16f2:	4563      	cmp	r3, ip
    16f4:	f200 8153 	bhi.w	199e <am_hal_iom_i2c_read_nq+0x386>

    //
    // Figure out how many whole words we're reading from the fifo, and how
    // many bytes will be left over when we're done.
    //
    ui32NumWords = ui32NumBytes / 4;
    16f8:	089a      	lsrs	r2, r3, #2
    16fa:	9205      	str	r2, [sp, #20]
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    16fc:	0091      	lsls	r1, r2, #2

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    16fe:	2a00      	cmp	r2, #0
    1700:	d056      	beq.n	17b0 <am_hal_iom_i2c_read_nq+0x198>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1702:	463a      	mov	r2, r7
    1704:	f8d9 0000 	ldr.w	r0, [r9]
    1708:	f842 0b04 	str.w	r0, [r2], #4
    170c:	eb07 0e01 	add.w	lr, r7, r1
    1710:	f1a1 0c04 	sub.w	ip, r1, #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1714:	4572      	cmp	r2, lr
    1716:	f3cc 0082 	ubfx	r0, ip, #2, #3
    171a:	d049      	beq.n	17b0 <am_hal_iom_i2c_read_nq+0x198>
    171c:	b348      	cbz	r0, 1772 <am_hal_iom_i2c_read_nq+0x15a>
    171e:	2801      	cmp	r0, #1
    1720:	d021      	beq.n	1766 <am_hal_iom_i2c_read_nq+0x14e>
    1722:	2802      	cmp	r0, #2
    1724:	d01b      	beq.n	175e <am_hal_iom_i2c_read_nq+0x146>
    1726:	2803      	cmp	r0, #3
    1728:	d015      	beq.n	1756 <am_hal_iom_i2c_read_nq+0x13e>
    172a:	2804      	cmp	r0, #4
    172c:	d00f      	beq.n	174e <am_hal_iom_i2c_read_nq+0x136>
    172e:	2805      	cmp	r0, #5
    1730:	d009      	beq.n	1746 <am_hal_iom_i2c_read_nq+0x12e>
    1732:	2806      	cmp	r0, #6
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1734:	bf1c      	itt	ne
    1736:	f8d9 0000 	ldrne.w	r0, [r9]
    173a:	f842 0b04 	strne.w	r0, [r2], #4
    173e:	f8d9 0000 	ldr.w	r0, [r9]
    1742:	f842 0b04 	str.w	r0, [r2], #4
    1746:	f8d9 0000 	ldr.w	r0, [r9]
    174a:	f842 0b04 	str.w	r0, [r2], #4
    174e:	f8d9 0000 	ldr.w	r0, [r9]
    1752:	f842 0b04 	str.w	r0, [r2], #4
    1756:	f8d9 0000 	ldr.w	r0, [r9]
    175a:	f842 0b04 	str.w	r0, [r2], #4
    175e:	f8d9 0000 	ldr.w	r0, [r9]
    1762:	f842 0b04 	str.w	r0, [r2], #4
    1766:	f8d9 0000 	ldr.w	r0, [r9]
    176a:	f842 0b04 	str.w	r0, [r2], #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    176e:	4572      	cmp	r2, lr
    1770:	d01e      	beq.n	17b0 <am_hal_iom_i2c_read_nq+0x198>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1772:	4610      	mov	r0, r2
    1774:	f8d9 c000 	ldr.w	ip, [r9]
    1778:	f840 cb04 	str.w	ip, [r0], #4
    177c:	f8d9 c000 	ldr.w	ip, [r9]
    1780:	f8c2 c004 	str.w	ip, [r2, #4]
    1784:	f8d9 c000 	ldr.w	ip, [r9]
    1788:	f8c0 c004 	str.w	ip, [r0, #4]
    178c:	f8d9 0000 	ldr.w	r0, [r9]
    1790:	60d0      	str	r0, [r2, #12]
    1792:	f8d9 0000 	ldr.w	r0, [r9]
    1796:	6110      	str	r0, [r2, #16]
    1798:	f8d9 0000 	ldr.w	r0, [r9]
    179c:	6150      	str	r0, [r2, #20]
    179e:	f8d9 0000 	ldr.w	r0, [r9]
    17a2:	6190      	str	r0, [r2, #24]
    17a4:	f8d9 0000 	ldr.w	r0, [r9]
    17a8:	61d0      	str	r0, [r2, #28]
    17aa:	3220      	adds	r2, #32
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    17ac:	4572      	cmp	r2, lr
    17ae:	d1e0      	bne.n	1772 <am_hal_iom_i2c_read_nq+0x15a>
    // definition requests, we wouldn't need to do this. It's possible to call
    // this function with a re-cast or packed pointer instead though. If that
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    17b0:	428b      	cmp	r3, r1
    17b2:	d00f      	beq.n	17d4 <am_hal_iom_i2c_read_nq+0x1bc>
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    17b4:	f8d9 2000 	ldr.w	r2, [r9]
        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    17b8:	9805      	ldr	r0, [sp, #20]
    17ba:	4439      	add	r1, r7
    17bc:	f807 2020 	strb.w	r2, [r7, r0, lsl #2]
    17c0:	f3c2 2e07 	ubfx	lr, r2, #8, #8
    17c4:	f3c2 4007 	ubfx	r0, r2, #16, #8
    17c8:	f3c2 6207 	ubfx	r2, r2, #24, #8
    17cc:	f881 e001 	strb.w	lr, [r1, #1]
    17d0:	7088      	strb	r0, [r1, #2]
    17d2:	70ca      	strb	r2, [r1, #3]
            // words out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);

            ui32NumBytes -= ui32BytesInFifo & ~0x3;
            pui32Data += ui32BytesInFifo >> 2;
    17d4:	f004 01fc 	and.w	r1, r4, #252	; 0xfc
    17d8:	440f      	add	r7, r1
            // If the fifo has at least one 32-bit word in it, copy whole
            // words out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);

            ui32NumBytes -= ui32BytesInFifo & ~0x3;
    17da:	1af6      	subs	r6, r6, r3
            pui32Data += ui32BytesInFifo >> 2;
        }

        if ( bCmdCmp == true )
    17dc:	2d01      	cmp	r5, #1
    17de:	d006      	beq.n	17ee <am_hal_iom_i2c_read_nq+0x1d6>
        {
            // No more data expected - exit out of loop
            break;
        }

        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
    17e0:	f8db 5000 	ldr.w	r5, [fp]
    17e4:	f005 0501 	and.w	r5, r5, #1
    }

    //
    // Start a loop to catch the Rx data.
    //
    while ( ui32NumBytes )
    17e8:	2e00      	cmp	r6, #0
    17ea:	f47f af70 	bne.w	16ce <am_hal_iom_i2c_read_nq+0xb6>
    17ee:	9c03      	ldr	r4, [sp, #12]
    }

    //
    // Make sure CMDCMP was raised,
    //
    waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    17f0:	4d5d      	ldr	r5, [pc, #372]	; (1968 <am_hal_iom_i2c_read_nq+0x350>)
    17f2:	2301      	movs	r3, #1
    17f4:	4659      	mov	r1, fp
    17f6:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
    17fa:	461a      	mov	r2, r3
    17fc:	f7ff f86a 	bl	8d4 <am_hal_flash_delay_status_change>
                 AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                 AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

    if (waitStatus != 1)
    1800:	2801      	cmp	r0, #1
    1802:	f000 80b9 	beq.w	1978 <am_hal_iom_i2c_read_nq+0x360>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    1806:	2001      	movs	r0, #1
    1808:	f808 0004 	strb.w	r0, [r8, r4]
    }
    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    180c:	f240 74ff 	movw	r4, #2047	; 0x7ff
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1810:	9e04      	ldr	r6, [sp, #16]
    }
    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1812:	f8c9 4208 	str.w	r4, [r9, #520]	; 0x208
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1816:	f8c9 6200 	str.w	r6, [r9, #512]	; 0x200
    181a:	e718      	b.n	164e <am_hal_iom_i2c_read_nq+0x36>

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    181c:	f8d9 311c 	ldr.w	r3, [r9, #284]	; 0x11c
    1820:	9c03      	ldr	r4, [sp, #12]
    1822:	0719      	lsls	r1, r3, #28
    1824:	d40a      	bmi.n	183c <am_hal_iom_i2c_read_nq+0x224>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    1826:	f8d9 0100 	ldr.w	r0, [r9, #256]	; 0x100
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    182a:	b2c2      	uxtb	r2, r0
    182c:	42b2      	cmp	r2, r6
    182e:	d205      	bcs.n	183c <am_hal_iom_i2c_read_nq+0x224>
    1830:	4a4e      	ldr	r2, [pc, #312]	; (196c <am_hal_iom_i2c_read_nq+0x354>)
    1832:	484f      	ldr	r0, [pc, #316]	; (1970 <am_hal_iom_i2c_read_nq+0x358>)
    1834:	f640 7142 	movw	r1, #3906	; 0xf42
    1838:	f7ff f844 	bl	8c4 <am_hal_debug_error>

    //
    // Figure out how many whole words we're reading from the fifo, and how
    // many bytes will be left over when we're done.
    //
    ui32NumWords = ui32NumBytes / 4;
    183c:	08b0      	lsrs	r0, r6, #2
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    183e:	0081      	lsls	r1, r0, #2
    1840:	1a76      	subs	r6, r6, r1

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1842:	2800      	cmp	r0, #0
    1844:	d056      	beq.n	18f4 <am_hal_iom_i2c_read_nq+0x2dc>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1846:	463b      	mov	r3, r7
    1848:	f8d9 2000 	ldr.w	r2, [r9]
    184c:	f843 2b04 	str.w	r2, [r3], #4
    1850:	eb07 0e01 	add.w	lr, r7, r1
    1854:	f1a1 0a04 	sub.w	sl, r1, #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1858:	459e      	cmp	lr, r3
    185a:	f3ca 0282 	ubfx	r2, sl, #2, #3
    185e:	d049      	beq.n	18f4 <am_hal_iom_i2c_read_nq+0x2dc>
    1860:	b34a      	cbz	r2, 18b6 <am_hal_iom_i2c_read_nq+0x29e>
    1862:	2a01      	cmp	r2, #1
    1864:	d021      	beq.n	18aa <am_hal_iom_i2c_read_nq+0x292>
    1866:	2a02      	cmp	r2, #2
    1868:	d01b      	beq.n	18a2 <am_hal_iom_i2c_read_nq+0x28a>
    186a:	2a03      	cmp	r2, #3
    186c:	d015      	beq.n	189a <am_hal_iom_i2c_read_nq+0x282>
    186e:	2a04      	cmp	r2, #4
    1870:	d00f      	beq.n	1892 <am_hal_iom_i2c_read_nq+0x27a>
    1872:	2a05      	cmp	r2, #5
    1874:	d009      	beq.n	188a <am_hal_iom_i2c_read_nq+0x272>
    1876:	2a06      	cmp	r2, #6
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1878:	bf1c      	itt	ne
    187a:	f8d9 2000 	ldrne.w	r2, [r9]
    187e:	f843 2b04 	strne.w	r2, [r3], #4
    1882:	f8d9 2000 	ldr.w	r2, [r9]
    1886:	f843 2b04 	str.w	r2, [r3], #4
    188a:	f8d9 2000 	ldr.w	r2, [r9]
    188e:	f843 2b04 	str.w	r2, [r3], #4
    1892:	f8d9 2000 	ldr.w	r2, [r9]
    1896:	f843 2b04 	str.w	r2, [r3], #4
    189a:	f8d9 2000 	ldr.w	r2, [r9]
    189e:	f843 2b04 	str.w	r2, [r3], #4
    18a2:	f8d9 2000 	ldr.w	r2, [r9]
    18a6:	f843 2b04 	str.w	r2, [r3], #4
    18aa:	f8d9 2000 	ldr.w	r2, [r9]
    18ae:	f843 2b04 	str.w	r2, [r3], #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    18b2:	459e      	cmp	lr, r3
    18b4:	d01e      	beq.n	18f4 <am_hal_iom_i2c_read_nq+0x2dc>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    18b6:	469a      	mov	sl, r3
    18b8:	f8d9 c000 	ldr.w	ip, [r9]
    18bc:	f84a cb04 	str.w	ip, [sl], #4
    18c0:	f8d9 c000 	ldr.w	ip, [r9]
    18c4:	f8c3 c004 	str.w	ip, [r3, #4]
    18c8:	f8d9 c000 	ldr.w	ip, [r9]
    18cc:	f8ca c004 	str.w	ip, [sl, #4]
    18d0:	f8d9 2000 	ldr.w	r2, [r9]
    18d4:	60da      	str	r2, [r3, #12]
    18d6:	f8d9 2000 	ldr.w	r2, [r9]
    18da:	611a      	str	r2, [r3, #16]
    18dc:	f8d9 2000 	ldr.w	r2, [r9]
    18e0:	615a      	str	r2, [r3, #20]
    18e2:	f8d9 2000 	ldr.w	r2, [r9]
    18e6:	619a      	str	r2, [r3, #24]
    18e8:	f8d9 2000 	ldr.w	r2, [r9]
    18ec:	61da      	str	r2, [r3, #28]
    18ee:	3320      	adds	r3, #32
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    18f0:	459e      	cmp	lr, r3
    18f2:	d1e0      	bne.n	18b6 <am_hal_iom_i2c_read_nq+0x29e>
    // definition requests, we wouldn't need to do this. It's possible to call
    // this function with a re-cast or packed pointer instead though. If that
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    18f4:	b1a6      	cbz	r6, 1920 <am_hal_iom_i2c_read_nq+0x308>
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    18f6:	f8d9 3000 	ldr.w	r3, [r9]
        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    18fa:	f807 3020 	strb.w	r3, [r7, r0, lsl #2]
        pui8Data = (uint8_t *) (&pui32Data[i]);

        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
    18fe:	2e01      	cmp	r6, #1
    1900:	d00e      	beq.n	1920 <am_hal_iom_i2c_read_nq+0x308>
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    1902:	4439      	add	r1, r7
        pui8Data = (uint8_t *) (&pui32Data[i]);

        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
    1904:	2e02      	cmp	r6, #2
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    1906:	f3c3 2707 	ubfx	r7, r3, #8, #8
    190a:	704f      	strb	r7, [r1, #1]
        pui8Data = (uint8_t *) (&pui32Data[i]);

        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
    190c:	d008      	beq.n	1920 <am_hal_iom_i2c_read_nq+0x308>
    190e:	2e03      	cmp	r6, #3
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    1910:	f3c3 4007 	ubfx	r0, r3, #16, #8
    1914:	bf18      	it	ne
    1916:	f3c3 6307 	ubfxne	r3, r3, #24, #8
    191a:	7088      	strb	r0, [r1, #2]
    191c:	bf18      	it	ne
    191e:	70cb      	strbne	r3, [r1, #3]

            ui32NumBytes -= ui32BytesInFifo & ~0x3;
            pui32Data += ui32BytesInFifo >> 2;
        }

        if ( bCmdCmp == true )
    1920:	2d01      	cmp	r5, #1
    1922:	f43f af65 	beq.w	17f0 <am_hal_iom_i2c_read_nq+0x1d8>
        {
            // No more data expected - exit out of loop
            break;
        }

        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
    1926:	f8d9 3204 	ldr.w	r3, [r9, #516]	; 0x204
    192a:	e761      	b.n	17f0 <am_hal_iom_i2c_read_nq+0x1d8>
                                        (uint8_t *)pui32Data, 0, false,
                                        (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    192c:	004b      	lsls	r3, r1, #1
    192e:	9d10      	ldr	r5, [sp, #64]	; 0x40
    1930:	f043 0b01 	orr.w	fp, r3, #1
    1934:	f3c7 7400 	ubfx	r4, r7, #28, #1
    1938:	2301      	movs	r3, #1
    193a:	e88d 0018 	stmia.w	sp, {r3, r4}
    193e:	fa5f f08b 	uxtb.w	r0, fp
    1942:	4631      	mov	r1, r6
    1944:	f3c5 2307 	ubfx	r3, r5, #8, #8
    1948:	f000 fd18 	bl	237c <am_hal_i2c_bit_bang_receive>
    194c:	e699      	b.n	1682 <am_hal_iom_i2c_read_nq+0x6a>
        //
        // Re-enable IOM interrupts.
        //
        // Clear interrupts
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    194e:	9a04      	ldr	r2, [sp, #16]
        g_iom_error_status[ui32Module] = ui32Status = ui32Status;
        //
        // Re-enable IOM interrupts.
        //
        // Clear interrupts
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1950:	f8c9 5208 	str.w	r5, [r9, #520]	; 0x208
    ui32Status = am_hal_iom_i2c_cmd_run(AM_HAL_IOM_READ, ui32Module, ui32BusAddress,
                           ui32NumBytes, ui32Options);

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status = ui32Status;
    1954:	f808 0004 	strb.w	r0, [r8, r4]
        //
        // Re-enable IOM interrupts.
        //
        // Clear interrupts
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1958:	f8c9 2200 	str.w	r2, [r9, #512]	; 0x200
    195c:	e677      	b.n	164e <am_hal_iom_i2c_read_nq+0x36>
    195e:	bf00      	nop
    1960:	1000105c 	.word	0x1000105c
    1964:	00005120 	.word	0x00005120
    1968:	10001388 	.word	0x10001388
    196c:	000050e8 	.word	0x000050e8
    1970:	00005010 	.word	0x00005010
    1974:	10001054 	.word	0x10001054
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    1978:	f8d9 1204 	ldr.w	r1, [r9, #516]	; 0x204
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    197c:	f011 0fcc 	tst.w	r1, #204	; 0xcc
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    1980:	bf18      	it	ne
    1982:	2005      	movne	r0, #5
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    1984:	d002      	beq.n	198c <am_hal_iom_i2c_read_nq+0x374>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    }
    else
    {
        g_iom_error_status[ui32Module] = ui32Status = internal_iom_get_int_err(ui32Module, 0);
    1986:	f808 0004 	strb.w	r0, [r8, r4]
    198a:	e73f      	b.n	180c <am_hal_iom_i2c_read_nq+0x1f4>
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    198c:	f411 6fe0 	tst.w	r1, #1792	; 0x700
    1990:	d10e      	bne.n	19b0 <am_hal_iom_i2c_read_nq+0x398>
//!
//*****************************************************************************
static am_hal_iom_status_e
internal_iom_get_int_err(uint32_t ui32Module, uint32_t ui32IntStatus)
{
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;
    1992:	f011 0f10 	tst.w	r1, #16
    1996:	bf14      	ite	ne
    1998:	2006      	movne	r0, #6
    199a:	2000      	moveq	r0, #0
    199c:	e7f3      	b.n	1986 <am_hal_iom_i2c_read_nq+0x36e>
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    199e:	4a05      	ldr	r2, [pc, #20]	; (19b4 <am_hal_iom_i2c_read_nq+0x39c>)
    19a0:	4805      	ldr	r0, [pc, #20]	; (19b8 <am_hal_iom_i2c_read_nq+0x3a0>)
    19a2:	9305      	str	r3, [sp, #20]
    19a4:	f640 7142 	movw	r1, #3906	; 0xf42
    19a8:	f7fe ff8c 	bl	8c4 <am_hal_debug_error>
    19ac:	9b05      	ldr	r3, [sp, #20]
    19ae:	e6a3      	b.n	16f8 <am_hal_iom_i2c_read_nq+0xe0>
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    {
        // Loss of I2C multi-master arbitration
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    19b0:	2007      	movs	r0, #7
    19b2:	e7e8      	b.n	1986 <am_hal_iom_i2c_read_nq+0x36e>
    19b4:	000050e8 	.word	0x000050e8
    19b8:	00005010 	.word	0x00005010

000019bc <am_hal_iom_i2c_write>:
    am_hal_iom_status_e ui32Status;
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;
    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    19bc:	2806      	cmp	r0, #6
    19be:	d901      	bls.n	19c4 <am_hal_iom_i2c_write+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    19c0:	2002      	movs	r0, #2
        //
        ui32Status = am_hal_iom_i2c_write_nq(ui32Module, ui32BusAddress, pui32Data,
                                ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    19c2:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_write(uint32_t ui32Module, uint32_t ui32BusAddress,
                     uint32_t *pui32Data, uint32_t ui32NumBytes,
                     uint32_t ui32Options)
{
    19c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    19c8:	461e      	mov	r6, r3
    19ca:	b08f      	sub	sp, #60	; 0x3c
    19cc:	4605      	mov	r5, r0
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    19ce:	d014      	beq.n	19fa <am_hal_iom_i2c_write+0x3e>
    19d0:	4f4a      	ldr	r7, [pc, #296]	; (1afc <am_hal_iom_i2c_write+0x140>)
    19d2:	4691      	mov	r9, r2
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    19d4:	5d7c      	ldrb	r4, [r7, r5]
    19d6:	4a49      	ldr	r2, [pc, #292]	; (1afc <am_hal_iom_i2c_write+0x140>)
    19d8:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    19dc:	2c00      	cmp	r4, #0
    19de:	d1f9      	bne.n	19d4 <am_hal_iom_i2c_write+0x18>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    19e0:	f8df 8128 	ldr.w	r8, [pc, #296]	; 1b0c <am_hal_iom_i2c_write+0x150>
    19e4:	f808 3005 	strb.w	r3, [r8, r5]
    if (ui32NumBytes == 0)
    19e8:	b10e      	cbz	r6, 19ee <am_hal_iom_i2c_write+0x32>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    19ea:	2eff      	cmp	r6, #255	; 0xff
    19ec:	d91f      	bls.n	1a2e <am_hal_iom_i2c_write+0x72>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    19ee:	2003      	movs	r0, #3
    19f0:	f808 0005 	strb.w	r0, [r8, r5]
        //
        ui32Status = am_hal_iom_i2c_write_nq(ui32Module, ui32BusAddress, pui32Data,
                                ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    19f4:	b00f      	add	sp, #60	; 0x3c
    19f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    19fa:	f8df 8110 	ldr.w	r8, [pc, #272]	; 1b0c <am_hal_iom_i2c_write+0x150>
    19fe:	2300      	movs	r3, #0
    1a00:	f888 3006 	strb.w	r3, [r8, #6]
    if (ui32NumBytes == 0)
    1a04:	2e00      	cmp	r6, #0
    1a06:	d0f2      	beq.n	19ee <am_hal_iom_i2c_write+0x32>
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    1a08:	9d18      	ldr	r5, [sp, #96]	; 0x60
    1a0a:	006c      	lsls	r4, r5, #1
    1a0c:	d55e      	bpl.n	1acc <am_hal_iom_i2c_write+0x110>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    1a0e:	9c18      	ldr	r4, [sp, #96]	; 0x60
    1a10:	9300      	str	r3, [sp, #0]
    1a12:	004f      	lsls	r7, r1, #1
    1a14:	f3c4 7500 	ubfx	r5, r4, #28, #1
    1a18:	f007 00fe 	and.w	r0, r7, #254	; 0xfe
    1a1c:	4631      	mov	r1, r6
    1a1e:	9501      	str	r5, [sp, #4]
    1a20:	f001 f904 	bl	2c2c <am_hal_i2c_bit_bang_send>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    1a24:	4e36      	ldr	r6, [pc, #216]	; (1b00 <am_hal_iom_i2c_write+0x144>)
    1a26:	5c30      	ldrb	r0, [r6, r0]
    1a28:	f888 0006 	strb.w	r0, [r8, #6]
        return ui32Status;
    1a2c:	e7e2      	b.n	19f4 <am_hal_iom_i2c_write+0x38>

    //
    // Check to see if queues have been enabled. If they are, we'll actually
    // switch to the queued interface.
    //
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    1a2e:	4835      	ldr	r0, [pc, #212]	; (1b04 <am_hal_iom_i2c_write+0x148>)
    1a30:	9204      	str	r2, [sp, #16]
    1a32:	ea4f 0b45 	mov.w	fp, r5, lsl #1
    1a36:	eb0b 0a05 	add.w	sl, fp, r5
    1a3a:	eb00 04ca 	add.w	r4, r0, sl, lsl #3
    1a3e:	9003      	str	r0, [sp, #12]
    1a40:	6962      	ldr	r2, [r4, #20]
    1a42:	2a00      	cmp	r2, #0
    1a44:	d051      	beq.n	1aea <am_hal_iom_i2c_write+0x12e>
    1a46:	9105      	str	r1, [sp, #20]
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    1a48:	f001 fc6e 	bl	3328 <am_hal_interrupt_master_disable>
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    1a4c:	9904      	ldr	r1, [sp, #16]
    1a4e:	9b03      	ldr	r3, [sp, #12]
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    1a50:	4682      	mov	sl, r0
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    1a52:	5d48      	ldrb	r0, [r1, r5]
    1a54:	9905      	ldr	r1, [sp, #20]
    1a56:	b908      	cbnz	r0, 1a5c <am_hal_iom_i2c_write+0xa0>
    1a58:	68a4      	ldr	r4, [r4, #8]
    1a5a:	b1dc      	cbz	r4, 1a94 <am_hal_iom_i2c_write+0xd8>
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1a5c:	eb0b 0205 	add.w	r2, fp, r5
    1a60:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
    1a64:	2702      	movs	r7, #2
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    1a66:	2300      	movs	r3, #0
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
    1a68:	9109      	str	r1, [sp, #36]	; 0x24
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
    1a6a:	960b      	str	r6, [sp, #44]	; 0x2c
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1a6c:	2201      	movs	r2, #1
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    1a6e:	9e18      	ldr	r6, [sp, #96]	; 0x60
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
    1a70:	9508      	str	r5, [sp, #32]
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1a72:	a907      	add	r1, sp, #28
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
    1a74:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    1a78:	960c      	str	r6, [sp, #48]	; 0x30
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
    1a7a:	9707      	str	r7, [sp, #28]
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    1a7c:	930d      	str	r3, [sp, #52]	; 0x34

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1a7e:	f000 fac7 	bl	2010 <am_hal_queue_item_add>
    1a82:	b9c8      	cbnz	r0, 1ab8 <am_hal_iom_i2c_write+0xfc>
        {
            //
            // Didn't have enough memory.
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
    1a84:	2408      	movs	r4, #8
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1a86:	4650      	mov	r0, sl
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    1a88:	f808 4005 	strb.w	r4, [r8, r5]
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1a8c:	f001 fc50 	bl	3330 <am_hal_interrupt_master_set>
    1a90:	4620      	mov	r0, r4
    1a92:	e7af      	b.n	19f4 <am_hal_iom_i2c_write+0x38>
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    1a94:	5d78      	ldrb	r0, [r7, r5]
    1a96:	f000 04ff 	and.w	r4, r0, #255	; 0xff
    1a9a:	2800      	cmp	r0, #0
    1a9c:	d1fa      	bne.n	1a94 <am_hal_iom_i2c_write+0xd8>
    1a9e:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1aa0:	9401      	str	r4, [sp, #4]
    1aa2:	9200      	str	r2, [sp, #0]
    1aa4:	4633      	mov	r3, r6
    1aa6:	464a      	mov	r2, r9
    1aa8:	4628      	mov	r0, r5
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1aaa:	f808 4005 	strb.w	r4, [r8, r5]
    1aae:	f7ff f9ad 	bl	e0c <am_hal_iom_i2c_write_nb.part.8>
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    1ab2:	4604      	mov	r4, r0
    1ab4:	2800      	cmp	r0, #0
    1ab6:	d1e6      	bne.n	1a86 <am_hal_iom_i2c_write+0xca>
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1ab8:	4650      	mov	r0, sl
    1aba:	f001 fc39 	bl	3330 <am_hal_interrupt_master_set>
        if (ui32Status == AM_HAL_IOM_SUCCESS)
        {
            //
            // Wait until the transaction actually clears.
            //
            am_hal_iom_queue_flush(ui32Module);
    1abe:	4912      	ldr	r1, [pc, #72]	; (1b08 <am_hal_iom_i2c_write+0x14c>)
    1ac0:	4628      	mov	r0, r5
    1ac2:	680f      	ldr	r7, [r1, #0]
    1ac4:	47b8      	blx	r7
            // g_iom_error_status gets set in the isr handling
            ui32Status = g_iom_error_status[ui32Module];
    1ac6:	f818 0005 	ldrb.w	r0, [r8, r5]
    1aca:	e793      	b.n	19f4 <am_hal_iom_i2c_write+0x38>
                                     (uint8_t *)pui32Data, 0, false,
                                     (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    1acc:	f3c5 7400 	ubfx	r4, r5, #28, #1
    1ad0:	2301      	movs	r3, #1
    1ad2:	e88d 0018 	stmia.w	sp, {r3, r4}
    1ad6:	9b18      	ldr	r3, [sp, #96]	; 0x60
    1ad8:	0048      	lsls	r0, r1, #1
    1ada:	f3c3 2307 	ubfx	r3, r3, #8, #8
    1ade:	4631      	mov	r1, r6
    1ae0:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    1ae4:	f001 f8a2 	bl	2c2c <am_hal_i2c_bit_bang_send>
    1ae8:	e79c      	b.n	1a24 <am_hal_iom_i2c_write+0x68>
    else
    {
        //
        // Otherwise, we'll just do a polled transaction.
        //
        ui32Status = am_hal_iom_i2c_write_nq(ui32Module, ui32BusAddress, pui32Data,
    1aea:	9f18      	ldr	r7, [sp, #96]	; 0x60
    1aec:	9700      	str	r7, [sp, #0]
    1aee:	4633      	mov	r3, r6
    1af0:	464a      	mov	r2, r9
    1af2:	4628      	mov	r0, r5
    1af4:	f7ff fbe4 	bl	12c0 <am_hal_iom_i2c_write_nq>
    1af8:	e77c      	b.n	19f4 <am_hal_iom_i2c_write+0x38>
    1afa:	bf00      	nop
    1afc:	1000105c 	.word	0x1000105c
    1b00:	00005120 	.word	0x00005120
    1b04:	10001418 	.word	0x10001418
    1b08:	10001050 	.word	0x10001050
    1b0c:	10001054 	.word	0x10001054

00001b10 <am_hal_iom_i2c_read>:
    am_hal_iom_status_e ui32Status;
    am_hal_i2c_bit_bang_enum_e i2cBBStatus;
    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    1b10:	2806      	cmp	r0, #6
    1b12:	d901      	bls.n	1b18 <am_hal_iom_i2c_read+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    1b14:	2002      	movs	r0, #2
        //
        ui32Status = am_hal_iom_i2c_read_nq(ui32Module, ui32BusAddress, pui32Data,
                               ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    1b16:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_i2c_read(uint32_t ui32Module, uint32_t ui32BusAddress,
                    uint32_t *pui32Data, uint32_t ui32NumBytes,
                    uint32_t ui32Options)
{
    1b18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1b1c:	461e      	mov	r6, r3
    1b1e:	b08f      	sub	sp, #60	; 0x3c
    1b20:	4605      	mov	r5, r0
am_hal_iom_poll_complete(uint32_t ui32Module)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1b22:	d014      	beq.n	1b4e <am_hal_iom_i2c_read+0x3e>
    1b24:	4f4b      	ldr	r7, [pc, #300]	; (1c54 <am_hal_iom_i2c_read+0x144>)
    1b26:	4691      	mov	r9, r2
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    1b28:	5d7c      	ldrb	r4, [r7, r5]
    1b2a:	4a4a      	ldr	r2, [pc, #296]	; (1c54 <am_hal_iom_i2c_read+0x144>)
    1b2c:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    1b30:	2c00      	cmp	r4, #0
    1b32:	d1f9      	bne.n	1b28 <am_hal_iom_i2c_read+0x18>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1b34:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1c64 <am_hal_iom_i2c_read+0x154>
    1b38:	f808 3005 	strb.w	r3, [r8, r5]
    if (ui32NumBytes == 0)
    1b3c:	b10e      	cbz	r6, 1b42 <am_hal_iom_i2c_read+0x32>
    }

    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 256)
    1b3e:	2eff      	cmp	r6, #255	; 0xff
    1b40:	d920      	bls.n	1b84 <am_hal_iom_i2c_read+0x74>

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    1b42:	2003      	movs	r0, #3
    1b44:	f808 0005 	strb.w	r0, [r8, r5]
        //
        ui32Status = am_hal_iom_i2c_read_nq(ui32Module, ui32BusAddress, pui32Data,
                               ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    1b48:	b00f      	add	sp, #60	; 0x3c
    1b4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1b4e:	f8df 8114 	ldr.w	r8, [pc, #276]	; 1c64 <am_hal_iom_i2c_read+0x154>
    1b52:	2300      	movs	r3, #0
    1b54:	f888 3006 	strb.w	r3, [r8, #6]
    if (ui32NumBytes == 0)
    1b58:	2e00      	cmp	r6, #0
    1b5a:	d0f2      	beq.n	1b42 <am_hal_iom_i2c_read+0x32>
    // Redirect to the bit-bang interface if the module number matches the
    // software I2C module.
    //
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    {
        if ( ui32Options & AM_HAL_IOM_RAW )
    1b5c:	9d18      	ldr	r5, [sp, #96]	; 0x60
    1b5e:	006c      	lsls	r4, r5, #1
    1b60:	d55f      	bpl.n	1c22 <am_hal_iom_i2c_read+0x112>
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    1b62:	9c18      	ldr	r4, [sp, #96]	; 0x60
    1b64:	9300      	str	r3, [sp, #0]
    1b66:	0048      	lsls	r0, r1, #1
    1b68:	f040 0701 	orr.w	r7, r0, #1
    1b6c:	f3c4 7500 	ubfx	r5, r4, #28, #1
    1b70:	b2f8      	uxtb	r0, r7
    1b72:	4631      	mov	r1, r6
    1b74:	9501      	str	r5, [sp, #4]
    1b76:	f000 fc01 	bl	237c <am_hal_i2c_bit_bang_receive>
        }

        //
        // Return. convert i2c bb retCode
        //
        g_iom_error_status[ui32Module] = ui32Status = i2c_bb_errmap[i2cBBStatus];
    1b7a:	4a37      	ldr	r2, [pc, #220]	; (1c58 <am_hal_iom_i2c_read+0x148>)
    1b7c:	5c10      	ldrb	r0, [r2, r0]
    1b7e:	f888 0006 	strb.w	r0, [r8, #6]
        return ui32Status;
    1b82:	e7e1      	b.n	1b48 <am_hal_iom_i2c_read+0x38>

    //
    // Check to see if queues have been enabled. If they are, we'll actually
    // switch to the queued interface.
    //
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    1b84:	4835      	ldr	r0, [pc, #212]	; (1c5c <am_hal_iom_i2c_read+0x14c>)
    1b86:	9204      	str	r2, [sp, #16]
    1b88:	ea4f 0b45 	mov.w	fp, r5, lsl #1
    1b8c:	eb0b 0a05 	add.w	sl, fp, r5
    1b90:	eb00 04ca 	add.w	r4, r0, sl, lsl #3
    1b94:	9003      	str	r0, [sp, #12]
    1b96:	6962      	ldr	r2, [r4, #20]
    1b98:	2a00      	cmp	r2, #0
    1b9a:	d053      	beq.n	1c44 <am_hal_iom_i2c_read+0x134>
    1b9c:	9105      	str	r1, [sp, #20]
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    1b9e:	f001 fbc3 	bl	3328 <am_hal_interrupt_master_disable>
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    1ba2:	9904      	ldr	r1, [sp, #16]
    1ba4:	9b03      	ldr	r3, [sp, #12]
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    1ba6:	4682      	mov	sl, r0
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    1ba8:	5d48      	ldrb	r0, [r1, r5]
    1baa:	9905      	ldr	r1, [sp, #20]
    1bac:	b908      	cbnz	r0, 1bb2 <am_hal_iom_i2c_read+0xa2>
    1bae:	68a4      	ldr	r4, [r4, #8]
    1bb0:	b1dc      	cbz	r4, 1bea <am_hal_iom_i2c_read+0xda>
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1bb2:	eb0b 0205 	add.w	r2, fp, r5
    1bb6:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
    1bba:	2703      	movs	r7, #3
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    1bbc:	2300      	movs	r3, #0
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
    1bbe:	9109      	str	r1, [sp, #36]	; 0x24
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
    1bc0:	960b      	str	r6, [sp, #44]	; 0x2c
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1bc2:	2201      	movs	r2, #1
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    1bc4:	9e18      	ldr	r6, [sp, #96]	; 0x60
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
        sIOMTransaction.ui32Module = ui32Module;
    1bc6:	9508      	str	r5, [sp, #32]
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1bc8:	a907      	add	r1, sp, #28
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
    1bca:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    1bce:	960c      	str	r6, [sp, #48]	; 0x30
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
    1bd0:	9707      	str	r7, [sp, #28]
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    1bd2:	930d      	str	r3, [sp, #52]	; 0x34

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1bd4:	f000 fa1c 	bl	2010 <am_hal_queue_item_add>
    1bd8:	b9c8      	cbnz	r0, 1c0e <am_hal_iom_i2c_read+0xfe>
        {
            //
            // Didn't have enough memory.
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
    1bda:	2408      	movs	r4, #8
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1bdc:	4650      	mov	r0, sl
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    1bde:	f808 4005 	strb.w	r4, [r8, r5]
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1be2:	f001 fba5 	bl	3330 <am_hal_interrupt_master_set>
    1be6:	4620      	mov	r0, r4
    1be8:	e7ae      	b.n	1b48 <am_hal_iom_i2c_read+0x38>
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    1bea:	5d78      	ldrb	r0, [r7, r5]
    1bec:	f000 04ff 	and.w	r4, r0, #255	; 0xff
    1bf0:	2800      	cmp	r0, #0
    1bf2:	d1fa      	bne.n	1bea <am_hal_iom_i2c_read+0xda>
    1bf4:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1bf6:	9401      	str	r4, [sp, #4]
    1bf8:	9200      	str	r2, [sp, #0]
    1bfa:	4633      	mov	r3, r6
    1bfc:	464a      	mov	r2, r9
    1bfe:	4628      	mov	r0, r5
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1c00:	f808 4005 	strb.w	r4, [r8, r5]
    1c04:	f7ff f896 	bl	d34 <am_hal_iom_i2c_read_nb.part.9>
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    1c08:	4604      	mov	r4, r0
    1c0a:	2800      	cmp	r0, #0
    1c0c:	d1e6      	bne.n	1bdc <am_hal_iom_i2c_read+0xcc>
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1c0e:	4650      	mov	r0, sl
    1c10:	f001 fb8e 	bl	3330 <am_hal_interrupt_master_set>
        if (ui32Status == AM_HAL_IOM_SUCCESS)
        {
            //
            // Wait until the transaction actually clears.
            //
            am_hal_iom_queue_flush(ui32Module);
    1c14:	4912      	ldr	r1, [pc, #72]	; (1c60 <am_hal_iom_i2c_read+0x150>)
    1c16:	4628      	mov	r0, r5
    1c18:	680f      	ldr	r7, [r1, #0]
    1c1a:	47b8      	blx	r7
            // g_iom_error_status gets set in the isr handling
            ui32Status = g_iom_error_status[ui32Module];
    1c1c:	f818 0005 	ldrb.w	r0, [r8, r5]
    1c20:	e792      	b.n	1b48 <am_hal_iom_i2c_read+0x38>
                                        (uint8_t *)pui32Data, 0, false,
                                        (ui32Options & AM_HAL_IOM_NO_STOP));
        }
        else
        {
            i2cBBStatus = am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    1c22:	004b      	lsls	r3, r1, #1
    1c24:	4631      	mov	r1, r6
    1c26:	9e18      	ldr	r6, [sp, #96]	; 0x60
    1c28:	f043 0e01 	orr.w	lr, r3, #1
    1c2c:	f3c5 7400 	ubfx	r4, r5, #28, #1
    1c30:	2301      	movs	r3, #1
    1c32:	e88d 0018 	stmia.w	sp, {r3, r4}
    1c36:	fa5f f08e 	uxtb.w	r0, lr
    1c3a:	f3c6 2307 	ubfx	r3, r6, #8, #8
    1c3e:	f000 fb9d 	bl	237c <am_hal_i2c_bit_bang_receive>
    1c42:	e79a      	b.n	1b7a <am_hal_iom_i2c_read+0x6a>
    else
    {
        //
        // Otherwise, just perform a polled transaction.
        //
        ui32Status = am_hal_iom_i2c_read_nq(ui32Module, ui32BusAddress, pui32Data,
    1c44:	9f18      	ldr	r7, [sp, #96]	; 0x60
    1c46:	9700      	str	r7, [sp, #0]
    1c48:	4633      	mov	r3, r6
    1c4a:	464a      	mov	r2, r9
    1c4c:	4628      	mov	r0, r5
    1c4e:	f7ff fce3 	bl	1618 <am_hal_iom_i2c_read_nq>
    1c52:	e779      	b.n	1b48 <am_hal_iom_i2c_read+0x38>
    1c54:	1000105c 	.word	0x1000105c
    1c58:	00005120 	.word	0x00005120
    1c5c:	10001418 	.word	0x10001418
    1c60:	10001050 	.word	0x10001050
    1c64:	10001054 	.word	0x10001054

00001c68 <am_hal_iom_int_clear>:
am_hal_iom_int_clear(uint32_t ui32Module, uint32_t ui32Interrupt)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1c68:	2805      	cmp	r0, #5
    1c6a:	d805      	bhi.n	1c78 <am_hal_iom_int_clear+0x10>
    {
        return;
    }

    AM_REGn(IOMSTR, ui32Module, INTCLR) = ui32Interrupt;
    1c6c:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    1c70:	3004      	adds	r0, #4
    1c72:	0302      	lsls	r2, r0, #12
    1c74:	f8c2 1208 	str.w	r1, [r2, #520]	; 0x208
    1c78:	4770      	bx	lr
    1c7a:	bf00      	nop

00001c7c <am_hal_pwrctrl_periph_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{
    1c7c:	b510      	push	{r4, lr}

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    1c7e:	4604      	mov	r4, r0
//! @return None.
//
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{
    1c80:	b082      	sub	sp, #8

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    1c82:	b1c0      	cbz	r0, 1cb6 <am_hal_pwrctrl_periph_enable+0x3a>
    1c84:	1e43      	subs	r3, r0, #1
    1c86:	4203      	tst	r3, r0
    1c88:	d115      	bne.n	1cb6 <am_hal_pwrctrl_periph_enable+0x3a>
                        "Cannot enable more than one peripheral at a time.");

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    1c8a:	f3ef 8010 	mrs	r0, PRIMASK
    1c8e:	9001      	str	r0, [sp, #4]
    1c90:	b672      	cpsid	i

    //
    // Enable power control for the given device.
    //
    AM_REG(PWRCTRL, DEVICEEN) |= ui32Peripheral;
    1c92:	4a18      	ldr	r2, [pc, #96]	; (1cf4 <am_hal_pwrctrl_periph_enable+0x78>)
    1c94:	6811      	ldr	r1, [r2, #0]
    1c96:	4321      	orrs	r1, r4
    1c98:	6011      	str	r1, [r2, #0]

    //
    // End Critical Section.
    //
    AM_CRITICAL_END_ASM
    1c9a:	9b01      	ldr	r3, [sp, #4]
    1c9c:	f383 8810 	msr	PRIMASK, r3

    //
    // Wait for the power to stablize.  Using a simple delay loop is more
    // power efficient than a polling loop.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);
    1ca0:	200e      	movs	r0, #14
    1ca2:	f7fe fe11 	bl	8c8 <am_hal_flash_delay>

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    1ca6:	f014 0f0e 	tst.w	r4, #14
    1caa:	d10a      	bne.n	1cc2 <am_hal_pwrctrl_periph_enable+0x46>
    1cac:	f014 0f70 	tst.w	r4, #112	; 0x70
    1cb0:	d00e      	beq.n	1cd0 <am_hal_pwrctrl_periph_enable+0x54>
    1cb2:	2408      	movs	r4, #8
    1cb4:	e006      	b.n	1cc4 <am_hal_pwrctrl_periph_enable+0x48>
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    1cb6:	4a10      	ldr	r2, [pc, #64]	; (1cf8 <am_hal_pwrctrl_periph_enable+0x7c>)
    1cb8:	4810      	ldr	r0, [pc, #64]	; (1cfc <am_hal_pwrctrl_periph_enable+0x80>)
    1cba:	215d      	movs	r1, #93	; 0x5d
    1cbc:	f7fe fe02 	bl	8c4 <am_hal_debug_error>
    1cc0:	e7e3      	b.n	1c8a <am_hal_pwrctrl_periph_enable+0xe>
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    1cc2:	2404      	movs	r4, #4
    1cc4:	4a0e      	ldr	r2, [pc, #56]	; (1d00 <am_hal_pwrctrl_periph_enable+0x84>)
    1cc6:	6811      	ldr	r1, [r2, #0]
    1cc8:	420c      	tst	r4, r1
    1cca:	d0fc      	beq.n	1cc6 <am_hal_pwrctrl_periph_enable+0x4a>
}
    1ccc:	b002      	add	sp, #8
    1cce:	bd10      	pop	{r4, pc}
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    1cd0:	f240 1081 	movw	r0, #385	; 0x181
    1cd4:	4020      	ands	r0, r4
    1cd6:	b940      	cbnz	r0, 1cea <am_hal_pwrctrl_periph_enable+0x6e>
    1cd8:	05a3      	lsls	r3, r4, #22
    1cda:	d408      	bmi.n	1cee <am_hal_pwrctrl_periph_enable+0x72>
    1cdc:	f414 6f80 	tst.w	r4, #1024	; 0x400
    1ce0:	bf14      	ite	ne
    1ce2:	2410      	movne	r4, #16
    1ce4:	f04f 34ff 	moveq.w	r4, #4294967295
    1ce8:	e7ec      	b.n	1cc4 <am_hal_pwrctrl_periph_enable+0x48>
    1cea:	2402      	movs	r4, #2
    1cec:	e7ea      	b.n	1cc4 <am_hal_pwrctrl_periph_enable+0x48>
    1cee:	2480      	movs	r4, #128	; 0x80
    1cf0:	e7e8      	b.n	1cc4 <am_hal_pwrctrl_periph_enable+0x48>
    1cf2:	bf00      	nop
    1cf4:	40021008 	.word	0x40021008
    1cf8:	00005128 	.word	0x00005128
    1cfc:	0000515c 	.word	0x0000515c
    1d00:	40021014 	.word	0x40021014

00001d04 <am_hal_pwrctrl_memory_enable>:
{
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    1d04:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    1d08:	b430      	push	{r4, r5}
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    1d0a:	d03a      	beq.n	1d82 <am_hal_pwrctrl_memory_enable+0x7e>
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    1d0c:	f5b0 5fc0 	cmp.w	r0, #6144	; 0x1800
    1d10:	f000 809d 	beq.w	1e4e <am_hal_pwrctrl_memory_enable+0x14a>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    1d14:	2801      	cmp	r0, #1
    1d16:	f000 809d 	beq.w	1e54 <am_hal_pwrctrl_memory_enable+0x150>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    1d1a:	2803      	cmp	r0, #3
    1d1c:	f000 80a6 	beq.w	1e6c <am_hal_pwrctrl_memory_enable+0x168>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM24K )
    1d20:	2807      	cmp	r0, #7
    1d22:	f000 809c 	beq.w	1e5e <am_hal_pwrctrl_memory_enable+0x15a>
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    1d26:	280f      	cmp	r0, #15
    1d28:	f000 80a5 	beq.w	1e76 <am_hal_pwrctrl_memory_enable+0x172>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    1d2c:	281f      	cmp	r0, #31
    1d2e:	f000 80b1 	beq.w	1e94 <am_hal_pwrctrl_memory_enable+0x190>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    1d32:	283f      	cmp	r0, #63	; 0x3f
    1d34:	f000 80b5 	beq.w	1ea2 <am_hal_pwrctrl_memory_enable+0x19e>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    1d38:	287f      	cmp	r0, #127	; 0x7f
    1d3a:	f000 80b9 	beq.w	1eb0 <am_hal_pwrctrl_memory_enable+0x1ac>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    1d3e:	28ff      	cmp	r0, #255	; 0xff
    1d40:	f000 80a0 	beq.w	1e84 <am_hal_pwrctrl_memory_enable+0x180>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    1d44:	f240 13ff 	movw	r3, #511	; 0x1ff
    1d48:	4298      	cmp	r0, r3
    1d4a:	f000 80b8 	beq.w	1ebe <am_hal_pwrctrl_memory_enable+0x1ba>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    1d4e:	f240 31ff 	movw	r1, #1023	; 0x3ff
    1d52:	4288      	cmp	r0, r1
    1d54:	f000 80b9 	beq.w	1eca <am_hal_pwrctrl_memory_enable+0x1c6>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM256K )
    1d58:	f240 72ff 	movw	r2, #2047	; 0x7ff
    1d5c:	4290      	cmp	r0, r2
    1d5e:	d00e      	beq.n	1d7e <am_hal_pwrctrl_memory_enable+0x7a>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM256K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    1d60:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
    1d64:	f000 80b7 	beq.w	1ed6 <am_hal_pwrctrl_memory_enable+0x1d2>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    1d68:	f06f 4420 	mvn.w	r4, #2684354560	; 0xa0000000
    1d6c:	42a0      	cmp	r0, r4
    1d6e:	f000 80b5 	beq.w	1edc <am_hal_pwrctrl_memory_enable+0x1d8>
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_ALL )
    1d72:	f104 4580 	add.w	r5, r4, #1073741824	; 0x40000000
    1d76:	f505 5c00 	add.w	ip, r5, #8192	; 0x2000
    1d7a:	4560      	cmp	r0, ip
    1d7c:	d132      	bne.n	1de4 <am_hal_pwrctrl_memory_enable+0xe0>
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_ALL;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
    1d7e:	495c      	ldr	r1, [pc, #368]	; (1ef0 <am_hal_pwrctrl_memory_enable+0x1ec>)
    1d80:	e066      	b.n	1e50 <am_hal_pwrctrl_memory_enable+0x14c>
    1d82:	f46f 5580 	mvn.w	r5, #4096	; 0x1000
    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    1d86:	2340      	movs	r3, #64	; 0x40

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
    1d88:	2120      	movs	r1, #32
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    1d8a:	4c5a      	ldr	r4, [pc, #360]	; (1ef4 <am_hal_pwrctrl_memory_enable+0x1f0>)
    1d8c:	6822      	ldr	r2, [r4, #0]
    1d8e:	402a      	ands	r2, r5
    1d90:	6022      	str	r2, [r4, #0]
    //
    // Enable the required memory.
    //
    if ( ui32MemEnMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) |= ui32MemEnMask;
    1d92:	4d58      	ldr	r5, [pc, #352]	; (1ef4 <am_hal_pwrctrl_memory_enable+0x1f0>)
    1d94:	682c      	ldr	r4, [r5, #0]
    1d96:	4320      	orrs	r0, r4
    1d98:	6028      	str	r0, [r5, #0]
    //
    // Wait for the power to be turned on.
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    1d9a:	2b00      	cmp	r3, #0
    1d9c:	d029      	beq.n	1df2 <am_hal_pwrctrl_memory_enable+0xee>
    {
        while ( --i32TOcnt              &&
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1d9e:	4a56      	ldr	r2, [pc, #344]	; (1ef8 <am_hal_pwrctrl_memory_enable+0x1f4>)
    1da0:	6810      	ldr	r0, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1da2:	4203      	tst	r3, r0
    1da4:	bf18      	it	ne
    1da6:	20c6      	movne	r0, #198	; 0xc6
    1da8:	d01f      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1daa:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1dac:	422b      	tst	r3, r5
    1dae:	d01c      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1db0:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1db2:	4223      	tst	r3, r4
    1db4:	d019      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1db6:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1db8:	422b      	tst	r3, r5
    1dba:	d016      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1dbc:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1dbe:	4223      	tst	r3, r4
    1dc0:	d013      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1dc2:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1dc4:	422b      	tst	r3, r5
    1dc6:	d010      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1dc8:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1dca:	4223      	tst	r3, r4
    1dcc:	d00d      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1dce:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1dd0:	422b      	tst	r3, r5
    1dd2:	d00a      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1dd4:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1dd6:	4223      	tst	r3, r4
    1dd8:	d007      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    1dda:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    1ddc:	422b      	tst	r3, r5
    1dde:	d004      	beq.n	1dea <am_hal_pwrctrl_memory_enable+0xe6>
    1de0:	3809      	subs	r0, #9
    1de2:	d1e2      	bne.n	1daa <am_hal_pwrctrl_memory_enable+0xa6>
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
        ui32PwrStatDisMask = 0;
    }
    else
    {
        return false;
    1de4:	2000      	movs	r0, #0
    {
        return false;
    }

    return true;
}
    1de6:	bc30      	pop	{r4, r5}
    1de8:	4770      	bx	lr
    {
        return false;
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    1dea:	b911      	cbnz	r1, 1df2 <am_hal_pwrctrl_memory_enable+0xee>
    if ( i32TOcnt <= 0 )
    {
        return false;
    }

    return true;
    1dec:	2001      	movs	r0, #1
}
    1dee:	bc30      	pop	{r4, r5}
    1df0:	4770      	bx	lr

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1df2:	4b41      	ldr	r3, [pc, #260]	; (1ef8 <am_hal_pwrctrl_memory_enable+0x1f4>)
    1df4:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1df6:	ea31 0402 	bics.w	r4, r1, r2
    1dfa:	bf18      	it	ne
    1dfc:	24c6      	movne	r4, #198	; 0xc6
    1dfe:	d0f5      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e00:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e02:	ea31 0000 	bics.w	r0, r1, r0
    1e06:	d0f1      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e08:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e0a:	ea31 0005 	bics.w	r0, r1, r5
    1e0e:	d0ed      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e10:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e12:	ea31 0002 	bics.w	r0, r1, r2
    1e16:	d0e9      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e18:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e1a:	ea31 0000 	bics.w	r0, r1, r0
    1e1e:	d0e5      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e20:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e22:	ea31 0005 	bics.w	r0, r1, r5
    1e26:	d0e1      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e28:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e2a:	ea31 0002 	bics.w	r0, r1, r2
    1e2e:	d0dd      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e30:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e32:	ea31 0000 	bics.w	r0, r1, r0
    1e36:	d0d9      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e38:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e3a:	ea31 0005 	bics.w	r0, r1, r5
    1e3e:	d0d5      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    1e40:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    1e42:	ea31 0002 	bics.w	r0, r1, r2
    1e46:	d0d1      	beq.n	1dec <am_hal_pwrctrl_memory_enable+0xe8>
    1e48:	3c09      	subs	r4, #9
    1e4a:	d1d9      	bne.n	1e00 <am_hal_pwrctrl_memory_enable+0xfc>
    1e4c:	e7ca      	b.n	1de4 <am_hal_pwrctrl_memory_enable+0xe0>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN |
                         AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
    1e4e:	2160      	movs	r1, #96	; 0x60
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    1e50:	2300      	movs	r3, #0
    1e52:	e79e      	b.n	1d92 <am_hal_pwrctrl_memory_enable+0x8e>
    1e54:	4d29      	ldr	r5, [pc, #164]	; (1efc <am_hal_pwrctrl_memory_enable+0x1f8>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1e56:	4b2a      	ldr	r3, [pc, #168]	; (1f00 <am_hal_pwrctrl_memory_enable+0x1fc>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    1e58:	f44f 7180 	mov.w	r1, #256	; 0x100
    1e5c:	e795      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1e5e:	f46f 65ff 	mvn.w	r5, #2040	; 0x7f8
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1e62:	f44f 23ff 	mov.w	r3, #522240	; 0x7f800
                         AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    1e66:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    1e6a:	e78e      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1e6c:	4d25      	ldr	r5, [pc, #148]	; (1f04 <am_hal_pwrctrl_memory_enable+0x200>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1e6e:	4b26      	ldr	r3, [pc, #152]	; (1f08 <am_hal_pwrctrl_memory_enable+0x204>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    1e70:	f44f 7140 	mov.w	r1, #768	; 0x300
    1e74:	e789      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1e76:	f46f 65fe 	mvn.w	r5, #2032	; 0x7f0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1e7a:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    1e7e:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    1e82:	e782      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1e84:	f46f 65e0 	mvn.w	r5, #1792	; 0x700
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1e88:	f44f 23e0 	mov.w	r3, #458752	; 0x70000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    1e8c:	f44f 417f 	mov.w	r1, #65280	; 0xff00
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
    1e90:	20ff      	movs	r0, #255	; 0xff
    1e92:	e77a      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1e94:	f46f 65fc 	mvn.w	r5, #2016	; 0x7e0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1e98:	f44f 23fc 	mov.w	r3, #516096	; 0x7e000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    1e9c:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
    1ea0:	e773      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1ea2:	f46f 65f8 	mvn.w	r5, #1984	; 0x7c0
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1ea6:	f44f 23f8 	mov.w	r3, #507904	; 0x7c000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    1eaa:	f44f 517c 	mov.w	r1, #16128	; 0x3f00
    1eae:	e76c      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1eb0:	f46f 65f0 	mvn.w	r5, #1920	; 0x780
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1eb4:	f44f 23f0 	mov.w	r3, #491520	; 0x78000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    1eb8:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
    1ebc:	e765      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    1ebe:	f46f 65c0 	mvn.w	r5, #1536	; 0x600
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1ec2:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    1ec6:	4911      	ldr	r1, [pc, #68]	; (1f0c <am_hal_pwrctrl_memory_enable+0x208>)
    1ec8:	e75f      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    1eca:	4911      	ldr	r1, [pc, #68]	; (1f10 <am_hal_pwrctrl_memory_enable+0x20c>)
    1ecc:	f46f 6580 	mvn.w	r5, #1024	; 0x400
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    1ed0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    1ed4:	e759      	b.n	1d8a <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN    |
                         AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    1ed6:	f44f 1120 	mov.w	r1, #2621440	; 0x280000
    1eda:	e7b9      	b.n	1e50 <am_hal_pwrctrl_memory_enable+0x14c>
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    1edc:	4805      	ldr	r0, [pc, #20]	; (1ef4 <am_hal_pwrctrl_memory_enable+0x1f0>)
    1ede:	6803      	ldr	r3, [r0, #0]
    1ee0:	f023 4120 	bic.w	r1, r3, #2684354560	; 0xa0000000
    1ee4:	6001      	str	r1, [r0, #0]
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    1ee6:	f44f 1320 	mov.w	r3, #2621440	; 0x280000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
    1eea:	2100      	movs	r1, #0
    1eec:	e757      	b.n	1d9e <am_hal_pwrctrl_memory_enable+0x9a>
    1eee:	bf00      	nop
    1ef0:	0007ff00 	.word	0x0007ff00
    1ef4:	40021010 	.word	0x40021010
    1ef8:	40021014 	.word	0x40021014
    1efc:	fffff801 	.word	0xfffff801
    1f00:	0007fe00 	.word	0x0007fe00
    1f04:	fffff803 	.word	0xfffff803
    1f08:	0007fc00 	.word	0x0007fc00
    1f0c:	0001ff00 	.word	0x0001ff00
    1f10:	0003ff00 	.word	0x0003ff00

00001f14 <am_hal_pwrctrl_bucks_init>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    1f14:	4b0f      	ldr	r3, [pc, #60]	; (1f54 <am_hal_pwrctrl_bucks_init+0x40>)
    1f16:	681a      	ldr	r2, [r3, #0]
    1f18:	0792      	lsls	r2, r2, #30
    1f1a:	d502      	bpl.n	1f22 <am_hal_pwrctrl_bucks_init+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    1f1c:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    1f1e:	07c3      	lsls	r3, r0, #31
    1f20:	d40e      	bmi.n	1f40 <am_hal_pwrctrl_bucks_init+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    1f22:	4b0d      	ldr	r3, [pc, #52]	; (1f58 <am_hal_pwrctrl_bucks_init+0x44>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    1f24:	4a0b      	ldr	r2, [pc, #44]	; (1f54 <am_hal_pwrctrl_bucks_init+0x40>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    1f26:	6819      	ldr	r1, [r3, #0]
    1f28:	f041 0002 	orr.w	r0, r1, #2
    1f2c:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    1f2e:	6819      	ldr	r1, [r3, #0]
    1f30:	f041 0001 	orr.w	r0, r1, #1
    1f34:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    1f36:	6813      	ldr	r3, [r2, #0]
    1f38:	f003 0103 	and.w	r1, r3, #3
    1f3c:	2903      	cmp	r1, #3
    1f3e:	d1fa      	bne.n	1f36 <am_hal_pwrctrl_bucks_init+0x22>
void
am_hal_pwrctrl_bucks_init(void)
{
    am_hal_pwrctrl_bucks_enable();

    while ( ( AM_REG(PWRCTRL, POWERSTATUS) &
    1f40:	4a04      	ldr	r2, [pc, #16]	; (1f54 <am_hal_pwrctrl_bucks_init+0x40>)
    1f42:	6810      	ldr	r0, [r2, #0]
    1f44:	f000 0303 	and.w	r3, r0, #3
    1f48:	2b03      	cmp	r3, #3
    1f4a:	d1fa      	bne.n	1f42 <am_hal_pwrctrl_bucks_init+0x2e>
                AM_REG_PWRCTRL_POWERSTATUS_MEMBUCKON_M ) );

    //
    // Additional delay to make sure BUCKs are initialized.
    //
    am_hal_flash_delay(200 / 3);
    1f4c:	2042      	movs	r0, #66	; 0x42
    1f4e:	f7fe bcbb 	b.w	8c8 <am_hal_flash_delay>
    1f52:	bf00      	nop
    1f54:	40021004 	.word	0x40021004
    1f58:	40021000 	.word	0x40021000

00001f5c <am_hal_pwrctrl_bucks_enable>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    1f5c:	4b0b      	ldr	r3, [pc, #44]	; (1f8c <am_hal_pwrctrl_bucks_enable+0x30>)
    1f5e:	681a      	ldr	r2, [r3, #0]
    1f60:	0792      	lsls	r2, r2, #30
    1f62:	d502      	bpl.n	1f6a <am_hal_pwrctrl_bucks_enable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    1f64:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    1f66:	07c3      	lsls	r3, r0, #31
    1f68:	d40e      	bmi.n	1f88 <am_hal_pwrctrl_bucks_enable+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    1f6a:	4b09      	ldr	r3, [pc, #36]	; (1f90 <am_hal_pwrctrl_bucks_enable+0x34>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    1f6c:	4a07      	ldr	r2, [pc, #28]	; (1f8c <am_hal_pwrctrl_bucks_enable+0x30>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    1f6e:	6819      	ldr	r1, [r3, #0]
    1f70:	f041 0002 	orr.w	r0, r1, #2
    1f74:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    1f76:	6819      	ldr	r1, [r3, #0]
    1f78:	f041 0001 	orr.w	r0, r1, #1
    1f7c:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    1f7e:	6813      	ldr	r3, [r2, #0]
    1f80:	f003 0103 	and.w	r1, r3, #3
    1f84:	2903      	cmp	r1, #3
    1f86:	d1fa      	bne.n	1f7e <am_hal_pwrctrl_bucks_enable+0x22>
    1f88:	4770      	bx	lr
    1f8a:	bf00      	nop
    1f8c:	40021004 	.word	0x40021004
    1f90:	40021000 	.word	0x40021000

00001f94 <am_hal_pwrctrl_bucks_disable>:
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    1f94:	4b12      	ldr	r3, [pc, #72]	; (1fe0 <am_hal_pwrctrl_bucks_disable+0x4c>)
    1f96:	681a      	ldr	r2, [r3, #0]
    1f98:	0792      	lsls	r2, r2, #30
    1f9a:	d402      	bmi.n	1fa2 <am_hal_pwrctrl_bucks_disable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) == 0)
    1f9c:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    1f9e:	07c3      	lsls	r3, r0, #31
    1fa0:	d51c      	bpl.n	1fdc <am_hal_pwrctrl_bucks_disable+0x48>
//
//*****************************************************************************
static bool
isRev_ADC(void)
{
    return AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    1fa2:	4910      	ldr	r1, [pc, #64]	; (1fe4 <am_hal_pwrctrl_bucks_disable+0x50>)
    1fa4:	680b      	ldr	r3, [r1, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    1fa6:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    1faa:	2a20      	cmp	r2, #32
    1fac:	d00b      	beq.n	1fc6 <am_hal_pwrctrl_bucks_disable+0x32>
    else
    {
        //
        // Power them down
        //
        AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 0);
    1fae:	4b0e      	ldr	r3, [pc, #56]	; (1fe8 <am_hal_pwrctrl_bucks_disable+0x54>)
    1fb0:	681a      	ldr	r2, [r3, #0]
    1fb2:	f022 0002 	bic.w	r0, r2, #2
    1fb6:	6018      	str	r0, [r3, #0]
        AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 0);
    1fb8:	6819      	ldr	r1, [r3, #0]
    1fba:	f021 0201 	bic.w	r2, r1, #1
    1fbe:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait until BUCKs are disabled.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_BUCKDIS_DELAYCYCLES / 3);
    1fc0:	200a      	movs	r0, #10
    1fc2:	f7fe bc81 	b.w	8c8 <am_hal_flash_delay>

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    1fc6:	4809      	ldr	r0, [pc, #36]	; (1fec <am_hal_pwrctrl_bucks_disable+0x58>)
    1fc8:	6801      	ldr	r1, [r0, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    1fca:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    1fce:	d1ee      	bne.n	1fae <am_hal_pwrctrl_bucks_disable+0x1a>
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    {
            //
            // Set SUPPLYSRC to handle this case
            //
            AM_REG(PWRCTRL, SUPPLYSRC) &=
    1fd0:	4805      	ldr	r0, [pc, #20]	; (1fe8 <am_hal_pwrctrl_bucks_disable+0x54>)
    1fd2:	6803      	ldr	r3, [r0, #0]
    1fd4:	f003 0105 	and.w	r1, r3, #5
    1fd8:	6001      	str	r1, [r0, #0]
    1fda:	e7f1      	b.n	1fc0 <am_hal_pwrctrl_bucks_disable+0x2c>
    1fdc:	4770      	bx	lr
    1fde:	bf00      	nop
    1fe0:	40021004 	.word	0x40021004
    1fe4:	4002000c 	.word	0x4002000c
    1fe8:	40021000 	.word	0x40021000
    1fec:	40021008 	.word	0x40021008

00001ff0 <am_hal_pwrctrl_low_power_init>:
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    1ff0:	4905      	ldr	r1, [pc, #20]	; (2008 <am_hal_pwrctrl_low_power_init+0x18>)
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    1ff2:	4a06      	ldr	r2, [pc, #24]	; (200c <am_hal_pwrctrl_low_power_init+0x1c>)
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    1ff4:	680b      	ldr	r3, [r1, #0]
    1ff6:	f043 0006 	orr.w	r0, r3, #6
    1ffa:	6008      	str	r0, [r1, #0]
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    1ffc:	6811      	ldr	r1, [r2, #0]
    1ffe:	f021 0304 	bic.w	r3, r1, #4
    2002:	6013      	str	r3, [r2, #0]
    2004:	4770      	bx	lr
    2006:	bf00      	nop
    2008:	40021018 	.word	0x40021018
    200c:	40021000 	.word	0x40021000

00002010 <am_hal_queue_item_add>:
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
    2010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2012:	4604      	mov	r4, r0
    uint32_t i;
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    2014:	6907      	ldr	r7, [r0, #16]
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
    2016:	460e      	mov	r6, r1
    uint32_t i;
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    2018:	fb07 f702 	mul.w	r7, r7, r2
    bool bSuccess = false;
    uint32_t ui32Primask;

    pui8Source = (uint8_t *) pvSource;

    ui32Primask = am_hal_interrupt_master_disable();
    201c:	f001 f984 	bl	3328 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't already full
    //
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    2020:	68a5      	ldr	r5, [r4, #8]
    2022:	68e3      	ldr	r3, [r4, #12]
    2024:	1b59      	subs	r1, r3, r5
    2026:	428f      	cmp	r7, r1
    2028:	d87a      	bhi.n	2120 <am_hal_queue_item_add+0x110>
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    202a:	2f00      	cmp	r7, #0
    202c:	d071      	beq.n	2112 <am_hal_queue_item_add+0x102>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    202e:	4635      	mov	r5, r6
    2030:	6823      	ldr	r3, [r4, #0]
    2032:	6962      	ldr	r2, [r4, #20]
    2034:	f815 1b01 	ldrb.w	r1, [r5], #1
    2038:	54d1      	strb	r1, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    203a:	6822      	ldr	r2, [r4, #0]
    203c:	68e3      	ldr	r3, [r4, #12]
    203e:	3201      	adds	r2, #1
    2040:	19f1      	adds	r1, r6, r7
    2042:	fbb2 fcf3 	udiv	ip, r2, r3
    2046:	1e7e      	subs	r6, r7, #1
    2048:	fb03 231c 	mls	r3, r3, ip, r2
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    204c:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    204e:	6023      	str	r3, [r4, #0]
    2050:	f006 0203 	and.w	r2, r6, #3
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    2054:	d05c      	beq.n	2110 <am_hal_queue_item_add+0x100>
    2056:	b34a      	cbz	r2, 20ac <am_hal_queue_item_add+0x9c>
    2058:	2a01      	cmp	r2, #1
    205a:	d019      	beq.n	2090 <am_hal_queue_item_add+0x80>
    205c:	2a02      	cmp	r2, #2
    205e:	d00b      	beq.n	2078 <am_hal_queue_item_add+0x68>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    2060:	6962      	ldr	r2, [r4, #20]
    2062:	f815 6b01 	ldrb.w	r6, [r5], #1
    2066:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    2068:	6822      	ldr	r2, [r4, #0]
    206a:	68e3      	ldr	r3, [r4, #12]
    206c:	3201      	adds	r2, #1
    206e:	fbb2 fef3 	udiv	lr, r2, r3
    2072:	fb03 231e 	mls	r3, r3, lr, r2
    2076:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    2078:	6962      	ldr	r2, [r4, #20]
    207a:	f815 6b01 	ldrb.w	r6, [r5], #1
    207e:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    2080:	6822      	ldr	r2, [r4, #0]
    2082:	68e3      	ldr	r3, [r4, #12]
    2084:	3201      	adds	r2, #1
    2086:	fbb2 fcf3 	udiv	ip, r2, r3
    208a:	fb03 231c 	mls	r3, r3, ip, r2
    208e:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    2090:	6962      	ldr	r2, [r4, #20]
    2092:	f815 6b01 	ldrb.w	r6, [r5], #1
    2096:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    2098:	6822      	ldr	r2, [r4, #0]
    209a:	68e3      	ldr	r3, [r4, #12]
    209c:	3201      	adds	r2, #1
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    209e:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    20a0:	fbb2 fef3 	udiv	lr, r2, r3
    20a4:	fb03 231e 	mls	r3, r3, lr, r2
    20a8:	6023      	str	r3, [r4, #0]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    20aa:	d031      	beq.n	2110 <am_hal_queue_item_add+0x100>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    20ac:	46ac      	mov	ip, r5
    20ae:	6962      	ldr	r2, [r4, #20]
    20b0:	f81c 6b01 	ldrb.w	r6, [ip], #1
    20b4:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    20b6:	6823      	ldr	r3, [r4, #0]
    20b8:	68e2      	ldr	r2, [r4, #12]
    20ba:	3301      	adds	r3, #1
    20bc:	fbb3 fef2 	udiv	lr, r3, r2
    20c0:	fb02 331e 	mls	r3, r2, lr, r3
    20c4:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    20c6:	6962      	ldr	r2, [r4, #20]
    20c8:	786e      	ldrb	r6, [r5, #1]
    20ca:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    20cc:	6823      	ldr	r3, [r4, #0]
    20ce:	68e6      	ldr	r6, [r4, #12]
    20d0:	3301      	adds	r3, #1
    20d2:	fbb3 fef6 	udiv	lr, r3, r6
    20d6:	fb06 331e 	mls	r3, r6, lr, r3
    20da:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    20dc:	6966      	ldr	r6, [r4, #20]
    20de:	f89c 2001 	ldrb.w	r2, [ip, #1]
    20e2:	54f2      	strb	r2, [r6, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    20e4:	6823      	ldr	r3, [r4, #0]
    20e6:	68e2      	ldr	r2, [r4, #12]
    20e8:	3301      	adds	r3, #1
    20ea:	fbb3 fcf2 	udiv	ip, r3, r2
    20ee:	fb02 331c 	mls	r3, r2, ip, r3
    20f2:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    20f4:	6962      	ldr	r2, [r4, #20]
    20f6:	78ee      	ldrb	r6, [r5, #3]
    20f8:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    20fa:	6826      	ldr	r6, [r4, #0]
    20fc:	68e3      	ldr	r3, [r4, #12]
    20fe:	3601      	adds	r6, #1
    2100:	3504      	adds	r5, #4
    2102:	fbb6 fef3 	udiv	lr, r6, r3
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    2106:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    2108:	fb03 631e 	mls	r3, r3, lr, r6
    210c:	6023      	str	r3, [r4, #0]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    210e:	d1cd      	bne.n	20ac <am_hal_queue_item_add+0x9c>
    2110:	68a5      	ldr	r5, [r4, #8]
        }

        //
        // Update the length value appropriately.
        //
        psQueue->ui32Length += ui32Bytes;
    2112:	443d      	add	r5, r7
    2114:	60a5      	str	r5, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
    2116:	2401      	movs	r4, #1
        // failure.
        //
        bSuccess = false;
    }

    am_hal_interrupt_master_set(ui32Primask);
    2118:	f001 f90a 	bl	3330 <am_hal_interrupt_master_set>

    return bSuccess;
}
    211c:	4620      	mov	r0, r4
    211e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    {
        //
        // The buffer can't fit the amount of data requested. Return a
        // failure.
        //
        bSuccess = false;
    2120:	2400      	movs	r4, #0
    }

    am_hal_interrupt_master_set(ui32Primask);
    2122:	f001 f905 	bl	3330 <am_hal_interrupt_master_set>

    return bSuccess;
}
    2126:	4620      	mov	r0, r4
    2128:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    212a:	bf00      	nop

0000212c <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    212c:	4a05      	ldr	r2, [pc, #20]	; (2144 <am_hal_rtc_osc_select+0x18>)
    212e:	6813      	ldr	r3, [r2, #0]
{
    //
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    2130:	b918      	cbnz	r0, 213a <am_hal_rtc_osc_select+0xe>
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    2132:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    2136:	6010      	str	r0, [r2, #0]
    2138:	4770      	bx	lr
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    213a:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    213e:	6011      	str	r1, [r2, #0]
    2140:	4770      	bx	lr
    2142:	bf00      	nop
    2144:	4000400c 	.word	0x4000400c

00002148 <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_REG(RTC, RTCCTL) |= AM_REG_RTC_RTCCTL_RSTOP(1);
    2148:	4a02      	ldr	r2, [pc, #8]	; (2154 <am_hal_rtc_osc_disable+0xc>)
    214a:	6813      	ldr	r3, [r2, #0]
    214c:	f043 0010 	orr.w	r0, r3, #16
    2150:	6010      	str	r0, [r2, #0]
    2152:	4770      	bx	lr
    2154:	40004050 	.word	0x40004050

00002158 <am_hal_sysctrl_sleep>:
//! @return None.
//
//*****************************************************************************
void
am_hal_sysctrl_sleep(bool bSleepDeep)
{
    2158:	b5f0      	push	{r4, r5, r6, r7, lr}
    215a:	b083      	sub	sp, #12
    215c:	4605      	mov	r5, r0
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    215e:	f001 f8e3 	bl	3328 <am_hal_interrupt_master_disable>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    2162:	4a41      	ldr	r2, [pc, #260]	; (2268 <am_hal_sysctrl_sleep+0x110>)
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    2164:	4604      	mov	r4, r0

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    2166:	b11d      	cbz	r5, 2170 <am_hal_sysctrl_sleep+0x18>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    2168:	4b40      	ldr	r3, [pc, #256]	; (226c <am_hal_sysctrl_sleep+0x114>)
    216a:	6818      	ldr	r0, [r3, #0]

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    216c:	07c3      	lsls	r3, r0, #31
    216e:	d509      	bpl.n	2184 <am_hal_sysctrl_sleep+0x2c>
    else
    {
        //
        // Prepare the core for normal sleep (write 0 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 0);
    2170:	6811      	ldr	r1, [r2, #0]
    2172:	f021 0604 	bic.w	r6, r1, #4
    2176:	6016      	str	r6, [r2, #0]

        //
        // Go to sleep.
        //
        AM_ASM_WFI;
    2178:	bf30      	wfi
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    217a:	4620      	mov	r0, r4
    217c:	f001 f8d8 	bl	3330 <am_hal_interrupt_master_set>
}
    2180:	b003      	add	sp, #12
    2182:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    2184:	6813      	ldr	r3, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    2186:	493a      	ldr	r1, [pc, #232]	; (2270 <am_hal_sysctrl_sleep+0x118>)
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    2188:	4f3a      	ldr	r7, [pc, #232]	; (2274 <am_hal_sysctrl_sleep+0x11c>)
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    218a:	4d3b      	ldr	r5, [pc, #236]	; (2278 <am_hal_sysctrl_sleep+0x120>)

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    218c:	483b      	ldr	r0, [pc, #236]	; (227c <am_hal_sysctrl_sleep+0x124>)
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    218e:	f043 0604 	orr.w	r6, r3, #4
    2192:	6016      	str	r6, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    2194:	6809      	ldr	r1, [r1, #0]
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    2196:	683b      	ldr	r3, [r7, #0]
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    2198:	682a      	ldr	r2, [r5, #0]

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    219a:	6800      	ldr	r0, [r0, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    219c:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
    21a0:	2920      	cmp	r1, #32

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    21a2:	f103 36ff 	add.w	r6, r3, #4294967295
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    21a6:	bf14      	ite	ne
    21a8:	2500      	movne	r5, #0
    21aa:	2502      	moveq	r5, #2

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    21ac:	2e03      	cmp	r6, #3
    21ae:	bf8c      	ite	hi
    21b0:	2100      	movhi	r1, #0
    21b2:	2104      	movls	r1, #4
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    21b4:	f012 0303 	ands.w	r3, r2, #3
    21b8:	bf18      	it	ne
    21ba:	2301      	movne	r3, #1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    21bc:	f240 56ff 	movw	r6, #1535	; 0x5ff
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    21c0:	432b      	orrs	r3, r5
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    21c2:	4006      	ands	r6, r0
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    21c4:	ea43 0501 	orr.w	r5, r3, r1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    21c8:	b91e      	cbnz	r6, 21d2 <am_hal_sysctrl_sleep+0x7a>
    21ca:	f045 0508 	orr.w	r5, r5, #8
        //
        // Check if special buck handling is needed
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
    21ce:	2d0f      	cmp	r5, #15
    21d0:	d00a      	beq.n	21e8 <am_hal_sysctrl_sleep+0x90>
        }

        //
        // Execute the sleep instruction.
        //
        AM_ASM_WFI;
    21d2:	bf30      	wfi

        //
        // Return from sleep
        //
        if ( bBuckZX_chk )
    21d4:	2d0f      	cmp	r5, #15
    21d6:	d01a      	beq.n	220e <am_hal_sysctrl_sleep+0xb6>
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    21d8:	4f29      	ldr	r7, [pc, #164]	; (2280 <am_hal_sysctrl_sleep+0x128>)
    21da:	2101      	movs	r1, #1
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    21dc:	4620      	mov	r0, r4
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    21de:	7039      	strb	r1, [r7, #0]
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    21e0:	f001 f8a6 	bl	3330 <am_hal_interrupt_master_set>
}
    21e4:	b003      	add	sp, #12
    21e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
        {
            ui32BuckTimer = g_ui32BuckTimer - 1;
    21e8:	683a      	ldr	r2, [r7, #0]
    21ea:	1e50      	subs	r0, r2, #1
    21ec:	9000      	str	r0, [sp, #0]
            //
            // Before going to sleep, clear the buck timers.
            // This will also handle the case where we're going back to
            // sleep before the buck sequence has even completed.
            //
            am_hal_ctimer_clear(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    21ee:	9800      	ldr	r0, [sp, #0]
    21f0:	f04f 31ff 	mov.w	r1, #4294967295
    21f4:	f000 f86a 	bl	22cc <am_hal_ctimer_clear>

            //
            // Set CMPR0 of both timerA and timerB to the period value
            //
            #define     TIMER_PERIOD_BUCKS  1
            am_hal_ctimer_period_set(ui32BuckTimer,
    21f8:	9800      	ldr	r0, [sp, #0]
    21fa:	4633      	mov	r3, r6
    21fc:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    2200:	f04f 31ff 	mov.w	r1, #4294967295
    2204:	f000 f876 	bl	22f4 <am_hal_ctimer_period_set>
                                     0);

            //
            // Disable bucks before going to sleep.
            //
            am_hal_pwrctrl_bucks_disable();
    2208:	f7ff fec4 	bl	1f94 <am_hal_pwrctrl_bucks_disable>
    220c:	e7e1      	b.n	21d2 <am_hal_sysctrl_sleep+0x7a>
    bool bDoRestore = false;

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    220e:	f3ef 8310 	mrs	r3, PRIMASK
    2212:	9301      	str	r3, [sp, #4]
    2214:	b672      	cpsid	i

    //
    // Get the current zero cross trim values.
    //
    ui32SaveCore = AM_BFR(MCUCTRL, BUCK3, COREBUCKZXTRIM);
    2216:	4e1b      	ldr	r6, [pc, #108]	; (2284 <am_hal_sysctrl_sleep+0x12c>)
    2218:	6832      	ldr	r2, [r6, #0]
    ui32SaveMem  = AM_BFR(MCUCTRL, BUCK3, MEMBUCKZXTRIM);
    221a:	6832      	ldr	r2, [r6, #0]
    //
    if ( bDoRestore )
    {
        if ( ui32Flags & SETBUCKZX_RESTORE_CORE_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, COREBUCKZXTRIM, ui32NewCore);
    221c:	6835      	ldr	r5, [r6, #0]
    221e:	f025 0c3c 	bic.w	ip, r5, #60	; 0x3c
    2222:	f04c 021c 	orr.w	r2, ip, #28
    2226:	6032      	str	r2, [r6, #0]
        }

        if ( ui32Flags & SETBUCKZX_RESTORE_MEM_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, MEMBUCKZXTRIM,  ui32NewMem);
    2228:	6830      	ldr	r0, [r6, #0]
    222a:	f420 31f0 	bic.w	r1, r0, #122880	; 0x1e000
    222e:	f441 4360 	orr.w	r3, r1, #57344	; 0xe000
    2232:	6033      	str	r3, [r6, #0]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    2234:	9e01      	ldr	r6, [sp, #4]
    2236:	f386 8810 	msr	PRIMASK, r6
                      SETBUCKZX_RESTORE_BOTH );

            //
            // Delay for 2us before enabling bucks.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(2) );
    223a:	201c      	movs	r0, #28
    223c:	f7fe fb44 	bl	8c8 <am_hal_flash_delay>

            //
            // Turn on the bucks
            //
            am_hal_pwrctrl_bucks_enable();
    2240:	f7ff fe8c 	bl	1f5c <am_hal_pwrctrl_bucks_enable>

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    2244:	683f      	ldr	r7, [r7, #0]
            g_bBuckRestoreComplete = false;

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    2246:	4910      	ldr	r1, [pc, #64]	; (2288 <am_hal_sysctrl_sleep+0x130>)
            ui32BuckTimer = g_ui32BuckTimer - 1;

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    2248:	4d0d      	ldr	r5, [pc, #52]	; (2280 <am_hal_sysctrl_sleep+0x128>)
    224a:	2200      	movs	r2, #0
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    224c:	1e7b      	subs	r3, r7, #1
            g_ui32BuckInputs = 0;

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    224e:	204c      	movs	r0, #76	; 0x4c
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    2250:	9300      	str	r3, [sp, #0]

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    2252:	702a      	strb	r2, [r5, #0]

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    2254:	600a      	str	r2, [r1, #0]

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    2256:	f7fe fb37 	bl	8c8 <am_hal_flash_delay>

            //
            // Start timers (set the enable bit, clear the clear bit)
            //
            am_hal_ctimer_start(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    225a:	9800      	ldr	r0, [sp, #0]
    225c:	f04f 31ff 	mov.w	r1, #4294967295
    2260:	f000 f81a 	bl	2298 <am_hal_ctimer_start>
    2264:	e789      	b.n	217a <am_hal_sysctrl_sleep+0x22>
    2266:	bf00      	nop
    2268:	e000ed10 	.word	0xe000ed10
    226c:	40020250 	.word	0x40020250
    2270:	4002000c 	.word	0x4002000c
    2274:	10001068 	.word	0x10001068
    2278:	40021000 	.word	0x40021000
    227c:	40021008 	.word	0x40021008
    2280:	10001063 	.word	0x10001063
    2284:	40020068 	.word	0x40020068
    2288:	10001064 	.word	0x10001064

0000228c <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    228c:	4b01      	ldr	r3, [pc, #4]	; (2294 <am_hal_vcomp_disable+0x8>)
    228e:	2237      	movs	r2, #55	; 0x37
    2290:	601a      	str	r2, [r3, #0]
    2292:	4770      	bx	lr
    2294:	4000c008 	.word	0x4000c008

00002298 <am_hal_ctimer_start>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    2298:	b410      	push	{r4}
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    229a:	f3ef 8310 	mrs	r3, PRIMASK
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    229e:	b083      	sub	sp, #12
    uint32_t ui32ConfigVal;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    22a0:	0100      	lsls	r0, r0, #4
    22a2:	4a09      	ldr	r2, [pc, #36]	; (22c8 <am_hal_ctimer_start+0x30>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    22a4:	9301      	str	r3, [sp, #4]
    22a6:	b672      	cpsid	i

    //
    // Read the current value.
    //
    ui32ConfigVal = *pui32ConfigReg;
    22a8:	5883      	ldr	r3, [r0, r2]

    //
    // Clear out the "clear" bit.
    //
    ui32ConfigVal &= ~(ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0CLR_M |
    22aa:	f001 2408 	and.w	r4, r1, #134219776	; 0x8000800
    22ae:	ea23 0304 	bic.w	r3, r3, r4
                                           AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Set the "enable bit"
    //
    ui32ConfigVal |= (ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0EN_M |
    22b2:	f001 1101 	and.w	r1, r1, #65537	; 0x10001
    22b6:	4319      	orrs	r1, r3
                                          AM_REG_CTIMER_CTRL0_TMRB0EN_M));

    //
    // Write the value back to the register.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    22b8:	5081      	str	r1, [r0, r2]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    22ba:	9801      	ldr	r0, [sp, #4]
    22bc:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_start()
    22c0:	b003      	add	sp, #12
    22c2:	f85d 4b04 	ldr.w	r4, [sp], #4
    22c6:	4770      	bx	lr
    22c8:	4000800c 	.word	0x4000800c

000022cc <am_hal_ctimer_clear>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_clear(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    22cc:	b082      	sub	sp, #8
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    22ce:	f3ef 8310 	mrs	r3, PRIMASK
    volatile uint32_t *pui32ConfigReg;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    22d2:	0100      	lsls	r0, r0, #4
    22d4:	4a06      	ldr	r2, [pc, #24]	; (22f0 <am_hal_ctimer_clear+0x24>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    22d6:	9301      	str	r3, [sp, #4]
    22d8:	b672      	cpsid	i

    //
    // Set the "clear" bit
    //
    AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
    22da:	5883      	ldr	r3, [r0, r2]
    22dc:	f001 2108 	and.w	r1, r1, #134219776	; 0x8000800
    22e0:	4319      	orrs	r1, r3
    22e2:	5081      	str	r1, [r0, r2]
                                   AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    22e4:	9801      	ldr	r0, [sp, #4]
    22e6:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_clear()
    22ea:	b002      	add	sp, #8
    22ec:	4770      	bx	lr
    22ee:	bf00      	nop
    22f0:	4000800c 	.word	0x4000800c

000022f4 <am_hal_ctimer_period_set>:
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    22f4:	b4f0      	push	{r4, r5, r6, r7}
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    22f6:	f3ef 8410 	mrs	r4, PRIMASK
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    22fa:	b082      	sub	sp, #8
    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                   (ui32TimerNumber * TIMER_OFFSET));
    22fc:	0100      	lsls	r0, r0, #4

    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    22fe:	4d1c      	ldr	r5, [pc, #112]	; (2370 <am_hal_ctimer_period_set+0x7c>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    2300:	9401      	str	r4, [sp, #4]
                                   (ui32TimerNumber * TIMER_OFFSET));

    //
    // Find the correct compare registers to write.
    //
    pui32CompareRegA = (uint32_t *)(AM_REG_CTIMERn(0) +
    2302:	4e1c      	ldr	r6, [pc, #112]	; (2374 <am_hal_ctimer_period_set+0x80>)
                                    AM_REG_CTIMER_CMPRA0_O +
                                    (ui32TimerNumber * TIMER_OFFSET));

    pui32CompareRegB = (uint32_t *)(AM_REG_CTIMERn(0) +
    2304:	4f1c      	ldr	r7, [pc, #112]	; (2378 <am_hal_ctimer_period_set+0x84>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    2306:	b672      	cpsid	i
    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    2308:	f511 3f80 	cmn.w	r1, #65536	; 0x10000

    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    230c:	5944      	ldr	r4, [r0, r5]
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    230e:	d01a      	beq.n	2346 <am_hal_ctimer_period_set+0x52>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    2310:	f404 75c0 	and.w	r5, r4, #384	; 0x180
    2314:	2d80      	cmp	r5, #128	; 0x80
    2316:	d01b      	beq.n	2350 <am_hal_ctimer_period_set+0x5c>

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    2318:	f64f 73ff 	movw	r3, #65535	; 0xffff
    231c:	2500      	movs	r5, #0
    231e:	4299      	cmp	r1, r3
        ui32Comp1 = ui32Period;
    }
    else
    {
        ui32Comp0 = ui32Period;
        ui32Comp1 = 0;
    2320:	462c      	mov	r4, r5

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    2322:	d01c      	beq.n	235e <am_hal_ctimer_period_set+0x6a>
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));
    }
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    2324:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    2328:	d01e      	beq.n	2368 <am_hal_ctimer_period_set+0x74>
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    232a:	0c21      	lsrs	r1, r4, #16
    232c:	040c      	lsls	r4, r1, #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    232e:	b291      	uxth	r1, r2
    2330:	430d      	orrs	r5, r1
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    2332:	ea44 4212 	orr.w	r2, r4, r2, lsr #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    2336:	5185      	str	r5, [r0, r6]
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    2338:	51c2      	str	r2, [r0, r7]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    233a:	9801      	ldr	r0, [sp, #4]
    233c:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_period_set()
    2340:	b002      	add	sp, #8
    2342:	bcf0      	pop	{r4, r5, r6, r7}
    2344:	4770      	bx	lr

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    2346:	0c25      	lsrs	r5, r4, #16
    2348:	f405 74c0 	and.w	r4, r5, #384	; 0x180
    234c:	2c80      	cmp	r4, #128	; 0x80
    234e:	d10a      	bne.n	2366 <am_hal_ctimer_period_set+0x72>
    2350:	0415      	lsls	r5, r2, #16
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
        ui32Comp1 = ui32Period;
    2352:	4614      	mov	r4, r2
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
    2354:	1ad2      	subs	r2, r2, r3

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    2356:	f64f 73ff 	movw	r3, #65535	; 0xffff
    235a:	4299      	cmp	r1, r3
    235c:	d1e2      	bne.n	2324 <am_hal_ctimer_period_set+0x30>
    {
        //
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    235e:	b297      	uxth	r7, r2
    2360:	433d      	orrs	r5, r7
    2362:	5185      	str	r5, [r0, r6]
    2364:	e7e9      	b.n	233a <am_hal_ctimer_period_set+0x46>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    2366:	2500      	movs	r5, #0
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    {
        //
        // For timer B, write the values to the TIMERA compare register.
        //
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    2368:	b296      	uxth	r6, r2
    236a:	4335      	orrs	r5, r6
    236c:	51c5      	str	r5, [r0, r7]
    236e:	e7e4      	b.n	233a <am_hal_ctimer_period_set+0x46>
    2370:	4000800c 	.word	0x4000800c
    2374:	40008004 	.word	0x40008004
    2378:	40008008 	.word	0x40008008

0000237c <am_hal_i2c_bit_bang_receive>:
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    237c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2380:	4c9c      	ldr	r4, [pc, #624]	; (25f4 <am_hal_i2c_bit_bang_receive+0x278>)
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    2382:	b085      	sub	sp, #20
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2384:	68e6      	ldr	r6, [r4, #12]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    2386:	f89d 5038 	ldrb.w	r5, [sp, #56]	; 0x38
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    238a:	69a7      	ldr	r7, [r4, #24]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    238c:	9503      	str	r5, [sp, #12]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    238e:	6965      	ldr	r5, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2390:	6037      	str	r7, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2392:	682d      	ldr	r5, [r5, #0]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    2394:	f89d b03c 	ldrb.w	fp, [sp, #60]	; 0x3c
    2398:	9101      	str	r1, [sp, #4]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    239a:	422f      	tst	r7, r5
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    239c:	4680      	mov	r8, r0
    239e:	4691      	mov	r9, r2
    23a0:	9302      	str	r3, [sp, #8]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23a2:	bf08      	it	eq
    23a4:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    23a8:	d14c      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23aa:	2004      	movs	r0, #4
    23ac:	f7fe fa8c 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23b0:	6962      	ldr	r2, [r4, #20]
    23b2:	69a3      	ldr	r3, [r4, #24]
    23b4:	6811      	ldr	r1, [r2, #0]
    23b6:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23b8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23bc:	d142      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23be:	f7fe fa83 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23c2:	6966      	ldr	r6, [r4, #20]
    23c4:	69a7      	ldr	r7, [r4, #24]
    23c6:	6832      	ldr	r2, [r6, #0]
    23c8:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23ca:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23ce:	d139      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23d0:	f7fe fa7a 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23d4:	6961      	ldr	r1, [r4, #20]
    23d6:	69a3      	ldr	r3, [r4, #24]
    23d8:	680e      	ldr	r6, [r1, #0]
    23da:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23dc:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23e0:	d130      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23e2:	f7fe fa71 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23e6:	6967      	ldr	r7, [r4, #20]
    23e8:	69a1      	ldr	r1, [r4, #24]
    23ea:	683a      	ldr	r2, [r7, #0]
    23ec:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23ee:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23f2:	d127      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23f4:	f7fe fa68 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    23f8:	6966      	ldr	r6, [r4, #20]
    23fa:	69a3      	ldr	r3, [r4, #24]
    23fc:	6837      	ldr	r7, [r6, #0]
    23fe:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2400:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2404:	d11e      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2406:	f7fe fa5f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    240a:	6961      	ldr	r1, [r4, #20]
    240c:	69a6      	ldr	r6, [r4, #24]
    240e:	680a      	ldr	r2, [r1, #0]
    2410:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2412:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2416:	d115      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2418:	f7fe fa56 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    241c:	6967      	ldr	r7, [r4, #20]
    241e:	69a3      	ldr	r3, [r4, #24]
    2420:	6839      	ldr	r1, [r7, #0]
    2422:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2424:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2428:	d10c      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    242a:	f7fe fa4d 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    242e:	6960      	ldr	r0, [r4, #20]
    2430:	69a6      	ldr	r6, [r4, #24]
    2432:	6802      	ldr	r2, [r0, #0]
    2434:	4232      	tst	r2, r6
    2436:	d105      	bne.n	2444 <am_hal_i2c_bit_bang_receive+0xc8>
    {
        if (--maxLoop == 0)
    2438:	3d08      	subs	r5, #8
    243a:	d1b6      	bne.n	23aa <am_hal_i2c_bit_bang_receive+0x2e>
    status = i2c_send_byte(address);
    if ( status != AM_HAL_I2C_BIT_BANG_SUCCESS )
    {
        if ( status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
        {
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    243c:	2003      	movs	r0, #3

    //
    // message successfully received (how could we fail???)
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
}
    243e:	b005      	add	sp, #20
    2440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Pull down on data line with clock high --> START CONDITION
    //
    WRITE_SDA_LO();
    2444:	6a27      	ldr	r7, [r4, #32]
    2446:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2448:	603b      	str	r3, [r7, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    244a:	2005      	movs	r0, #5
    244c:	f7fe fa3c 	bl	8c8 <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2450:	4f68      	ldr	r7, [pc, #416]	; (25f4 <am_hal_i2c_bit_bang_receive+0x278>)
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2452:	2600      	movs	r6, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    2454:	f04f 0a80 	mov.w	sl, #128	; 0x80
    2458:	fa4a f306 	asr.w	r3, sl, r6
    245c:	ea13 0f08 	tst.w	r3, r8
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2460:	6921      	ldr	r1, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    2462:	bf14      	ite	ne
    2464:	69fb      	ldrne	r3, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    2466:	6a3b      	ldreq	r3, [r7, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2468:	69a0      	ldr	r0, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    246a:	6aba      	ldr	r2, [r7, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    246c:	6008      	str	r0, [r1, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    246e:	601a      	str	r2, [r3, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    2470:	2007      	movs	r0, #7
    2472:	f7fe fa29 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2476:	68e1      	ldr	r1, [r4, #12]
    2478:	69a0      	ldr	r0, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    247a:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    247c:	6008      	str	r0, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    247e:	681a      	ldr	r2, [r3, #0]
    2480:	4210      	tst	r0, r2
    2482:	bf08      	it	eq
    2484:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2488:	d149      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    248a:	2004      	movs	r0, #4
    248c:	f7fe fa1c 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2490:	6961      	ldr	r1, [r4, #20]
    2492:	69a3      	ldr	r3, [r4, #24]
    2494:	680a      	ldr	r2, [r1, #0]
    2496:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2498:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    249c:	d13f      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    249e:	f7fe fa13 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24a2:	6961      	ldr	r1, [r4, #20]
    24a4:	69a3      	ldr	r3, [r4, #24]
    24a6:	680a      	ldr	r2, [r1, #0]
    24a8:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24aa:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24ae:	d136      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24b0:	f7fe fa0a 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24b4:	6961      	ldr	r1, [r4, #20]
    24b6:	69a3      	ldr	r3, [r4, #24]
    24b8:	680a      	ldr	r2, [r1, #0]
    24ba:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24bc:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24c0:	d12d      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24c2:	f7fe fa01 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24c6:	6961      	ldr	r1, [r4, #20]
    24c8:	69a3      	ldr	r3, [r4, #24]
    24ca:	680a      	ldr	r2, [r1, #0]
    24cc:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24ce:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24d2:	d124      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24d4:	f7fe f9f8 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24d8:	6961      	ldr	r1, [r4, #20]
    24da:	69a3      	ldr	r3, [r4, #24]
    24dc:	680a      	ldr	r2, [r1, #0]
    24de:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24e0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24e4:	d11b      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24e6:	f7fe f9ef 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24ea:	6961      	ldr	r1, [r4, #20]
    24ec:	69a3      	ldr	r3, [r4, #24]
    24ee:	680a      	ldr	r2, [r1, #0]
    24f0:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24f2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24f6:	d112      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24f8:	f7fe f9e6 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    24fc:	6961      	ldr	r1, [r4, #20]
    24fe:	69a3      	ldr	r3, [r4, #24]
    2500:	680a      	ldr	r2, [r1, #0]
    2502:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2504:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2508:	d109      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    250a:	f7fe f9dd 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    250e:	6960      	ldr	r0, [r4, #20]
    2510:	69a1      	ldr	r1, [r4, #24]
    2512:	6803      	ldr	r3, [r0, #0]
    2514:	420b      	tst	r3, r1
    2516:	d102      	bne.n	251e <am_hal_i2c_bit_bang_receive+0x1a2>
    {
        if (--maxLoop == 0)
    2518:	3d08      	subs	r5, #8
    251a:	d1b6      	bne.n	248a <am_hal_i2c_bit_bang_receive+0x10e>
    251c:	e78e      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    251e:	3601      	adds	r6, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    2520:	2005      	movs	r0, #5
    2522:	f7fe f9d1 	bl	8c8 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2526:	2e08      	cmp	r6, #8
    2528:	d196      	bne.n	2458 <am_hal_i2c_bit_bang_receive+0xdc>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    252a:	6927      	ldr	r7, [r4, #16]
    252c:	69a2      	ldr	r2, [r4, #24]
    252e:	603a      	str	r2, [r7, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    2530:	2007      	movs	r0, #7
    2532:	f7fe f9c9 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2536:	68e0      	ldr	r0, [r4, #12]
    2538:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    253a:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    253c:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    253e:	681f      	ldr	r7, [r3, #0]
    2540:	4239      	tst	r1, r7
    2542:	bf08      	it	eq
    2544:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2548:	d149      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    254a:	2004      	movs	r0, #4
    254c:	f7fe f9bc 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2550:	6962      	ldr	r2, [r4, #20]
    2552:	69a1      	ldr	r1, [r4, #24]
    2554:	6813      	ldr	r3, [r2, #0]
    2556:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2558:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    255c:	d13f      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    255e:	f7fe f9b3 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2562:	6967      	ldr	r7, [r4, #20]
    2564:	69a1      	ldr	r1, [r4, #24]
    2566:	683a      	ldr	r2, [r7, #0]
    2568:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    256a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    256e:	d136      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2570:	f7fe f9aa 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2574:	6967      	ldr	r7, [r4, #20]
    2576:	69a3      	ldr	r3, [r4, #24]
    2578:	6839      	ldr	r1, [r7, #0]
    257a:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    257c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2580:	d12d      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2582:	f7fe f9a1 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2586:	6962      	ldr	r2, [r4, #20]
    2588:	69a7      	ldr	r7, [r4, #24]
    258a:	6813      	ldr	r3, [r2, #0]
    258c:	423b      	tst	r3, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    258e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2592:	d124      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2594:	f7fe f998 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2598:	6961      	ldr	r1, [r4, #20]
    259a:	69a7      	ldr	r7, [r4, #24]
    259c:	680a      	ldr	r2, [r1, #0]
    259e:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25a0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    25a4:	d11b      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25a6:	f7fe f98f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    25aa:	6961      	ldr	r1, [r4, #20]
    25ac:	69a3      	ldr	r3, [r4, #24]
    25ae:	680f      	ldr	r7, [r1, #0]
    25b0:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25b2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    25b6:	d112      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25b8:	f7fe f986 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    25bc:	6962      	ldr	r2, [r4, #20]
    25be:	69a1      	ldr	r1, [r4, #24]
    25c0:	6813      	ldr	r3, [r2, #0]
    25c2:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25c4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    25c8:	d109      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25ca:	f7fe f97d 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    25ce:	6960      	ldr	r0, [r4, #20]
    25d0:	69a7      	ldr	r7, [r4, #24]
    25d2:	6802      	ldr	r2, [r0, #0]
    25d4:	423a      	tst	r2, r7
    25d6:	d102      	bne.n	25de <am_hal_i2c_bit_bang_receive+0x262>
    {
        if (--maxLoop == 0)
    25d8:	3d08      	subs	r5, #8
    25da:	d1b6      	bne.n	254a <am_hal_i2c_bit_bang_receive+0x1ce>
    25dc:	e72e      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    25de:	6a65      	ldr	r5, [r4, #36]	; 0x24
    25e0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    25e2:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    25e4:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    25e6:	400d      	ands	r5, r1
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    25e8:	f7fe f96e 	bl	8c8 <am_hal_flash_delay>
    if ( data_naked )
    25ec:	b125      	cbz	r5, 25f8 <am_hal_i2c_bit_bang_receive+0x27c>
    status = i2c_send_byte(address);
    if ( status != AM_HAL_I2C_BIT_BANG_SUCCESS )
    {
        if ( status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
        {
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    25ee:	2001      	movs	r0, #1
    25f0:	e725      	b.n	243e <am_hal_i2c_bit_bang_receive+0xc2>
    25f2:	bf00      	nop
    25f4:	1000106c 	.word	0x1000106c
        }
        return status;
    }

    if ( bUseOffset )
    25f8:	9b03      	ldr	r3, [sp, #12]
    25fa:	2b00      	cmp	r3, #0
    25fc:	f040 81b5 	bne.w	296a <am_hal_i2c_bit_bang_receive+0x5ee>
    }

    //
    // receive the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    2600:	9f01      	ldr	r7, [sp, #4]
    2602:	f1b7 0a01 	subs.w	sl, r7, #1
    2606:	f000 80d8 	beq.w	27ba <am_hal_i2c_bit_bang_receive+0x43e>
    260a:	46c8      	mov	r8, r9
    260c:	44ca      	add	sl, r9
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    260e:	2700      	movs	r7, #0
    2610:	463e      	mov	r6, r7
        if ( GET_SDA() )
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    2612:	f04f 0980 	mov.w	r9, #128	; 0x80
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2616:	6921      	ldr	r1, [r4, #16]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    2618:	69e3      	ldr	r3, [r4, #28]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    261a:	69a0      	ldr	r0, [r4, #24]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    261c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    261e:	6008      	str	r0, [r1, #0]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    2620:	601a      	str	r2, [r3, #0]

        //
        // Delay for 1/2 bit cell time to start the clock and let peer write on SDA
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    2622:	2007      	movs	r0, #7
    2624:	f7fe f950 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2628:	68e1      	ldr	r1, [r4, #12]
    262a:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    262c:	6960      	ldr	r0, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    262e:	600b      	str	r3, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2630:	6802      	ldr	r2, [r0, #0]
    2632:	4213      	tst	r3, r2
    2634:	bf08      	it	eq
    2636:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    263a:	d149      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    263c:	2004      	movs	r0, #4
    263e:	f7fe f943 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2642:	6961      	ldr	r1, [r4, #20]
    2644:	69a3      	ldr	r3, [r4, #24]
    2646:	680a      	ldr	r2, [r1, #0]
    2648:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    264a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    264e:	d13f      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2650:	f7fe f93a 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2654:	6961      	ldr	r1, [r4, #20]
    2656:	69a3      	ldr	r3, [r4, #24]
    2658:	680a      	ldr	r2, [r1, #0]
    265a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    265c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2660:	d136      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2662:	f7fe f931 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2666:	6961      	ldr	r1, [r4, #20]
    2668:	69a3      	ldr	r3, [r4, #24]
    266a:	680a      	ldr	r2, [r1, #0]
    266c:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    266e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2672:	d12d      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2674:	f7fe f928 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2678:	6961      	ldr	r1, [r4, #20]
    267a:	69a3      	ldr	r3, [r4, #24]
    267c:	680a      	ldr	r2, [r1, #0]
    267e:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2680:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2684:	d124      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2686:	f7fe f91f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    268a:	6961      	ldr	r1, [r4, #20]
    268c:	69a3      	ldr	r3, [r4, #24]
    268e:	680a      	ldr	r2, [r1, #0]
    2690:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2692:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2696:	d11b      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2698:	f7fe f916 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    269c:	6961      	ldr	r1, [r4, #20]
    269e:	69a3      	ldr	r3, [r4, #24]
    26a0:	680a      	ldr	r2, [r1, #0]
    26a2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26a4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    26a8:	d112      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26aa:	f7fe f90d 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    26ae:	6961      	ldr	r1, [r4, #20]
    26b0:	69a3      	ldr	r3, [r4, #24]
    26b2:	680a      	ldr	r2, [r1, #0]
    26b4:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26b6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    26ba:	d109      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26bc:	f7fe f904 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    26c0:	6960      	ldr	r0, [r4, #20]
    26c2:	69a1      	ldr	r1, [r4, #24]
    26c4:	6803      	ldr	r3, [r0, #0]
    26c6:	420b      	tst	r3, r1
    26c8:	d102      	bne.n	26d0 <am_hal_i2c_bit_bang_receive+0x354>
    {
        if (--maxLoop == 0)
    26ca:	3d08      	subs	r5, #8
    26cc:	d1b6      	bne.n	263c <am_hal_i2c_bit_bang_receive+0x2c0>
    26ce:	e6b5      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // grab the data bit here
        //
        if ( GET_SDA() )
    26d0:	6a62      	ldr	r2, [r4, #36]	; 0x24
    26d2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    26d4:	6811      	ldr	r1, [r2, #0]
    26d6:	4201      	tst	r1, r0
    26d8:	d003      	beq.n	26e2 <am_hal_i2c_bit_bang_receive+0x366>
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    26da:	fa49 f306 	asr.w	r3, r9, r6
    26de:	431f      	orrs	r7, r3
    26e0:	b2ff      	uxtb	r7, r7
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    26e2:	3601      	adds	r6, #1
        }

        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    26e4:	2005      	movs	r0, #5
    26e6:	f7fe f8ef 	bl	8c8 <am_hal_flash_delay>
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    26ea:	2e08      	cmp	r6, #8
    26ec:	d193      	bne.n	2616 <am_hal_i2c_bit_bang_receive+0x29a>

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    26ee:	6921      	ldr	r1, [r4, #16]
    else
    {
        //
        // Pull down on data line with clock low to indicate ACK
        //
        WRITE_SDA_LO();
    26f0:	6a26      	ldr	r6, [r4, #32]

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    26f2:	69a0      	ldr	r0, [r4, #24]
    else
    {
        //
        // Pull down on data line with clock low to indicate ACK
        //
        WRITE_SDA_LO();
    26f4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    }

    *pRxByte = data_byte;
    26f6:	f808 7b01 	strb.w	r7, [r8], #1
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    26fa:	6008      	str	r0, [r1, #0]
    else
    {
        //
        // Pull down on data line with clock low to indicate ACK
        //
        WRITE_SDA_LO();
    26fc:	6032      	str	r2, [r6, #0]
    }
    //
    // Delay for 1/2 bit cell time before sending ACK to device
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    26fe:	2007      	movs	r0, #7
    2700:	f7fe f8e2 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2704:	68e7      	ldr	r7, [r4, #12]
    2706:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2708:	6961      	ldr	r1, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    270a:	603b      	str	r3, [r7, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    270c:	680e      	ldr	r6, [r1, #0]
    270e:	421e      	tst	r6, r3
    2710:	bf08      	it	eq
    2712:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2716:	d149      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2718:	2004      	movs	r0, #4
    271a:	f7fe f8d5 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    271e:	6962      	ldr	r2, [r4, #20]
    2720:	69a7      	ldr	r7, [r4, #24]
    2722:	6813      	ldr	r3, [r2, #0]
    2724:	423b      	tst	r3, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2726:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    272a:	d13f      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    272c:	f7fe f8cc 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2730:	6961      	ldr	r1, [r4, #20]
    2732:	69a6      	ldr	r6, [r4, #24]
    2734:	680a      	ldr	r2, [r1, #0]
    2736:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2738:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    273c:	d136      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    273e:	f7fe f8c3 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2742:	6967      	ldr	r7, [r4, #20]
    2744:	69a3      	ldr	r3, [r4, #24]
    2746:	6839      	ldr	r1, [r7, #0]
    2748:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    274a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    274e:	d12d      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2750:	f7fe f8ba 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2754:	6966      	ldr	r6, [r4, #20]
    2756:	69a7      	ldr	r7, [r4, #24]
    2758:	6832      	ldr	r2, [r6, #0]
    275a:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    275c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2760:	d124      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2762:	f7fe f8b1 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2766:	6961      	ldr	r1, [r4, #20]
    2768:	69a3      	ldr	r3, [r4, #24]
    276a:	680e      	ldr	r6, [r1, #0]
    276c:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    276e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2772:	d11b      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2774:	f7fe f8a8 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2778:	6967      	ldr	r7, [r4, #20]
    277a:	69a1      	ldr	r1, [r4, #24]
    277c:	683a      	ldr	r2, [r7, #0]
    277e:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2780:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2784:	d112      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2786:	f7fe f89f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    278a:	6966      	ldr	r6, [r4, #20]
    278c:	69a3      	ldr	r3, [r4, #24]
    278e:	6837      	ldr	r7, [r6, #0]
    2790:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2792:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2796:	d109      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2798:	f7fe f896 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    279c:	6960      	ldr	r0, [r4, #20]
    279e:	69a1      	ldr	r1, [r4, #24]
    27a0:	6802      	ldr	r2, [r0, #0]
    27a2:	420a      	tst	r2, r1
    27a4:	d102      	bne.n	27ac <am_hal_i2c_bit_bang_receive+0x430>
    {
        if (--maxLoop == 0)
    27a6:	3d08      	subs	r5, #8
    27a8:	d1b6      	bne.n	2718 <am_hal_i2c_bit_bang_receive+0x39c>
    27aa:	e647      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high to le peer sample the ACK/NAK
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    27ac:	2005      	movs	r0, #5
    27ae:	f7fe f88b 	bl	8c8 <am_hal_flash_delay>
    }

    //
    // receive the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    27b2:	45d0      	cmp	r8, sl
        status = i2c_receive_byte(pData, false);
        if (status != AM_HAL_I2C_BIT_BANG_SUCCESS)
        {
            return status;
        }
        pData++;
    27b4:	46c1      	mov	r9, r8
    }

    //
    // receive the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    27b6:	f47f af2a 	bne.w	260e <am_hal_i2c_bit_bang_receive+0x292>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    27ba:	2600      	movs	r6, #0
    27bc:	4637      	mov	r7, r6
        if ( GET_SDA() )
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    27be:	f04f 0880 	mov.w	r8, #128	; 0x80
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    27c2:	6920      	ldr	r0, [r4, #16]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    27c4:	69e3      	ldr	r3, [r4, #28]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    27c6:	69a1      	ldr	r1, [r4, #24]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    27c8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    27ca:	6001      	str	r1, [r0, #0]

        //
        // release the data line from from the previous ACK
        //
        PULL_SDA_HI();
    27cc:	601a      	str	r2, [r3, #0]

        //
        // Delay for 1/2 bit cell time to start the clock and let peer write on SDA
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    27ce:	2007      	movs	r0, #7
    27d0:	f7fe f87a 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    27d4:	68e0      	ldr	r0, [r4, #12]
    27d6:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    27d8:	6961      	ldr	r1, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    27da:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    27dc:	680a      	ldr	r2, [r1, #0]
    27de:	4213      	tst	r3, r2
    27e0:	bf08      	it	eq
    27e2:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    27e6:	d149      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27e8:	2004      	movs	r0, #4
    27ea:	f7fe f86d 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    27ee:	6961      	ldr	r1, [r4, #20]
    27f0:	69a3      	ldr	r3, [r4, #24]
    27f2:	680a      	ldr	r2, [r1, #0]
    27f4:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27f6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    27fa:	d13f      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27fc:	f7fe f864 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2800:	6961      	ldr	r1, [r4, #20]
    2802:	69a3      	ldr	r3, [r4, #24]
    2804:	680a      	ldr	r2, [r1, #0]
    2806:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2808:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    280c:	d136      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    280e:	f7fe f85b 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2812:	6961      	ldr	r1, [r4, #20]
    2814:	69a3      	ldr	r3, [r4, #24]
    2816:	680a      	ldr	r2, [r1, #0]
    2818:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    281a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    281e:	d12d      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2820:	f7fe f852 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2824:	6961      	ldr	r1, [r4, #20]
    2826:	69a3      	ldr	r3, [r4, #24]
    2828:	680a      	ldr	r2, [r1, #0]
    282a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    282c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2830:	d124      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2832:	f7fe f849 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2836:	6961      	ldr	r1, [r4, #20]
    2838:	69a3      	ldr	r3, [r4, #24]
    283a:	680a      	ldr	r2, [r1, #0]
    283c:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    283e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2842:	d11b      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2844:	f7fe f840 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2848:	6961      	ldr	r1, [r4, #20]
    284a:	69a3      	ldr	r3, [r4, #24]
    284c:	680a      	ldr	r2, [r1, #0]
    284e:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2850:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2854:	d112      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2856:	f7fe f837 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    285a:	6961      	ldr	r1, [r4, #20]
    285c:	69a3      	ldr	r3, [r4, #24]
    285e:	680a      	ldr	r2, [r1, #0]
    2860:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2862:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2866:	d109      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2868:	f7fe f82e 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    286c:	6960      	ldr	r0, [r4, #20]
    286e:	69a1      	ldr	r1, [r4, #24]
    2870:	6803      	ldr	r3, [r0, #0]
    2872:	420b      	tst	r3, r1
    2874:	d102      	bne.n	287c <am_hal_i2c_bit_bang_receive+0x500>
    {
        if (--maxLoop == 0)
    2876:	3d08      	subs	r5, #8
    2878:	d1b6      	bne.n	27e8 <am_hal_i2c_bit_bang_receive+0x46c>
    287a:	e5df      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // grab the data bit here
        //
        if ( GET_SDA() )
    287c:	6a62      	ldr	r2, [r4, #36]	; 0x24
    287e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    2880:	6811      	ldr	r1, [r2, #0]
    2882:	4201      	tst	r1, r0
    2884:	d003      	beq.n	288e <am_hal_i2c_bit_bang_receive+0x512>
        {
            //
            // set the bit in the data byte to be returned
            //
            data_byte |=  (0x80 >> i);
    2886:	fa48 f307 	asr.w	r3, r8, r7
    288a:	431e      	orrs	r6, r3
    288c:	b2f6      	uxtb	r6, r6
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    288e:	3701      	adds	r7, #1
        }

        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    2890:	2005      	movs	r0, #5
    2892:	f7fe f819 	bl	8c8 <am_hal_flash_delay>
    uint8_t data_byte = 0;

    //
    // Loop through receiving 8 bits
    //
    for (i = 0; i < 8; i++)
    2896:	2f08      	cmp	r7, #8
    2898:	d193      	bne.n	27c2 <am_hal_i2c_bit_bang_receive+0x446>

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    289a:	6921      	ldr	r1, [r4, #16]
    if (bNack)
    {
        //
        // Pull up on data line with clock low to indicate NAK
        //
        PULL_SDA_HI();
    289c:	69e7      	ldr	r7, [r4, #28]

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    289e:	69a5      	ldr	r5, [r4, #24]
    if (bNack)
    {
        //
        // Pull up on data line with clock low to indicate NAK
        //
        PULL_SDA_HI();
    28a0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    }

    *pRxByte = data_byte;
    28a2:	f889 6000 	strb.w	r6, [r9]
        WRITE_SDA_LO();
    }
    //
    // Delay for 1/2 bit cell time before sending ACK to device
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    28a6:	2007      	movs	r0, #7

    *pRxByte = data_byte;
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    28a8:	600d      	str	r5, [r1, #0]
    if (bNack)
    {
        //
        // Pull up on data line with clock low to indicate NAK
        //
        PULL_SDA_HI();
    28aa:	603a      	str	r2, [r7, #0]
        WRITE_SDA_LO();
    }
    //
    // Delay for 1/2 bit cell time before sending ACK to device
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    28ac:	f7fe f80c 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    28b0:	68e0      	ldr	r0, [r4, #12]
    28b2:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    28b4:	6966      	ldr	r6, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    28b6:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    28b8:	6831      	ldr	r1, [r6, #0]
    28ba:	420b      	tst	r3, r1
    28bc:	bf08      	it	eq
    28be:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    28c2:	f040 811e 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    28c6:	2004      	movs	r0, #4
    28c8:	f7fd fffe 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    28cc:	6967      	ldr	r7, [r4, #20]
    28ce:	69a3      	ldr	r3, [r4, #24]
    28d0:	683a      	ldr	r2, [r7, #0]
    28d2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    28d4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    28d8:	f040 8113 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    28dc:	f7fd fff4 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    28e0:	6966      	ldr	r6, [r4, #20]
    28e2:	69a1      	ldr	r1, [r4, #24]
    28e4:	6837      	ldr	r7, [r6, #0]
    28e6:	420f      	tst	r7, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    28e8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    28ec:	f040 8109 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    28f0:	f7fd ffea 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    28f4:	6962      	ldr	r2, [r4, #20]
    28f6:	69a3      	ldr	r3, [r4, #24]
    28f8:	6816      	ldr	r6, [r2, #0]
    28fa:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    28fc:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2900:	f040 80ff 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2904:	f7fd ffe0 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2908:	6961      	ldr	r1, [r4, #20]
    290a:	69a7      	ldr	r7, [r4, #24]
    290c:	680a      	ldr	r2, [r1, #0]
    290e:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2910:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2914:	f040 80f5 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2918:	f7fd ffd6 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    291c:	6966      	ldr	r6, [r4, #20]
    291e:	69a3      	ldr	r3, [r4, #24]
    2920:	6831      	ldr	r1, [r6, #0]
    2922:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2924:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2928:	f040 80eb 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    292c:	f7fd ffcc 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2930:	6967      	ldr	r7, [r4, #20]
    2932:	69a6      	ldr	r6, [r4, #24]
    2934:	683a      	ldr	r2, [r7, #0]
    2936:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2938:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    293c:	f040 80e1 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2940:	f7fd ffc2 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2944:	6961      	ldr	r1, [r4, #20]
    2946:	69a3      	ldr	r3, [r4, #24]
    2948:	680f      	ldr	r7, [r1, #0]
    294a:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    294c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2950:	f040 80d7 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2954:	f7fd ffb8 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2958:	6960      	ldr	r0, [r4, #20]
    295a:	69a6      	ldr	r6, [r4, #24]
    295c:	6802      	ldr	r2, [r0, #0]
    295e:	4232      	tst	r2, r6
    2960:	f040 80cf 	bne.w	2b02 <am_hal_i2c_bit_bang_receive+0x786>
    {
        if (--maxLoop == 0)
    2964:	3d08      	subs	r5, #8
    2966:	d1ae      	bne.n	28c6 <am_hal_i2c_bit_bang_receive+0x54a>
    2968:	e568      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    296a:	4fa4      	ldr	r7, [pc, #656]	; (2bfc <am_hal_i2c_bit_bang_receive+0x880>)

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    296c:	f04f 0880 	mov.w	r8, #128	; 0x80
    2970:	9b02      	ldr	r3, [sp, #8]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2972:	6920      	ldr	r0, [r4, #16]
    2974:	69a2      	ldr	r2, [r4, #24]
    2976:	6002      	str	r2, [r0, #0]

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    2978:	fa48 f105 	asr.w	r1, r8, r5
    297c:	4219      	tst	r1, r3
        {
            PULL_SDA_HI();
    297e:	bf14      	ite	ne
    2980:	69f9      	ldrne	r1, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    2982:	6a39      	ldreq	r1, [r7, #32]
    2984:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    2986:	6008      	str	r0, [r1, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    2988:	2007      	movs	r0, #7
    298a:	f7fd ff9d 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    298e:	68e1      	ldr	r1, [r4, #12]
    2990:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2992:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2994:	600b      	str	r3, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2996:	6810      	ldr	r0, [r2, #0]
    2998:	4203      	tst	r3, r0
    299a:	bf08      	it	eq
    299c:	f44f 76c8 	moveq.w	r6, #400	; 0x190
    29a0:	d149      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29a2:	2004      	movs	r0, #4
    29a4:	f7fd ff90 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29a8:	6961      	ldr	r1, [r4, #20]
    29aa:	69a3      	ldr	r3, [r4, #24]
    29ac:	680a      	ldr	r2, [r1, #0]
    29ae:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29b0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29b4:	d13f      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29b6:	f7fd ff87 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29ba:	6961      	ldr	r1, [r4, #20]
    29bc:	69a3      	ldr	r3, [r4, #24]
    29be:	680a      	ldr	r2, [r1, #0]
    29c0:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29c2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29c6:	d136      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29c8:	f7fd ff7e 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29cc:	6961      	ldr	r1, [r4, #20]
    29ce:	69a3      	ldr	r3, [r4, #24]
    29d0:	680a      	ldr	r2, [r1, #0]
    29d2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29d4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29d8:	d12d      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29da:	f7fd ff75 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29de:	6961      	ldr	r1, [r4, #20]
    29e0:	69a3      	ldr	r3, [r4, #24]
    29e2:	680a      	ldr	r2, [r1, #0]
    29e4:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29e6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29ea:	d124      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29ec:	f7fd ff6c 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29f0:	6961      	ldr	r1, [r4, #20]
    29f2:	69a3      	ldr	r3, [r4, #24]
    29f4:	680a      	ldr	r2, [r1, #0]
    29f6:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29f8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    29fc:	d11b      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    29fe:	f7fd ff63 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a02:	6961      	ldr	r1, [r4, #20]
    2a04:	69a3      	ldr	r3, [r4, #24]
    2a06:	680a      	ldr	r2, [r1, #0]
    2a08:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a0a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a0e:	d112      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a10:	f7fd ff5a 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a14:	6961      	ldr	r1, [r4, #20]
    2a16:	69a3      	ldr	r3, [r4, #24]
    2a18:	680a      	ldr	r2, [r1, #0]
    2a1a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a1c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a20:	d109      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a22:	f7fd ff51 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a26:	6960      	ldr	r0, [r4, #20]
    2a28:	69a1      	ldr	r1, [r4, #24]
    2a2a:	6803      	ldr	r3, [r0, #0]
    2a2c:	420b      	tst	r3, r1
    2a2e:	d102      	bne.n	2a36 <am_hal_i2c_bit_bang_receive+0x6ba>
    {
        if (--maxLoop == 0)
    2a30:	3e08      	subs	r6, #8
    2a32:	d1b6      	bne.n	29a2 <am_hal_i2c_bit_bang_receive+0x626>
    2a34:	e502      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2a36:	3501      	adds	r5, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    2a38:	2005      	movs	r0, #5
    2a3a:	f7fd ff45 	bl	8c8 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2a3e:	2d08      	cmp	r5, #8
    2a40:	d196      	bne.n	2970 <am_hal_i2c_bit_bang_receive+0x5f4>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    2a42:	6926      	ldr	r6, [r4, #16]
    2a44:	69a7      	ldr	r7, [r4, #24]
    2a46:	6037      	str	r7, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    2a48:	2007      	movs	r0, #7
    2a4a:	f7fd ff3d 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2a4e:	68e0      	ldr	r0, [r4, #12]
    2a50:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a52:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2a54:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a56:	6813      	ldr	r3, [r2, #0]
    2a58:	4219      	tst	r1, r3
    2a5a:	bf08      	it	eq
    2a5c:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2a60:	f040 80b5 	bne.w	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a64:	2004      	movs	r0, #4
    2a66:	f7fd ff2f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a6a:	6966      	ldr	r6, [r4, #20]
    2a6c:	69a7      	ldr	r7, [r4, #24]
    2a6e:	6831      	ldr	r1, [r6, #0]
    2a70:	4239      	tst	r1, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a72:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a76:	f040 80aa 	bne.w	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a7a:	f7fd ff25 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a7e:	6962      	ldr	r2, [r4, #20]
    2a80:	69a3      	ldr	r3, [r4, #24]
    2a82:	6816      	ldr	r6, [r2, #0]
    2a84:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a86:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a8a:	f040 80a0 	bne.w	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a8e:	f7fd ff1b 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a92:	6967      	ldr	r7, [r4, #20]
    2a94:	69a1      	ldr	r1, [r4, #24]
    2a96:	683a      	ldr	r2, [r7, #0]
    2a98:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2a9a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2a9e:	f040 8096 	bne.w	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2aa2:	f7fd ff11 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2aa6:	6966      	ldr	r6, [r4, #20]
    2aa8:	69a3      	ldr	r3, [r4, #24]
    2aaa:	6837      	ldr	r7, [r6, #0]
    2aac:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2aae:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ab2:	f040 808c 	bne.w	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ab6:	f7fd ff07 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2aba:	6961      	ldr	r1, [r4, #20]
    2abc:	69a6      	ldr	r6, [r4, #24]
    2abe:	680a      	ldr	r2, [r1, #0]
    2ac0:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ac2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ac6:	f040 8082 	bne.w	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2aca:	f7fd fefd 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ace:	6967      	ldr	r7, [r4, #20]
    2ad0:	69a3      	ldr	r3, [r4, #24]
    2ad2:	6839      	ldr	r1, [r7, #0]
    2ad4:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ad6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ada:	d178      	bne.n	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2adc:	f7fd fef4 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ae0:	6966      	ldr	r6, [r4, #20]
    2ae2:	69a7      	ldr	r7, [r4, #24]
    2ae4:	6832      	ldr	r2, [r6, #0]
    2ae6:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ae8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2aec:	d16f      	bne.n	2bce <am_hal_i2c_bit_bang_receive+0x852>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2aee:	f7fd feeb 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2af2:	6960      	ldr	r0, [r4, #20]
    2af4:	69a3      	ldr	r3, [r4, #24]
    2af6:	6801      	ldr	r1, [r0, #0]
    2af8:	4219      	tst	r1, r3
    2afa:	d168      	bne.n	2bce <am_hal_i2c_bit_bang_receive+0x852>
    {
        if (--maxLoop == 0)
    2afc:	3d08      	subs	r5, #8
    2afe:	d1b1      	bne.n	2a64 <am_hal_i2c_bit_bang_receive+0x6e8>
    2b00:	e49c      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high to le peer sample the ACK/NAK
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2b02:	2005      	movs	r0, #5
    2b04:	f7fd fee0 	bl	8c8 <am_hal_flash_delay>
    // Send stop condition
    //********************
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    2b08:	6925      	ldr	r5, [r4, #16]
    2b0a:	69a1      	ldr	r1, [r4, #24]
    2b0c:	6029      	str	r1, [r5, #0]

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2b0e:	2004      	movs	r0, #4
    // Send stop condition
    //********************
    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    2b10:	4f3a      	ldr	r7, [pc, #232]	; (2bfc <am_hal_i2c_bit_bang_receive+0x880>)

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2b12:	f7fd fed9 	bl	8c8 <am_hal_flash_delay>


    if (!bNoStop)
    2b16:	f1bb 0f00 	cmp.w	fp, #0
    2b1a:	d171      	bne.n	2c00 <am_hal_i2c_bit_bang_receive+0x884>
    {
        //
        // Pull down on data line with clock low
        //
        WRITE_SDA_LO();
    2b1c:	6a3b      	ldr	r3, [r7, #32]
    2b1e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    2b20:	6018      	str	r0, [r3, #0]
    }
    //
    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2b22:	2004      	movs	r0, #4
    2b24:	f7fd fed0 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2b28:	68fe      	ldr	r6, [r7, #12]
    2b2a:	69bd      	ldr	r5, [r7, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b2c:	697f      	ldr	r7, [r7, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2b2e:	6035      	str	r5, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b30:	683a      	ldr	r2, [r7, #0]
    2b32:	422a      	tst	r2, r5
    2b34:	d176      	bne.n	2c24 <am_hal_i2c_bit_bang_receive+0x8a8>
    2b36:	f44f 76c8 	mov.w	r6, #400	; 0x190
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b3a:	2004      	movs	r0, #4
    2b3c:	f7fd fec4 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b40:	6961      	ldr	r1, [r4, #20]
    2b42:	69a3      	ldr	r3, [r4, #24]
    2b44:	680d      	ldr	r5, [r1, #0]
    2b46:	421d      	tst	r5, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b48:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b4c:	d14b      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b4e:	f7fd febb 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b52:	6967      	ldr	r7, [r4, #20]
    2b54:	69a1      	ldr	r1, [r4, #24]
    2b56:	683a      	ldr	r2, [r7, #0]
    2b58:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b5a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b5e:	d142      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b60:	f7fd feb2 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b64:	6965      	ldr	r5, [r4, #20]
    2b66:	69a3      	ldr	r3, [r4, #24]
    2b68:	682f      	ldr	r7, [r5, #0]
    2b6a:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b6c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b70:	d139      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b72:	f7fd fea9 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b76:	6961      	ldr	r1, [r4, #20]
    2b78:	69a5      	ldr	r5, [r4, #24]
    2b7a:	680a      	ldr	r2, [r1, #0]
    2b7c:	422a      	tst	r2, r5
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b7e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b82:	d130      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b84:	f7fd fea0 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b88:	6967      	ldr	r7, [r4, #20]
    2b8a:	69a3      	ldr	r3, [r4, #24]
    2b8c:	6839      	ldr	r1, [r7, #0]
    2b8e:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b90:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b94:	d127      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2b96:	f7fd fe97 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2b9a:	6965      	ldr	r5, [r4, #20]
    2b9c:	69a7      	ldr	r7, [r4, #24]
    2b9e:	682a      	ldr	r2, [r5, #0]
    2ba0:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ba2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ba6:	d11e      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ba8:	f7fd fe8e 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2bac:	6961      	ldr	r1, [r4, #20]
    2bae:	69a3      	ldr	r3, [r4, #24]
    2bb0:	680d      	ldr	r5, [r1, #0]
    2bb2:	421d      	tst	r5, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2bb4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2bb8:	d115      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2bba:	f7fd fe85 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2bbe:	6960      	ldr	r0, [r4, #20]
    2bc0:	69a7      	ldr	r7, [r4, #24]
    2bc2:	6802      	ldr	r2, [r0, #0]
    2bc4:	423a      	tst	r2, r7
    2bc6:	d10e      	bne.n	2be6 <am_hal_i2c_bit_bang_receive+0x86a>
    {
        if (--maxLoop == 0)
    2bc8:	3e08      	subs	r6, #8
    2bca:	d1b6      	bne.n	2b3a <am_hal_i2c_bit_bang_receive+0x7be>
    2bcc:	e436      	b.n	243c <am_hal_i2c_bit_bang_receive+0xc0>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    2bce:	6a65      	ldr	r5, [r4, #36]	; 0x24
    2bd0:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    2bd2:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2bd4:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    2bd6:	4035      	ands	r5, r6
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2bd8:	f7fd fe76 	bl	8c8 <am_hal_flash_delay>
    if ( data_naked )
    2bdc:	2d00      	cmp	r5, #0
    2bde:	f43f ad0f 	beq.w	2600 <am_hal_i2c_bit_bang_receive+0x284>
    {
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;
    2be2:	2002      	movs	r0, #2
    2be4:	e42b      	b.n	243e <am_hal_i2c_bit_bang_receive+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2be6:	2005      	movs	r0, #5
    2be8:	f7fd fe6e 	bl	8c8 <am_hal_flash_delay>

    if (!bNoStop)
    2bec:	f1bb 0f00 	cmp.w	fp, #0
    2bf0:	d116      	bne.n	2c20 <am_hal_i2c_bit_bang_receive+0x8a4>
    {
        //
        // release data line with clock high --> STOP CONDITION
        //
        PULL_SDA_HI();
    2bf2:	69e6      	ldr	r6, [r4, #28]
    2bf4:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    2bf6:	6034      	str	r4, [r6, #0]
    }

    //
    // message successfully received (how could we fail???)
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    2bf8:	2000      	movs	r0, #0
    2bfa:	e420      	b.n	243e <am_hal_i2c_bit_bang_receive+0xc2>
    2bfc:	1000106c 	.word	0x1000106c
    else
    {
        //
        // Release data line with clock low itself, as we are not sending STOP
        //
        PULL_SDA_HI();
    2c00:	69fb      	ldr	r3, [r7, #28]
    2c02:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    2c04:	6018      	str	r0, [r3, #0]
    }
    //
    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2c06:	2004      	movs	r0, #4
    2c08:	f7fd fe5e 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2c0c:	68fe      	ldr	r6, [r7, #12]
    2c0e:	69bd      	ldr	r5, [r7, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c10:	697a      	ldr	r2, [r7, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2c12:	6035      	str	r5, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c14:	6811      	ldr	r1, [r2, #0]
    2c16:	4229      	tst	r1, r5
    2c18:	d08d      	beq.n	2b36 <am_hal_i2c_bit_bang_receive+0x7ba>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2c1a:	2005      	movs	r0, #5
    2c1c:	f7fd fe54 	bl	8c8 <am_hal_flash_delay>
    }

    //
    // message successfully received (how could we fail???)
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    2c20:	2000      	movs	r0, #0
    2c22:	e40c      	b.n	243e <am_hal_i2c_bit_bang_receive+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2c24:	2005      	movs	r0, #5
    2c26:	f7fd fe4f 	bl	8c8 <am_hal_flash_delay>
    2c2a:	e7e2      	b.n	2bf2 <am_hal_i2c_bit_bang_receive+0x876>

00002c2c <am_hal_i2c_bit_bang_send>:
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    2c2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2c30:	4c9c      	ldr	r4, [pc, #624]	; (2ea4 <am_hal_i2c_bit_bang_send+0x278>)
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    2c32:	b085      	sub	sp, #20
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2c34:	68e6      	ldr	r6, [r4, #12]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    2c36:	f89d 5038 	ldrb.w	r5, [sp, #56]	; 0x38
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2c3a:	69a7      	ldr	r7, [r4, #24]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    2c3c:	9503      	str	r5, [sp, #12]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c3e:	6965      	ldr	r5, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2c40:	6037      	str	r7, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c42:	682d      	ldr	r5, [r5, #0]
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    2c44:	f89d 603c 	ldrb.w	r6, [sp, #60]	; 0x3c
    2c48:	9602      	str	r6, [sp, #8]
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c4a:	422f      	tst	r7, r5
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    2c4c:	4680      	mov	r8, r0
    2c4e:	9101      	str	r1, [sp, #4]
    2c50:	4693      	mov	fp, r2
    2c52:	469a      	mov	sl, r3
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c54:	bf08      	it	eq
    2c56:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2c5a:	d14c      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2c5c:	2004      	movs	r0, #4
    2c5e:	f7fd fe33 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c62:	6962      	ldr	r2, [r4, #20]
    2c64:	69a3      	ldr	r3, [r4, #24]
    2c66:	6811      	ldr	r1, [r2, #0]
    2c68:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2c6a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c6e:	d142      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2c70:	f7fd fe2a 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c74:	6967      	ldr	r7, [r4, #20]
    2c76:	69a6      	ldr	r6, [r4, #24]
    2c78:	683a      	ldr	r2, [r7, #0]
    2c7a:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2c7c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c80:	d139      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2c82:	f7fd fe21 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c86:	6961      	ldr	r1, [r4, #20]
    2c88:	69a3      	ldr	r3, [r4, #24]
    2c8a:	680f      	ldr	r7, [r1, #0]
    2c8c:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2c8e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c92:	d130      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2c94:	f7fd fe18 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2c98:	6966      	ldr	r6, [r4, #20]
    2c9a:	69a1      	ldr	r1, [r4, #24]
    2c9c:	6832      	ldr	r2, [r6, #0]
    2c9e:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ca0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ca4:	d127      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ca6:	f7fd fe0f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2caa:	6967      	ldr	r7, [r4, #20]
    2cac:	69a3      	ldr	r3, [r4, #24]
    2cae:	683e      	ldr	r6, [r7, #0]
    2cb0:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2cb2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2cb6:	d11e      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2cb8:	f7fd fe06 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2cbc:	6961      	ldr	r1, [r4, #20]
    2cbe:	69a7      	ldr	r7, [r4, #24]
    2cc0:	680a      	ldr	r2, [r1, #0]
    2cc2:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2cc4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2cc8:	d115      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2cca:	f7fd fdfd 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2cce:	6966      	ldr	r6, [r4, #20]
    2cd0:	69a3      	ldr	r3, [r4, #24]
    2cd2:	6831      	ldr	r1, [r6, #0]
    2cd4:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2cd6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2cda:	d10c      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2cdc:	f7fd fdf4 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ce0:	6960      	ldr	r0, [r4, #20]
    2ce2:	69a7      	ldr	r7, [r4, #24]
    2ce4:	6802      	ldr	r2, [r0, #0]
    2ce6:	423a      	tst	r2, r7
    2ce8:	d105      	bne.n	2cf6 <am_hal_i2c_bit_bang_send+0xca>
    {
        if (--maxLoop == 0)
    2cea:	3d08      	subs	r5, #8
    2cec:	d1b6      	bne.n	2c5c <am_hal_i2c_bit_bang_send+0x30>
    //
    WAIT_I2C_CLOCK_HI_PERIOD();

    if ( data_naked )
    {
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;  // if it happens early
    2cee:	2003      	movs	r0, #3

    //
    // message successfully sent
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
}
    2cf0:	b005      	add	sp, #20
    2cf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Pull down on data line with clock high --> START CONDITION
    //
    WRITE_SDA_LO();
    2cf6:	6a26      	ldr	r6, [r4, #32]
    2cf8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2cfa:	6033      	str	r3, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2cfc:	2005      	movs	r0, #5
    2cfe:	f7fd fde3 	bl	8c8 <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2d02:	4f68      	ldr	r7, [pc, #416]	; (2ea4 <am_hal_i2c_bit_bang_send+0x278>)
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2d04:	2600      	movs	r6, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    2d06:	f04f 0980 	mov.w	r9, #128	; 0x80
    2d0a:	fa49 f306 	asr.w	r3, r9, r6
    2d0e:	ea13 0f08 	tst.w	r3, r8
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2d12:	6921      	ldr	r1, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    2d14:	bf14      	ite	ne
    2d16:	69fb      	ldrne	r3, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    2d18:	6a3b      	ldreq	r3, [r7, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2d1a:	69a0      	ldr	r0, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    2d1c:	6aba      	ldr	r2, [r7, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2d1e:	6008      	str	r0, [r1, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    2d20:	601a      	str	r2, [r3, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    2d22:	2007      	movs	r0, #7
    2d24:	f7fd fdd0 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2d28:	68e1      	ldr	r1, [r4, #12]
    2d2a:	69a0      	ldr	r0, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d2c:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2d2e:	6008      	str	r0, [r1, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d30:	681a      	ldr	r2, [r3, #0]
    2d32:	4202      	tst	r2, r0
    2d34:	bf08      	it	eq
    2d36:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2d3a:	d149      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d3c:	2004      	movs	r0, #4
    2d3e:	f7fd fdc3 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d42:	6961      	ldr	r1, [r4, #20]
    2d44:	69a3      	ldr	r3, [r4, #24]
    2d46:	680a      	ldr	r2, [r1, #0]
    2d48:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d4a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d4e:	d13f      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d50:	f7fd fdba 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d54:	6961      	ldr	r1, [r4, #20]
    2d56:	69a3      	ldr	r3, [r4, #24]
    2d58:	680a      	ldr	r2, [r1, #0]
    2d5a:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d5c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d60:	d136      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d62:	f7fd fdb1 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d66:	6961      	ldr	r1, [r4, #20]
    2d68:	69a3      	ldr	r3, [r4, #24]
    2d6a:	680a      	ldr	r2, [r1, #0]
    2d6c:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d6e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d72:	d12d      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d74:	f7fd fda8 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d78:	6961      	ldr	r1, [r4, #20]
    2d7a:	69a3      	ldr	r3, [r4, #24]
    2d7c:	680a      	ldr	r2, [r1, #0]
    2d7e:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d80:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d84:	d124      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d86:	f7fd fd9f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d8a:	6961      	ldr	r1, [r4, #20]
    2d8c:	69a3      	ldr	r3, [r4, #24]
    2d8e:	680a      	ldr	r2, [r1, #0]
    2d90:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d92:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d96:	d11b      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2d98:	f7fd fd96 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2d9c:	6961      	ldr	r1, [r4, #20]
    2d9e:	69a3      	ldr	r3, [r4, #24]
    2da0:	680a      	ldr	r2, [r1, #0]
    2da2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2da4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2da8:	d112      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2daa:	f7fd fd8d 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2dae:	6961      	ldr	r1, [r4, #20]
    2db0:	69a3      	ldr	r3, [r4, #24]
    2db2:	680a      	ldr	r2, [r1, #0]
    2db4:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2db6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2dba:	d109      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2dbc:	f7fd fd84 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2dc0:	6960      	ldr	r0, [r4, #20]
    2dc2:	69a1      	ldr	r1, [r4, #24]
    2dc4:	6803      	ldr	r3, [r0, #0]
    2dc6:	420b      	tst	r3, r1
    2dc8:	d102      	bne.n	2dd0 <am_hal_i2c_bit_bang_send+0x1a4>
    {
        if (--maxLoop == 0)
    2dca:	3d08      	subs	r5, #8
    2dcc:	d1b6      	bne.n	2d3c <am_hal_i2c_bit_bang_send+0x110>
    2dce:	e78e      	b.n	2cee <am_hal_i2c_bit_bang_send+0xc2>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2dd0:	3601      	adds	r6, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    2dd2:	2005      	movs	r0, #5
    2dd4:	f7fd fd78 	bl	8c8 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2dd8:	2e08      	cmp	r6, #8
    2dda:	d196      	bne.n	2d0a <am_hal_i2c_bit_bang_send+0xde>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    2ddc:	6926      	ldr	r6, [r4, #16]
    2dde:	69a2      	ldr	r2, [r4, #24]
    2de0:	6032      	str	r2, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    2de2:	2007      	movs	r0, #7
    2de4:	f7fd fd70 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2de8:	68e0      	ldr	r0, [r4, #12]
    2dea:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2dec:	6963      	ldr	r3, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2dee:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2df0:	681e      	ldr	r6, [r3, #0]
    2df2:	4231      	tst	r1, r6
    2df4:	bf08      	it	eq
    2df6:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2dfa:	d149      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2dfc:	2004      	movs	r0, #4
    2dfe:	f7fd fd63 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e02:	6962      	ldr	r2, [r4, #20]
    2e04:	69a1      	ldr	r1, [r4, #24]
    2e06:	6813      	ldr	r3, [r2, #0]
    2e08:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e0a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e0e:	d13f      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e10:	f7fd fd5a 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e14:	6966      	ldr	r6, [r4, #20]
    2e16:	69a1      	ldr	r1, [r4, #24]
    2e18:	6832      	ldr	r2, [r6, #0]
    2e1a:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e1c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e20:	d136      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e22:	f7fd fd51 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e26:	6966      	ldr	r6, [r4, #20]
    2e28:	69a3      	ldr	r3, [r4, #24]
    2e2a:	6831      	ldr	r1, [r6, #0]
    2e2c:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e2e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e32:	d12d      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e34:	f7fd fd48 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e38:	6962      	ldr	r2, [r4, #20]
    2e3a:	69a6      	ldr	r6, [r4, #24]
    2e3c:	6813      	ldr	r3, [r2, #0]
    2e3e:	4233      	tst	r3, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e40:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e44:	d124      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e46:	f7fd fd3f 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e4a:	6961      	ldr	r1, [r4, #20]
    2e4c:	69a6      	ldr	r6, [r4, #24]
    2e4e:	680a      	ldr	r2, [r1, #0]
    2e50:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e52:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e56:	d11b      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e58:	f7fd fd36 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e5c:	6961      	ldr	r1, [r4, #20]
    2e5e:	69a3      	ldr	r3, [r4, #24]
    2e60:	680e      	ldr	r6, [r1, #0]
    2e62:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e64:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e68:	d112      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e6a:	f7fd fd2d 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e6e:	6962      	ldr	r2, [r4, #20]
    2e70:	69a1      	ldr	r1, [r4, #24]
    2e72:	6813      	ldr	r3, [r2, #0]
    2e74:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e76:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e7a:	d109      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2e7c:	f7fd fd24 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2e80:	6960      	ldr	r0, [r4, #20]
    2e82:	69a6      	ldr	r6, [r4, #24]
    2e84:	6802      	ldr	r2, [r0, #0]
    2e86:	4232      	tst	r2, r6
    2e88:	d102      	bne.n	2e90 <am_hal_i2c_bit_bang_send+0x264>
    {
        if (--maxLoop == 0)
    2e8a:	3d08      	subs	r5, #8
    2e8c:	d1b6      	bne.n	2dfc <am_hal_i2c_bit_bang_send+0x1d0>
    2e8e:	e72e      	b.n	2cee <am_hal_i2c_bit_bang_send+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    2e90:	6a65      	ldr	r5, [r4, #36]	; 0x24
    2e92:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    2e94:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2e96:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    2e98:	400d      	ands	r5, r1
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    2e9a:	f7fd fd15 	bl	8c8 <am_hal_flash_delay>
    if ( data_naked )
    2e9e:	b11d      	cbz	r5, 2ea8 <am_hal_i2c_bit_bang_send+0x27c>
    status = i2c_send_byte(address);
    if ( status != AM_HAL_I2C_BIT_BANG_SUCCESS )
    {
        if ( status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
        {
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    2ea0:	2001      	movs	r0, #1
    2ea2:	e725      	b.n	2cf0 <am_hal_i2c_bit_bang_send+0xc4>
    2ea4:	1000106c 	.word	0x1000106c
        }
        return status;
    }

    if ( bUseOffset )
    2ea8:	9b03      	ldr	r3, [sp, #12]
    2eaa:	2b00      	cmp	r3, #0
    2eac:	f040 8164 	bne.w	3178 <am_hal_i2c_bit_bang_send+0x54c>
    }

    //
    // send the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    2eb0:	9f01      	ldr	r7, [sp, #4]
    2eb2:	2f00      	cmp	r7, #0
    2eb4:	f000 80de 	beq.w	3074 <am_hal_i2c_bit_bang_send+0x448>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2eb8:	4fa0      	ldr	r7, [pc, #640]	; (313c <am_hal_i2c_bit_bang_send+0x510>)
    }

    //
    // send the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    2eba:	f04f 0a00 	mov.w	sl, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    2ebe:	f04f 0980 	mov.w	r9, #128	; 0x80
    2ec2:	f81b 8b01 	ldrb.w	r8, [fp], #1
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2ec6:	2600      	movs	r6, #0
        WRITE_SCL_LO();

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    2ec8:	fa49 f306 	asr.w	r3, r9, r6
    2ecc:	ea13 0f08 	tst.w	r3, r8
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2ed0:	6920      	ldr	r0, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    2ed2:	bf14      	ite	ne
    2ed4:	69fb      	ldrne	r3, [r7, #28]
        }
        else
        {
            WRITE_SDA_LO();
    2ed6:	6a3b      	ldreq	r3, [r7, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2ed8:	69a2      	ldr	r2, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    2eda:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    2edc:	6002      	str	r2, [r0, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    2ede:	6019      	str	r1, [r3, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    2ee0:	2007      	movs	r0, #7
    2ee2:	f7fd fcf1 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2ee6:	68e0      	ldr	r0, [r4, #12]
    2ee8:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2eea:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2eec:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2eee:	6811      	ldr	r1, [r2, #0]
    2ef0:	420b      	tst	r3, r1
    2ef2:	bf08      	it	eq
    2ef4:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2ef8:	d149      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2efa:	2004      	movs	r0, #4
    2efc:	f7fd fce4 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f00:	6962      	ldr	r2, [r4, #20]
    2f02:	69a3      	ldr	r3, [r4, #24]
    2f04:	6811      	ldr	r1, [r2, #0]
    2f06:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f08:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f0c:	d13f      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f0e:	f7fd fcdb 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f12:	6962      	ldr	r2, [r4, #20]
    2f14:	69a3      	ldr	r3, [r4, #24]
    2f16:	6811      	ldr	r1, [r2, #0]
    2f18:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f1a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f1e:	d136      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f20:	f7fd fcd2 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f24:	6962      	ldr	r2, [r4, #20]
    2f26:	69a3      	ldr	r3, [r4, #24]
    2f28:	6811      	ldr	r1, [r2, #0]
    2f2a:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f2c:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f30:	d12d      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f32:	f7fd fcc9 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f36:	6962      	ldr	r2, [r4, #20]
    2f38:	69a3      	ldr	r3, [r4, #24]
    2f3a:	6811      	ldr	r1, [r2, #0]
    2f3c:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f3e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f42:	d124      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f44:	f7fd fcc0 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f48:	6962      	ldr	r2, [r4, #20]
    2f4a:	69a3      	ldr	r3, [r4, #24]
    2f4c:	6811      	ldr	r1, [r2, #0]
    2f4e:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f50:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f54:	d11b      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f56:	f7fd fcb7 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f5a:	6962      	ldr	r2, [r4, #20]
    2f5c:	69a3      	ldr	r3, [r4, #24]
    2f5e:	6811      	ldr	r1, [r2, #0]
    2f60:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f62:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f66:	d112      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f68:	f7fd fcae 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f6c:	6962      	ldr	r2, [r4, #20]
    2f6e:	69a3      	ldr	r3, [r4, #24]
    2f70:	6811      	ldr	r1, [r2, #0]
    2f72:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f74:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f78:	d109      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2f7a:	f7fd fca5 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2f7e:	6960      	ldr	r0, [r4, #20]
    2f80:	69a3      	ldr	r3, [r4, #24]
    2f82:	6802      	ldr	r2, [r0, #0]
    2f84:	421a      	tst	r2, r3
    2f86:	d102      	bne.n	2f8e <am_hal_i2c_bit_bang_send+0x362>
    {
        if (--maxLoop == 0)
    2f88:	3d08      	subs	r5, #8
    2f8a:	d1b6      	bne.n	2efa <am_hal_i2c_bit_bang_send+0x2ce>
    2f8c:	e6af      	b.n	2cee <am_hal_i2c_bit_bang_send+0xc2>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2f8e:	3601      	adds	r6, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    2f90:	2005      	movs	r0, #5
    2f92:	f7fd fc99 	bl	8c8 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    2f96:	2e08      	cmp	r6, #8
    2f98:	d196      	bne.n	2ec8 <am_hal_i2c_bit_bang_send+0x29c>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    2f9a:	6926      	ldr	r6, [r4, #16]
    2f9c:	69a1      	ldr	r1, [r4, #24]
    2f9e:	6031      	str	r1, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    2fa0:	2007      	movs	r0, #7
    2fa2:	f7fd fc91 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2fa6:	68e0      	ldr	r0, [r4, #12]
    2fa8:	69a3      	ldr	r3, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2faa:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    2fac:	6003      	str	r3, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2fae:	6816      	ldr	r6, [r2, #0]
    2fb0:	4233      	tst	r3, r6
    2fb2:	bf08      	it	eq
    2fb4:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2fb8:	d149      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2fba:	2004      	movs	r0, #4
    2fbc:	f7fd fc84 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2fc0:	6961      	ldr	r1, [r4, #20]
    2fc2:	69a3      	ldr	r3, [r4, #24]
    2fc4:	680a      	ldr	r2, [r1, #0]
    2fc6:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2fc8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2fcc:	d13f      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2fce:	f7fd fc7b 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2fd2:	6966      	ldr	r6, [r4, #20]
    2fd4:	69a1      	ldr	r1, [r4, #24]
    2fd6:	6833      	ldr	r3, [r6, #0]
    2fd8:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2fda:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2fde:	d136      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2fe0:	f7fd fc72 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2fe4:	6962      	ldr	r2, [r4, #20]
    2fe6:	69a6      	ldr	r6, [r4, #24]
    2fe8:	6811      	ldr	r1, [r2, #0]
    2fea:	4231      	tst	r1, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2fec:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ff0:	d12d      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ff2:	f7fd fc69 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    2ff6:	6962      	ldr	r2, [r4, #20]
    2ff8:	69a3      	ldr	r3, [r4, #24]
    2ffa:	6816      	ldr	r6, [r2, #0]
    2ffc:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2ffe:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3002:	d124      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3004:	f7fd fc60 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3008:	6961      	ldr	r1, [r4, #20]
    300a:	69a3      	ldr	r3, [r4, #24]
    300c:	680a      	ldr	r2, [r1, #0]
    300e:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3010:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3014:	d11b      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3016:	f7fd fc57 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    301a:	6966      	ldr	r6, [r4, #20]
    301c:	69a1      	ldr	r1, [r4, #24]
    301e:	6833      	ldr	r3, [r6, #0]
    3020:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3022:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3026:	d112      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3028:	f7fd fc4e 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    302c:	6962      	ldr	r2, [r4, #20]
    302e:	69a6      	ldr	r6, [r4, #24]
    3030:	6811      	ldr	r1, [r2, #0]
    3032:	4231      	tst	r1, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3034:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3038:	d109      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    303a:	f7fd fc45 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    303e:	6960      	ldr	r0, [r4, #20]
    3040:	69a3      	ldr	r3, [r4, #24]
    3042:	6802      	ldr	r2, [r0, #0]
    3044:	421a      	tst	r2, r3
    3046:	d102      	bne.n	304e <am_hal_i2c_bit_bang_send+0x422>
    {
        if (--maxLoop == 0)
    3048:	3d08      	subs	r5, #8
    304a:	d1b6      	bne.n	2fba <am_hal_i2c_bit_bang_send+0x38e>
    304c:	e64f      	b.n	2cee <am_hal_i2c_bit_bang_send+0xc2>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    304e:	6a65      	ldr	r5, [r4, #36]	; 0x24
    3050:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    3052:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    3054:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    3056:	4035      	ands	r5, r6
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    3058:	f7fd fc36 	bl	8c8 <am_hal_flash_delay>
    if ( data_naked )
    305c:	b125      	cbz	r5, 3068 <am_hal_i2c_bit_bang_send+0x43c>
        status =  i2c_send_byte(*pData++);
        if (status != AM_HAL_I2C_BIT_BANG_SUCCESS)
        {
            if (status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
            {
                if (ui32I != (number_of_bytes-1))
    305e:	9901      	ldr	r1, [sp, #4]
    3060:	1e48      	subs	r0, r1, #1
    3062:	4550      	cmp	r0, sl
    3064:	f040 814e 	bne.w	3304 <am_hal_i2c_bit_bang_send+0x6d8>
    }

    //
    // send the requested number of data bytes
    //
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    3068:	9b01      	ldr	r3, [sp, #4]
    306a:	f10a 0a01 	add.w	sl, sl, #1
    306e:	4553      	cmp	r3, sl
    3070:	f47f af27 	bne.w	2ec2 <am_hal_i2c_bit_bang_send+0x296>
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    uint32_t ui32I;
    am_hal_i2c_bit_bang_enum_e status;
    bool data_naked = false;
    3074:	2700      	movs	r7, #0
    //********************

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    3076:	6926      	ldr	r6, [r4, #16]
    3078:	69a2      	ldr	r2, [r4, #24]
    307a:	6032      	str	r2, [r6, #0]

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    307c:	2004      	movs	r0, #4
    307e:	f7fd fc23 	bl	8c8 <am_hal_flash_delay>


    if (!bNoStop)
    3082:	9902      	ldr	r1, [sp, #8]
    //********************

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    3084:	4d2d      	ldr	r5, [pc, #180]	; (313c <am_hal_i2c_bit_bang_send+0x510>)
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();


    if (!bNoStop)
    3086:	2900      	cmp	r1, #0
    3088:	d05a      	beq.n	3140 <am_hal_i2c_bit_bang_send+0x514>
    else
    {
        //
        // Release data line with clock low itself, as we are not sending STOP
        //
        PULL_SDA_HI();
    308a:	69e8      	ldr	r0, [r5, #28]
    308c:	6aab      	ldr	r3, [r5, #40]	; 0x28
    308e:	6003      	str	r3, [r0, #0]
    }

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    3090:	2004      	movs	r0, #4
    3092:	f7fd fc19 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    3096:	68ee      	ldr	r6, [r5, #12]
    3098:	69a9      	ldr	r1, [r5, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    309a:	696a      	ldr	r2, [r5, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    309c:	6031      	str	r1, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    309e:	6815      	ldr	r5, [r2, #0]
    30a0:	4229      	tst	r1, r5
    30a2:	d15d      	bne.n	3160 <am_hal_i2c_bit_bang_send+0x534>
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    uint32_t ui32I;
    am_hal_i2c_bit_bang_enum_e status;
    bool data_naked = false;
    30a4:	f44f 76c8 	mov.w	r6, #400	; 0x190
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30a8:	2004      	movs	r0, #4
    30aa:	f7fd fc0d 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30ae:	6961      	ldr	r1, [r4, #20]
    30b0:	69a3      	ldr	r3, [r4, #24]
    30b2:	680a      	ldr	r2, [r1, #0]
    30b4:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30b6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30ba:	d159      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30bc:	f7fd fc04 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30c0:	6965      	ldr	r5, [r4, #20]
    30c2:	69a1      	ldr	r1, [r4, #24]
    30c4:	682b      	ldr	r3, [r5, #0]
    30c6:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30c8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30cc:	d150      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30ce:	f7fd fbfb 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30d2:	6962      	ldr	r2, [r4, #20]
    30d4:	69a5      	ldr	r5, [r4, #24]
    30d6:	6811      	ldr	r1, [r2, #0]
    30d8:	4229      	tst	r1, r5
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30da:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30de:	d147      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30e0:	f7fd fbf2 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30e4:	6962      	ldr	r2, [r4, #20]
    30e6:	69a3      	ldr	r3, [r4, #24]
    30e8:	6815      	ldr	r5, [r2, #0]
    30ea:	421d      	tst	r5, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30ec:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30f0:	d13e      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30f2:	f7fd fbe9 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    30f6:	6961      	ldr	r1, [r4, #20]
    30f8:	69a3      	ldr	r3, [r4, #24]
    30fa:	680a      	ldr	r2, [r1, #0]
    30fc:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    30fe:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3102:	d135      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3104:	f7fd fbe0 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3108:	6965      	ldr	r5, [r4, #20]
    310a:	69a1      	ldr	r1, [r4, #24]
    310c:	682b      	ldr	r3, [r5, #0]
    310e:	420b      	tst	r3, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3110:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3114:	d12c      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3116:	f7fd fbd7 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    311a:	6962      	ldr	r2, [r4, #20]
    311c:	69a5      	ldr	r5, [r4, #24]
    311e:	6811      	ldr	r1, [r2, #0]
    3120:	4229      	tst	r1, r5
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3122:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3126:	d123      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3128:	f7fd fbce 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    312c:	6960      	ldr	r0, [r4, #20]
    312e:	69a3      	ldr	r3, [r4, #24]
    3130:	6802      	ldr	r2, [r0, #0]
    3132:	421a      	tst	r2, r3
    3134:	d11c      	bne.n	3170 <am_hal_i2c_bit_bang_send+0x544>
    {
        if (--maxLoop == 0)
    3136:	3e08      	subs	r6, #8
    3138:	d1b6      	bne.n	30a8 <am_hal_i2c_bit_bang_send+0x47c>
    313a:	e5d8      	b.n	2cee <am_hal_i2c_bit_bang_send+0xc2>
    313c:	1000106c 	.word	0x1000106c
    if (!bNoStop)
    {
        //
        // Pull down on data line with clock low
        //
        WRITE_SDA_LO();
    3140:	6a28      	ldr	r0, [r5, #32]
    3142:	6aab      	ldr	r3, [r5, #40]	; 0x28
    3144:	6003      	str	r3, [r0, #0]
    }

    //
    // Delay for 1/4 bit cell time
    //
    WAIT_FOR_QUARTER_I2C_CLOCK();
    3146:	2004      	movs	r0, #4
    3148:	f7fd fbbe 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    314c:	68ee      	ldr	r6, [r5, #12]
    314e:	69a9      	ldr	r1, [r5, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3150:	696a      	ldr	r2, [r5, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    3152:	6031      	str	r1, [r6, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3154:	6815      	ldr	r5, [r2, #0]
    3156:	420d      	tst	r5, r1
    3158:	d0a4      	beq.n	30a4 <am_hal_i2c_bit_bang_send+0x478>
    if (!bNoStop)
    {
        //
        // release data line with clock high --> STOP CONDITION
        //
        PULL_SDA_HI();
    315a:	69e5      	ldr	r5, [r4, #28]
    315c:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    315e:	602c      	str	r4, [r5, #0]
    }

    //
    // Delay for 1/2 bit cell time while clock is high
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    3160:	2005      	movs	r0, #5
    3162:	f7fd fbb1 	bl	8c8 <am_hal_flash_delay>

    if ( data_naked )
    3166:	2f00      	cmp	r7, #0
    3168:	f000 80d9 	beq.w	331e <am_hal_i2c_bit_bang_send+0x6f2>
    {
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;  // if it happens early
    316c:	2002      	movs	r0, #2
    316e:	e5bf      	b.n	2cf0 <am_hal_i2c_bit_bang_send+0xc4>

    if (i2c_pull_and_wait_scl_hi())
    {
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    if (!bNoStop)
    3170:	9e02      	ldr	r6, [sp, #8]
    3172:	2e00      	cmp	r6, #0
    3174:	d0f1      	beq.n	315a <am_hal_i2c_bit_bang_send+0x52e>
    3176:	e7f3      	b.n	3160 <am_hal_i2c_bit_bang_send+0x534>
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    3178:	4e6a      	ldr	r6, [pc, #424]	; (3324 <am_hal_i2c_bit_bang_send+0x6f8>)

        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
    317a:	f04f 0880 	mov.w	r8, #128	; 0x80
    317e:	fa48 f105 	asr.w	r1, r8, r5
    3182:	ea11 0f0a 	tst.w	r1, sl
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    3186:	6920      	ldr	r0, [r4, #16]
        //
        // output the next data bit
        //
        if ( one_byte & (0x80 >> i) )
        {
            PULL_SDA_HI();
    3188:	bf14      	ite	ne
    318a:	69f1      	ldrne	r1, [r6, #28]
        }
        else
        {
            WRITE_SDA_LO();
    318c:	6a31      	ldreq	r1, [r6, #32]
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    318e:	69a2      	ldr	r2, [r4, #24]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    3190:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    for (i = 0; i < 8; i++)
    {
        //
        // Pull down on clock line
        //
        WRITE_SCL_LO();
    3192:	6002      	str	r2, [r0, #0]
        {
            PULL_SDA_HI();
        }
        else
        {
            WRITE_SDA_LO();
    3194:	600b      	str	r3, [r1, #0]
        }

        //
        // Delay for 1/2 bit cell time to start the clock
        //
        WAIT_I2C_CLOCK_LOW_PERIOD();
    3196:	2007      	movs	r0, #7
    3198:	f7fd fb96 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    319c:	68e0      	ldr	r0, [r4, #12]
    319e:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31a0:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    31a2:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31a4:	6813      	ldr	r3, [r2, #0]
    31a6:	4219      	tst	r1, r3
    31a8:	bf08      	it	eq
    31aa:	f44f 77c8 	moveq.w	r7, #400	; 0x190
    31ae:	d149      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31b0:	2004      	movs	r0, #4
    31b2:	f7fd fb89 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31b6:	6961      	ldr	r1, [r4, #20]
    31b8:	69a3      	ldr	r3, [r4, #24]
    31ba:	680a      	ldr	r2, [r1, #0]
    31bc:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31be:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31c2:	d13f      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31c4:	f7fd fb80 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31c8:	6961      	ldr	r1, [r4, #20]
    31ca:	69a3      	ldr	r3, [r4, #24]
    31cc:	680a      	ldr	r2, [r1, #0]
    31ce:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31d0:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31d4:	d136      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31d6:	f7fd fb77 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31da:	6961      	ldr	r1, [r4, #20]
    31dc:	69a3      	ldr	r3, [r4, #24]
    31de:	680a      	ldr	r2, [r1, #0]
    31e0:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31e2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31e6:	d12d      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31e8:	f7fd fb6e 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31ec:	6961      	ldr	r1, [r4, #20]
    31ee:	69a3      	ldr	r3, [r4, #24]
    31f0:	680a      	ldr	r2, [r1, #0]
    31f2:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31f4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31f8:	d124      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    31fa:	f7fd fb65 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    31fe:	6961      	ldr	r1, [r4, #20]
    3200:	69a3      	ldr	r3, [r4, #24]
    3202:	680a      	ldr	r2, [r1, #0]
    3204:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3206:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    320a:	d11b      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    320c:	f7fd fb5c 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3210:	6961      	ldr	r1, [r4, #20]
    3212:	69a3      	ldr	r3, [r4, #24]
    3214:	680a      	ldr	r2, [r1, #0]
    3216:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3218:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    321c:	d112      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    321e:	f7fd fb53 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3222:	6961      	ldr	r1, [r4, #20]
    3224:	69a3      	ldr	r3, [r4, #24]
    3226:	680a      	ldr	r2, [r1, #0]
    3228:	421a      	tst	r2, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    322a:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    322e:	d109      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3230:	f7fd fb4a 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3234:	6960      	ldr	r0, [r4, #20]
    3236:	69a1      	ldr	r1, [r4, #24]
    3238:	6803      	ldr	r3, [r0, #0]
    323a:	420b      	tst	r3, r1
    323c:	d102      	bne.n	3244 <am_hal_i2c_bit_bang_send+0x618>
    {
        if (--maxLoop == 0)
    323e:	3f08      	subs	r7, #8
    3240:	d1b6      	bne.n	31b0 <am_hal_i2c_bit_bang_send+0x584>
    3242:	e554      	b.n	2cee <am_hal_i2c_bit_bang_send+0xc2>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    3244:	3501      	adds	r5, #1
            return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
        }
        //
        // Delay for 1/2 bit cell time while clock is high
        //
        WAIT_I2C_CLOCK_HI_PERIOD();
    3246:	2005      	movs	r0, #5
    3248:	f7fd fb3e 	bl	8c8 <am_hal_flash_delay>
    bool data_naked = false;

    //
    // Loop through sending 8 bits
    //
    for (i = 0; i < 8; i++)
    324c:	2d08      	cmp	r5, #8
    324e:	d196      	bne.n	317e <am_hal_i2c_bit_bang_send+0x552>
    }

    //
    // Pull down on clock line
    //
    WRITE_SCL_LO();
    3250:	6926      	ldr	r6, [r4, #16]
    3252:	69a7      	ldr	r7, [r4, #24]
    3254:	6037      	str	r7, [r6, #0]

    //
    // Delay for 1/2 bit cell time to start the clock
    //
    WAIT_I2C_CLOCK_LOW_PERIOD();
    3256:	2007      	movs	r0, #7
    3258:	f7fd fb36 	bl	8c8 <am_hal_flash_delay>
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    325c:	68e0      	ldr	r0, [r4, #12]
    325e:	69a1      	ldr	r1, [r4, #24]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3260:	6962      	ldr	r2, [r4, #20]
i2c_pull_and_wait_scl_hi(void)
{
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    3262:	6001      	str	r1, [r0, #0]
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3264:	6813      	ldr	r3, [r2, #0]
    3266:	4219      	tst	r1, r3
    3268:	bf08      	it	eq
    326a:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    326e:	d14b      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3270:	2004      	movs	r0, #4
    3272:	f7fd fb29 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3276:	6966      	ldr	r6, [r4, #20]
    3278:	69a7      	ldr	r7, [r4, #24]
    327a:	6831      	ldr	r1, [r6, #0]
    327c:	4239      	tst	r1, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    327e:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3282:	d141      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3284:	f7fd fb20 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3288:	6962      	ldr	r2, [r4, #20]
    328a:	69a3      	ldr	r3, [r4, #24]
    328c:	6816      	ldr	r6, [r2, #0]
    328e:	421e      	tst	r6, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3290:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    3294:	d138      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    3296:	f7fd fb17 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    329a:	6967      	ldr	r7, [r4, #20]
    329c:	69a1      	ldr	r1, [r4, #24]
    329e:	683a      	ldr	r2, [r7, #0]
    32a0:	420a      	tst	r2, r1
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32a2:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32a6:	d12f      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32a8:	f7fd fb0e 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32ac:	6966      	ldr	r6, [r4, #20]
    32ae:	69a3      	ldr	r3, [r4, #24]
    32b0:	6837      	ldr	r7, [r6, #0]
    32b2:	421f      	tst	r7, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32b4:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32b8:	d126      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32ba:	f7fd fb05 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32be:	6961      	ldr	r1, [r4, #20]
    32c0:	69a6      	ldr	r6, [r4, #24]
    32c2:	680a      	ldr	r2, [r1, #0]
    32c4:	4232      	tst	r2, r6
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32c6:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32ca:	d11d      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32cc:	f7fd fafc 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32d0:	6967      	ldr	r7, [r4, #20]
    32d2:	69a3      	ldr	r3, [r4, #24]
    32d4:	6839      	ldr	r1, [r7, #0]
    32d6:	4219      	tst	r1, r3
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32d8:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32dc:	d114      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32de:	f7fd faf3 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32e2:	6966      	ldr	r6, [r4, #20]
    32e4:	69a7      	ldr	r7, [r4, #24]
    32e6:	6832      	ldr	r2, [r6, #0]
    32e8:	423a      	tst	r2, r7
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32ea:	f04f 0004 	mov.w	r0, #4
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32ee:	d10b      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
        {
            // timeout!
            return true;
        }
        WAIT_FOR_QUARTER_I2C_CLOCK();
    32f0:	f7fd faea 	bl	8c8 <am_hal_flash_delay>
    // Maximum time to wait for clock stretching
    uint32_t maxLoop = 4*I2C_BB_MAX_CLOCK_STRETCH_WAIT + 1;
    // Pull SCL High
    PULL_SCL_HI();
    // Poll for SCL to check for clock stretching
    while (!GET_SCL())
    32f4:	6960      	ldr	r0, [r4, #20]
    32f6:	69a3      	ldr	r3, [r4, #24]
    32f8:	6801      	ldr	r1, [r0, #0]
    32fa:	4219      	tst	r1, r3
    32fc:	d104      	bne.n	3308 <am_hal_i2c_bit_bang_send+0x6dc>
    {
        if (--maxLoop == 0)
    32fe:	3d08      	subs	r5, #8
    3300:	d1b6      	bne.n	3270 <am_hal_i2c_bit_bang_send+0x644>
    3302:	e4f4      	b.n	2cee <am_hal_i2c_bit_bang_send+0xc2>
        {
            if (status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
            {
                if (ui32I != (number_of_bytes-1))
                {
                    data_naked = true;
    3304:	2701      	movs	r7, #1
    3306:	e6b6      	b.n	3076 <am_hal_i2c_bit_bang_send+0x44a>
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    3308:	6a65      	ldr	r5, [r4, #36]	; 0x24
    330a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    330c:	682d      	ldr	r5, [r5, #0]
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    330e:	2005      	movs	r0, #5
        return AM_HAL_I2C_BIT_BANG_CLOCK_TIMEOUT;
    }
    //
    // Grab the state of the ACK bit and return it
    //
    data_naked = GET_SDA();
    3310:	4035      	ands	r5, r6
    //
    // Delay for 1/2 bit cell time to complete the high period
    //
    WAIT_I2C_CLOCK_HI_PERIOD();
    3312:	f7fd fad9 	bl	8c8 <am_hal_flash_delay>
    if ( data_naked )
    3316:	2d00      	cmp	r5, #0
    3318:	f47f af28 	bne.w	316c <am_hal_i2c_bit_bang_send+0x540>
    331c:	e5c8      	b.n	2eb0 <am_hal_i2c_bit_bang_send+0x284>
    }

    //
    // message successfully sent
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    331e:	4638      	mov	r0, r7
    3320:	e4e6      	b.n	2cf0 <am_hal_i2c_bit_bang_send+0xc4>
    3322:	bf00      	nop
    3324:	1000106c 	.word	0x1000106c

00003328 <am_hal_interrupt_master_disable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
    3328:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
    332c:	b672      	cpsid	i
    __asm("    bx lr");
    332e:	4770      	bx	lr

00003330 <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
    3330:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
    3334:	4770      	bx	lr
    3336:	bf00      	nop

00003338 <g_pui8Apollo2BootDemo>:
    3338:	1000 1000 9c01 0000 9c09 0000 98dd 0000     ................
    3348:	98dd 0000 98dd 0000 98dd 0000 0000 0000     ................
	...
    3364:	9c07 0000 9c07 0000 0000 0000 9c07 0000     ................
    3374:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    3384:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    3394:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    33a4:	9c07 0000 9c07 0000 93a7 0000 9c07 0000     ................
    33b4:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    33c4:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    33d4:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    33e4:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    33f4:	9c07 0000 f8df 18a0 6008 4770 e92d 0ff0     .........`pG-...
    3404:	0004 000d 2d00 d04d 0020 0029 0849 ea5f     .....-M. .).I._.
    3414:	0030 4680 4689 0020 0029 0880 ea40 7081     0..F.F .)...@..p
    3424:	0889 eb18 0000 eb59 0101 0006 000f 0030     ......Y.......0.
    3434:	0039 0900 ea40 7001 0909 1836 414f 0030     9...@..p..6.OA0.
    3444:	0039 0a00 ea40 6001 0a09 1836 414f 0030     9...@..`..6.OA0.
    3454:	0039 0c00 ea40 4001 0c09 1836 414f 0030     9...@..@..6.OA0.
    3464:	0039 0008 2100 1836 414f 08f6 ea46 7647     9....!6.OA..F.Gv
    3474:	08ff 200a 2100 fba0 8906 fb00 9907 fb01     ... .!..........
    3484:	9906 ebb4 0008 eb75 0109 4682 468b f11a     ......u....F.F..
    3494:	0006 f15b 0100 0900 ea40 7001 0909 1830     ..[.....@..p..0.
    34a4:	4179 e015 46a4 4660 0880 eb10 005c 0002     yA...F`F....\...
    34b4:	eb12 1212 eb12 2212 eb12 4212 08d2 200a     ......."...B... 
    34c4:	fb00 c012 0003 1d9b eb12 1213 0010 2100     ...............!
    34d4:	e8bd 0ff0 4770 b510 0002 000b 2000 2100     ....pG....... .!
    34e4:	428b d101 4282 d001 2400 e000 2401 2000     .B...B...$...$. 
    34f4:	2100 428b d101 4282 d007 0010 0019 f7ff     .!.B...B........
    3504:	ff7d 0002 000b 1c64 e7f1 0020 bd10 b580     }.....d... .....
    3514:	2200 2300 4299 dc05 db01 4290 d202 4240     .".#.B.....B..@B
    3524:	eb71 0141 f7ff ffd7 bd02 b430 0002 000b     q.A.......0.....
    3534:	2000 2100 428b d101 4282 d001 2000 e000     . .!.B...B... ..
    3544:	2001 2400 2500 42ab d101 42a2 d005 0912     . .$.%.B...B....
    3554:	ea42 7203 091b 1c40 e7f3 bc30 4770 b430     B..r..@...0.pG0.
    3564:	0003 2200 2000 2500 781c 2c2d d103 2401     ...". .%.x-,...$
    3574:	0022 1c5b 1c6d 781c 2c30 db0a 781c 2c3a     ".[.m..x0,...x:,
    3584:	da07 1c6d 240a 4360 781c 3c30 1820 1c5b     ..m..$`C.x0< .[.
    3594:	e7f1 2900 d000 600d b2d2 2a00 d001 4240     ...)...`...*..@B
    35a4:	e7ff bc30 4770 e92d 4ff0 b087 0006 000f     ..0.pG-..O......
    35b4:	4690 f05f 0900 f05f 0a00 0030 0039 f7ff     .F_..._...0.9...
    35c4:	ff1d 0004 000d 200a 2100 fba0 2304 fb00     ....... .!...#..
    35d4:	3305 fb01 3304 1ab0 eb77 0103 4683 f11b     .3...3..w....F..
    35e4:	0030 4669 f801 0009 f119 0901 0026 002f     0.iF........&./.
    35f4:	2000 2100 428f d1e0 4286 d1de 46ca f1b8     . .!.B...B...F..
    3604:	0f00 d00f 4648 f1b0 0901 2800 d007 4668     ....HF.....(..hF
    3614:	f810 0009 f888 0000 f118 0801 e7f2 2000     ............... 
    3624:	f888 0000 4650 b007 e8bd 8ff0 b5f0 b085     ....PF..........
    3634:	0004 000d f05f 0c00 2600 2700 42bd d107     ...._....&.'.B..
    3644:	42b4 d105 2030 466e f806 000c f11c 0c01     .B..0 nF........
    3654:	2600 2700 42bd d101 42b4 d01c 0020 f010     .&.'.B...B.. ...
    3664:	000f 4686 fa5f fe8e f1be 0f0a db07 b2db     ...F_...........
    3674:	2b00 d001 2027 e000 2007 eb10 0e0e f11e     .+..' ... ......
    3684:	0030 466e f806 000c f11c 0c01 0924 ea44     0.nF........$.D.
    3694:	7405 092d e7dc 4661 2a00 d00c 4660 f1b0     .t-...aF.*..`F..
    36a4:	0c01 2800 d005 4668 f810 000c 7010 1c52     ...(..hF.....pR.
    36b4:	e7f4 2000 7010 0008 b005 bdf0 0002 2000     ... .p......... 
    36c4:	2a00 d006 0011 1c4a 7809 2900 d001 1c40     .*....J..x.)..@.
    36d4:	e7f8 4770 b410 0004 2000 2a01 db09 0013     ..pG..... .*....
    36e4:	1e5a 2b00 d005 2c00 d001 7021 1c64 1c40     Z..+...,..!pd.@.
    36f4:	e7f5 bc10 4770 e92d 4ff8 ed2d 8b02 b082     ....pG-..O-.....
    3704:	eeb0 8a40 0006 000f 6830 4683 f1bb 0f04     ..@.....0h.F....
    3714:	da02 f07f 0002 e09a eeb5 8a40 eef1 fa10     ..........@.....
    3724:	d104 f8df 057c 6030 2003 e090 46b1 ed8d     ....|.0`. ...F..
    3734:	8a00 9800 f3c0 50c7 387f 4680 9800 f020     .......P.8.F.. .
    3744:	407f f450 0000 4682 2000 0005 2000 0004     .@P....F. ... ..
    3754:	f1b8 0f1f db02 f07f 0001 e078 f118 0f17     ..........x.....
    3764:	da02 f05f 30ff e072 f1b8 0f17 db05 4640     .._..0r.......@F
    3774:	3817 fa1a f000 0004 e016 f1b8 0f00 d40c     .8..............
    3784:	f1d8 0017 4651 4101 000c f118 0001 fa1a     ....QF.A........
    3794:	f000 f020 407f 0005 e006 f02a 407f f118     .. ..@....*..@..
    37a4:	0101 4249 4108 0005 9800 2800 d502 202d     ..IB.A.....(..- 
    37b4:	7030 1c76 2c00 d103 2030 7030 1c76 e014     0pv..,..0 0pv...
    37c4:	2c01 db05 0032 0020 17e1 f7ff feec e007     .,..2. .........
    37d4:	202d 7030 1c76 0032 4260 17c1 f7ff fee3     - 0pv.2.`B......
    37e4:	7830 2800 d001 1c76 e7fa 202e 7030 1c76     0x.(..v.... 0pv.
    37f4:	2d00 d103 2030 7030 1c76 e023 ebb6 0009     .-..0 0pv.#.....
    3804:	ebbb 0000 1e40 0001 428f da01 0039 e7ff     ....@....B..9...
    3814:	2000 0002 428a da0a 200a 4345 0028 1600     . ...B... EC(...
    3824:	3030 7030 1c76 f025 457f 1c52 e7f2 1e76     000pv.%..ER...v.
    3834:	7830 2830 d105 f816 0c01 282e d001 1e76     0x0(.......(..v.
    3844:	e7f6 1c76 2000 7030 ebb6 0609 0030 b002     ..v.. 0p....0...
    3854:	ecbd 8b02 e8bd 8ff2 e92d 4ff8 ed2d 8b02     ........-..O-...
    3864:	b088 0004 4688 0017 2600 2000 9002 f898     .....F...&. ....
    3874:	0000 2800 f000 81ed 2006 9005 f898 0000     ...(..... ......
    3884:	2825 d016 2c00 d010 f898 0000 280a d108     %(...,.......(..
    3894:	f8df 0408 7800 2800 d003 200d 7020 1c64     .....x.(...  pd.
    38a4:	1c76 f898 0000 7020 1c64 f118 0801 1c76     v..... pd.....v.
    38b4:	e7dd f118 0801 2000 f88d 0001 f89d 0001     ....... ........
    38c4:	f88d 0003 2020 f88d 0000 f898 0000 2830     ....  ........0(
    38d4:	d104 2030 f88d 0000 f118 0801 a904 4640     ..0 ..........@F
    38e4:	f7ff fe3d 0005 9804 4480 f898 0000 2873     ..=......D....s(
    38f4:	d002 2d00 d500 426d f898 0000 282e d108     ...-..mB.....(..
    3904:	f118 0801 a904 4640 f7ff fe29 9005 9804     ......@F..).....
    3914:	4480 f898 0000 286c d10a f118 0801 f898     .D....l(........
    3924:	0000 286c d104 f118 0801 2001 f88d 0001     ..l(....... ....
    3934:	f898 0000 2846 f000 8153 2858 d067 2863     ....F(..S.X(g.c(
    3944:	d010 2864 f000 80d1 2866 f000 8149 2869     ..d(....f(..I.i(
    3954:	f000 80cb 2873 d011 2875 f000 8090 2878     ....s(..u(....x(
    3964:	d052 e16c 6838 1d3f f88d 0004 2c00 d003     R.l.8h?......,..
    3974:	f89d 0004 7020 1c64 1c76 e167 6838 1d3f     .... pd.v.g.8h?.
    3984:	9003 9803 f7ff fe9a 9002 2d01 db14 9802     ...........-....
    3994:	42a8 d211 9802 1a2d 002a f89d 1000 0020     .B....-.*..... .
    39a4:	f7ff fe98 0005 2c00 d001 0028 e000 2000     .......,..(.... 
    39b4:	4404 19ae 2000 0005 9803 7800 2800 d00a     .D... .....x.(..
    39c4:	2c00 d003 9803 7800 7020 1c64 9803 1c40     .,.....x pd...@.
    39d4:	9003 1c76 e7f0 2d00 d015 426d 9802 42a8     ..v....-..mB...B
    39e4:	d211 9802 1a2d 002a f89d 1000 0020 f7ff     ....-.*..... ...
    39f4:	fe71 0005 2c00 d001 0028 e000 2000 4404     q....,..(.... .D
    3a04:	19ae 2000 0005 e121 2001 f88d 0003 f89d     ... ..!.. ......
    3a14:	0001 2800 d008 1dff f037 0707 e9d7 0100     ...(....7.......
    3a24:	3708 4682 468b e004 6838 1d3f 2100 4682     .7.F.F..8h?..!.F
    3a34:	468b 2d00 d015 4650 4659 f7ff fd76 1a28     .F.-..PFYF..v.(.
    3a44:	0005 002a f89d 1000 0020 f7ff fe43 0005     ..*..... ...C...
    3a54:	2c00 d001 0028 e000 2000 4404 19ae 2000     .,..(.... .D... 
    3a64:	0005 f89d 3003 0022 4650 4659 f7ff fdde     .....0".PFYF....
    3a74:	4681 2c00 d000 444c eb19 0606 e0e6 f89d     .F.,..LD........
    3a84:	0001 2800 d008 1dff f037 0707 e9d7 0100     ...(....7.......
    3a94:	3708 4682 468b e004 6838 1d3f 2100 4682     .7.F.F..8h?..!.F
    3aa4:	468b 2d00 d015 4650 4659 f7ff fd14 1a28     .F.-..PFYF....(.
    3ab4:	0005 002a f89d 1000 0020 f7ff fe0b 0005     ..*..... .......
    3ac4:	2c00 d001 0028 e000 2000 4404 19ae 2000     .,..(.... .D... 
    3ad4:	0005 0022 4650 4659 f7ff fd65 4681 2c00     ..".PFYF..e..F.,
    3ae4:	d000 444c eb19 0606 e0b0 f89d 0001 2800     ..LD...........(
    3af4:	d008 1dff f037 0707 e9d7 0100 3708 e9cd     ....7........7..
    3b04:	0106 e004 6838 1d3f 17c1 e9cd 0106 e9dd     ....8h?.........
    3b14:	0106 0002 000b 2000 2100 428b dc0d db01     ....... .!.B....
    3b24:	4282 d20a e9dd 0106 4240 eb71 0141 4682     .B......@Bq.A..F
    3b34:	468b 2001 f88d 0002 e006 e9dd 0106 4682     .F. ...........F
    3b44:	468b 2000 f88d 0002 2d00 d033 4650 4659     .F. .....-3.PFYF
    3b54:	f7ff fcdd 1a28 0005 f89d 0002 2800 d00a     ....(........(..
    3b64:	1e6d f89d 0000 2830 d105 2c00 d002 202d     m.....0(...,..- 
    3b74:	7020 1c64 1c76 002a f89d 1000 0020 f7ff      pd.v.*..... ...
    3b84:	fda9 0005 2c00 d001 0028 e000 2000 4404     .....,..(.... .D
    3b94:	19ae 2000 0005 f89d 0002 2800 d014 f89d     ... .......(....
    3ba4:	0000 2820 d110 2c00 d002 202d 7020 1c64     .. (...,..-  pd.
    3bb4:	1c76 e009 f89d 0002 2800 d005 2c00 d002     v........(...,..
    3bc4:	202d 7020 1c64 1c76 0022 4650 4659 f7ff     -  pd.v.".PFYF..
    3bd4:	fcea 4681 2c00 d000 444c eb19 0606 e035     ...F.,..LD....5.
    3be4:	2c00 d02b 1dff f037 0707 ed97 0b00 3708     .,+...7........7
    3bf4:	ec51 0b10 f000 f85e ee08 0a10 2014 6020     Q.....^......  `
    3c04:	9905 0020 eeb0 0a48 f7ff fd75 4681 f1b9     .. ...H...u..F..
    3c14:	0f00 d510 f119 0f01 d102 4921 0008 e007     ..........!I....
    3c24:	f119 0f02 d102 491f 0008 e001 491e 0008     .......I.....I..
    3c34:	6020 2103 4689 eb19 0606 444c e006 2c00      `.!.F....LD...,
    3c44:	d003 f898 0000 7020 1c64 1c76 f118 0801     ...... pd.v.....
    3c54:	e60d 2c00 d001 2000 7020 0030 b008 ecbd     ...,...  p0.....
    3c64:	8b02 e8bd 8ff2 b40e b578 0004 a805 0006     ........x.......
    3c74:	0032 0021 480d f7ff fdef 0005 480b 4906     2.!..H.......H.I
    3c84:	6809 4788 0028 bc72 f85d fb10 b580 4808     .h.G(.r.]......H
    3c94:	f7ff ffe9 bd01 0000 119c 1000 11a8 1000     ................
    3ca4:	2e30 0030 2e23 0023 2e3f 003f 1084 1000     0.0.#.#.?.?.....
    3cb4:	9bd4 0000 f001 4200 1a8b f1a3 5160 f5b1     .......B....`Q..
    3cc4:	1f80 db0a f1b1 6f7f d21f ea42 02c1 00c1     .......o..B.....
    3cd4:	f171 4100 eb42 7050 4770 150b f1c3 0309     q..AB.PppG......
    3ce4:	2b21 d210 0289 ea41 5190 0280 2801 4149     !+....A..Q...(IA
    3cf4:	f041 4100 fa21 f003 f1c3 0320 4099 f171     A..A!..... ..@q.
    3d04:	4100 4150 4770 0010 4770 f06f 0000 eb13     .APApG..pGo.....
    3d14:	3f10 bf5c 0e00 ea42 50c0 4770 b418 7901     .?\...B..PpG...y
    3d24:	0789 f140 808d 6801 2932 d25d f3ef 8110     ..@....h2)].....
    3d34:	9100 b672 2173 f8df 2314 6011 2202 6801     ..r.s!...#.`.".h
    3d44:	0089 f011 011c 408a 6803 085b f013 037c     .......@.h[...|.
    3d54:	f8df 12fc 18cb 6819 2307 6804 00a4 f014     .......h.#.h....
    3d64:	041c 40a3 4399 430a 6803 085b f013 037c     ...@.C.C.h[...|.
    3d74:	f8df 12dc 18cb 601a 2218 6801 00c9 f011     .......`.".h....
    3d84:	0118 408a 7803 f013 03fc f8df 12c8 18cb     ...@.x..........
    3d94:	6819 23ff 6804 00e4 f014 0418 40a3 4399     .h.#.h.......@.C
    3da4:	430a 7803 f013 03fc f8df 12a8 18cb 601a     .C.x...........`
    3db4:	7802 f012 02fc f8df 12a0 188a 6812 21ff     .x...........h.!
    3dc4:	6803 00db f013 0318 4099 438a 7803 f013     .h.......@.C.x..
    3dd4:	03fc f8df 1284 18cb 601a 2100 f8df 226c     .........`.!..l"
    3de4:	6011 9900 f381 8810 2201 7801 f011 011f     .`.......".x....
    3df4:	408a 6803 08db f013 0304 f8df 1260 18cb     .@.h........`...
    3e04:	601a 7901 07c9 d50d 2201 7801 f011 011f     .`.y.....".x....
    3e14:	408a 6803 08db f013 0304 f8df 1244 18cb     .@.h........D...
    3e24:	601a e08e 2201 7801 f011 011f 408a 6803     .`...".x.....@.h
    3e34:	08db f013 0304 f8df 122c 18cb 601a e080     ........,....`..
    3e44:	6801 2932 d255 f3ef 8110 9100 b672 2173     .h2)U.......r.s!
    3e54:	4a7e 6011 2206 6801 0089 f011 011c 408a     ~J.`.".h.......@
    3e64:	6803 085b f013 037c 4979 18cb 6819 2307     .h[...|.yI...h.#
    3e74:	6804 00a4 f014 041c 40a3 4399 430a 6803     .h.......@.C.C.h
    3e84:	085b f013 037c 4972 18cb 601a 2218 6801     [...|.rI...`.".h
    3e94:	00c9 f011 0118 408a 7803 f013 03fc 496d     .......@.x....mI
    3ea4:	18cb 6819 23ff 6804 00e4 f014 0418 40a3     ...h.#.h.......@
    3eb4:	4399 430a 7803 f013 03fc 4966 18cb 601a     .C.C.x....fI...`
    3ec4:	7802 f012 02fc 4964 188a 6812 21ff 6803     .x....dI...h.!.h
    3ed4:	00db f013 0318 4099 438a 7803 f013 03fc     .......@.C.x....
    3ee4:	495d 18cb 601a 2100 4a58 6011 9900 f381     ]I...`.!XJ.`....
    3ef4:	8810 2201 7801 f011 011f 408a 6803 08db     ...".x.....@.h..
    3f04:	f013 0304 4958 18cb 601a 7901 07c9 d50c     ....XI...`.y....
    3f14:	2201 7801 f011 011f 408a 6803 08db f013     .".x.....@.h....
    3f24:	0304 494f 18cb 601a e00b 2201 7801 f011     ..OI...`...".x..
    3f34:	011f 408a 6803 08db f013 0304 4949 18cb     ...@.h......II..
    3f44:	601a bc11 4770 0000 b570 0004 000d 2000     .`..pG..p...... 
    3f54:	0006 42ae d205 eb04 00c6 f7ff fedf 1c76     ...B..........v.
    3f64:	e7f7 bd70 b410 eb00 02c1 7912 0792 d522     ..p........y..".
    3f74:	eb00 02c1 7912 07d2 d50e f850 3031 08db     .....y....P.10..
    3f84:	f013 0304 4a36 18d3 2201 f810 4031 f014     ....6J..."..1@..
    3f94:	041f 40a2 601a e01c f850 3031 08db f013     ...@.`..P.10....
    3fa4:	0304 4a30 18d3 2201 f810 4031 f014 041f     ..0J..."..1@....
    3fb4:	40a2 601a e00d f850 3031 08db f013 0304     .@.`..P.10......
    3fc4:	4a26 18d3 2201 f810 4031 f014 041f 40a2     &J..."..1@.....@
    3fd4:	601a bc10 4770 b410 eb00 02c1 7912 0792     .`..pG.......y..
    3fe4:	d522 eb00 02c1 7912 07d2 d40e f850 3031     "......y....P.10
    3ff4:	08db f013 0304 4a1a 18d3 2201 f810 4031     .......J..."..1@
    4004:	f014 041f 40a2 601a e01c f850 3031 08db     .....@.`..P.10..
    4014:	f013 0304 4a13 18d3 2201 f810 4031 f014     .....J..."..1@..
    4024:	041f 40a2 601a e00d f850 3031 08db f013     ...@.`..P.10....
    4034:	0304 4a0d 18d3 2201 f810 4031 f014 041f     ...J..."..1@....
    4044:	40a2 601a bc10 4770 0000 0000 0060 4001     .@.`..pG....`..@
    4054:	0040 4001 0000 4001 00e0 4001 00a8 4001     @..@...@...@...@
    4064:	0090 4001 0098 4001 00b4 4001 b5f8 0004     ...@...@...@....
    4074:	000d 0016 2000 0007 42af d20e 0030 40f8     ..... ...B..0..@
    4084:	07c0 d504 0039 0020 f7ff ff6c e003 0039     ....9. ...l...9.
    4094:	0020 f7ff ffa0 1c7f e7ee bdf1 b430 f5b0      ...........0...
    40a4:	6f00 d127 f44f 6300 f44f 5080 2220 2140     .o'.O..cO..P "@!
    40b4:	4c8d 6825 ea25 0000 2b00 6020 f040 80a0     .L%h%....+ `@...
    40c4:	20c8 1e40 d013 4b88 685c 420c d1f9 2800     . @....K\h.B...(
    40d4:	dd0d 20c8 2a00 f000 809c 1e40 d007 4982     ... .*....@....I
    40e4:	684b 4013 4293 d1f8 2800 f300 8092 bc30     Kh.@.B...(....0.
    40f4:	2000 4770 f5b0 5fc0 d103 f44f 53c0 2260     . pG..._..O..S`"
    4104:	e07d 2801 d106 2301 f240 70fe f44f 7280     }..(...#@..pO..r
    4114:	4976 e7cd 2803 d106 2303 f240 70fc f44f     vI...(...#@..pO.
    4124:	7240 4973 e7c4 2807 d107 2307 f44f 60ff     @rsI...(...#O..`
    4134:	f44f 62e0 f44f 21ff e7ba 280f d107 230f     O..bO..!...(...#
    4144:	f44f 60fe f44f 6270 f44f 21fe e7b0 281f     O..`O.pbO..!...(
    4154:	d107 231f f44f 60fc f44f 52f8 f44f 21fc     ...#O..`O..RO..!
    4164:	e7a6 283f d107 233f f44f 60f8 f44f 527c     ..?(..?#O..`O.|R
    4174:	f44f 21f8 e79c 287f d107 237f f44f 60f0     O..!...(...#O..`
    4184:	f44f 42fe f44f 21f0 e792 28ff d107 23ff     O..BO..!...(...#
    4194:	f44f 60e0 f44f 427f f44f 21e0 e788 f240     O..`O..BO..!..@.
    41a4:	13ff 4298 d105 f44f 60c0 4a52 f44f 21c0     ...B..O..`RJO..!
    41b4:	e77e f240 33ff 4298 d105 f44f 6080 4a4e     ~.@..3.B..O..`NJ
    41c4:	f44f 2180 e774 f240 73ff 4298 d016 f1b0     O..!t.@..s.B....
    41d4:	4f20 d104 f04f 4320 f44f 1220 e00f f06f      O..O. CO. ...o.
    41e4:	4120 4288 d106 2300 f04f 4020 2200 f44f      A.B...#O. @."O.
    41f4:	1120 e75d 4b41 4298 f47f af79 4a40 2100      .].AK.B..y.@J.!
    4204:	4c39 6820 4303 20c8 2900 6023 f43f af61     9L h.C. .)#`?.a.
    4214:	e757 bc30 2001 4770 493a 6848 f3c0 0040     W.0.. pG:IHh..@.
    4224:	b110 6848 07c2 d40c 680a f042 0202 600a     ..Hh.....hB....`
    4234:	6808 f040 0001 6008 684a f002 0203 2a03     .h@....`Jh.....*
    4244:	d1fa 6848 f000 0003 2803 d1fa 2042 f000     ..Hh.....(..B ..
    4254:	b85d 492c 6848 f3c0 0040 b110 6848 07c2     ].,IHh..@...Hh..
    4264:	d40c 680a f042 0202 600a 6808 f040 0001     ...hB....`.h@...
    4274:	6008 684a f002 0203 2a03 d1fa 4770 4922     .`Jh.....*..pG"I
    4284:	f8d1 0ff8 f3c0 0040 b918 f8d1 0ff8 07c2     ......@.........
    4294:	d51f 680a f002 02f0 2a20 bf04 f8d1 0ffc     ...h.... *......
    42a4:	f5b0 7f00 d106 f8d1 2ff4 f002 0205 f8c1     ........./......
    42b4:	2ff4 e00b f8d1 0ff4 f020 0002 f8c1 0ff4     ./...... .......
    42c4:	f8d1 0ff4 0840 0040 f8c1 0ff4 200a f000     ....@.@...... ..
    42d4:	b81d 4770 480b 6981 f041 0106 6181 6802     ..pG.H.iA....a.h
    42e4:	f022 0204 6002 4770 1010 4002 fe00 0007     "....`pG...@....
    42f4:	fc00 0007 ff00 0001 ff00 0003 1fff a000     ................
    4304:	ff00 0007 1000 4002 000c 4002 f8df 1004     .......@...@....
    4314:	6b4a 4710 100c 1000 b081 684a 688b 6809     Jk.G......Jh.h.h
    4324:	ea42 4203 2900 bf18 f052 4200 f3ef 8110     B..B.)..R..B....
    4334:	9100 b672 f8df 117c eb01 1100 f8df 0174     ..r...|.......t.
    4344:	600a f8d0 10f4 f001 010f 2901 bf18 2902     .`.........)...)
    4354:	d036 6801 f3c1 0244 1e52 2a04 bf82 f3c1     6..h..D.R..*....
    4364:	4144 1e49 2904 d92b 6901 f3c1 0244 1e52     DAI..)+..i..D.R.
    4374:	2a04 bf82 f3c1 4144 1e49 2904 d920 6a01     .*....DAI..) ..j
    4384:	f3c1 0244 1e52 2a04 bf82 f3c1 4144 1e49     ..D.R..*....DAI.
    4394:	2904 d915 6b00 f3c0 0144 1e49 2904 bf82     .)...k..D.I..)..
    43a4:	f3c0 4044 1e40 2804 d90a f8df 010c 6801     ..D@@..(.......h
    43b4:	f041 0104 6001 9800 f380 8810 b001 4770     A....`........pG
    43c4:	f8df 00f4 6802 f022 0204 6002 9800 f380     .....h"....`....
    43d4:	8810 b001 4770 0000 4a36 b081 eb12 1200     ....pG..6J......
    43e4:	f3ef 8010 9000 b672 6813 f001 2008 4383     ......r..h... .C
    43f4:	f001 1101 4319 6011 9800 f380 8810 b001     .....C.`........
    4404:	4770 0000 4a2b b081 eb12 1200 f3ef 8010     pG..+J..........
    4414:	9000 b672 6810 f001 2108 4301 6011 9800     ..r..h...!.C.`..
    4424:	f380 8810 b001 4770 b4f0 b081 4d24 4e25     ......pG....$M%N
    4434:	eb05 1500 f3ef 8410 eb16 1600 9400 b672     ..............r.
    4444:	4c1c eb04 1000 4c1d 6800 42a1 bf08 0c00     .L.....L.h.B....
    4454:	f400 70e0 2880 bf17 28c0 1ad3 4613 2200     ...p.(...(...F."
    4464:	f64f 77ff eac3 4002 42b9 bf08 6028 d009     O..w...@.B..(`..
    4474:	42a1 bf08 6030 d005 0c12 0412 6028 ea42     .B..0`......(`B.
    4484:	4213 6032 9800 f380 8810 b001 bcf0 4770     .B2`..........pG
    4494:	b081 f3ef 8110 9100 b672 490b 680a 4310     ........r..I.h.C
    44a4:	6008 9800 f380 8810 b001 4770 4907 6008     .`........pG.I.`
    44b4:	4770 0000 800c 4000 1020 4002 0000 ffff     pG.....@ ..@....
    44c4:	8004 4000 8008 4000 8200 4000 8208 4000     ...@...@...@...@
    44d4:	b470 b081 f3ef 8310 9300 b672 4b51 681c     p.........r.QK.h
    44e4:	681d 0796 f3c4 0483 f3c5 3543 d503 494e     .h........C5..NI
    44f4:	6808 6849 e001 07d6 d513 06d6 d507 681e     .hIh...........h
    4504:	0080 f000 003c f026 063c 4330 6018 0690     ....<.&.<.0C.`..
    4514:	d507 6818 0349 f401 31f0 f420 30f0 4301     ...hI....1 ..0.C
    4524:	6019 0751 d507 06d0 bf44 483f 6004 0690     .`Q.....D.?H.`..
    4534:	bf44 483d 6045 9800 f380 8810 b001 bc70     D.=HE`........p.
    4544:	4770 0000 b570 b082 4604 f000 f8a1 2c01     pG..p....F.....,
    4554:	4605 d15a 4835 f8d0 1244 07ca d455 4934     .FZ.5H..D...U.4I
    4564:	4e34 680a f042 0204 600a 6801 6872 f001     4N.hB....`.hrh..
    4574:	01f0 2920 bf0c 2102 2100 1e52 2a04 f8d0     .. )...!.!R..*..
    4584:	2ff4 f8d0 0ffc bf38 f041 0104 f012 0f03     ./....8.A.......
    4594:	bf18 f041 0101 f240 52ff 4210 bf08 f041     ..A...@..R.B..A.
    45a4:	0108 290f d112 6870 1e40 9000 f04f 31ff     ...)..ph@...O..1
    45b4:	9800 f7ff ff27 9800 2300 f04f 1201 f04f     ....'....#O...O.
    45c4:	31ff f7ff ff31 f7ff fe5a e000 2400 bf30     .1..1...Z....$0.
    45d4:	b1c4 2231 2107 2007 f7ff ff7a 201c f7ff     ..1".!. ..z.. ..
    45e4:	fe95 f7ff fe36 6870 1e40 9000 2100 7031     ....6.ph@....!1p
    45f4:	60b1 204c f7ff fe8a 9800 f04f 31ff f7ff     .`L ......O..1..
    4604:	feeb e008 2001 7030 e005 4909 6808 f030     ..... 0p...I.h0.
    4614:	0004 6008 bf30 4628 b002 e8bd 4070 f000     ...`0.(F....p@..
    4624:	b83d 0000 0068 4002 1194 1000 000c 4002     =...h..@.......@
    4634:	ed10 e000 1184 1000 2810 d307 3810 2101     .........(...8.!
    4644:	f000 001f 4a0e 4081 6011 4770 2804 d00f     .....J.@.`pG.(..
    4654:	d315 2806 d006 d212 4809 f8d0 1c24 f441     ...(.....H..$.A.
    4664:	3100 e00a 4806 f8d0 1c24 f441 2180 e004     .1...H..$.A..!..
    4674:	4803 f8d0 1c24 f441 3180 f8c0 1c24 4770     .H..$.A..1..$.pG
    4684:	e100 e000 f3ef 8010 b662 4770 4770 0000     ........b.pGpG..
    4694:	f3ef 8010 b672 4770 4770 0000 f380 8810     ....r.pGpG......
    46a4:	4770 4770 b510 2002 f000 f8af f64f 71ff     pGpG... ....O..q
    46b4:	2000 f7ff fea7 493b 2000 f7ff fe2d 2008     . ....;I. ..-.. 
    46c4:	0004 0023 085b 0022 f64f 71ff 2000 f7ff     ..#.[.".O..q. ..
    46d4:	feab 2001 f7ff feea bd10 b580 2001 f7ff     ... ......... ..
    46e4:	fee5 4831 6800 1c40 492f 6008 2820 d302     ..1H.h@./I.` (..
    46f4:	2000 492d 6008 bd01 b580 2000 f000 f866     . -I.`..... ..f.
    4704:	482a f000 f8db f000 f937 4829 f7fe fe72     *H......7.)H..r.
    4714:	f3ef 8010 9000 b672 2073 4926 6008 4826     ......r.s &I.`&H
    4724:	6800 f030 0070 4924 6008 4824 6800 f430     .h0.p.$I.`$H.h0.
    4734:	407f f450 5080 4921 6008 4821 6800 f430     .@P..P!I.`!H.h0.
    4744:	407f 491f 6008 2000 491a 6008 9800 f380     .@.I.`. .I.`....
    4754:	8810 2105 481b f7ff fbf7 f000 f996 f000     ...!.H..........
    4764:	f91f f7ff fa93 4818 f7ff fa7d f7ff ff9a     .......H..}.....
    4774:	2001 f7ff fe8d 201d f7ff ff5e f7ff ff82     . ..... ..^.....
    4784:	f64f 71ff 2000 f7ff fe27 f000 f937 2001     O..q. ..'...7.. 
    4794:	f7ff fed8 4804 6802 2105 480a f7ff fc66     .....H.h.!.H..f.
    47a4:	e7f5 0000 1000 1000 11a0 1000 9be8 0000     ................
    47b4:	9739 0000 0060 4001 0054 4001 0028 4001     9...`..@T..@(..@
    47c4:	0108 4001 105c 1000 9bbc 0000 b510 0004     ...@\...........
    47d4:	d006 f20f 02b0 f20f 005c 2150 f000 f9af     ........\.P!....
    47e4:	480f 2147 6001 6044 2100 6001 bd10 480d     .HG!.`D`.!.`...H
    47f4:	6800 f010 0001 d004 2801 d004 f04f 30ff     .h.......(..O..0
    4804:	4770 4809 4770 4809 4770 4909 680a ea22     pG.HpG.HpG.I.h".
    4814:	0000 6008 4770 4906 680a 4310 6008 4770     ...`pG.I.h.C.`pG
    4824:	4014 4000 4018 4000 6c00 02dc 3600 016e     .@.@.@.@.l...6n.
    4834:	400c 4000 3a43 6a5c 7376 615c 626d 7169     .@.@C:\jvs\ambiq
    4844:	775c 726f 5c6b 6574 7473 6e69 5c67 6552     \work\testing\Re
    4854:	2d6c 2e31 2e32 5c39 6d41 6962 5371 6975     l-1.2.9\AmbiqSui
    4864:	6574 6d5c 7563 615c 6f70 6c6c 326f 685c     te\mcu\apollo2\h
    4874:	6c61 615c 5f6d 6168 5f6c 6c63 676b 6e65     al\am_hal_clkgen
    4884:	632e 0000 6d61 685f 6c61 635f 6b6c 6567     .c..am_hal_clkge
    4894:	5f6e 7973 6373 6b6c 735f 6c65 6365 2874     n_sysclk_select(
    48a4:	3a29 6920 766e 6c61 6469 6320 6f6c 6b63     ): invalid clock
    48b4:	7320 7465 6974 676e 002e 0000 b530 4605      setting....0..F
    48c4:	b081 78ac 7868 0040 00a1 0864 f000 0002     ...xhx@...d.....
    48d4:	f001 0104 00e4 4308 f004 0408 4304 78e8     .......C.....C.x
    48e4:	4304 7928 01c0 f000 0080 4304 79a8 0280     .C(y.......C.y..
    48f4:	f400 6080 4304 79e8 02c0 f400 6000 4304     ...`.C.y.....`.C
    4904:	7a28 0300 f400 4070 4304 7a68 0400 f400     (z....p@.Chz....
    4914:	2070 4304 7aa8 0500 f400 1080 4304 7ae8     p .C.z.......C.z
    4924:	0600 f000 7080 4304 f04f 4020 f7ff fbb6     .....p.CO. @....
    4934:	4910 f044 0401 600c 2032 688a 0753 d401     .ID....`2 .hS...
    4944:	1e40 d1fa 6888 f040 0001 6088 2032 688a     @....h@....`2 .h
    4954:	0753 d401 1e40 d1fa 7968 0202 0840 f402     S...@...hy..@...
    4964:	7280 0240 4314 f400 7000 4304 600c b001     .r@..C...p.C.`..
    4974:	bd30 0000 8000 4001 b500 b081 f7ff fc4c     0......@......L.
    4984:	f7ff fca8 f000 f8dc 2001 f000 f8df 2001     ......... ..... 
    4994:	f7ff ff41 b001 f85d eb04 f000 b8e4 0000     ..A...].........
    49a4:	482d 6801 07ca d500 4770 b500 492b 482c     -H.h....pG..+I,H
    49b4:	b087 6008 a801 492b 9101 f000 f8df f3ef     ...`..+I........
    49c4:	8010 9000 b672 4828 2173 6381 6ac1 f021     ....r.(Hs!.c.j!.
    49d4:	0170 62c1 6802 f422 427f f442 5280 6002     p..b.h"..BB..R.`
    49e4:	2200 f8d0 10e0 f421 417f f8c0 10e0 6382     ."....!..A.....c
    49f4:	9800 f380 8810 b007 bd00 0000 b500 4816     ...............H
    4a04:	b081 6801 07ca d424 f000 f858 f3ef 8010     ...h..$...X.....
    4a14:	9000 b672 4814 2173 6381 2200 6ac1 f021     ..r..Hs!.c.".j!.
    4a24:	0170 f041 0120 62c1 6801 f421 417f f441     p.A. ..b.h!..AA.
    4a34:	51c0 6001 f8d0 10e0 f421 417f f8c0 10e0     .Q.`....!..A....
    4a44:	6382 9800 f380 8810 b001 f85d eb04 f000     .c........].....
    4a54:	b8d2 b001 bd00 0000 11a4 1000 0e80 e000     ................
    4a64:	0511 0015 4240 000f 0028 4001 f000 b848     ....@B..(..@..H.
    4a74:	b510 4604 f7ff febb 4a1a fba0 2102 0d48     ...F.....J...!H.
    4a84:	4360 e8bd 4010 f7ff bc41 4817 6801 07ca     `C...@..A..H.h..
    4a94:	d413 4816 6801 f041 7180 6001 6802 01d1     ...H.hA..q.`.h..
    4aa4:	d5fc 4813 4913 f8c0 11b0 210f 6401 f04f     ...H.I.....!.dO.
    4ab4:	31ff 6001 4910 f8c0 1080 4770 b500 b081     .1.`.I....pG....
    4ac4:	480e 6801 020a d4fc f7ff fe91 4b05 fba0     .H.h.........K..
    4ad4:	3203 b001 0d50 2132 f85d eb04 fb11 f000     .2..P.2!].......
    4ae4:	f7ff bc14 fc08 b2f4 11a4 1000 edfc e000     ................
    4af4:	0e00 e000 ce55 c5ac 0511 0015 0e80 e000     ....U...........
    4b04:	7801 2200 b1d1 1c52 5c83 b153 1c52 5c81     .x."..R..\S.R..\
    4b14:	b139 1c52 5c83 2b00 d003 1c52 5c81 2900     9.R..\.+..R..\.)
    4b24:	d1f1 b15a f04f 4360 f890 c000 6819 2900     ..Z.O.`C.....h.)
    4b34:	d0fc 1c40 1e52 f883 c000 d1f5 4770 e7fe     ..@.R.......pG..
    4b44:	4901 2037 6008 4770 c008 4000 f8df 1024     .I7 .`pG...@..$.
    4b54:	b120 6808 f040 0080 6008 4770 680a f022      ..h@....`pG.h".
    4b64:	0280 600a 4770 f8df 0010 6801 f041 0110     ...`pG.....hA...
    4b74:	6001 4770 400c 4000 4050 4000 b530 b081     .`pG.@.@P@.@0...
    4b84:	6804 4d20 2100 f8c5 1300 b1fc 2001 6028     .h M.!....... (`
    4b94:	f5a4 4061 491c 4288 bf28 4c1c f7ff fe27     ..a@.I.B(..L..'.
    4ba4:	f110 0f01 d005 08c0 fbb0 f0f4 1e40 b280     ............@...
    4bb4:	e000 2005 60e8 2002 f8c5 00ec 2000 f8c5     ... .`. ..... ..
    4bc4:	0efc f240 2001 490e 6008 e00e 6901 60e9     ..@.. .I.`...i.`
    4bd4:	2201 6881 f8c5 10ec 68c3 1e59 408a 602a     .".h.....hY..@*`
    4be4:	4907 680a 6840 4302 600a b001 e8bd 4030     .I.h@h.C.`....0@
    4bf4:	2032 f7ff bf3d 4902 2000 6008 4770 0000     2 ..=..I. .`pG..
    4c04:	0250 4002 0004 e004 a381 001d 4240 000f     P..@........@B..
    4c14:	b580 4668 3008 f000 f808 bd01 4770 0000     ..hF.0......pG..
    4c24:	0080 1840 6800 4770 4770 b530 b093 0004     ..@..hpGpG0.....
    4c34:	a80c 2118 f000 f852 2500 950a 4825 6800     ...!..R..%..%H.h
    4c44:	900a 980a f88d 002c 980a 0a00 f88d 002d     ......,.......-.
    4c54:	980a 0c00 f8ad 002e 481f 6800 9009 f89d     .........H.h....
    4c64:	002d 0780 d504 0021 2006 f7ff ffd9 e001     -.....!.. ......
    4c74:	f05f 30ff 9008 0021 2000 f7ff ffd1 9000     _..0..!.. ......
    4c84:	0021 2001 f7ff ffcc 9001 0021 2002 f7ff     !.. ......!.. ..
    4c94:	ffc7 9002 0021 2003 f7ff ffc2 9003 0021     ....!.. ......!.
    4ca4:	2004 f7ff ffbd 9004 0021 2005 f7ff ffb8     . ......!.. ....
    4cb4:	9005 0021 2006 f7ff ffb3 9006 0021 2007     ..!.. ......!.. 
    4cc4:	f7ff ffae 9007 a80c f000 f80c 2000 0005     ............. ..
    4cd4:	e7fe 0000 ed28 e000 ed38 e000 2200 f000     ....(...8...."..
    4ce4:	b81b 0000 4a0b 68d1 f001 0301 7003 084b     .....J.h.....pK.
    4cf4:	0889 f001 0101 f003 0301 7401 7203 6851     ...........t.rQh
    4d04:	6843 60c1 6811 430b 6043 6943 6891 430b     Ch.`.h.CC`Ci.h.C
    4d14:	6143 4770 01c0 4002 b500 bf00 0013 4696     CapG...@.......F
    4d24:	4694 3910 bf28 e8a0 500c d8fa ea5f 7c41     .F.9(....P.._.A|
    4d34:	bf28 c00c bf48 f840 2b04 07c9 bf28 f820     (...H.@..+..(. .
    4d44:	2b02 bf48 f800 2b01 bd00 0000 0000 0000     .+H....+........
    4d54:	0256 0000 0000 0000 004d 0800 0051 0800     V.......M...Q...
    4d64:	0055 0800 0059 0800 006d 0800 0071 0800     U...Y...m...q...
    4d74:	007d 0800 0081 0800 0089 0800 0091 0800     }...............
    4d84:	0099 0800 0075 0800 0079 0800 009d 0800     ....u...y.......
    4d94:	005d 0800 0061 0800 0065 0800 0069 0800     ]...a...e...i...
    4da4:	0085 0800 008d 0800 0011 0000 0003 0000     ................
    4db4:	000e 0000 0003 0000 000f 0000 0003 0000     ................
    4dc4:	001e 0000 0003 0000 000a 0000 0003 0000     ................
    4dd4:	e019 f850 2b04 07d3 bf44 f1a9 0301 189a     ..P..+..D.......
    4de4:	1f09 2300 2904 f842 3b04 d2f9 ea5f 7c81     ...#.)B..;.._..|
    4df4:	4613 d504 f04f 0c00 f8a2 c000 1c9b 07c9     .F..O...........
    4e04:	bf44 2100 7019 f850 1b04 2900 d1e1 4770     D..!.pP....)..pG
    4e14:	b410 f850 1b04 b179 6802 6843 4402 3008     ..P...y..hCh.D.0
    4e24:	07dc bf44 f1a9 0401 18e3 f852 4b04 f843     ..D.......R..KC.
    4e34:	4b04 1f09 d1f9 e7ec bc10 4770 b510 4907     .K........pG...I
    4e44:	4479 3118 4c06 447c 3416 e004 680a 1d08     yD.1.L|D.4...h..
    4e54:	4411 4788 4601 42a1 d1f8 bd10 002c 0000     .D.G.F.B....,...
    4e64:	004c 0000 f64e 5188 f2ce 0100 6808 f440     L...N..Q.....h@.
    4e74:	0070 6008 f3bf 8f4f f3bf 8f6f f04f 7000     p..`..O...o.O..p
    4e84:	eee1 0a10 4770 0000 ff49 ffff 0128 0000     ....pG..I...(...
    4e94:	1084 1000 0000 0000 ff79 ffff 0084 0000     ........y.......
    4ea4:	feac ffff 1000 1000 0000 0000 f000 f80b     ................
    4eb4:	2800 d001 f7ff ffc2 2000 f3af 8000 f7ff     .(....... ......
    4ec4:	fc1b f000 f802 2001 4770 f000 b801 0000     ....... pG......
    4ed4:	4607 4638 f000 f802 e7fb 0000 b580 f3af     .F8F............
    4ee4:	8000 4a02 0011 2018 beab e7fb 0026 0002     ...J... ....&...
    4ef4:	6942 616e 7972 4320 756f 746e 7265 4520     Binary Counter E
    4f04:	6178 706d 656c 000a 0a0a 0a0a 0a0a 0a0a     xample..........
    4f14:	0a0a 0a0a 0a0a 0a0a 0a0a 0000 0001 5000     ...............P
    4f24:	0300 0001 0101 0001 f3af 8000 f7ff ff9a     ................
    4f34:	f7ff ffbc f7ff fff8 4770 e7fe e7fe 0000     ........pG......

00004f44 <g_sIOMConfig>:
    4f44:	0000 0000 86a0 0001 0000 3c04               ...........<

00004f50 <g_SPIpins>:
    4f50:	0006 0000 000a 0000 0009 0000 000a 0000     ................
    4f60:	0019 0000 002a 0000 002b 0000 002a 0000     ....*...+...*...
    4f70:	0028 0000 002a 0000 0031 0000 002a 0000     (...*...1...*...

00004f80 <am_hal_cachectrl_defaults>:
    4f80:	0001 5000 0300 0001 0101 0001 6d61 685f     ...P........am_h
    4f90:	6c61 635f 6b6c 6567 5f6e 7973 6373 6b6c     al_clkgen_sysclk
    4fa0:	735f 6c65 6365 2874 3a29 6920 766e 6c61     _select(): inval
    4fb0:	6469 6320 6f6c 6b63 7320 7465 6974 676e     id clock setting
    4fc0:	002e 0000 2e2e 2e5c 5c2e 6d61 685f 6c61     ......\..\am_hal
    4fd0:	635f 6b6c 6567 2e6e 0063 0000 6854 2065     _clkgen.c...The 
    4fe0:	6966 6f66 6320 756f 646c 276e 2074 6966     fifo couldn't fi
    4ff0:	2074 6874 2065 6572 7571 7365 6574 2064     t the requested 
    5000:	756e 626d 7265 6f20 2066 7962 6574 0073     number of bytes.
    5010:	2e2e 2e5c 5c2e 6d61 685f 6c61 695f 6d6f     ..\..\am_hal_iom
    5020:	632e 0000 7254 6979 676e 7420 206f 6e65     .c..Trying to en
    5030:	6261 656c 6120 206e 4f49 204d 6f6d 7564     able an IOM modu
    5040:	656c 7420 6168 2074 6f64 7365 276e 2074     le that doesn't 
    5050:	7865 7369 2e74 0000 7254 6979 676e 7420     exist...Trying t
    5060:	206f 6964 6173 6c62 2065 6e61 4920 4d4f     o disable an IOM
    5070:	6d20 646f 6c75 2065 6874 7461 6420 656f      module that doe
    5080:	6e73 7427 6520 6978 7473 002e 5053 2049     sn't exist..SPI 
    5090:	7274 6e61 6673 7265 7420 6f6f 6220 6769     transfer too big
    50a0:	002e 0000 6e49 6176 696c 2064 6948 4620     ....Invalid Hi F
    50b0:	6572 7571 6e65 7963 6620 726f 4920 4d4f     requency for IOM
    50c0:	002e 0000 7254 6979 676e 7420 206f 6f64     ....Trying to do
    50d0:	6120 3020 6220 7479 2065 7274 6e61 6173      a 0 byte transa
    50e0:	7463 6f69 006e 0000 6854 2065 6966 6f66     ction...The fifo
    50f0:	6420 656f 6e73 7427 6320 6e6f 6174 6e69      doesn't contain
    5100:	7420 6568 7220 7165 6575 7473 6465 6e20      the requested n
    5110:	6d75 6562 2072 666f 6220 7479 7365 002e     umber of bytes..

00005120 <i2c_bb_errmap>:
    5120:	0600 0106 0001 0000 6143 6e6e 746f 6520     ........Cannot e
    5130:	616e 6c62 2065 6f6d 6572 7420 6168 206e     nable more than 
    5140:	6e6f 2065 6570 6972 6870 7265 6c61 6120     one peripheral a
    5150:	2074 2061 6974 656d 002e 0000 2e2e 2e5c     t a time......\.
    5160:	5c2e 6d61 685f 6c61 705f 7277 7463 6c72     .\am_hal_pwrctrl
    5170:	632e 0000                                   .c..
