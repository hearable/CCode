
C:\jenkins\jobs\ambiqsuite-checkout\workspace\ambiqsuite-sdk\boards\apollo2_evb\examples\spi_boot_host\atollic_gcc\bin\spi_boot_host_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000047a4  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00030000  2**2
                  ALLOC
  2 .data         00000054  10001000  000047a4  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000004a0  10001054  000047f8  00021054  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00021054  2**0
                  CONTENTS, READONLY
  5 .debug_info   0000c58a  00000000  00000000  0002108b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001b0e  00000000  00000000  0002d615  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000008d0  00000000  00000000  0002f123  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000019f0  00000000  00000000  0002f9f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00004d70  00000000  00000000  000313e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003347  00000000  00000000  00036153  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007e  00000000  00000000  0003949a  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00001bb8  00000000  00000000  00039518  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00010403  00000000  00000000  0003b0d0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <g_am_pfnVectors>:
       0:	00 10 00 10 19 06 00 00 81 06 00 00 89 06 00 00     ................
      10:	89 06 00 00 89 06 00 00 89 06 00 00 00 00 00 00     ................
	...
      2c:	91 06 00 00 91 06 00 00 00 00 00 00 91 06 00 00     ................
      3c:	91 06 00 00 91 06 00 00 91 06 00 00 91 06 00 00     ................
      4c:	91 06 00 00 91 06 00 00 91 06 00 00 91 06 00 00     ................
      5c:	91 06 00 00 91 06 00 00 91 06 00 00 91 06 00 00     ................
      6c:	91 06 00 00 41 02 00 00 91 06 00 00 91 06 00 00     ....A...........
      7c:	91 06 00 00 91 06 00 00 91 06 00 00 91 06 00 00     ................
      8c:	91 06 00 00 91 06 00 00 91 06 00 00 91 06 00 00     ................
      9c:	91 06 00 00 91 06 00 00 91 06 00 00 91 06 00 00     ................
      ac:	91 06 00 00 91 06 00 00 91 06 00 00 91 06 00 00     ................
      bc:	91 06 00 00                                         ....

000000c0 <configure_pins>:
// Configure GPIOs for this example
//
//*****************************************************************************
void
configure_pins(void)
{
      c0:	b480      	push	{r7}
      c2:	b087      	sub	sp, #28
      c4:	af00      	add	r7, sp, #0
    //
    // Configure I/O Master 0 as SPI
    //
    am_hal_gpio_pin_config(5, AM_HAL_PIN_5_M0SCK);
      c6:	f3ef 8310 	mrs	r3, PRIMASK
      ca:	617b      	str	r3, [r7, #20]
      cc:	b672      	cpsid	i
      ce:	4b53      	ldr	r3, [pc, #332]	; (21c <configure_pins+0x15c>)
      d0:	2273      	movs	r2, #115	; 0x73
      d2:	601a      	str	r2, [r3, #0]
      d4:	4a52      	ldr	r2, [pc, #328]	; (220 <configure_pins+0x160>)
      d6:	4b52      	ldr	r3, [pc, #328]	; (220 <configure_pins+0x160>)
      d8:	681b      	ldr	r3, [r3, #0]
      da:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
      de:	6013      	str	r3, [r2, #0]
      e0:	4a50      	ldr	r2, [pc, #320]	; (224 <configure_pins+0x164>)
      e2:	4b50      	ldr	r3, [pc, #320]	; (224 <configure_pins+0x164>)
      e4:	681b      	ldr	r3, [r3, #0]
      e6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
      ea:	f443 6320 	orr.w	r3, r3, #2560	; 0xa00
      ee:	6013      	str	r3, [r2, #0]
      f0:	4a4d      	ldr	r2, [pc, #308]	; (228 <configure_pins+0x168>)
      f2:	4b4d      	ldr	r3, [pc, #308]	; (228 <configure_pins+0x168>)
      f4:	681b      	ldr	r3, [r3, #0]
      f6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
      fa:	6013      	str	r3, [r2, #0]
      fc:	4b47      	ldr	r3, [pc, #284]	; (21c <configure_pins+0x15c>)
      fe:	2200      	movs	r2, #0
     100:	601a      	str	r2, [r3, #0]
     102:	697b      	ldr	r3, [r7, #20]
     104:	f383 8810 	msr	PRIMASK, r3
    am_hal_gpio_pin_config(6, AM_HAL_PIN_6_M0MISO);
     108:	f3ef 8310 	mrs	r3, PRIMASK
     10c:	613b      	str	r3, [r7, #16]
     10e:	b672      	cpsid	i
     110:	4b42      	ldr	r3, [pc, #264]	; (21c <configure_pins+0x15c>)
     112:	2273      	movs	r2, #115	; 0x73
     114:	601a      	str	r2, [r3, #0]
     116:	4a42      	ldr	r2, [pc, #264]	; (220 <configure_pins+0x160>)
     118:	4b41      	ldr	r3, [pc, #260]	; (220 <configure_pins+0x160>)
     11a:	681b      	ldr	r3, [r3, #0]
     11c:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
     120:	6013      	str	r3, [r2, #0]
     122:	4a40      	ldr	r2, [pc, #256]	; (224 <configure_pins+0x164>)
     124:	4b3f      	ldr	r3, [pc, #252]	; (224 <configure_pins+0x164>)
     126:	681b      	ldr	r3, [r3, #0]
     128:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     12c:	f443 2320 	orr.w	r3, r3, #655360	; 0xa0000
     130:	6013      	str	r3, [r2, #0]
     132:	4a3d      	ldr	r2, [pc, #244]	; (228 <configure_pins+0x168>)
     134:	4b3c      	ldr	r3, [pc, #240]	; (228 <configure_pins+0x168>)
     136:	681b      	ldr	r3, [r3, #0]
     138:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     13c:	6013      	str	r3, [r2, #0]
     13e:	4b37      	ldr	r3, [pc, #220]	; (21c <configure_pins+0x15c>)
     140:	2200      	movs	r2, #0
     142:	601a      	str	r2, [r3, #0]
     144:	693b      	ldr	r3, [r7, #16]
     146:	f383 8810 	msr	PRIMASK, r3
    am_hal_gpio_pin_config(7, AM_HAL_PIN_7_M0MOSI);
     14a:	f3ef 8310 	mrs	r3, PRIMASK
     14e:	60fb      	str	r3, [r7, #12]
     150:	b672      	cpsid	i
     152:	4b32      	ldr	r3, [pc, #200]	; (21c <configure_pins+0x15c>)
     154:	2273      	movs	r2, #115	; 0x73
     156:	601a      	str	r2, [r3, #0]
     158:	4a31      	ldr	r2, [pc, #196]	; (220 <configure_pins+0x160>)
     15a:	4b31      	ldr	r3, [pc, #196]	; (220 <configure_pins+0x160>)
     15c:	681b      	ldr	r3, [r3, #0]
     15e:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
     162:	6013      	str	r3, [r2, #0]
     164:	4a2f      	ldr	r2, [pc, #188]	; (224 <configure_pins+0x164>)
     166:	4b2f      	ldr	r3, [pc, #188]	; (224 <configure_pins+0x164>)
     168:	681b      	ldr	r3, [r3, #0]
     16a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     16e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
     172:	6013      	str	r3, [r2, #0]
     174:	4a2c      	ldr	r2, [pc, #176]	; (228 <configure_pins+0x168>)
     176:	4b2c      	ldr	r3, [pc, #176]	; (228 <configure_pins+0x168>)
     178:	681b      	ldr	r3, [r3, #0]
     17a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     17e:	6013      	str	r3, [r2, #0]
     180:	4b26      	ldr	r3, [pc, #152]	; (21c <configure_pins+0x15c>)
     182:	2200      	movs	r2, #0
     184:	601a      	str	r2, [r3, #0]
     186:	68fb      	ldr	r3, [r7, #12]
     188:	f383 8810 	msr	PRIMASK, r3
    am_hal_gpio_pin_config(11, AM_HAL_PIN_11_M0nCE0);
     18c:	f3ef 8310 	mrs	r3, PRIMASK
     190:	60bb      	str	r3, [r7, #8]
     192:	b672      	cpsid	i
     194:	4b21      	ldr	r3, [pc, #132]	; (21c <configure_pins+0x15c>)
     196:	2273      	movs	r2, #115	; 0x73
     198:	601a      	str	r2, [r3, #0]
     19a:	4a24      	ldr	r2, [pc, #144]	; (22c <configure_pins+0x16c>)
     19c:	4b23      	ldr	r3, [pc, #140]	; (22c <configure_pins+0x16c>)
     19e:	681b      	ldr	r3, [r3, #0]
     1a0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
     1a4:	6013      	str	r3, [r2, #0]
     1a6:	4a22      	ldr	r2, [pc, #136]	; (230 <configure_pins+0x170>)
     1a8:	4b21      	ldr	r3, [pc, #132]	; (230 <configure_pins+0x170>)
     1aa:	681b      	ldr	r3, [r3, #0]
     1ac:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     1b0:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
     1b4:	6013      	str	r3, [r2, #0]
     1b6:	4a1f      	ldr	r2, [pc, #124]	; (234 <configure_pins+0x174>)
     1b8:	4b1e      	ldr	r3, [pc, #120]	; (234 <configure_pins+0x174>)
     1ba:	681b      	ldr	r3, [r3, #0]
     1bc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     1c0:	6013      	str	r3, [r2, #0]
     1c2:	4b16      	ldr	r3, [pc, #88]	; (21c <configure_pins+0x15c>)
     1c4:	2200      	movs	r2, #0
     1c6:	601a      	str	r2, [r3, #0]
     1c8:	68bb      	ldr	r3, [r7, #8]
     1ca:	f383 8810 	msr	PRIMASK, r3


    //
    // Configure the I/O Slave interrupt pin
    //
    am_hal_gpio_pin_config(BOOTLOADER_HANDSHAKE_PIN, AM_HAL_PIN_INPUT | AM_HAL_GPIO_PULLUP);
     1ce:	f3ef 8310 	mrs	r3, PRIMASK
     1d2:	607b      	str	r3, [r7, #4]
     1d4:	b672      	cpsid	i
     1d6:	4b11      	ldr	r3, [pc, #68]	; (21c <configure_pins+0x15c>)
     1d8:	2273      	movs	r2, #115	; 0x73
     1da:	601a      	str	r2, [r3, #0]
     1dc:	4a10      	ldr	r2, [pc, #64]	; (220 <configure_pins+0x160>)
     1de:	4b10      	ldr	r3, [pc, #64]	; (220 <configure_pins+0x160>)
     1e0:	681b      	ldr	r3, [r3, #0]
     1e2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
     1e6:	6013      	str	r3, [r2, #0]
     1e8:	4a13      	ldr	r2, [pc, #76]	; (238 <configure_pins+0x178>)
     1ea:	4b13      	ldr	r3, [pc, #76]	; (238 <configure_pins+0x178>)
     1ec:	681b      	ldr	r3, [r3, #0]
     1ee:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     1f2:	f443 13d8 	orr.w	r3, r3, #1769472	; 0x1b0000
     1f6:	6013      	str	r3, [r2, #0]
     1f8:	4a10      	ldr	r2, [pc, #64]	; (23c <configure_pins+0x17c>)
     1fa:	4b10      	ldr	r3, [pc, #64]	; (23c <configure_pins+0x17c>)
     1fc:	681b      	ldr	r3, [r3, #0]
     1fe:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     202:	6013      	str	r3, [r2, #0]
     204:	4b05      	ldr	r3, [pc, #20]	; (21c <configure_pins+0x15c>)
     206:	2200      	movs	r2, #0
     208:	601a      	str	r2, [r3, #0]
     20a:	687b      	ldr	r3, [r7, #4]
     20c:	f383 8810 	msr	PRIMASK, r3
}
     210:	bf00      	nop
     212:	371c      	adds	r7, #28
     214:	46bd      	mov	sp, r7
     216:	f85d 7b04 	ldr.w	r7, [sp], #4
     21a:	4770      	bx	lr
     21c:	40010060 	.word	0x40010060
     220:	40010040 	.word	0x40010040
     224:	40010004 	.word	0x40010004
     228:	400100e4 	.word	0x400100e4
     22c:	40010044 	.word	0x40010044
     230:	40010008 	.word	0x40010008
     234:	400100e8 	.word	0x400100e8
     238:	40010000 	.word	0x40010000
     23c:	400100e0 	.word	0x400100e0

00000240 <am_gpio_isr>:
// Interrupt handler for the GPIO pins.
//
//*****************************************************************************
void
am_gpio_isr(void)
{
     240:	b580      	push	{r7, lr}
     242:	b082      	sub	sp, #8
     244:	af00      	add	r7, sp, #0
    uint64_t ui64Status;

    //
    // Read and clear the GPIO interrupt status.
    //
    ui64Status = am_hal_gpio_int_status_get(false);
     246:	2000      	movs	r0, #0
     248:	f000 fc58 	bl	afc <am_hal_gpio_int_status_get>
     24c:	e9c7 0100 	strd	r0, r1, [r7]
    am_hal_gpio_int_clear(ui64Status);
     250:	e9d7 0100 	ldrd	r0, r1, [r7]
     254:	f000 fc40 	bl	ad8 <am_hal_gpio_int_clear>
}
     258:	bf00      	nop
     25a:	3708      	adds	r7, #8
     25c:	46bd      	mov	sp, r7
     25e:	bd80      	pop	{r7, pc}

00000260 <start_boot_mode>:
// Reset the slave device and force it into boot mode.
//
//*****************************************************************************
void
start_boot_mode(void)
{
     260:	b580      	push	{r7, lr}
     262:	b082      	sub	sp, #8
     264:	af00      	add	r7, sp, #0
    //
    // Drive RESET low.
    //
    am_hal_gpio_out_bit_clear(DRIVE_SLAVE_RESET_PIN);
     266:	4b2f      	ldr	r3, [pc, #188]	; (324 <start_boot_mode+0xc4>)
     268:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     26c:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(DRIVE_SLAVE_RESET_PIN, AM_HAL_PIN_OUTPUT);
     26e:	f3ef 8310 	mrs	r3, PRIMASK
     272:	607b      	str	r3, [r7, #4]
     274:	b672      	cpsid	i
     276:	4b2c      	ldr	r3, [pc, #176]	; (328 <start_boot_mode+0xc8>)
     278:	2273      	movs	r2, #115	; 0x73
     27a:	601a      	str	r2, [r3, #0]
     27c:	4a2b      	ldr	r2, [pc, #172]	; (32c <start_boot_mode+0xcc>)
     27e:	4b2b      	ldr	r3, [pc, #172]	; (32c <start_boot_mode+0xcc>)
     280:	681b      	ldr	r3, [r3, #0]
     282:	f023 0370 	bic.w	r3, r3, #112	; 0x70
     286:	f043 0320 	orr.w	r3, r3, #32
     28a:	6013      	str	r3, [r2, #0]
     28c:	4a28      	ldr	r2, [pc, #160]	; (330 <start_boot_mode+0xd0>)
     28e:	4b28      	ldr	r3, [pc, #160]	; (330 <start_boot_mode+0xd0>)
     290:	681b      	ldr	r3, [r3, #0]
     292:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     296:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
     29a:	6013      	str	r3, [r2, #0]
     29c:	4a25      	ldr	r2, [pc, #148]	; (334 <start_boot_mode+0xd4>)
     29e:	4b25      	ldr	r3, [pc, #148]	; (334 <start_boot_mode+0xd4>)
     2a0:	681b      	ldr	r3, [r3, #0]
     2a2:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     2a6:	6013      	str	r3, [r2, #0]
     2a8:	4b1f      	ldr	r3, [pc, #124]	; (328 <start_boot_mode+0xc8>)
     2aa:	2200      	movs	r2, #0
     2ac:	601a      	str	r2, [r3, #0]
     2ae:	687b      	ldr	r3, [r7, #4]
     2b0:	f383 8810 	msr	PRIMASK, r3

    //
    // Drive the override pin low to force the slave into boot mode.
    //
    am_hal_gpio_out_bit_clear(DRIVE_SLAVE_OVERRIDE_PIN);
     2b4:	4b1b      	ldr	r3, [pc, #108]	; (324 <start_boot_mode+0xc4>)
     2b6:	2210      	movs	r2, #16
     2b8:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(DRIVE_SLAVE_OVERRIDE_PIN, AM_HAL_PIN_OUTPUT);
     2ba:	f3ef 8310 	mrs	r3, PRIMASK
     2be:	603b      	str	r3, [r7, #0]
     2c0:	b672      	cpsid	i
     2c2:	4b19      	ldr	r3, [pc, #100]	; (328 <start_boot_mode+0xc8>)
     2c4:	2273      	movs	r2, #115	; 0x73
     2c6:	601a      	str	r2, [r3, #0]
     2c8:	4a1b      	ldr	r2, [pc, #108]	; (338 <start_boot_mode+0xd8>)
     2ca:	4b1b      	ldr	r3, [pc, #108]	; (338 <start_boot_mode+0xd8>)
     2cc:	681b      	ldr	r3, [r3, #0]
     2ce:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
     2d2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     2d6:	6013      	str	r3, [r2, #0]
     2d8:	4a18      	ldr	r2, [pc, #96]	; (33c <start_boot_mode+0xdc>)
     2da:	4b18      	ldr	r3, [pc, #96]	; (33c <start_boot_mode+0xdc>)
     2dc:	681b      	ldr	r3, [r3, #0]
     2de:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     2e2:	f043 0318 	orr.w	r3, r3, #24
     2e6:	6013      	str	r3, [r2, #0]
     2e8:	4a15      	ldr	r2, [pc, #84]	; (340 <start_boot_mode+0xe0>)
     2ea:	4b15      	ldr	r3, [pc, #84]	; (340 <start_boot_mode+0xe0>)
     2ec:	681b      	ldr	r3, [r3, #0]
     2ee:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     2f2:	6013      	str	r3, [r2, #0]
     2f4:	4b0c      	ldr	r3, [pc, #48]	; (328 <start_boot_mode+0xc8>)
     2f6:	2200      	movs	r2, #0
     2f8:	601a      	str	r2, [r3, #0]
     2fa:	683b      	ldr	r3, [r7, #0]
     2fc:	f383 8810 	msr	PRIMASK, r3

    //
    // Short delay.
    //
    am_util_delay_us(5);
     300:	2005      	movs	r0, #5
     302:	f000 f9c9 	bl	698 <am_util_delay_us>

    //
    // Release RESET.
    //
    am_hal_gpio_out_bit_set(DRIVE_SLAVE_RESET_PIN);
     306:	4b0f      	ldr	r3, [pc, #60]	; (344 <start_boot_mode+0xe4>)
     308:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     30c:	601a      	str	r2, [r3, #0]

    //
    // Wait for the slave to Set the handshake pin
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     30e:	bf00      	nop
     310:	4b0d      	ldr	r3, [pc, #52]	; (348 <start_boot_mode+0xe8>)
     312:	681b      	ldr	r3, [r3, #0]
     314:	f003 0304 	and.w	r3, r3, #4
     318:	2b00      	cmp	r3, #0
     31a:	d0f9      	beq.n	310 <start_boot_mode+0xb0>
}
     31c:	bf00      	nop
     31e:	3708      	adds	r7, #8
     320:	46bd      	mov	sp, r7
     322:	bd80      	pop	{r7, pc}
     324:	40010098 	.word	0x40010098
     328:	40010060 	.word	0x40010060
     32c:	40010048 	.word	0x40010048
     330:	40010010 	.word	0x40010010
     334:	400100f0 	.word	0x400100f0
     338:	40010040 	.word	0x40010040
     33c:	40010004 	.word	0x40010004
     340:	400100e4 	.word	0x400100e4
     344:	40010090 	.word	0x40010090
     348:	40010080 	.word	0x40010080

0000034c <start_new_image>:
// Send the commands to start a new boot download.
//
//*****************************************************************************
void
start_new_image(void)
{
     34c:	b580      	push	{r7, lr}
     34e:	b082      	sub	sp, #8
     350:	af02      	add	r7, sp, #8
    //
    // Wait for the slave to send the ready signal
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     352:	bf00      	nop
     354:	4b25      	ldr	r3, [pc, #148]	; (3ec <start_new_image+0xa0>)
     356:	681b      	ldr	r3, [r3, #0]
     358:	f003 0304 	and.w	r3, r3, #4
     35c:	2b00      	cmp	r3, #0
     35e:	d1f9      	bne.n	354 <start_new_image+0x8>
    //
    // Make sure the override pin is high so the slave will reboot into
    // application mode when our boot procedure is complete.
    //
    am_hal_gpio_out_bit_set(DRIVE_SLAVE_OVERRIDE_PIN);
     360:	4b23      	ldr	r3, [pc, #140]	; (3f0 <start_new_image+0xa4>)
     362:	2210      	movs	r2, #16
     364:	601a      	str	r2, [r3, #0]
    // Clear any interrupts that may have happened while Slave is coming up
    am_hal_iom_int_clear(0, 0xFFFFFFFF);
     366:	f04f 31ff 	mov.w	r1, #4294967295
     36a:	2000      	movs	r0, #0
     36c:	f001 ff6e 	bl	224c <am_hal_iom_int_clear>
    am_hal_iom_spi_read(0, 0, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     370:	2300      	movs	r3, #0
     372:	9300      	str	r3, [sp, #0]
     374:	2304      	movs	r3, #4
     376:	4a1f      	ldr	r2, [pc, #124]	; (3f4 <start_new_image+0xa8>)
     378:	2100      	movs	r1, #0
     37a:	2000      	movs	r0, #0
     37c:	f001 fee6 	bl	214c <am_hal_iom_spi_read>

    //
    // ACK the ready signal to have slave pull the interrupt line high.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     380:	4b1d      	ldr	r3, [pc, #116]	; (3f8 <start_new_image+0xac>)
     382:	2200      	movs	r2, #0
     384:	601a      	str	r2, [r3, #0]
    am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     386:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     38a:	9300      	str	r3, [sp, #0]
     38c:	2304      	movs	r3, #4
     38e:	4a1a      	ldr	r2, [pc, #104]	; (3f8 <start_new_image+0xac>)
     390:	2100      	movs	r1, #0
     392:	2000      	movs	r0, #0
     394:	f001 fc7c 	bl	1c90 <am_hal_iom_spi_write>
    //
    // Wait for the slave to read the ACK
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     398:	bf00      	nop
     39a:	4b14      	ldr	r3, [pc, #80]	; (3ec <start_new_image+0xa0>)
     39c:	681b      	ldr	r3, [r3, #0]
     39e:	f003 0304 	and.w	r3, r3, #4
     3a2:	2b00      	cmp	r3, #0
     3a4:	d0f9      	beq.n	39a <start_new_image+0x4e>

    //
    // Write the image parameters to the SPI FIFO
    //
    g_psTxBuffer.words[0] = IMAGE_LINK_ADDRESS;
     3a6:	4b14      	ldr	r3, [pc, #80]	; (3f8 <start_new_image+0xac>)
     3a8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
     3ac:	601a      	str	r2, [r3, #0]
    g_psTxBuffer.words[1] = IMAGE_SIZE;
     3ae:	4b12      	ldr	r3, [pc, #72]	; (3f8 <start_new_image+0xac>)
     3b0:	f641 420a 	movw	r2, #7178	; 0x1c0a
     3b4:	605a      	str	r2, [r3, #4]
    g_psTxBuffer.words[2] = IMAGE_CRC;
     3b6:	4b10      	ldr	r3, [pc, #64]	; (3f8 <start_new_image+0xac>)
     3b8:	4a10      	ldr	r2, [pc, #64]	; (3fc <start_new_image+0xb0>)
     3ba:	609a      	str	r2, [r3, #8]

    //
    // Send the image parameters to the slave.
    //
    am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 12, AM_HAL_IOM_OFFSET(0x84));
     3bc:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     3c0:	9300      	str	r3, [sp, #0]
     3c2:	230c      	movs	r3, #12
     3c4:	4a0c      	ldr	r2, [pc, #48]	; (3f8 <start_new_image+0xac>)
     3c6:	2100      	movs	r1, #0
     3c8:	2000      	movs	r0, #0
     3ca:	f001 fc61 	bl	1c90 <am_hal_iom_spi_write>

    //
    // Finish out the image start routine with the "New Image" packet.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_NEW_IMAGE;
     3ce:	4b0a      	ldr	r3, [pc, #40]	; (3f8 <start_new_image+0xac>)
     3d0:	2202      	movs	r2, #2
     3d2:	601a      	str	r2, [r3, #0]
    am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     3d4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     3d8:	9300      	str	r3, [sp, #0]
     3da:	2304      	movs	r3, #4
     3dc:	4a06      	ldr	r2, [pc, #24]	; (3f8 <start_new_image+0xac>)
     3de:	2100      	movs	r1, #0
     3e0:	2000      	movs	r0, #0
     3e2:	f001 fc55 	bl	1c90 <am_hal_iom_spi_write>
}
     3e6:	bf00      	nop
     3e8:	46bd      	mov	sp, r7
     3ea:	bd80      	pop	{r7, pc}
     3ec:	40010080 	.word	0x40010080
     3f0:	40010090 	.word	0x40010090
     3f4:	1000125c 	.word	0x1000125c
     3f8:	1000106c 	.word	0x1000106c
     3fc:	160b7b17 	.word	0x160b7b17

00000400 <override_pin_set>:
// Set override pin.
//
//*****************************************************************************
void
override_pin_set(uint32_t ui32OverridePin, uint32_t ui32OverridePolarity)
{
     400:	b580      	push	{r7, lr}
     402:	b084      	sub	sp, #16
     404:	af02      	add	r7, sp, #8
     406:	6078      	str	r0, [r7, #4]
     408:	6039      	str	r1, [r7, #0]
    //
    // Wait for the slave to send the ready signal
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     40a:	bf00      	nop
     40c:	4b1f      	ldr	r3, [pc, #124]	; (48c <override_pin_set+0x8c>)
     40e:	681b      	ldr	r3, [r3, #0]
     410:	f003 0304 	and.w	r3, r3, #4
     414:	2b00      	cmp	r3, #0
     416:	d1f9      	bne.n	40c <override_pin_set+0xc>
    am_hal_iom_spi_read(0, 0, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     418:	2300      	movs	r3, #0
     41a:	9300      	str	r3, [sp, #0]
     41c:	2304      	movs	r3, #4
     41e:	4a1c      	ldr	r2, [pc, #112]	; (490 <override_pin_set+0x90>)
     420:	2100      	movs	r1, #0
     422:	2000      	movs	r0, #0
     424:	f001 fe92 	bl	214c <am_hal_iom_spi_read>

    //
    // ACK the ready signal to have slave pull the interrupt line high.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     428:	4b1a      	ldr	r3, [pc, #104]	; (494 <override_pin_set+0x94>)
     42a:	2200      	movs	r2, #0
     42c:	601a      	str	r2, [r3, #0]
    am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     42e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     432:	9300      	str	r3, [sp, #0]
     434:	2304      	movs	r3, #4
     436:	4a17      	ldr	r2, [pc, #92]	; (494 <override_pin_set+0x94>)
     438:	2100      	movs	r1, #0
     43a:	2000      	movs	r0, #0
     43c:	f001 fc28 	bl	1c90 <am_hal_iom_spi_write>
    //
    // Wait for the slave to read the ACK
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     440:	bf00      	nop
     442:	4b12      	ldr	r3, [pc, #72]	; (48c <override_pin_set+0x8c>)
     444:	681b      	ldr	r3, [r3, #0]
     446:	f003 0304 	and.w	r3, r3, #4
     44a:	2b00      	cmp	r3, #0
     44c:	d0f9      	beq.n	442 <override_pin_set+0x42>

    //
    // Write the image parameters to the SPI FIFO
    //
    g_psTxBuffer.words[0] = ui32OverridePin;
     44e:	4a11      	ldr	r2, [pc, #68]	; (494 <override_pin_set+0x94>)
     450:	687b      	ldr	r3, [r7, #4]
     452:	6013      	str	r3, [r2, #0]
    g_psTxBuffer.words[1] = ui32OverridePolarity;
     454:	4a0f      	ldr	r2, [pc, #60]	; (494 <override_pin_set+0x94>)
     456:	683b      	ldr	r3, [r7, #0]
     458:	6053      	str	r3, [r2, #4]

    //
    // Send the image parameters to the slave.
    //
    am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 8, AM_HAL_IOM_OFFSET(0x84));
     45a:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     45e:	9300      	str	r3, [sp, #0]
     460:	2308      	movs	r3, #8
     462:	4a0c      	ldr	r2, [pc, #48]	; (494 <override_pin_set+0x94>)
     464:	2100      	movs	r1, #0
     466:	2000      	movs	r0, #0
     468:	f001 fc12 	bl	1c90 <am_hal_iom_spi_write>

    //
    // Finish out the image start routine with the "New Image" packet.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_SET_OVERRIDE_CMD;
     46c:	4b09      	ldr	r3, [pc, #36]	; (494 <override_pin_set+0x94>)
     46e:	2205      	movs	r2, #5
     470:	601a      	str	r2, [r3, #0]
    am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     472:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     476:	9300      	str	r3, [sp, #0]
     478:	2304      	movs	r3, #4
     47a:	4a06      	ldr	r2, [pc, #24]	; (494 <override_pin_set+0x94>)
     47c:	2100      	movs	r1, #0
     47e:	2000      	movs	r0, #0
     480:	f001 fc06 	bl	1c90 <am_hal_iom_spi_write>
}
     484:	bf00      	nop
     486:	3708      	adds	r7, #8
     488:	46bd      	mov	sp, r7
     48a:	bd80      	pop	{r7, pc}
     48c:	40010080 	.word	0x40010080
     490:	1000125c 	.word	0x1000125c
     494:	1000106c 	.word	0x1000106c

00000498 <transfer_image>:
// Send the actual firmware image over to the boot slave.
//
//*****************************************************************************
void
transfer_image(void)
{
     498:	b580      	push	{r7, lr}
     49a:	b086      	sub	sp, #24
     49c:	af02      	add	r7, sp, #8
    uint32_t i;

    //
    // Send the firmware image across.
    //
    ui32BytesRemaining = IMAGE_SIZE;
     49e:	f641 430a 	movw	r3, #7178	; 0x1c0a
     4a2:	60fb      	str	r3, [r7, #12]
    ui32Offset = 0;
     4a4:	2300      	movs	r3, #0
     4a6:	60bb      	str	r3, [r7, #8]

    while ( ui32BytesRemaining )
     4a8:	e05b      	b.n	562 <transfer_image+0xca>
    {
        //
        // Wait for another ready signal.
        //
        while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     4aa:	bf00      	nop
     4ac:	4b30      	ldr	r3, [pc, #192]	; (570 <transfer_image+0xd8>)
     4ae:	681b      	ldr	r3, [r3, #0]
     4b0:	f003 0304 	and.w	r3, r3, #4
     4b4:	2b00      	cmp	r3, #0
     4b6:	d1f9      	bne.n	4ac <transfer_image+0x14>
        am_hal_iom_spi_read(0, 0, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     4b8:	2300      	movs	r3, #0
     4ba:	9300      	str	r3, [sp, #0]
     4bc:	2304      	movs	r3, #4
     4be:	4a2d      	ldr	r2, [pc, #180]	; (574 <transfer_image+0xdc>)
     4c0:	2100      	movs	r1, #0
     4c2:	2000      	movs	r0, #0
     4c4:	f001 fe42 	bl	214c <am_hal_iom_spi_read>
        //
        // ACK the ready signal to have slave pull the interrupt line high.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     4c8:	4b2b      	ldr	r3, [pc, #172]	; (578 <transfer_image+0xe0>)
     4ca:	2200      	movs	r2, #0
     4cc:	601a      	str	r2, [r3, #0]
        am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     4ce:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     4d2:	9300      	str	r3, [sp, #0]
     4d4:	2304      	movs	r3, #4
     4d6:	4a28      	ldr	r2, [pc, #160]	; (578 <transfer_image+0xe0>)
     4d8:	2100      	movs	r1, #0
     4da:	2000      	movs	r0, #0
     4dc:	f001 fbd8 	bl	1c90 <am_hal_iom_spi_write>
        //
        // Wait for the slave to read the ACK
        //
        while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     4e0:	bf00      	nop
     4e2:	4b23      	ldr	r3, [pc, #140]	; (570 <transfer_image+0xd8>)
     4e4:	681b      	ldr	r3, [r3, #0]
     4e6:	f003 0304 	and.w	r3, r3, #4
     4ea:	2b00      	cmp	r3, #0
     4ec:	d0f9      	beq.n	4e2 <transfer_image+0x4a>

        //
        // We can't transfer more than a few bytes at a time. Limit the
        // transaction to 112 bytes max.
        //
        ui32TransferSize = ui32BytesRemaining > 112 ? 112 : ui32BytesRemaining;
     4ee:	68fb      	ldr	r3, [r7, #12]
     4f0:	2b70      	cmp	r3, #112	; 0x70
     4f2:	bf28      	it	cs
     4f4:	2370      	movcs	r3, #112	; 0x70
     4f6:	603b      	str	r3, [r7, #0]

        //
        // Start the packet with the packet length.
        //
        g_psTxBuffer.words[0] = ui32TransferSize;
     4f8:	4a1f      	ldr	r2, [pc, #124]	; (578 <transfer_image+0xe0>)
     4fa:	683b      	ldr	r3, [r7, #0]
     4fc:	6013      	str	r3, [r2, #0]

        //
        // Fill in the packet contents.
        //
        for ( i = 0; i < ui32TransferSize; i++ )
     4fe:	2300      	movs	r3, #0
     500:	607b      	str	r3, [r7, #4]
     502:	e00b      	b.n	51c <transfer_image+0x84>
        {
            g_psTxBuffer.bytes[4 + i] = IMAGE_ARRAY[ui32Offset + i];
     504:	687b      	ldr	r3, [r7, #4]
     506:	3304      	adds	r3, #4
     508:	68b9      	ldr	r1, [r7, #8]
     50a:	687a      	ldr	r2, [r7, #4]
     50c:	440a      	add	r2, r1
     50e:	491b      	ldr	r1, [pc, #108]	; (57c <transfer_image+0xe4>)
     510:	5c89      	ldrb	r1, [r1, r2]
     512:	4a19      	ldr	r2, [pc, #100]	; (578 <transfer_image+0xe0>)
     514:	54d1      	strb	r1, [r2, r3]
        g_psTxBuffer.words[0] = ui32TransferSize;

        //
        // Fill in the packet contents.
        //
        for ( i = 0; i < ui32TransferSize; i++ )
     516:	687b      	ldr	r3, [r7, #4]
     518:	3301      	adds	r3, #1
     51a:	607b      	str	r3, [r7, #4]
     51c:	687a      	ldr	r2, [r7, #4]
     51e:	683b      	ldr	r3, [r7, #0]
     520:	429a      	cmp	r2, r3
     522:	d3ef      	bcc.n	504 <transfer_image+0x6c>
        }

        //
        // Send the data over to the slave.
        //
        am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, ui32TransferSize + 4,
     524:	683b      	ldr	r3, [r7, #0]
     526:	1d1a      	adds	r2, r3, #4
     528:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     52c:	9300      	str	r3, [sp, #0]
     52e:	4613      	mov	r3, r2
     530:	4a11      	ldr	r2, [pc, #68]	; (578 <transfer_image+0xe0>)
     532:	2100      	movs	r1, #0
     534:	2000      	movs	r0, #0
     536:	f001 fbab 	bl	1c90 <am_hal_iom_spi_write>
                             AM_HAL_IOM_OFFSET(0x84));

        //
        // Finish with the "New Packet" boot command.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_NEW_PACKET;
     53a:	4b0f      	ldr	r3, [pc, #60]	; (578 <transfer_image+0xe0>)
     53c:	2203      	movs	r2, #3
     53e:	601a      	str	r2, [r3, #0]
        am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     540:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     544:	9300      	str	r3, [sp, #0]
     546:	2304      	movs	r3, #4
     548:	4a0b      	ldr	r2, [pc, #44]	; (578 <transfer_image+0xe0>)
     54a:	2100      	movs	r1, #0
     54c:	2000      	movs	r0, #0
     54e:	f001 fb9f 	bl	1c90 <am_hal_iom_spi_write>

        //
        // Update the loop variables.
        //
        ui32BytesRemaining -= ui32TransferSize;
     552:	68fa      	ldr	r2, [r7, #12]
     554:	683b      	ldr	r3, [r7, #0]
     556:	1ad3      	subs	r3, r2, r3
     558:	60fb      	str	r3, [r7, #12]
        ui32Offset += ui32TransferSize;
     55a:	68ba      	ldr	r2, [r7, #8]
     55c:	683b      	ldr	r3, [r7, #0]
     55e:	4413      	add	r3, r2
     560:	60bb      	str	r3, [r7, #8]
    // Send the firmware image across.
    //
    ui32BytesRemaining = IMAGE_SIZE;
    ui32Offset = 0;

    while ( ui32BytesRemaining )
     562:	68fb      	ldr	r3, [r7, #12]
     564:	2b00      	cmp	r3, #0
     566:	d1a0      	bne.n	4aa <transfer_image+0x12>
        // Update the loop variables.
        //
        ui32BytesRemaining -= ui32TransferSize;
        ui32Offset += ui32TransferSize;
    }
}
     568:	bf00      	nop
     56a:	3710      	adds	r7, #16
     56c:	46bd      	mov	sp, r7
     56e:	bd80      	pop	{r7, pc}
     570:	40010080 	.word	0x40010080
     574:	1000125c 	.word	0x1000125c
     578:	1000106c 	.word	0x1000106c
     57c:	00002970 	.word	0x00002970

00000580 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
     580:	b580      	push	{r7, lr}
     582:	b082      	sub	sp, #8
     584:	af02      	add	r7, sp, #8
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
     586:	2000      	movs	r0, #0
     588:	f000 f9aa 	bl	8e0 <am_hal_clkgen_sysclk_select>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);
     58c:	481d      	ldr	r0, [pc, #116]	; (604 <main+0x84>)
     58e:	f000 f911 	bl	7b4 <am_hal_cachectrl_enable>

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
     592:	f000 f8fd 	bl	790 <am_bsp_low_power_init>

    //
    // Setup the pins for IO Master Example.
    //
    configure_pins();
     596:	f7ff fd93 	bl	c0 <configure_pins>

    //
    // Initialize IOM 0 in SPI mode at 100KHz
    //
#ifndef AM_PART_APOLLO
    am_hal_iom_pwrctrl_enable(0);
     59a:	2000      	movs	r0, #0
     59c:	f000 fb0e 	bl	bbc <am_hal_iom_pwrctrl_enable>
#endif
    am_hal_iom_config(0, &g_sIOMConfig);
     5a0:	4919      	ldr	r1, [pc, #100]	; (608 <main+0x88>)
     5a2:	2000      	movs	r0, #0
     5a4:	f000 fb34 	bl	c10 <am_hal_iom_config>
    //
    // Turn on the IOM for this operation.
    //
    am_bsp_iom_enable(0);
     5a8:	2000      	movs	r0, #0
     5aa:	f000 f88d 	bl	6c8 <am_bsp_iom_enable>

    //
    // Force the slave into boot mode.
    //
    start_boot_mode();
     5ae:	f7ff fe57 	bl	260 <start_boot_mode>

    //
    // Wait for the 'READY' from the boot slave, and then send the packet
    // information.
    //
    start_new_image();
     5b2:	f7ff fecb 	bl	34c <start_new_image>

    //
    // Change the override pin to correspond to a button on the Apollo EVK
    //
    override_pin_set(TARGET_BOARD_OVERRIDE_PIN, 0);
     5b6:	2100      	movs	r1, #0
     5b8:	2012      	movs	r0, #18
     5ba:	f7ff ff21 	bl	400 <override_pin_set>

    //
    // Wait for another 'READY', and send the actual image across.
    //
    transfer_image();
     5be:	f7ff ff6b 	bl	498 <transfer_image>
    //
    // At this point, the slave should send back a either 'CRC OK' or some sort
    // of error. If the CRC was good, we should tell the slave to reset itself
    // and run the new image.
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     5c2:	bf00      	nop
     5c4:	4b11      	ldr	r3, [pc, #68]	; (60c <main+0x8c>)
     5c6:	681b      	ldr	r3, [r3, #0]
     5c8:	f003 0304 	and.w	r3, r3, #4
     5cc:	2b00      	cmp	r3, #0
     5ce:	d1f9      	bne.n	5c4 <main+0x44>
    am_hal_iom_spi_read(0, 0, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     5d0:	2300      	movs	r3, #0
     5d2:	9300      	str	r3, [sp, #0]
     5d4:	2304      	movs	r3, #4
     5d6:	4a0e      	ldr	r2, [pc, #56]	; (610 <main+0x90>)
     5d8:	2100      	movs	r1, #0
     5da:	2000      	movs	r0, #0
     5dc:	f001 fdb6 	bl	214c <am_hal_iom_spi_read>

    if ( g_psRxBuffer.words[0] == AM_BOOTLOADER_IMAGE_COMPLETE )
     5e0:	4b0b      	ldr	r3, [pc, #44]	; (610 <main+0x90>)
     5e2:	681b      	ldr	r3, [r3, #0]
     5e4:	2b03      	cmp	r3, #3
     5e6:	d10b      	bne.n	600 <main+0x80>
    {
        //
        // If the CRC is correct, send a RESET command.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_RESET;
     5e8:	4b0a      	ldr	r3, [pc, #40]	; (614 <main+0x94>)
     5ea:	2204      	movs	r2, #4
     5ec:	601a      	str	r2, [r3, #0]
        am_hal_iom_spi_write(0, 0, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     5ee:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     5f2:	9300      	str	r3, [sp, #0]
     5f4:	2304      	movs	r3, #4
     5f6:	4a07      	ldr	r2, [pc, #28]	; (614 <main+0x94>)
     5f8:	2100      	movs	r1, #0
     5fa:	2000      	movs	r0, #0
     5fc:	f001 fb48 	bl	1c90 <am_hal_iom_spi_write>
    //
    // Loop forever.
    //
    while (1)
    {
    }
     600:	e7fe      	b.n	600 <main+0x80>
     602:	bf00      	nop
     604:	000045b8 	.word	0x000045b8
     608:	0000457c 	.word	0x0000457c
     60c:	40010080 	.word	0x40010080
     610:	1000125c 	.word	0x1000125c
     614:	1000106c 	.word	0x1000106c

00000618 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
     618:	4811      	ldr	r0, [pc, #68]	; (660 <zero_loop+0x12>)
     61a:	4912      	ldr	r1, [pc, #72]	; (664 <zero_loop+0x16>)
     61c:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
     61e:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
     622:	4811      	ldr	r0, [pc, #68]	; (668 <zero_loop+0x1a>)
     624:	6801      	ldr	r1, [r0, #0]
     626:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     62a:	6001      	str	r1, [r0, #0]
     62c:	f3bf 8f4f 	dsb	sy
     630:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
     634:	480d      	ldr	r0, [pc, #52]	; (66c <zero_loop+0x1e>)
     636:	490e      	ldr	r1, [pc, #56]	; (670 <zero_loop+0x22>)
     638:	4a0e      	ldr	r2, [pc, #56]	; (674 <zero_loop+0x26>)

0000063a <copy_loop>:
     63a:	f850 3b04 	ldr.w	r3, [r0], #4
     63e:	f841 3b04 	str.w	r3, [r1], #4
     642:	4291      	cmp	r1, r2
     644:	dbf9      	blt.n	63a <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
     646:	480c      	ldr	r0, [pc, #48]	; (678 <zero_loop+0x2a>)
     648:	490c      	ldr	r1, [pc, #48]	; (67c <zero_loop+0x2e>)
     64a:	f04f 0200 	mov.w	r2, #0

0000064e <zero_loop>:
     64e:	4288      	cmp	r0, r1
     650:	bfb8      	it	lt
     652:	f840 2b04 	strlt.w	r2, [r0], #4
     656:	dbfa      	blt.n	64e <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
     658:	f7ff ff92 	bl	580 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
     65c:	be00      	bkpt	0x0000
}
     65e:	bf00      	nop
     660:	e000ed08 	.word	0xe000ed08
     664:	00000000 	.word	0x00000000
     668:	e000ed88 	.word	0xe000ed88
     66c:	000047a4 	.word	0x000047a4
     670:	10001000 	.word	0x10001000
     674:	10001054 	.word	0x10001054
     678:	10001054 	.word	0x10001054
     67c:	100014f4 	.word	0x100014f4

00000680 <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
     680:	b480      	push	{r7}
     682:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     684:	e7fe      	b.n	684 <am_nmi_isr+0x4>
     686:	bf00      	nop

00000688 <am_busfault_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_fault_isr(void)
{
     688:	b480      	push	{r7}
     68a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     68c:	e7fe      	b.n	68c <am_busfault_isr+0x4>
     68e:	bf00      	nop

00000690 <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
     690:	b480      	push	{r7}
     692:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    {
    }
     694:	e7fe      	b.n	694 <am_adc_isr+0x4>
     696:	bf00      	nop

00000698 <am_util_delay_us>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_us(uint32_t ui32MicroSeconds)
{
     698:	b580      	push	{r7, lr}
     69a:	b084      	sub	sp, #16
     69c:	af00      	add	r7, sp, #0
     69e:	6078      	str	r0, [r7, #4]
    uint32_t ui32Loops = ui32MicroSeconds *
                          (am_hal_clkgen_sysclk_get() / 3000000);
     6a0:	f000 f936 	bl	910 <am_hal_clkgen_sysclk_get>
     6a4:	4602      	mov	r2, r0
     6a6:	4b07      	ldr	r3, [pc, #28]	; (6c4 <am_util_delay_us+0x2c>)
     6a8:	fba3 2302 	umull	r2, r3, r3, r2
     6ac:	0c9b      	lsrs	r3, r3, #18
//
//*****************************************************************************
void
am_util_delay_us(uint32_t ui32MicroSeconds)
{
    uint32_t ui32Loops = ui32MicroSeconds *
     6ae:	687a      	ldr	r2, [r7, #4]
     6b0:	fb02 f303 	mul.w	r3, r2, r3
     6b4:	60fb      	str	r3, [r7, #12]
                          (am_hal_clkgen_sysclk_get() / 3000000);

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
     6b6:	68f8      	ldr	r0, [r7, #12]
     6b8:	f000 f946 	bl	948 <am_hal_flash_delay>
}
     6bc:	bf00      	nop
     6be:	3710      	adds	r7, #16
     6c0:	46bd      	mov	sp, r7
     6c2:	bd80      	pop	{r7, pc}
     6c4:	165e9f81 	.word	0x165e9f81

000006c8 <am_bsp_iom_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_iom_enable(uint32_t ui32Module)
{
     6c8:	b5f0      	push	{r4, r5, r6, r7, lr}
     6ca:	b083      	sub	sp, #12
     6cc:	4604      	mov	r4, r0
    am_hal_iom_enable(ui32Module);
     6ce:	f000 fa89 	bl	be4 <am_hal_iom_enable>

    //
    // Check that the MISO pin is defined in BSP and we are in SPI mode.
    //
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
     6d2:	492a      	ldr	r1, [pc, #168]	; (77c <am_bsp_iom_enable+0xb4>)
     6d4:	4a2a      	ldr	r2, [pc, #168]	; (780 <am_bsp_iom_enable+0xb8>)
     6d6:	f851 3034 	ldr.w	r3, [r1, r4, lsl #3]
     6da:	4293      	cmp	r3, r2
     6dc:	d04c      	beq.n	778 <am_bsp_iom_enable+0xb0>
         (1 == AM_BFRn(IOMSTR, ui32Module, CFG, IFCSEL) ) )
     6de:	f504 20a0 	add.w	r0, r4, #327680	; 0x50000
     6e2:	3004      	adds	r0, #4
     6e4:	0305      	lsls	r5, r0, #12
     6e6:	f8d5 611c 	ldr.w	r6, [r5, #284]	; 0x11c
    am_hal_iom_enable(ui32Module);

    //
    // Check that the MISO pin is defined in BSP and we are in SPI mode.
    //
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
     6ea:	07f2      	lsls	r2, r6, #31
     6ec:	d544      	bpl.n	778 <am_bsp_iom_enable+0xb0>
         (1 == AM_BFRn(IOMSTR, ui32Module, CFG, IFCSEL) ) )
    {
        am_hal_gpio_pin_config(g_SPIpins[ui32Module][0],
     6ee:	2b31      	cmp	r3, #49	; 0x31
     6f0:	d842      	bhi.n	778 <am_bsp_iom_enable+0xb0>
     6f2:	f3ef 8710 	mrs	r7, PRIMASK
     6f6:	9701      	str	r7, [sp, #4]
     6f8:	b672      	cpsid	i
     6fa:	eb01 0ec4 	add.w	lr, r1, r4, lsl #3
     6fe:	4821      	ldr	r0, [pc, #132]	; (784 <am_bsp_iom_enable+0xbc>)
     700:	f8de 2004 	ldr.w	r2, [lr, #4]
     704:	f8df c084 	ldr.w	ip, [pc, #132]	; 78c <am_bsp_iom_enable+0xc4>
     708:	4d1f      	ldr	r5, [pc, #124]	; (788 <am_bsp_iom_enable+0xc0>)
     70a:	085c      	lsrs	r4, r3, #1
     70c:	f004 077c 	and.w	r7, r4, #124	; 0x7c
     710:	009e      	lsls	r6, r3, #2
     712:	2173      	movs	r1, #115	; 0x73
     714:	6001      	str	r1, [r0, #0]
     716:	f006 041c 	and.w	r4, r6, #28
     71a:	f3c2 2102 	ubfx	r1, r2, #8, #3
     71e:	2607      	movs	r6, #7
     720:	fa01 fe04 	lsl.w	lr, r1, r4
     724:	40a6      	lsls	r6, r4
     726:	f857 400c 	ldr.w	r4, [r7, ip]
     72a:	ea24 0106 	bic.w	r1, r4, r6
     72e:	f003 06fc 	and.w	r6, r3, #252	; 0xfc
     732:	ea4e 0401 	orr.w	r4, lr, r1
     736:	f106 4e80 	add.w	lr, r6, #1073741824	; 0x40000000
     73a:	f847 400c 	str.w	r4, [r7, ip]
     73e:	f50e 3e80 	add.w	lr, lr, #65536	; 0x10000
     742:	00db      	lsls	r3, r3, #3
     744:	f003 0318 	and.w	r3, r3, #24
     748:	21ff      	movs	r1, #255	; 0xff
     74a:	f8de 7000 	ldr.w	r7, [lr]
     74e:	4099      	lsls	r1, r3
     750:	43c9      	mvns	r1, r1
     752:	b2d4      	uxtb	r4, r2
     754:	400f      	ands	r7, r1
     756:	409c      	lsls	r4, r3
     758:	433c      	orrs	r4, r7
     75a:	f8ce 4000 	str.w	r4, [lr]
     75e:	5977      	ldr	r7, [r6, r5]
     760:	f3c2 4c07 	ubfx	ip, r2, #16, #8
     764:	fa0c f303 	lsl.w	r3, ip, r3
     768:	4039      	ands	r1, r7
     76a:	430b      	orrs	r3, r1
     76c:	2200      	movs	r2, #0
     76e:	5173      	str	r3, [r6, r5]
     770:	6002      	str	r2, [r0, #0]
     772:	9801      	ldr	r0, [sp, #4]
     774:	f380 8810 	msr	PRIMASK, r0
                               g_SPIpins[ui32Module][1]);
    }
}
     778:	b003      	add	sp, #12
     77a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     77c:	00004588 	.word	0x00004588
     780:	deadbeef 	.word	0xdeadbeef
     784:	40010060 	.word	0x40010060
     788:	400100e0 	.word	0x400100e0
     78c:	40010040 	.word	0x40010040

00000790 <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
     790:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_pwrctrl_bucks_init();
     792:	f001 feb1 	bl	24f8 <am_hal_pwrctrl_bucks_init>

    //
    // Initialize for low power in the power control block
    //
    am_hal_pwrctrl_low_power_init();
     796:	f001 ff1d 	bl	25d4 <am_hal_pwrctrl_low_power_init>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
     79a:	f002 f869 	bl	2870 <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
     79e:	2001      	movs	r0, #1
     7a0:	f001 ffb6 	bl	2710 <am_hal_rtc_osc_select>

    //
    // Stop the XT and LFRC.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
     7a4:	2001      	movs	r0, #1
     7a6:	f000 f8c3 	bl	930 <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
}
     7aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_LFRC);

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
     7ae:	f001 bfbd 	b.w	272c <am_hal_rtc_osc_disable>
     7b2:	bf00      	nop

000007b4 <am_hal_cachectrl_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_cachectrl_enable(const am_hal_cachectrl_config_t *psConfig)
{
     7b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     7b6:	4604      	mov	r4, r0
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
     7b8:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
                       AM_REG_CACHECTRL_CACHECFG_LRU( psConfig->ui32LRU )                                   |
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC0( (psConfig->ui32EnableNCregions & 0x1) >> 0 )   |
     7bc:	78a7      	ldrb	r7, [r4, #2]
    // workaround for a timing issue with early versions of Apollo2 that caused
    // the cache to incorrectly mark itself valid during the startup sequence.
    // The workaround calls for us to start the cache, manually invalidate it,
    // and then enable ICACHE and DCACHE operation.
    //
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
     7be:	7863      	ldrb	r3, [r4, #1]
     7c0:	78e2      	ldrb	r2, [r4, #3]
     7c2:	7925      	ldrb	r5, [r4, #4]
     7c4:	79a1      	ldrb	r1, [r4, #6]
     7c6:	00be      	lsls	r6, r7, #2
     7c8:	ea4f 0e43 	mov.w	lr, r3, lsl #1
     7cc:	f006 0304 	and.w	r3, r6, #4
     7d0:	f00e 0602 	and.w	r6, lr, #2
     7d4:	431e      	orrs	r6, r3
     7d6:	f042 0201 	orr.w	r2, r2, #1
     7da:	79e3      	ldrb	r3, [r4, #7]
     7dc:	01ed      	lsls	r5, r5, #7
     7de:	4316      	orrs	r6, r2
     7e0:	b2ed      	uxtb	r5, r5
     7e2:	7a22      	ldrb	r2, [r4, #8]
     7e4:	0289      	lsls	r1, r1, #10
     7e6:	432e      	orrs	r6, r5
     7e8:	f401 6180 	and.w	r1, r1, #1024	; 0x400
     7ec:	7a65      	ldrb	r5, [r4, #9]
     7ee:	02db      	lsls	r3, r3, #11
     7f0:	430e      	orrs	r6, r1
     7f2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
     7f6:	0312      	lsls	r2, r2, #12
     7f8:	7aa1      	ldrb	r1, [r4, #10]
     7fa:	431e      	orrs	r6, r3
     7fc:	042d      	lsls	r5, r5, #16
     7fe:	b293      	uxth	r3, r2
     800:	7ae2      	ldrb	r2, [r4, #11]
     802:	431e      	orrs	r6, r3
     804:	0509      	lsls	r1, r1, #20
     806:	f405 2370 	and.w	r3, r5, #983040	; 0xf0000
     80a:	0612      	lsls	r2, r2, #24
     80c:	4333      	orrs	r3, r6
     80e:	f401 1680 	and.w	r6, r1, #1048576	; 0x100000
     812:	00bf      	lsls	r7, r7, #2
     814:	f002 7180 	and.w	r1, r2, #16777216	; 0x1000000
     818:	4333      	orrs	r3, r6
     81a:	430b      	orrs	r3, r1
     81c:	f007 0508 	and.w	r5, r7, #8
     820:	431d      	orrs	r5, r3
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
     822:	f001 fd61 	bl	22e8 <am_hal_pwrctrl_memory_enable>

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     826:	482c      	ldr	r0, [pc, #176]	; (8d8 <am_hal_cachectrl_enable+0x124>)
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
     828:	4b2c      	ldr	r3, [pc, #176]	; (8dc <am_hal_cachectrl_enable+0x128>)
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     82a:	6005      	str	r5, [r0, #0]
     82c:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
     82e:	681e      	ldr	r6, [r3, #0]
     830:	0777      	lsls	r7, r6, #29
     832:	d41e      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     834:	681f      	ldr	r7, [r3, #0]
     836:	077e      	lsls	r6, r7, #29
     838:	f102 32ff 	add.w	r2, r2, #4294967295
     83c:	d419      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     83e:	6819      	ldr	r1, [r3, #0]
     840:	074f      	lsls	r7, r1, #29
     842:	d416      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     844:	6818      	ldr	r0, [r3, #0]
     846:	0746      	lsls	r6, r0, #29
     848:	d413      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     84a:	681e      	ldr	r6, [r3, #0]
     84c:	0770      	lsls	r0, r6, #29
     84e:	d410      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     850:	681f      	ldr	r7, [r3, #0]
     852:	0779      	lsls	r1, r7, #29
     854:	d40d      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     856:	6819      	ldr	r1, [r3, #0]
     858:	074f      	lsls	r7, r1, #29
     85a:	d40a      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     85c:	6818      	ldr	r0, [r3, #0]
     85e:	0746      	lsls	r6, r0, #29
     860:	d407      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     862:	681e      	ldr	r6, [r3, #0]
     864:	0770      	lsls	r0, r6, #29
     866:	d404      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
     868:	681f      	ldr	r7, [r3, #0]
     86a:	0779      	lsls	r1, r7, #29
     86c:	d401      	bmi.n	872 <am_hal_cachectrl_enable+0xbe>
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;

    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
     86e:	3a09      	subs	r2, #9
     870:	d1dd      	bne.n	82e <am_hal_cachectrl_enable+0x7a>
    }

    //
    // Manually invalidate the cache (workaround for the issue described above.)
    //
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);
     872:	4b1a      	ldr	r3, [pc, #104]	; (8dc <am_hal_cachectrl_enable+0x128>)
     874:	681a      	ldr	r2, [r3, #0]
     876:	f042 0101 	orr.w	r1, r2, #1
     87a:	6019      	str	r1, [r3, #0]
     87c:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
     87e:	6818      	ldr	r0, [r3, #0]
     880:	0740      	lsls	r0, r0, #29
     882:	d41e      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     884:	681e      	ldr	r6, [r3, #0]
     886:	0771      	lsls	r1, r6, #29
     888:	f102 32ff 	add.w	r2, r2, #4294967295
     88c:	d419      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     88e:	681f      	ldr	r7, [r3, #0]
     890:	077f      	lsls	r7, r7, #29
     892:	d416      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     894:	6819      	ldr	r1, [r3, #0]
     896:	074e      	lsls	r6, r1, #29
     898:	d413      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     89a:	6818      	ldr	r0, [r3, #0]
     89c:	0740      	lsls	r0, r0, #29
     89e:	d410      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     8a0:	681e      	ldr	r6, [r3, #0]
     8a2:	0771      	lsls	r1, r6, #29
     8a4:	d40d      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     8a6:	681f      	ldr	r7, [r3, #0]
     8a8:	077f      	lsls	r7, r7, #29
     8aa:	d40a      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     8ac:	6819      	ldr	r1, [r3, #0]
     8ae:	074e      	lsls	r6, r1, #29
     8b0:	d407      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     8b2:	6818      	ldr	r0, [r3, #0]
     8b4:	0740      	lsls	r0, r0, #29
     8b6:	d404      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
     8b8:	681e      	ldr	r6, [r3, #0]
     8ba:	0771      	lsls	r1, r6, #29
     8bc:	d401      	bmi.n	8c2 <am_hal_cachectrl_enable+0x10e>
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);

    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
     8be:	3a09      	subs	r2, #9
     8c0:	d1dd      	bne.n	87e <am_hal_cachectrl_enable+0xca>

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
     8c2:	7964      	ldrb	r4, [r4, #5]
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     8c4:	4f04      	ldr	r7, [pc, #16]	; (8d8 <am_hal_cachectrl_enable+0x124>)

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
     8c6:	0223      	lsls	r3, r4, #8
     8c8:	f403 7100 	and.w	r1, r3, #512	; 0x200
     8cc:	f403 7280 	and.w	r2, r3, #256	; 0x100
     8d0:	4311      	orrs	r1, r2
     8d2:	4329      	orrs	r1, r5
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
     8d4:	6039      	str	r1, [r7, #0]
     8d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     8d8:	40018000 	.word	0x40018000
     8dc:	40018008 	.word	0x40018008

000008e0 <am_hal_clkgen_sysclk_select>:
//! @return None.
//
//*****************************************************************************
void
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
     8e0:	b510      	push	{r4, lr}
    am_hal_debug_assert_msg(ui32ClockSetting == AM_HAL_CLKGEN_SYSCLK_48MHZ,
     8e2:	4604      	mov	r4, r0
     8e4:	b120      	cbz	r0, 8f0 <am_hal_clkgen_sysclk_select+0x10>
     8e6:	4a06      	ldr	r2, [pc, #24]	; (900 <am_hal_clkgen_sysclk_select+0x20>)
     8e8:	4806      	ldr	r0, [pc, #24]	; (904 <am_hal_clkgen_sysclk_select+0x24>)
     8ea:	2150      	movs	r1, #80	; 0x50
     8ec:	f000 f82a 	bl	944 <am_hal_debug_error>
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     8f0:	4b05      	ldr	r3, [pc, #20]	; (908 <am_hal_clkgen_sysclk_select+0x28>)

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
     8f2:	4906      	ldr	r1, [pc, #24]	; (90c <am_hal_clkgen_sysclk_select+0x2c>)
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     8f4:	2047      	movs	r0, #71	; 0x47
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
     8f6:	2200      	movs	r2, #0
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     8f8:	6018      	str	r0, [r3, #0]

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
     8fa:	600c      	str	r4, [r1, #0]

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
     8fc:	601a      	str	r2, [r3, #0]
     8fe:	bd10      	pop	{r4, pc}
     900:	000045c4 	.word	0x000045c4
     904:	000045fc 	.word	0x000045fc
     908:	40004014 	.word	0x40004014
     90c:	40004018 	.word	0x40004018

00000910 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
     910:	4b04      	ldr	r3, [pc, #16]	; (924 <am_hal_clkgen_sysclk_get+0x14>)

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
     912:	4905      	ldr	r1, [pc, #20]	; (928 <am_hal_clkgen_sysclk_get+0x18>)
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
     914:	681a      	ldr	r2, [r3, #0]

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
     916:	4805      	ldr	r0, [pc, #20]	; (92c <am_hal_clkgen_sysclk_get+0x1c>)
    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;

    switch ( ui32ClockSetting )
     918:	f012 0f01 	tst.w	r2, #1
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC_DIV2:
            return 24000000;
        default:
            return 0xFFFFFFFF;
    }
}
     91c:	bf08      	it	eq
     91e:	4608      	moveq	r0, r1
     920:	4770      	bx	lr
     922:	bf00      	nop
     924:	40004018 	.word	0x40004018
     928:	02dc6c00 	.word	0x02dc6c00
     92c:	016e3600 	.word	0x016e3600

00000930 <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
     930:	0783      	lsls	r3, r0, #30
     932:	d003      	beq.n	93c <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
     934:	4a02      	ldr	r2, [pc, #8]	; (940 <am_hal_clkgen_osc_stop+0x10>)
     936:	6813      	ldr	r3, [r2, #0]
     938:	4318      	orrs	r0, r3
     93a:	6010      	str	r0, [r2, #0]
     93c:	4770      	bx	lr
     93e:	bf00      	nop
     940:	4000400c 	.word	0x4000400c

00000944 <am_hal_debug_error>:
__weak void
#else
void __attribute__((weak))
#endif
am_hal_debug_error(const char *pcFile, uint32_t ui32Line, const char *pcMessage)
{
     944:	e7fe      	b.n	944 <am_hal_debug_error>
     946:	bf00      	nop

00000948 <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     948:	4b01      	ldr	r3, [pc, #4]	; (950 <am_hal_flash_delay+0x8>)
     94a:	6b59      	ldr	r1, [r3, #52]	; 0x34
     94c:	4708      	bx	r1
     94e:	bf00      	nop
     950:	10001000 	.word	0x10001000

00000954 <am_hal_flash_delay_status_change>:
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
     954:	2800      	cmp	r0, #0
     956:	f000 80bb 	beq.w	ad0 <am_hal_flash_delay_status_change+0x17c>
//
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
     95a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     95e:	f100 3aff 	add.w	sl, r0, #4294967295
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     962:	6808      	ldr	r0, [r1, #0]
     964:	4010      	ands	r0, r2
     966:	4283      	cmp	r3, r0
     968:	f000 80ac 	beq.w	ac4 <am_hal_flash_delay_status_change+0x170>
     96c:	f01a 0907 	ands.w	r9, sl, #7
     970:	461c      	mov	r4, r3
     972:	4615      	mov	r5, r2
     974:	460e      	mov	r6, r1
     976:	f04f 0700 	mov.w	r7, #0
     97a:	f8df 8158 	ldr.w	r8, [pc, #344]	; ad4 <am_hal_flash_delay_status_change+0x180>
     97e:	d056      	beq.n	a2e <am_hal_flash_delay_status_change+0xda>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     980:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     984:	200c      	movs	r0, #12
     986:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     988:	6831      	ldr	r1, [r6, #0]
     98a:	4029      	ands	r1, r5
     98c:	42a1      	cmp	r1, r4
     98e:	f04f 0701 	mov.w	r7, #1
     992:	f000 8097 	beq.w	ac4 <am_hal_flash_delay_status_change+0x170>
     996:	45b9      	cmp	r9, r7
     998:	d049      	beq.n	a2e <am_hal_flash_delay_status_change+0xda>
     99a:	f1b9 0f02 	cmp.w	r9, #2
     99e:	d03c      	beq.n	a1a <am_hal_flash_delay_status_change+0xc6>
     9a0:	f1b9 0f03 	cmp.w	r9, #3
     9a4:	d02f      	beq.n	a06 <am_hal_flash_delay_status_change+0xb2>
     9a6:	f1b9 0f04 	cmp.w	r9, #4
     9aa:	d022      	beq.n	9f2 <am_hal_flash_delay_status_change+0x9e>
     9ac:	f1b9 0f05 	cmp.w	r9, #5
     9b0:	d015      	beq.n	9de <am_hal_flash_delay_status_change+0x8a>
     9b2:	f1b9 0f06 	cmp.w	r9, #6
     9b6:	d008      	beq.n	9ca <am_hal_flash_delay_status_change+0x76>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9b8:	200c      	movs	r0, #12
     9ba:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     9be:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9c0:	6830      	ldr	r0, [r6, #0]
     9c2:	4028      	ands	r0, r5
     9c4:	42a0      	cmp	r0, r4
     9c6:	443f      	add	r7, r7
     9c8:	d07c      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9ca:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     9ce:	200c      	movs	r0, #12
     9d0:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9d2:	6831      	ldr	r1, [r6, #0]
     9d4:	4029      	ands	r1, r5
     9d6:	42a1      	cmp	r1, r4
     9d8:	f107 0701 	add.w	r7, r7, #1
     9dc:	d072      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9de:	200c      	movs	r0, #12
     9e0:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     9e4:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9e6:	6830      	ldr	r0, [r6, #0]
     9e8:	4028      	ands	r0, r5
     9ea:	42a0      	cmp	r0, r4
     9ec:	f107 0701 	add.w	r7, r7, #1
     9f0:	d068      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     9f2:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     9f6:	200c      	movs	r0, #12
     9f8:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     9fa:	6831      	ldr	r1, [r6, #0]
     9fc:	4029      	ands	r1, r5
     9fe:	42a1      	cmp	r1, r4
     a00:	f107 0701 	add.w	r7, r7, #1
     a04:	d05e      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a06:	200c      	movs	r0, #12
     a08:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     a0c:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a0e:	6830      	ldr	r0, [r6, #0]
     a10:	4028      	ands	r0, r5
     a12:	42a0      	cmp	r0, r4
     a14:	f107 0701 	add.w	r7, r7, #1
     a18:	d054      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a1a:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     a1e:	200c      	movs	r0, #12
     a20:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a22:	6831      	ldr	r1, [r6, #0]
     a24:	4029      	ands	r1, r5
     a26:	42a1      	cmp	r1, r4
     a28:	f107 0701 	add.w	r7, r7, #1
     a2c:	d04a      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a2e:	200c      	movs	r0, #12
     a30:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     a34:	4790      	blx	r2
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
     a36:	4557      	cmp	r7, sl
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a38:	f04f 000c 	mov.w	r0, #12
     a3c:	f107 0708 	add.w	r7, r7, #8
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
     a40:	d043      	beq.n	aca <am_hal_flash_delay_status_change+0x176>
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a42:	6833      	ldr	r3, [r6, #0]
     a44:	402b      	ands	r3, r5
     a46:	42a3      	cmp	r3, r4
     a48:	d03c      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a4a:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
     a4e:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a50:	6832      	ldr	r2, [r6, #0]
     a52:	402a      	ands	r2, r5
     a54:	42a2      	cmp	r2, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a56:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a5a:	d033      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a5c:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     a60:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a62:	6831      	ldr	r1, [r6, #0]
     a64:	4029      	ands	r1, r5
     a66:	42a1      	cmp	r1, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a68:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a6c:	d02a      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a6e:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     a72:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a74:	6833      	ldr	r3, [r6, #0]
     a76:	402b      	ands	r3, r5
     a78:	42a3      	cmp	r3, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a7a:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a7e:	d021      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a80:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
     a84:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a86:	6832      	ldr	r2, [r6, #0]
     a88:	402a      	ands	r2, r5
     a8a:	42a2      	cmp	r2, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a8c:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a90:	d018      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a92:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
     a96:	4798      	blx	r3
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     a98:	6831      	ldr	r1, [r6, #0]
     a9a:	4029      	ands	r1, r5
     a9c:	42a1      	cmp	r1, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     a9e:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     aa2:	d00f      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     aa4:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
     aa8:	4790      	blx	r2
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     aaa:	6833      	ldr	r3, [r6, #0]
     aac:	402b      	ands	r3, r5
     aae:	42a3      	cmp	r3, r4
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     ab0:	f04f 000c 	mov.w	r0, #12
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     ab4:	d006      	beq.n	ac4 <am_hal_flash_delay_status_change+0x170>
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
     ab6:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
     aba:	4788      	blx	r1
    while ( ui32usMaxDelay-- )
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     abc:	6830      	ldr	r0, [r6, #0]
     abe:	4028      	ands	r0, r5
     ac0:	42a0      	cmp	r0, r4
     ac2:	d1b4      	bne.n	a2e <am_hal_flash_delay_status_change+0xda>
        {
            return 1;
     ac4:	2001      	movs	r0, #1
     ac6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        // Call the BOOTROM cycle function to delay for about 1 microsecond.
        //
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
    }

    return 0;
     aca:	2000      	movs	r0, #0
     acc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     ad0:	2000      	movs	r0, #0
} // am_hal_flash_delay_status_change()
     ad2:	4770      	bx	lr
     ad4:	10001000 	.word	0x10001000

00000ad8 <am_hal_gpio_int_clear>:
//! @return None
//
//*****************************************************************************
void
am_hal_gpio_int_clear(uint64_t ui64InterruptMask)
{
     ad8:	b082      	sub	sp, #8
    //
    // Clear the interrupts.
    //
    AM_CRITICAL_BEGIN_ASM
     ada:	f3ef 8310 	mrs	r3, PRIMASK
     ade:	9301      	str	r3, [sp, #4]
     ae0:	b672      	cpsid	i
    AM_REG(GPIO, INT1CLR) = (ui64InterruptMask >> 32);
     ae2:	4a04      	ldr	r2, [pc, #16]	; (af4 <am_hal_gpio_int_clear+0x1c>)
    AM_REG(GPIO, INT0CLR) = (ui64InterruptMask & 0xFFFFFFFF);
     ae4:	4b04      	ldr	r3, [pc, #16]	; (af8 <am_hal_gpio_int_clear+0x20>)
{
    //
    // Clear the interrupts.
    //
    AM_CRITICAL_BEGIN_ASM
    AM_REG(GPIO, INT1CLR) = (ui64InterruptMask >> 32);
     ae6:	6011      	str	r1, [r2, #0]
    AM_REG(GPIO, INT0CLR) = (ui64InterruptMask & 0xFFFFFFFF);
     ae8:	6018      	str	r0, [r3, #0]
    AM_CRITICAL_END_ASM
     aea:	9801      	ldr	r0, [sp, #4]
     aec:	f380 8810 	msr	PRIMASK, r0
}
     af0:	b002      	add	sp, #8
     af2:	4770      	bx	lr
     af4:	40010218 	.word	0x40010218
     af8:	40010208 	.word	0x40010208

00000afc <am_hal_gpio_int_status_get>:
//! @return None
//
//*****************************************************************************
uint64_t
am_hal_gpio_int_status_get(bool bEnabledOnly)
{
     afc:	b4f0      	push	{r4, r5, r6, r7}
    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
     afe:	f3ef 8310 	mrs	r3, PRIMASK
//! @return None
//
//*****************************************************************************
uint64_t
am_hal_gpio_int_status_get(bool bEnabledOnly)
{
     b02:	b082      	sub	sp, #8
    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
     b04:	9301      	str	r3, [sp, #4]
     b06:	b672      	cpsid	i
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     b08:	4a0e      	ldr	r2, [pc, #56]	; (b44 <am_hal_gpio_int_status_get+0x48>)
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     b0a:	490f      	ldr	r1, [pc, #60]	; (b48 <am_hal_gpio_int_status_get+0x4c>)
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     b0c:	6814      	ldr	r4, [r2, #0]
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     b0e:	680d      	ldr	r5, [r1, #0]
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    AM_CRITICAL_BEGIN_ASM
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     b10:	f04f 0c00 	mov.w	ip, #0
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     b14:	ea4c 0605 	orr.w	r6, ip, r5
     b18:	4627      	mov	r7, r4

    if ( bEnabledOnly )
     b1a:	b170      	cbz	r0, b3a <am_hal_gpio_int_status_get+0x3e>
    {
        ui64Mask    = ((uint64_t) AM_REGn(GPIO, 0, INT1EN)) << 32;
     b1c:	480b      	ldr	r0, [pc, #44]	; (b4c <am_hal_gpio_int_status_get+0x50>)
        ui64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0EN)) << 0;
     b1e:	4b0c      	ldr	r3, [pc, #48]	; (b50 <am_hal_gpio_int_status_get+0x54>)
    ui64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
    ui64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;

    if ( bEnabledOnly )
    {
        ui64Mask    = ((uint64_t) AM_REGn(GPIO, 0, INT1EN)) << 32;
     b20:	6802      	ldr	r2, [r0, #0]
        ui64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0EN)) << 0;
     b22:	6819      	ldr	r1, [r3, #0]
     b24:	ea4c 0001 	orr.w	r0, ip, r1
     b28:	4611      	mov	r1, r2
    }

    ui64RetVal &= ui64Mask;
    AM_CRITICAL_END_ASM
     b2a:	9b01      	ldr	r3, [sp, #4]
     b2c:	f383 8810 	msr	PRIMASK, r3

    return ui64RetVal;
}
     b30:	4030      	ands	r0, r6
     b32:	4039      	ands	r1, r7
     b34:	b002      	add	sp, #8
     b36:	bcf0      	pop	{r4, r5, r6, r7}
     b38:	4770      	bx	lr
    uint64_t ui64RetVal, ui64Mask;

    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;
     b3a:	f04f 30ff 	mov.w	r0, #4294967295
     b3e:	f04f 31ff 	mov.w	r1, #4294967295
     b42:	e7f2      	b.n	b2a <am_hal_gpio_int_status_get+0x2e>
     b44:	40010214 	.word	0x40010214
     b48:	40010204 	.word	0x40010204
     b4c:	40010210 	.word	0x40010210
     b50:	40010200 	.word	0x40010200

00000b54 <iom_workaround_loop>:
                    bool bRising)
{
    //
    // Check to see if this is a "rising edge" or "falling edge" detector.
    //
    __asm("    cbz      r2, falling_edge");
     b54:	b132      	cbz	r2, b64 <falling_edge>

00000b56 <rising_edge>:

    //
    // Read GPIO pin 44, and loop until it's HIGH.
    //
    __asm("rising_edge:");
    __asm("    ldr      r2, =0x40010084");
     b56:	4a07      	ldr	r2, [pc, #28]	; (b74 <falling_check_mosi+0xe>)

00000b58 <rising_check_mosi>:
    __asm("rising_check_mosi:");
    __asm("    ldr      r3, [r2]");
     b58:	6813      	ldr	r3, [r2, #0]
    __asm("    ands     r3, r3, #0x1000");
     b5a:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
    __asm("    beq      rising_check_mosi");
     b5e:	d0fb      	beq.n	b58 <rising_check_mosi>

    //
    // Write the PADREG Value to the PADREG register.
    //
    __asm("    str     r0, [r1]");
     b60:	6008      	str	r0, [r1, #0]
    __asm("    bx      lr");
     b62:	4770      	bx	lr

00000b64 <falling_edge>:

    //
    // Read GPIO pin 44, and loop until it's LOW.
    //
    __asm("falling_edge:");
    __asm("    ldr      r2, =0x40010084");
     b64:	4a03      	ldr	r2, [pc, #12]	; (b74 <falling_check_mosi+0xe>)

00000b66 <falling_check_mosi>:
    __asm("falling_check_mosi:");
    __asm("    ldr      r3, [r2]");
     b66:	6813      	ldr	r3, [r2, #0]
    __asm("    ands     r3, r3, #0x1000");
     b68:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
    __asm("    bne      falling_check_mosi");
     b6c:	d1fb      	bne.n	b66 <falling_check_mosi>

    //
    // Write the PADREG Value to the PADREG register.
    //
    __asm("    str     r0, [r1]");
     b6e:	6008      	str	r0, [r1, #0]
    __asm("    bx      lr");
     b70:	4770      	bx	lr
     b72:	0000      	.short	0x0000
     b74:	40010084 	.word	0x40010084

00000b78 <am_hal_iom_sleeping_queue_flush>:
    uint32_t ui32Critical;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     b78:	2805      	cmp	r0, #5
     b7a:	d819      	bhi.n	bb0 <am_hal_iom_sleeping_queue_flush+0x38>
//! implementations expect to control sleep behavior).
//
//*****************************************************************************
void
am_hal_iom_sleeping_queue_flush(uint32_t ui32Module)
{
     b7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     b7e:	4b0d      	ldr	r3, [pc, #52]	; (bb4 <am_hal_iom_sleeping_queue_flush+0x3c>)
     b80:	4e0d      	ldr	r6, [pc, #52]	; (bb8 <am_hal_iom_sleeping_queue_flush+0x40>)

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
            am_hal_queue_empty(&g_psIOMQueue[ui32Module]) )
     b82:	eb00 0740 	add.w	r7, r0, r0, lsl #1
     b86:	4604      	mov	r4, r0
     b88:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
    while ( bWaiting )
    {
        //
        // Start a critical section.
        //
        ui32Critical = am_hal_interrupt_master_disable();
     b8c:	f001 fee8 	bl	2960 <am_hal_interrupt_master_disable>

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
     b90:	5d31      	ldrb	r1, [r6, r4]
    while ( bWaiting )
    {
        //
        // Start a critical section.
        //
        ui32Critical = am_hal_interrupt_master_disable();
     b92:	4605      	mov	r5, r0

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
     b94:	b929      	cbnz	r1, ba2 <am_hal_iom_sleeping_queue_flush+0x2a>
     b96:	68ba      	ldr	r2, [r7, #8]
     b98:	b91a      	cbnz	r2, ba2 <am_hal_iom_sleeping_queue_flush+0x2a>
        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
    }
}
     b9a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        }

        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
     b9e:	f001 bee3 	b.w	2968 <am_hal_interrupt_master_set>
        else
        {
            //
            // Otherwise, we should sleep until the interface is actually free.
            //
            am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_NORMAL);
     ba2:	2000      	movs	r0, #0
     ba4:	f001 fdca 	bl	273c <am_hal_sysctrl_sleep>
        }

        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
     ba8:	4628      	mov	r0, r5
     baa:	f001 fedd 	bl	2968 <am_hal_interrupt_master_set>
     bae:	e7ed      	b.n	b8c <am_hal_iom_sleeping_queue_flush+0x14>
     bb0:	4770      	bx	lr
     bb2:	bf00      	nop
     bb4:	100013ec 	.word	0x100013ec
     bb8:	1000105c 	.word	0x1000105c

00000bbc <am_hal_iom_pwrctrl_enable>:
//
//*****************************************************************************
void
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
     bbc:	2805      	cmp	r0, #5
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
     bbe:	b510      	push	{r4, lr}
     bc0:	4604      	mov	r4, r0
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
     bc2:	d905      	bls.n	bd0 <am_hal_iom_pwrctrl_enable+0x14>
     bc4:	4a05      	ldr	r2, [pc, #20]	; (bdc <am_hal_iom_pwrctrl_enable+0x20>)
     bc6:	4806      	ldr	r0, [pc, #24]	; (be0 <am_hal_iom_pwrctrl_enable+0x24>)
     bc8:	f240 21d2 	movw	r1, #722	; 0x2d2
     bcc:	f7ff feba 	bl	944 <am_hal_debug_error>
                            "Trying to enable an IOM module that doesn't exist.");

    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOM0 << ui32Module);
     bd0:	2002      	movs	r0, #2
     bd2:	40a0      	lsls	r0, r4
}
     bd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
am_hal_iom_pwrctrl_enable(uint32_t ui32Module)
{
    am_hal_debug_assert_msg(ui32Module < AM_REG_IOMSTR_NUM_MODULES,
                            "Trying to enable an IOM module that doesn't exist.");

    am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_IOM0 << ui32Module);
     bd8:	f001 bb42 	b.w	2260 <am_hal_pwrctrl_periph_enable>
     bdc:	0000465c 	.word	0x0000465c
     be0:	00004648 	.word	0x00004648

00000be4 <am_hal_iom_enable>:
//
//*****************************************************************************
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
     be4:	2805      	cmp	r0, #5
     be6:	d80f      	bhi.n	c08 <am_hal_iom_enable+0x24>
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
     be8:	f500 23a0 	add.w	r3, r0, #327680	; 0x50000
     bec:	3304      	adds	r3, #4
     bee:	031b      	lsls	r3, r3, #12
        g_bIomBusy[ui32Module] = false;
     bf0:	4906      	ldr	r1, [pc, #24]	; (c0c <am_hal_iom_enable+0x28>)
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
     bf2:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_enable(uint32_t ui32Module)
{
     bf6:	b410      	push	{r4}
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
     bf8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
        g_bIomBusy[ui32Module] = false;
     bfc:	2400      	movs	r4, #0
void
am_hal_iom_enable(uint32_t ui32Module)
{
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    {
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
     bfe:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
        g_bIomBusy[ui32Module] = false;
     c02:	540c      	strb	r4, [r1, r0]
    }
}
     c04:	f85d 4b04 	ldr.w	r4, [sp], #4
     c08:	4770      	bx	lr
     c0a:	bf00      	nop
     c0c:	1000105c 	.word	0x1000105c

00000c10 <am_hal_iom_config>:
    // Start by checking the interface mode (I2C or SPI), and writing it to the
    // configuration word.
    //
    ui32Config = psConfig->ui32InterfaceMode;

    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     c10:	2805      	cmp	r0, #5
     c12:	f200 80ec 	bhi.w	dee <am_hal_iom_config+0x1de>
//! @return None.
//
//*****************************************************************************
void
am_hal_iom_config(uint32_t ui32Module, const am_hal_iom_config_t *psConfig)
{
     c16:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    //
    // Check the SPI format, and OR in the bits for SPHA (clock phase) and SPOL
    // (polarity). These shouldn't have any effect in I2C mode, so it should be
    // ok to write them without checking exactly which mode we're in.
    //
    if ( psConfig->bSPHA )
     c1a:	7a0d      	ldrb	r5, [r1, #8]

    //
    // Start by checking the interface mode (I2C or SPI), and writing it to the
    // configuration word.
    //
    ui32Config = psConfig->ui32InterfaceMode;
     c1c:	680b      	ldr	r3, [r1, #0]
    //
    // Check the SPI format, and OR in the bits for SPHA (clock phase) and SPOL
    // (polarity). These shouldn't have any effect in I2C mode, so it should be
    // ok to write them without checking exactly which mode we're in.
    //
    if ( psConfig->bSPHA )
     c1e:	b10d      	cbz	r5, c24 <am_hal_iom_config+0x14>
    {
        ui32Config |= AM_REG_IOMSTR_CFG_SPHA(1);
     c20:	f043 0304 	orr.w	r3, r3, #4
    }

    if ( psConfig->bSPOL )
     c24:	7a4a      	ldrb	r2, [r1, #9]
     c26:	b10a      	cbz	r2, c2c <am_hal_iom_config+0x1c>
    {
        ui32Config |= AM_REG_IOMSTR_CFG_SPOL(1);
     c28:	f043 0302 	orr.w	r3, r3, #2
    // For all I2C frequencies and SPI frequencies below 16 MHz, the STARTRD
    // field should be set to 0 to minimize the potential of the IO transfer
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
     c2c:	684c      	ldr	r4, [r1, #4]
     c2e:	4a8d      	ldr	r2, [pc, #564]	; (e64 <am_hal_iom_config+0x254>)

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
     c30:	f500 26a0 	add.w	r6, r0, #327680	; 0x50000
     c34:	3604      	adds	r6, #4
    // For all I2C frequencies and SPI frequencies below 16 MHz, the STARTRD
    // field should be set to 0 to minimize the potential of the IO transfer
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
     c36:	4294      	cmp	r4, r2

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
     c38:	ea4f 3406 	mov.w	r4, r6, lsl #12
    // holding off a bus access to the FIFO. For SPI frequencies of 16 MHz
    // or 24 MHz, the STARTRD field must be set to a value of 2 to insure
    // enough time for the IO preread.
    if ( psConfig->ui32ClockFrequency >= 16000000UL)
    {
        ui32Config |= AM_REG_IOMSTR_CFG_STARTRD(2);
     c3c:	bf88      	it	hi
     c3e:	f043 0320 	orrhi.w	r3, r3, #32

    //
    // Write the resulting configuration word to the IO master CFG register for
    // the module number we were provided.
    //
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
     c42:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
     c46:	7a8f      	ldrb	r7, [r1, #10]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
     c48:	2f03      	cmp	r7, #3
     c4a:	f240 80c8 	bls.w	dde <am_hal_iom_config+0x1ce>
    {
        corrected_threshold = MIN_RW_THRESHOLD;
    }

    if ( corrected_threshold > MAX_RW_THRESHOLD )
     c4e:	2f7c      	cmp	r7, #124	; 0x7c
     c50:	bf88      	it	hi
     c52:	f44f 42f8 	movhi.w	r2, #31744	; 0x7c00
     c56:	f240 8101 	bls.w	e5c <am_hal_iom_config+0x24c>
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(check_iom_threshold(psConfig->ui8ReadThreshold)));
     c5a:	7acb      	ldrb	r3, [r1, #11]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
     c5c:	2b03      	cmp	r3, #3
     c5e:	f240 80c4 	bls.w	dea <am_hal_iom_config+0x1da>
     c62:	2b7c      	cmp	r3, #124	; 0x7c
     c64:	bf28      	it	cs
     c66:	237c      	movcs	r3, #124	; 0x7c
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
     c68:	4313      	orrs	r3, r2

    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
     c6a:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108

    // Apply I2C clock stretching workaround if B2 silicon and IOM 1,2,3, or 5
    // Note: Only I2C clock speeds of AM_HAL_IOM_800KHZ, AM_HAL_IOM_400KHZ,
    // AM_HAL_IOM_200KHZ, and AM_HAL_IOM_100KHZ are allowed.  Other values will
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
     c6e:	f030 0304 	bics.w	r3, r0, #4
     c72:	d005      	beq.n	c80 <am_hal_iom_config+0x70>
isRevB2(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) ==
     c74:	4e7c      	ldr	r6, [pc, #496]	; (e68 <am_hal_iom_config+0x258>)
     c76:	6837      	ldr	r7, [r6, #0]
     c78:	b2fa      	uxtb	r2, r7
     c7a:	2a22      	cmp	r2, #34	; 0x22
     c7c:	f000 80bc 	beq.w	df8 <am_hal_iom_config+0x1e8>
      //  is being selected.
      // If SPHA=0 the low period must be 60%. If SPHA=1 high period must be 60%.
      // Note that the predetermined frequency parameters use the formula
      //  lowper = (totper-1)/2, which results in a 60% low period.
      //
      ui32ClkCfg = iom_get_interface_clock_cfg(psConfig->ui32ClockFrequency,
     c80:	f8d1 e004 	ldr.w	lr, [r1, #4]
    uint32_t ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer, ui32LowPer;
    uint32_t ui32Denom, ui32v1, ui32Denomfinal, ui32ClkFreq, ui32ClkCfg;
    uint32_t ui32HFRCfreqHz;
    int32_t i32Div, i32N;

    if ( ui32FreqHz == 0 )
     c84:	f1be 0f00 	cmp.w	lr, #0
     c88:	f000 8099 	beq.w	dbe <am_hal_iom_config+0x1ae>
    ui32HFRCfreqHz = AM_HAL_CLKGEN_FREQ_MAX_HZ;

    //
    // Compute various parameters used for computing the optimal CLKCFG setting.
    //
    i32Div = (ui32HFRCfreqHz / ui32FreqHz) + ((ui32HFRCfreqHz % ui32FreqHz) ? 1 : 0);    // Round up (ceiling)
     c8c:	4e77      	ldr	r6, [pc, #476]	; (e6c <am_hal_iom_config+0x25c>)
     c8e:	fbb6 f7fe 	udiv	r7, r6, lr
     c92:	fb0e f207 	mul.w	r2, lr, r7
     c96:	f1c2 7937 	rsb	r9, r2, #47972352	; 0x2dc0000
     c9a:	f509 4ad8 	add.w	sl, r9, #27648	; 0x6c00
     c9e:	f1ba 0f00 	cmp.w	sl, #0
     ca2:	bf18      	it	ne
     ca4:	3701      	addne	r7, #1

    //
    // Compute N (count the number of LS zeros of Div) = ctz(Div) = log2(Div & (-Div))
    //
    i32N = 31 - AM_INSTR_CLZ((i32Div & (-i32Div)));
     ca6:	427b      	negs	r3, r7
     ca8:	403b      	ands	r3, r7
     caa:	fab3 f683 	clz	r6, r3
     cae:	f1c6 031f 	rsb	r3, r6, #31
     cb2:	2b06      	cmp	r3, #6
     cb4:	bfa8      	it	ge
     cb6:	2306      	movge	r3, #6
        i32N = 6;
    }

    ui32Div3 = ( (ui32FreqHz < (ui32HFRCfreqHz / 16384))            ||
                 ( ((ui32FreqHz >= (ui32HFRCfreqHz / 3))    &&
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
     cb8:	f5be 6f37 	cmp.w	lr, #2928	; 0xb70
     cbc:	f240 8098 	bls.w	df0 <am_hal_iom_config+0x1e0>
     cc0:	4e6b      	ldr	r6, [pc, #428]	; (e70 <am_hal_iom_config+0x260>)
     cc2:	f5ae 0b74 	sub.w	fp, lr, #15990784	; 0xf40000
     cc6:	f5ab 5c10 	sub.w	ip, fp, #9216	; 0x2400
     cca:	45b4      	cmp	ip, r6
     ccc:	bf8b      	itete	hi
     cce:	f04f 0800 	movhi.w	r8, #0
     cd2:	f44f 6800 	movls.w	r8, #2048	; 0x800
     cd6:	2601      	movhi	r6, #1
     cd8:	2603      	movls	r6, #3
    ui32Denom = ( 1 << i32N ) * ( 1 + (ui32Div3 * 2) );
     cda:	fa06 f903 	lsl.w	r9, r6, r3
    ui32TotPer = i32Div / ui32Denom;
     cde:	fbb7 f2f9 	udiv	r2, r7, r9
    ui32TotPer += (i32Div % ui32Denom) ? 1 : 0;
     ce2:	fb09 7a12 	mls	sl, r9, r2, r7
     ce6:	f1ba 0f00 	cmp.w	sl, #0
     cea:	bf18      	it	ne
     cec:	3201      	addne	r2, #1
    ui32v1 = 31 - AM_INSTR_CLZ(ui32TotPer);     // v1 = log2(TotPer)
     cee:	fab2 fb82 	clz	fp, r2
     cf2:	f1cb 0c1f 	rsb	ip, fp, #31
    ui32Fsel = (ui32v1 > 7) ? ui32v1 + i32N - 7 : i32N;
     cf6:	f1bc 0f07 	cmp.w	ip, #7
     cfa:	f240 809b 	bls.w	e34 <am_hal_iom_config+0x224>
     cfe:	3b07      	subs	r3, #7
     d00:	4463      	add	r3, ip
    ui32Fsel++;
     d02:	f103 0901 	add.w	r9, r3, #1

    if ( ui32Fsel > 7 )
     d06:	f1b9 0f07 	cmp.w	r9, #7
     d0a:	d858      	bhi.n	dbe <am_hal_iom_config+0x1ae>
    }

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
     d0c:	f1ac 0b07 	sub.w	fp, ip, #7
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
     d10:	f04f 0a01 	mov.w	sl, #1
     d14:	fa0a fc0b 	lsl.w	ip, sl, fp
     d18:	f10c 3aff 	add.w	sl, ip, #4294967295
     d1c:	ea0a 0c02 	and.w	ip, sl, r2
    }

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
     d20:	fa22 f20b 	lsr.w	r2, r2, fp
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
     d24:	f8df b16c 	ldr.w	fp, [pc, #364]	; e94 <am_hal_iom_config+0x284>

    if ( ui32v1 > 7 )
    {
        ui32DivEn = ui32TotPer;     // Save TotPer for the round up calculation
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
     d28:	f1bc 0f00 	cmp.w	ip, #0
     d2c:	bf18      	it	ne
     d2e:	3201      	addne	r2, #1
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
     d30:	45de      	cmp	lr, fp
     d32:	f200 8086 	bhi.w	e42 <am_hal_iom_config+0x232>
     d36:	f04f 0e01 	mov.w	lr, #1
     d3a:	fa0e fa03 	lsl.w	sl, lr, r3
     d3e:	4557      	cmp	r7, sl
     d40:	d07f      	beq.n	e42 <am_hal_iom_config+0x232>
     d42:	f102 3eff 	add.w	lr, r2, #4294967295
     d46:	4694      	mov	ip, r2
     d48:	f44f 5780 	mov.w	r7, #4096	; 0x1000

    if (ui32Phase == 1)
     d4c:	2d00      	cmp	r5, #0
     d4e:	d17e      	bne.n	e4e <am_hal_iom_config+0x23e>
    {
        ui32LowPer = (ui32TotPer - 2) / 2;          // Longer high phase
    }
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
     d50:	ea4f 025e 	mov.w	r2, lr, lsr #1
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
     d54:	409e      	lsls	r6, r3
     d56:	fb0c f606 	mul.w	r6, ip, r6
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
     d5a:	f8df b110 	ldr.w	fp, [pc, #272]	; e6c <am_hal_iom_config+0x25c>
     d5e:	fbbb f3f6 	udiv	r3, fp, r6
     d62:	fb06 fa03 	mul.w	sl, r6, r3
     d66:	f1ca 7c37 	rsb	ip, sl, #47972352	; 0x2dc0000
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
     d6a:	ea4f 2509 	mov.w	r5, r9, lsl #8
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
     d6e:	f50c 4bd8 	add.w	fp, ip, #27648	; 0x6c00
     d72:	0876      	lsrs	r6, r6, #1
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
     d74:	f8df a120 	ldr.w	sl, [pc, #288]	; e98 <am_hal_iom_config+0x288>
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
     d78:	455e      	cmp	r6, fp
     d7a:	bf38      	it	cc
     d7c:	3301      	addcc	r3, #1
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
     d7e:	f405 69e0 	and.w	r9, r5, #1792	; 0x700
     d82:	ea49 0608 	orr.w	r6, r9, r8
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
     d86:	fbaa bc03 	umull	fp, ip, sl, r3
     d8a:	4d3a      	ldr	r5, [pc, #232]	; (e74 <am_hal_iom_config+0x264>)
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
     d8c:	433e      	orrs	r6, r7
     d8e:	0412      	lsls	r2, r2, #16
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
     d90:	ea4f 471c 	mov.w	r7, ip, lsr #16
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
     d94:	ea46 680e 	orr.w	r8, r6, lr, lsl #24
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
     d98:	fb05 3317 	mls	r3, r5, r7, r3
    else
    {
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    }

    ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)                |
     d9c:	f402 0e7f 	and.w	lr, r2, #16711680	; 0xff0000
     da0:	ea48 060e 	orr.w	r6, r8, lr
    ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer - 1);

    //
    // Determine if the actual frequency is a power of 2 (MHz).
    //
    if ( (ui32ClkFreq % 250000) == 0 )
     da4:	b91b      	cbnz	r3, dae <am_hal_iom_config+0x19e>
// A power of 2?
// Return true if ui32Value has exactly 1 bit set, otherwise false.
//
static bool onebit(uint32_t ui32Value)
{
    return ui32Value  &&  !(ui32Value & (ui32Value - 1));
     da6:	b117      	cbz	r7, dae <am_hal_iom_config+0x19e>
     da8:	1e7d      	subs	r5, r7, #1
     daa:	423d      	tst	r5, r7
     dac:	d03f      	beq.n	e2e <am_hal_iom_config+0x21e>
      //  is being selected.
      // If SPHA=0 the low period must be 60%. If SPHA=1 high period must be 60%.
      // Note that the predetermined frequency parameters use the formula
      //  lowper = (totper-1)/2, which results in a 60% low period.
      //
      ui32ClkCfg = iom_get_interface_clock_cfg(psConfig->ui32ClockFrequency,
     dae:	f04f 0b00 	mov.w	fp, #0
     db2:	ea4b 0206 	orr.w	r2, fp, r6
     db6:	4617      	mov	r7, r2
                                               psConfig->bSPHA );
    }

    if ( ui32ClkCfg )
     db8:	b10a      	cbz	r2, dbe <am_hal_iom_config+0x1ae>
    {
        AM_REGn(IOMSTR, ui32Module, CLKCFG) = (uint32_t)ui32ClkCfg;
     dba:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
     dbe:	4688      	mov	r8, r1
     dc0:	4604      	mov	r4, r0

    //
    // Compute the status timeout value.
    //
    ui32StatusTimeout[ui32Module] = MAX_IOM_BITS * AM_HAL_IOM_MAX_FIFO_SIZE *
      IOM_OVERHEAD_FACTOR * (am_hal_clkgen_sysclk_get() / psConfig->ui32ClockFrequency);
     dc2:	f7ff fda5 	bl	910 <am_hal_clkgen_sysclk_get>
    }

    //
    // Compute the status timeout value.
    //
    ui32StatusTimeout[ui32Module] = MAX_IOM_BITS * AM_HAL_IOM_MAX_FIFO_SIZE *
     dc6:	4f2c      	ldr	r7, [pc, #176]	; (e78 <am_hal_iom_config+0x268>)
     dc8:	f8d8 1004 	ldr.w	r1, [r8, #4]
     dcc:	fbb0 f0f1 	udiv	r0, r0, r1
     dd0:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
     dd4:	0215      	lsls	r5, r2, #8
     dd6:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
     dda:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
#elif   (AM_ASSERT_INVALID_THRESHOLD == 0)
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(check_iom_threshold(psConfig->ui8WriteThreshold)) |
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(check_iom_threshold(psConfig->ui8ReadThreshold)));
     dde:	7acb      	ldrb	r3, [r1, #11]
#if (AM_ASSERT_INVALID_THRESHOLD == 0)
static uint8_t check_iom_threshold(const uint8_t iom_threshold)
{
    uint8_t corrected_threshold = iom_threshold;

    if ( corrected_threshold < MIN_RW_THRESHOLD )
     de0:	2b03      	cmp	r3, #3
     de2:	f44f 6280 	mov.w	r2, #1024	; 0x400
     de6:	f63f af3c 	bhi.w	c62 <am_hal_iom_config+0x52>
     dea:	2304      	movs	r3, #4
     dec:	e73c      	b.n	c68 <am_hal_iom_config+0x58>
     dee:	4770      	bx	lr
        i32N = 6;
    }

    ui32Div3 = ( (ui32FreqHz < (ui32HFRCfreqHz / 16384))            ||
                 ( ((ui32FreqHz >= (ui32HFRCfreqHz / 3))    &&
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
     df0:	f44f 6800 	mov.w	r8, #2048	; 0x800
     df4:	2603      	movs	r6, #3
     df6:	e770      	b.n	cda <am_hal_iom_config+0xca>
    // Apply I2C clock stretching workaround if B2 silicon and IOM 1,2,3, or 5
    // Note: Only I2C clock speeds of AM_HAL_IOM_800KHZ, AM_HAL_IOM_400KHZ,
    // AM_HAL_IOM_200KHZ, and AM_HAL_IOM_100KHZ are allowed.  Other values will
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
			isRevB2() && (AM_HAL_IOM_I2CMODE == psConfig->ui32InterfaceMode))
     df8:	680b      	ldr	r3, [r1, #0]
     dfa:	2b00      	cmp	r3, #0
     dfc:	f47f af40 	bne.w	c80 <am_hal_iom_config+0x70>
    {
      // Set SPHA field to 1 on B2 silicon to enable the feature;
      AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_SPHA_M;
     e00:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
     e04:	4a1d      	ldr	r2, [pc, #116]	; (e7c <am_hal_iom_config+0x26c>)
    // result in the default of AM_HAL_IOM_100KHZ.
    if ((0 != ui32Module) && (4 != ui32Module) && (6 != ui32Module) && 
			isRevB2() && (AM_HAL_IOM_I2CMODE == psConfig->ui32InterfaceMode))
    {
      // Set SPHA field to 1 on B2 silicon to enable the feature;
      AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_SPHA_M;
     e06:	f043 0504 	orr.w	r5, r3, #4
     e0a:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
      ui32ClkCfg = iom_get_i2c_workaround_clock_cfg(psConfig->ui32ClockFrequency);
     e0e:	684d      	ldr	r5, [r1, #4]
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
     e10:	4295      	cmp	r5, r2
     e12:	d01f      	beq.n	e54 <am_hal_iom_config+0x244>
  {
    ui32Fsel = 2;
  }
  else if (ui32FreqHz == AM_HAL_IOM_400KHZ)
     e14:	4e1a      	ldr	r6, [pc, #104]	; (e80 <am_hal_iom_config+0x270>)
     e16:	42b5      	cmp	r5, r6
     e18:	d01e      	beq.n	e58 <am_hal_iom_config+0x248>
  {
    ui32Fsel = 3;
  }
  else if (ui32FreqHz == AM_HAL_IOM_200KHZ)
     e1a:	4b1a      	ldr	r3, [pc, #104]	; (e84 <am_hal_iom_config+0x274>)
     e1c:	4f1a      	ldr	r7, [pc, #104]	; (e88 <am_hal_iom_config+0x278>)
     e1e:	f102 59e8 	add.w	r9, r2, #486539264	; 0x1d000000
     e22:	f509 3af0 	add.w	sl, r9, #122880	; 0x1e000
     e26:	429d      	cmp	r5, r3
     e28:	bf18      	it	ne
     e2a:	4657      	movne	r7, sl
     e2c:	e7c5      	b.n	dba <am_hal_iom_config+0x1aa>
            //
            // Now, compute the return values.
            //
            ui32ClkFreq = compute_freq(ui32HFRCfreqHz, ui32Fsel, ui32Div3, ui32DivEn, ui32TotPer);

            ui32ClkCfg = AM_REG_IOMSTR_CLKCFG_FSEL(ui32Fsel)    |
     e2e:	f449 6600 	orr.w	r6, r9, #2048	; 0x800
     e32:	e7bc      	b.n	dae <am_hal_iom_config+0x19e>
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
     e34:	f8df b05c 	ldr.w	fp, [pc, #92]	; e94 <am_hal_iom_config+0x284>
     e38:	45de      	cmp	lr, fp
    ui32Denom = ( 1 << i32N ) * ( 1 + (ui32Div3 * 2) );
    ui32TotPer = i32Div / ui32Denom;
    ui32TotPer += (i32Div % ui32Denom) ? 1 : 0;
    ui32v1 = 31 - AM_INSTR_CLZ(ui32TotPer);     // v1 = log2(TotPer)
    ui32Fsel = (ui32v1 > 7) ? ui32v1 + i32N - 7 : i32N;
    ui32Fsel++;
     e3a:	f103 0901 	add.w	r9, r3, #1
        ui32TotPer = ui32TotPer>>(ui32v1-7);
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    }

    ui32DivEn = ( (ui32FreqHz >= (ui32HFRCfreqHz / 4)) ||
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
     e3e:	f67f af7a 	bls.w	d36 <am_hal_iom_config+0x126>
     e42:	f102 3eff 	add.w	lr, r2, #4294967295
     e46:	f04f 0c01 	mov.w	ip, #1
     e4a:	2700      	movs	r7, #0
     e4c:	e77e      	b.n	d4c <am_hal_iom_config+0x13c>

    if (ui32Phase == 1)
    {
        ui32LowPer = (ui32TotPer - 2) / 2;          // Longer high phase
     e4e:	1e95      	subs	r5, r2, #2
     e50:	086a      	lsrs	r2, r5, #1
     e52:	e77f      	b.n	d54 <am_hal_iom_config+0x144>
uint64_t iom_get_i2c_workaround_clock_cfg(uint32_t ui32FreqHz)
{
  uint32_t      ui32Fsel;

  // Only allow certain SCL frequencies for clock stretching devices.
  if (ui32FreqHz == AM_HAL_IOM_800KHZ)
     e54:	4f0d      	ldr	r7, [pc, #52]	; (e8c <am_hal_iom_config+0x27c>)
     e56:	e7b0      	b.n	dba <am_hal_iom_config+0x1aa>
  {
    ui32Fsel = 2;
  }
  else if (ui32FreqHz == AM_HAL_IOM_400KHZ)
     e58:	4f0d      	ldr	r7, [pc, #52]	; (e90 <am_hal_iom_config+0x280>)
     e5a:	e7ae      	b.n	dba <am_hal_iom_config+0x1aa>
     e5c:	023a      	lsls	r2, r7, #8
     e5e:	f402 42fe 	and.w	r2, r2, #32512	; 0x7f00
     e62:	e6fa      	b.n	c5a <am_hal_iom_config+0x4a>
     e64:	00f423ff 	.word	0x00f423ff
     e68:	4002000c 	.word	0x4002000c
     e6c:	02dc6c00 	.word	0x02dc6c00
     e70:	007a11ff 	.word	0x007a11ff
     e74:	0003d090 	.word	0x0003d090
     e78:	1000135c 	.word	0x1000135c
     e7c:	000c3500 	.word	0x000c3500
     e80:	00061a80 	.word	0x00061a80
     e84:	00030d40 	.word	0x00030d40
     e88:	1d0e1400 	.word	0x1d0e1400
     e8c:	1d0e1200 	.word	0x1d0e1200
     e90:	1d0e1300 	.word	0x1d0e1300
     e94:	00b71aff 	.word	0x00b71aff
     e98:	431bde83 	.word	0x431bde83

00000e9c <am_hal_iom_workaround_word_write>:
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
     e9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t ui32HiFreq = 0, ui32NormalFreq = 0;
    uint32_t ui32DelayTime = 0;
    uint32_t ui32LowFsel = 0;
    uint32_t ui32HiFsel = 0;
    uint32_t ui32FirstWord = 0;
    uint32_t ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, WORKAROUND_IOM, CFG, FULLDUP)) ?
     ea0:	4cc9      	ldr	r4, [pc, #804]	; (11c8 <am_hal_iom_workaround_word_write+0x32c>)
     ea2:	6825      	ldr	r5, [r4, #0]
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
     ea4:	4691      	mov	r9, r2
    uint32_t ui32HiFreq = 0, ui32NormalFreq = 0;
    uint32_t ui32DelayTime = 0;
    uint32_t ui32LowFsel = 0;
    uint32_t ui32HiFsel = 0;
    uint32_t ui32FirstWord = 0;
    uint32_t ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, WORKAROUND_IOM, CFG, FULLDUP)) ?
     ea6:	f015 0f08 	tst.w	r5, #8
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
     eaa:	b08d      	sub	sp, #52	; 0x34
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
     eac:	f640 72fb 	movw	r2, #4091	; 0xffb
    uint32_t ui32HiFreq = 0, ui32NormalFreq = 0;
    uint32_t ui32DelayTime = 0;
    uint32_t ui32LowFsel = 0;
    uint32_t ui32HiFsel = 0;
    uint32_t ui32FirstWord = 0;
    uint32_t ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, WORKAROUND_IOM, CFG, FULLDUP)) ?
     eb0:	bf14      	ite	ne
     eb2:	2740      	movne	r7, #64	; 0x40
     eb4:	2780      	moveq	r7, #128	; 0x80
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
     eb6:	4591      	cmp	r9, r2
//*****************************************************************************
void
am_hal_iom_workaround_word_write(uint32_t ui32ChipSelect,
                                 uint32_t *pui32Data, uint32_t ui32NumBytes,
                                 uint32_t ui32Options)
{
     eb8:	4604      	mov	r4, r0
     eba:	4688      	mov	r8, r1
     ebc:	9301      	str	r3, [sp, #4]
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
     ebe:	f200 834e 	bhi.w	155e <am_hal_iom_workaround_word_write+0x6c2>

    // We want to slow down the clock to help us count edges more
    // accurately. Save it first, then slow it down. Also, we will
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
     ec2:	4bc2      	ldr	r3, [pc, #776]	; (11cc <am_hal_iom_workaround_word_write+0x330>)
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
     ec4:	4ec2      	ldr	r6, [pc, #776]	; (11d0 <am_hal_iom_workaround_word_write+0x334>)

    // We want to slow down the clock to help us count edges more
    // accurately. Save it first, then slow it down. Also, we will
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
     ec6:	681d      	ldr	r5, [r3, #0]
//*****************************************************************************
static uint32_t
iom_get_workaround_fsel(uint32_t maxFreq)
{
    uint32_t ui32Freq, ui32Fsel;
    uint32_t ui32ClkCfg = AM_REGn(IOMSTR, 4, CLKCFG);
     ec8:	681a      	ldr	r2, [r3, #0]
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
     eca:	49c2      	ldr	r1, [pc, #776]	; (11d4 <am_hal_iom_workaround_word_write+0x338>)
     ecc:	f3c2 3000 	ubfx	r0, r2, #12, #1
     ed0:	f3c2 23c0 	ubfx	r3, r2, #11, #1
     ed4:	0e12      	lsrs	r2, r2, #24
     ed6:	fb02 f200 	mul.w	r2, r2, r0
     eda:	005b      	lsls	r3, r3, #1
     edc:	3301      	adds	r3, #1
     ede:	3201      	adds	r2, #1
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
     ee0:	fb02 fe03 	mul.w	lr, r2, r3
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
     ee4:	fbb6 fcfe 	udiv	ip, r6, lr
     ee8:	fb0e fa0c 	mul.w	sl, lr, ip
     eec:	f1ca 7b37 	rsb	fp, sl, #47972352	; 0x2dc0000
     ef0:	f50b 40d8 	add.w	r0, fp, #27648	; 0x6c00
     ef4:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
     ef8:	4586      	cmp	lr, r0
     efa:	bf2c      	ite	cs
     efc:	4660      	movcs	r0, ip
     efe:	f10c 0001 	addcc.w	r0, ip, #1
     f02:	4288      	cmp	r0, r1
     f04:	f240 8378 	bls.w	15f8 <am_hal_iom_workaround_word_write+0x75c>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
     f08:	005b      	lsls	r3, r3, #1
     f0a:	fb02 f303 	mul.w	r3, r2, r3
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
     f0e:	fbb6 f6f3 	udiv	r6, r6, r3
     f12:	fb03 f206 	mul.w	r2, r3, r6
     f16:	f1c2 7c37 	rsb	ip, r2, #47972352	; 0x2dc0000
     f1a:	f50c 40d8 	add.w	r0, ip, #27648	; 0x6c00
     f1e:	085b      	lsrs	r3, r3, #1
     f20:	4283      	cmp	r3, r0
     f22:	bf38      	it	cc
     f24:	3601      	addcc	r6, #1

    //
    // Starting with the current clock configuration parameters, find a value
    // of FSEL that will bring our total frequency down to or below maxFreq.
    //
    for ( ui32Fsel = 1; ui32Fsel < 8; ui32Fsel++ )
     f26:	428e      	cmp	r6, r1
     f28:	bf8c      	ite	hi
     f2a:	f04f 0e03 	movhi.w	lr, #3
     f2e:	f04f 0e02 	movls.w	lr, #2
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
     f32:	f3c5 21c0 	ubfx	r1, r5, #11, #1
     f36:	004e      	lsls	r6, r1, #1
     f38:	f3c5 2a02 	ubfx	sl, r5, #8, #3
     f3c:	f3c5 3c00 	ubfx	ip, r5, #12, #1
     f40:	f10a 3bff 	add.w	fp, sl, #4294967295
     f44:	4663      	mov	r3, ip
     f46:	3601      	adds	r6, #1
     f48:	0e28      	lsrs	r0, r5, #24
     f4a:	fa06 f20b 	lsl.w	r2, r6, fp
     f4e:	fb00 f003 	mul.w	r0, r0, r3
     f52:	fb00 2102 	mla	r1, r0, r2, r2
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
     f56:	f8df b278 	ldr.w	fp, [pc, #632]	; 11d0 <am_hal_iom_workaround_word_write+0x334>
     f5a:	fbbb f6f1 	udiv	r6, fp, r1
     f5e:	fb01 fa06 	mul.w	sl, r1, r6
     f62:	f1ca 7c37 	rsb	ip, sl, #47972352	; 0x2dc0000
     f66:	f50c 40d8 	add.w	r0, ip, #27648	; 0x6c00
     f6a:	084a      	lsrs	r2, r1, #1
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
    // Get the largest speed we can configure within our rated speed of 16MHz
    ui32HiFsel = iom_get_workaround_fsel(16000000);
    ui32HiClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
     f6c:	f425 6ae0 	bic.w	sl, r5, #1792	; 0x700
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32HiFsel));
    // Switch to Hi Freq
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
     f70:	4996      	ldr	r1, [pc, #600]	; (11cc <am_hal_iom_workaround_word_write+0x330>)
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
     f72:	4282      	cmp	r2, r0
     f74:	bf2c      	ite	cs
     f76:	4633      	movcs	r3, r6
     f78:	1c73      	addcc	r3, r6, #1
    // pre-calculate a delay for when we need to restore the SPI settings.
    //
    ui32ClkCfg = AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG);
    // Get the largest speed we can configure within our rated speed of 16MHz
    ui32HiFsel = iom_get_workaround_fsel(16000000);
    ui32HiClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
     f7a:	ea4a 260e 	orr.w	r6, sl, lr, lsl #8
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
     f7e:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32HiFsel));
    // Switch to Hi Freq
    // Need to make sure we wait long enough for the hi clock to be effective
    // Delay 2 cycles based on previous frequency
    ui32NormalFreq = am_hal_iom_frequency_get(ui32ClkCfg);
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32HiClkCfg;
     f82:	600e      	str	r6, [r1, #0]
    ui32DelayTime = ((2 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32NormalFreq * 3));
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
     f84:	4a94      	ldr	r2, [pc, #592]	; (11d8 <am_hal_iom_workaround_word_write+0x33c>)
     f86:	4895      	ldr	r0, [pc, #596]	; (11dc <am_hal_iom_workaround_word_write+0x340>)
     f88:	fbb0 f0fc 	udiv	r0, r0, ip
     f8c:	4790      	blx	r2
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
     f8e:	f3c6 23c0 	ubfx	r3, r6, #11, #1
     f92:	0058      	lsls	r0, r3, #1
     f94:	f3c6 2101 	ubfx	r1, r6, #8, #2
     f98:	1c42      	adds	r2, r0, #1
     f9a:	f101 3cff 	add.w	ip, r1, #4294967295
     f9e:	f3c6 3000 	ubfx	r0, r6, #12, #1
     fa2:	0e36      	lsrs	r6, r6, #24
     fa4:	fa02 f30c 	lsl.w	r3, r2, ip
     fa8:	fb06 f600 	mul.w	r6, r6, r0
     fac:	fb06 3103 	mla	r1, r6, r3, r3
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
     fb0:	fbbb f2f1 	udiv	r2, fp, r1
     fb4:	fb01 f002 	mul.w	r0, r1, r2
     fb8:	f1c0 7b37 	rsb	fp, r0, #47972352	; 0x2dc0000
     fbc:	f50b 4cd8 	add.w	ip, fp, #27648	; 0x6c00
     fc0:	084e      	lsrs	r6, r1, #1
     fc2:	4566      	cmp	r6, ip
     fc4:	bf2c      	ite	cs
     fc6:	4616      	movcs	r6, r2
     fc8:	1c56      	addcc	r6, r2, #1
    ui32HiFreq = am_hal_iom_frequency_get(ui32HiClkCfg);

    //
    // Validate return value to prevent DIVBY0 errors.
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");
     fca:	2e00      	cmp	r6, #0
     fcc:	f000 82c0 	beq.w	1550 <am_hal_iom_workaround_word_write+0x6b4>
//*****************************************************************************
static uint32_t
iom_get_workaround_fsel(uint32_t maxFreq)
{
    uint32_t ui32Freq, ui32Fsel;
    uint32_t ui32ClkCfg = AM_REGn(IOMSTR, 4, CLKCFG);
     fd0:	4b7e      	ldr	r3, [pc, #504]	; (11cc <am_hal_iom_workaround_word_write+0x330>)
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
     fd2:	4a7f      	ldr	r2, [pc, #508]	; (11d0 <am_hal_iom_workaround_word_write+0x334>)
//*****************************************************************************
static uint32_t
iom_get_workaround_fsel(uint32_t maxFreq)
{
    uint32_t ui32Freq, ui32Fsel;
    uint32_t ui32ClkCfg = AM_REGn(IOMSTR, 4, CLKCFG);
     fd4:	6818      	ldr	r0, [r3, #0]
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
     fd6:	f8df e214 	ldr.w	lr, [pc, #532]	; 11ec <am_hal_iom_workaround_word_write+0x350>
     fda:	f3c0 21c0 	ubfx	r1, r0, #11, #1
     fde:	f3c0 3300 	ubfx	r3, r0, #12, #1
     fe2:	0e00      	lsrs	r0, r0, #24
     fe4:	fb00 f303 	mul.w	r3, r0, r3
     fe8:	0049      	lsls	r1, r1, #1
     fea:	3101      	adds	r1, #1
     fec:	3301      	adds	r3, #1
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
     fee:	fb03 f001 	mul.w	r0, r3, r1
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
     ff2:	fbb2 fbf0 	udiv	fp, r2, r0
     ff6:	fb00 fc0b 	mul.w	ip, r0, fp
     ffa:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
     ffe:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    1002:	0840      	lsrs	r0, r0, #1
    1004:	4560      	cmp	r0, ip
    1006:	bf38      	it	cc
    1008:	f10b 0b01 	addcc.w	fp, fp, #1
    100c:	45f3      	cmp	fp, lr
    100e:	f240 82f1 	bls.w	15f4 <am_hal_iom_workaround_word_write+0x758>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1012:	0048      	lsls	r0, r1, #1
    1014:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    1018:	fbb2 fbf0 	udiv	fp, r2, r0
    101c:	fb00 fc0b 	mul.w	ip, r0, fp
    1020:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    1024:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    1028:	0840      	lsrs	r0, r0, #1
    102a:	4560      	cmp	r0, ip
    102c:	bf38      	it	cc
    102e:	f10b 0b01 	addcc.w	fp, fp, #1
    1032:	45f3      	cmp	fp, lr
    1034:	f240 82e3 	bls.w	15fe <am_hal_iom_workaround_word_write+0x762>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1038:	0088      	lsls	r0, r1, #2
    103a:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    103e:	fbb2 fbf0 	udiv	fp, r2, r0
    1042:	fb00 fc0b 	mul.w	ip, r0, fp
    1046:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    104a:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    104e:	0840      	lsrs	r0, r0, #1
    1050:	4560      	cmp	r0, ip
    1052:	bf38      	it	cc
    1054:	f10b 0b01 	addcc.w	fp, fp, #1
    1058:	45f3      	cmp	fp, lr
    105a:	f240 82d2 	bls.w	1602 <am_hal_iom_workaround_word_write+0x766>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    105e:	00c8      	lsls	r0, r1, #3
    1060:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    1064:	fbb2 fbf0 	udiv	fp, r2, r0
    1068:	fb00 fc0b 	mul.w	ip, r0, fp
    106c:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    1070:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    1074:	0840      	lsrs	r0, r0, #1
    1076:	4560      	cmp	r0, ip
    1078:	bf38      	it	cc
    107a:	f10b 0b01 	addcc.w	fp, fp, #1
    107e:	45f3      	cmp	fp, lr
    1080:	f240 82c1 	bls.w	1606 <am_hal_iom_workaround_word_write+0x76a>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    1084:	0108      	lsls	r0, r1, #4
    1086:	fb03 f000 	mul.w	r0, r3, r0
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    108a:	fbb2 fbf0 	udiv	fp, r2, r0
    108e:	fb00 fc0b 	mul.w	ip, r0, fp
    1092:	f1cc 7c37 	rsb	ip, ip, #47972352	; 0x2dc0000
    1096:	f50c 4cd8 	add.w	ip, ip, #27648	; 0x6c00
    109a:	0840      	lsrs	r0, r0, #1
    109c:	4560      	cmp	r0, ip
    109e:	bf38      	it	cc
    10a0:	f10b 0b01 	addcc.w	fp, fp, #1
    10a4:	45f3      	cmp	fp, lr
    10a6:	f240 82b0 	bls.w	160a <am_hal_iom_workaround_word_write+0x76e>
                             uint32_t ui32Fsel, uint32_t ui32Div3,
                             uint32_t ui32DivEn, uint32_t ui32TotPer)
{
    uint32_t ui32Denomfinal, ui32ClkFreq;

    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    10aa:	0149      	lsls	r1, r1, #5
    10ac:	fb03 f301 	mul.w	r3, r3, r1
        ui32Freq = compute_freq(AM_HAL_CLKGEN_FREQ_MAX_HZ, ui32Fsel,
                                AM_BFX(IOMSTR, CLKCFG, DIV3, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, DIVEN, ui32ClkCfg),
                                AM_BFX(IOMSTR, CLKCFG, TOTPER, ui32ClkCfg));

        if ( ui32Freq <= maxFreq && ui32Freq != 0 )
    10b0:	fbb2 f2f3 	udiv	r2, r2, r3
    10b4:	fb03 f002 	mul.w	r0, r3, r2
    10b8:	f1c0 7c37 	rsb	ip, r0, #47972352	; 0x2dc0000
    10bc:	f50c 4bd8 	add.w	fp, ip, #27648	; 0x6c00
    10c0:	085b      	lsrs	r3, r3, #1
    10c2:	455b      	cmp	r3, fp
    10c4:	bf38      	it	cc
    10c6:	3201      	addcc	r2, #1

    //
    // Starting with the current clock configuration parameters, find a value
    // of FSEL that will bring our total frequency down to or below maxFreq.
    //
    for ( ui32Fsel = 1; ui32Fsel < 8; ui32Fsel++ )
    10c8:	4572      	cmp	r2, lr
    10ca:	bf8c      	ite	hi
    10cc:	2107      	movhi	r1, #7
    10ce:	2106      	movls	r1, #6
    // Get a reasonably slow speed (~1MHz) we can safely poll for the transition
    ui32LowFsel = iom_get_workaround_fsel(1000000);
    ui32LowClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32LowFsel));

    if ( ui32Options & AM_HAL_IOM_RAW )
    10d0:	9801      	ldr	r0, [sp, #4]
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");

    // Get a reasonably slow speed (~1MHz) we can safely poll for the transition
    ui32LowFsel = iom_get_workaround_fsel(1000000);
    ui32LowClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
    10d2:	ea4a 2201 	orr.w	r2, sl, r1, lsl #8
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32LowFsel));

    if ( ui32Options & AM_HAL_IOM_RAW )
    10d6:	f010 4180 	ands.w	r1, r0, #1073741824	; 0x40000000
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");

    // Get a reasonably slow speed (~1MHz) we can safely poll for the transition
    ui32LowFsel = iom_get_workaround_fsel(1000000);
    ui32LowClkCfg = ((ui32ClkCfg & (~AM_REG_IOMSTR_CLKCFG_FSEL_M)) |
    10da:	9203      	str	r2, [sp, #12]
                     AM_BFV(IOMSTR, CLKCFG, FSEL, ui32LowFsel));

    if ( ui32Options & AM_HAL_IOM_RAW )
    10dc:	f000 813f 	beq.w	135e <am_hal_iom_workaround_word_write+0x4c2>
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((27 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));

        if ( pui32Data[0] & 0x80 )
    10e0:	f8d8 3000 	ldr.w	r3, [r8]
        // The transition we care for is on 33rd bit.
        // Prepare to delay 27 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((27 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    10e4:	4a3e      	ldr	r2, [pc, #248]	; (11e0 <am_hal_iom_workaround_word_write+0x344>)

        if ( pui32Data[0] & 0x80 )
    10e6:	f003 0080 	and.w	r0, r3, #128	; 0x80
        {
            ui32FirstWord = 0x00000000;
    10ea:	2800      	cmp	r0, #0
        // The transition we care for is on 33rd bit.
        // Prepare to delay 27 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((27 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    10ec:	eb06 0146 	add.w	r1, r6, r6, lsl #1
    10f0:	fbb2 f3f1 	udiv	r3, r2, r1
    10f4:	9307      	str	r3, [sp, #28]

        if ( pui32Data[0] & 0x80 )
        {
            ui32FirstWord = 0x00000000;
    10f6:	bf0b      	itete	eq
    10f8:	2300      	moveq	r3, #0
    10fa:	2301      	movne	r3, #1
    10fc:	f06f 06ff 	mvneq.w	r6, #255	; 0xff
    1100:	2600      	movne	r6, #0
    1102:	9306      	str	r3, [sp, #24]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1104:	4a30      	ldr	r2, [pc, #192]	; (11c8 <am_hal_iom_workaround_word_write+0x32c>)
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    1106:	4837      	ldr	r0, [pc, #220]	; (11e4 <am_hal_iom_workaround_word_write+0x348>)
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1108:	6812      	ldr	r2, [r2, #0]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    110a:	6801      	ldr	r1, [r0, #0]
    // Now that weve taken care of the offset byte, we can run the
    // transaction in RAW mode.
    //
    ui32Options |= AM_HAL_IOM_RAW;

    ui32NumBytes += 4;
    110c:	f109 0304 	add.w	r3, r9, #4

    //
    // Figure out how many bytes we can write to the FIFO immediately.
    //
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    1110:	429f      	cmp	r7, r3
    1112:	bf28      	it	cs
    1114:	461f      	movcs	r7, r3
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1116:	f012 0f08 	tst.w	r2, #8
    111a:	bf14      	ite	ne
    111c:	2240      	movne	r2, #64	; 0x40
    111e:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1120:	1a50      	subs	r0, r2, r1
    1122:	f000 02fc 	and.w	r2, r0, #252	; 0xfc
    1126:	2a03      	cmp	r2, #3
    1128:	f240 8209 	bls.w	153e <am_hal_iom_workaround_word_write+0x6a2>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    112c:	492e      	ldr	r1, [pc, #184]	; (11e8 <am_hal_iom_workaround_word_write+0x34c>)
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    112e:	4826      	ldr	r0, [pc, #152]	; (11c8 <am_hal_iom_workaround_word_write+0x32c>)
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1130:	600e      	str	r6, [r1, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1132:	6806      	ldr	r6, [r0, #0]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    1134:	f850 1c1c 	ldr.w	r1, [r0, #-28]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1138:	f016 0f08 	tst.w	r6, #8
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    113c:	f1a0 021c 	sub.w	r2, r0, #28
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1140:	bf14      	ite	ne
    1142:	2240      	movne	r2, #64	; 0x40
    1144:	2280      	moveq	r2, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1146:	1a50      	subs	r0, r2, r1
    ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
                        ui32MaxFifoSize);

    am_hal_iom_fifo_write(WORKAROUND_IOM, &ui32FirstWord, 4);

    am_hal_iom_fifo_write(WORKAROUND_IOM, pui32Data, ui32TransferSize - 4);
    1148:	3f04      	subs	r7, #4
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    114a:	f000 06fc 	and.w	r6, r0, #252	; 0xfc
    114e:	42b7      	cmp	r7, r6
    1150:	f200 81ec 	bhi.w	152c <am_hal_iom_workaround_word_write+0x690>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1154:	2f00      	cmp	r7, #0
    1156:	d069      	beq.n	122c <am_hal_iom_workaround_word_write+0x390>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1158:	4642      	mov	r2, r8
    115a:	ea6f 0908 	mvn.w	r9, r8
    115e:	f852 cb04 	ldr.w	ip, [r2], #4
    1162:	4921      	ldr	r1, [pc, #132]	; (11e8 <am_hal_iom_workaround_word_write+0x34c>)
    1164:	44c1      	add	r9, r8

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1166:	ebc8 0b02 	rsb	fp, r8, r2
    116a:	44b9      	add	r9, r7
    116c:	455f      	cmp	r7, fp
    116e:	f3c9 0082 	ubfx	r0, r9, #2, #3
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1172:	f8c1 c000 	str.w	ip, [r1]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1176:	d959      	bls.n	122c <am_hal_iom_workaround_word_write+0x390>
    1178:	2800      	cmp	r0, #0
    117a:	d039      	beq.n	11f0 <am_hal_iom_workaround_word_write+0x354>
    117c:	2801      	cmp	r0, #1
    117e:	d01b      	beq.n	11b8 <am_hal_iom_workaround_word_write+0x31c>
    1180:	2802      	cmp	r0, #2
    1182:	d016      	beq.n	11b2 <am_hal_iom_workaround_word_write+0x316>
    1184:	2803      	cmp	r0, #3
    1186:	d011      	beq.n	11ac <am_hal_iom_workaround_word_write+0x310>
    1188:	2804      	cmp	r0, #4
    118a:	d00c      	beq.n	11a6 <am_hal_iom_workaround_word_write+0x30a>
    118c:	2805      	cmp	r0, #5
    118e:	d007      	beq.n	11a0 <am_hal_iom_workaround_word_write+0x304>
    1190:	2806      	cmp	r0, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1192:	bf1c      	itt	ne
    1194:	f852 0b04 	ldrne.w	r0, [r2], #4
    1198:	6008      	strne	r0, [r1, #0]
    119a:	f852 6b04 	ldr.w	r6, [r2], #4
    119e:	600e      	str	r6, [r1, #0]
    11a0:	f852 0b04 	ldr.w	r0, [r2], #4
    11a4:	6008      	str	r0, [r1, #0]
    11a6:	f852 6b04 	ldr.w	r6, [r2], #4
    11aa:	600e      	str	r6, [r1, #0]
    11ac:	f852 0b04 	ldr.w	r0, [r2], #4
    11b0:	6008      	str	r0, [r1, #0]
    11b2:	f852 6b04 	ldr.w	r6, [r2], #4
    11b6:	600e      	str	r6, [r1, #0]
    11b8:	f852 0b04 	ldr.w	r0, [r2], #4
    11bc:	6008      	str	r0, [r1, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    11be:	ebc8 0602 	rsb	r6, r8, r2
    11c2:	42b7      	cmp	r7, r6
    11c4:	d932      	bls.n	122c <am_hal_iom_workaround_word_write+0x390>
    11c6:	e013      	b.n	11f0 <am_hal_iom_workaround_word_write+0x354>
    11c8:	5000811c 	.word	0x5000811c
    11cc:	5000810c 	.word	0x5000810c
    11d0:	02dc6c00 	.word	0x02dc6c00
    11d4:	00f42400 	.word	0x00f42400
    11d8:	0800009d 	.word	0x0800009d
    11dc:	05b8d800 	.word	0x05b8d800
    11e0:	4d3f6400 	.word	0x4d3f6400
    11e4:	50008100 	.word	0x50008100
    11e8:	50008000 	.word	0x50008000
    11ec:	000f4240 	.word	0x000f4240
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    11f0:	4692      	mov	sl, r2
    11f2:	3220      	adds	r2, #32
    11f4:	f85a 0b04 	ldr.w	r0, [sl], #4
    11f8:	6008      	str	r0, [r1, #0]
    11fa:	f852 6c1c 	ldr.w	r6, [r2, #-28]
    11fe:	600e      	str	r6, [r1, #0]
    1200:	f8da 0004 	ldr.w	r0, [sl, #4]
    1204:	6008      	str	r0, [r1, #0]
    1206:	f852 6c14 	ldr.w	r6, [r2, #-20]
    120a:	600e      	str	r6, [r1, #0]
    120c:	f852 0c10 	ldr.w	r0, [r2, #-16]
    1210:	6008      	str	r0, [r1, #0]
    1212:	f852 6c0c 	ldr.w	r6, [r2, #-12]
    1216:	600e      	str	r6, [r1, #0]
    1218:	f852 0c08 	ldr.w	r0, [r2, #-8]
    121c:	6008      	str	r0, [r1, #0]
    121e:	f852 6c04 	ldr.w	r6, [r2, #-4]
    1222:	600e      	str	r6, [r1, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1224:	ebc8 0e02 	rsb	lr, r8, r2
    1228:	4577      	cmp	r7, lr
    122a:	d8e1      	bhi.n	11f0 <am_hal_iom_workaround_word_write+0x354>
    for ( index = 0; index < (sizeof(g_IOMPads) / sizeof(IOMPad_t)); index++ )
    {
        //
        //  Is this one of the CEn that we are using?
        //
        if ( g_IOMPads[index].channel == ui32ChipSelect )
    122c:	2c00      	cmp	r4, #0
    122e:	f000 81c7 	beq.w	15c0 <am_hal_iom_workaround_word_write+0x724>
    1232:	2c01      	cmp	r4, #1
    1234:	f000 80a4 	beq.w	1380 <am_hal_iom_workaround_word_write+0x4e4>
    1238:	2c02      	cmp	r4, #2
    123a:	f000 80b9 	beq.w	13b0 <am_hal_iom_workaround_word_write+0x514>
    123e:	2c03      	cmp	r4, #3
    1240:	f000 80c7 	beq.w	13d2 <am_hal_iom_workaround_word_write+0x536>
    1244:	2c04      	cmp	r4, #4
    1246:	f000 811f 	beq.w	1488 <am_hal_iom_workaround_word_write+0x5ec>
    124a:	2c05      	cmp	r4, #5
    124c:	f000 8134 	beq.w	14b8 <am_hal_iom_workaround_word_write+0x61c>
    1250:	2c06      	cmp	r4, #6
    1252:	f000 8149 	beq.w	14e8 <am_hal_iom_workaround_word_write+0x64c>
    1256:	2c07      	cmp	r4, #7
    1258:	f000 8157 	beq.w	150a <am_hal_iom_workaround_word_write+0x66e>
    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32CSPadregVal = *pui32CSPadreg;
    125c:	4ec3      	ldr	r6, [pc, #780]	; (156c <am_hal_iom_workaround_word_write+0x6d0>)
    //
    // Calculate the GPIO to be controlled until the initial shift is
    // complete. Make sure we get a valid value.
    //
    ui32IOMGPIO = iom_calc_gpio(ui32ChipSelect);
    am_hal_debug_assert(0xDEADBEEF != ui32IOMGPIO);
    125e:	48c4      	ldr	r0, [pc, #784]	; (1570 <am_hal_iom_workaround_word_write+0x6d4>)
    1260:	9304      	str	r3, [sp, #16]
    1262:	f240 5126 	movw	r1, #1318	; 0x526
    1266:	2200      	movs	r2, #0
    1268:	f7ff fb6c 	bl	944 <am_hal_debug_error>
    ui32CSPadregVal = *pui32CSPadreg;

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    126c:	4fc1      	ldr	r7, [pc, #772]	; (1574 <am_hal_iom_workaround_word_write+0x6d8>)
    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32CSPadregVal = *pui32CSPadreg;
    126e:	6833      	ldr	r3, [r6, #0]
    1270:	9302      	str	r3, [sp, #8]

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    1272:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    1276:	9b04      	ldr	r3, [sp, #16]
    1278:	6039      	str	r1, [r7, #0]

    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    127a:	46b3      	mov	fp, r6
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_GPIO_OUTPUT);

    //
    // Enable the input buffer on MOSI.
    //
    am_hal_gpio_pin_config(WORKAROUND_IOM_MOSI_PIN, WORKAROUND_IOM_MOSI_CFG | AM_HAL_PIN_DIR_INPUT);
    127c:	f3ef 8210 	mrs	r2, PRIMASK
    1280:	9204      	str	r2, [sp, #16]
    1282:	920a      	str	r2, [sp, #40]	; 0x28
    1284:	b672      	cpsid	i
    1286:	4ebc      	ldr	r6, [pc, #752]	; (1578 <am_hal_iom_workaround_word_write+0x6dc>)
    1288:	f8df 9324 	ldr.w	r9, [pc, #804]	; 15b0 <am_hal_iom_workaround_word_write+0x714>
    128c:	f8df 8324 	ldr.w	r8, [pc, #804]	; 15b4 <am_hal_iom_workaround_word_write+0x718>
    1290:	4fba      	ldr	r7, [pc, #744]	; (157c <am_hal_iom_workaround_word_write+0x6e0>)
    1292:	2173      	movs	r1, #115	; 0x73
    1294:	6031      	str	r1, [r6, #0]
    1296:	f8d9 0000 	ldr.w	r0, [r9]
    129a:	f420 22e0 	bic.w	r2, r0, #458752	; 0x70000
    129e:	f8c9 2000 	str.w	r2, [r9]
    12a2:	f8d8 1000 	ldr.w	r1, [r8]
    12a6:	f021 00ff 	bic.w	r0, r1, #255	; 0xff
    12aa:	f040 022a 	orr.w	r2, r0, #42	; 0x2a
    12ae:	f8c8 2000 	str.w	r2, [r8]
    12b2:	6839      	ldr	r1, [r7, #0]
    12b4:	f04f 0a00 	mov.w	sl, #0
    12b8:	f021 00ff 	bic.w	r0, r1, #255	; 0xff
    12bc:	6038      	str	r0, [r7, #0]
    12be:	f8c6 a000 	str.w	sl, [r6]
    12c2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    12c4:	f382 8810 	msr	PRIMASK, r2
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    12c8:	9901      	ldr	r1, [sp, #4]
    12ca:	0424      	lsls	r4, r4, #16
    12cc:	f021 4c23 	bic.w	ip, r1, #2734686208	; 0xa3000000
    12d0:	f404 20e0 	and.w	r0, r4, #458752	; 0x70000
    12d4:	f00c 22ff 	and.w	r2, ip, #4278255360	; 0xff00ff00
    12d8:	f040 4480 	orr.w	r4, r0, #1073741824	; 0x40000000
    12dc:	b2d9      	uxtb	r1, r3
    12de:	4322      	orrs	r2, r4
    12e0:	03db      	lsls	r3, r3, #15
    12e2:	f003 64f0 	and.w	r4, r3, #125829120	; 0x7800000
    12e6:	430a      	orrs	r2, r1

    //
    // Write the GPIO PADKEY register to allow the workaround loop to
    // reconfigure chip enable.
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    12e8:	2073      	movs	r0, #115	; 0x73
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    12ea:	4322      	orrs	r2, r4

    //
    // Write the GPIO PADKEY register to allow the workaround loop to
    // reconfigure chip enable.
    //
    AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    12ec:	6030      	str	r0, [r6, #0]
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    12ee:	9205      	str	r2, [sp, #20]
{
    uint32_t ui32Critical = 0;
    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    12f0:	f001 fb36 	bl	2960 <am_hal_interrupt_master_disable>

    //
    // Start the write on the bus.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CMD) = ui32Command;
    12f4:	4ba2      	ldr	r3, [pc, #648]	; (1580 <am_hal_iom_workaround_word_write+0x6e4>)
{
    uint32_t ui32Critical = 0;
    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    12f6:	9001      	str	r0, [sp, #4]

    //
    // Start the write on the bus.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CMD) = ui32Command;
    12f8:	9805      	ldr	r0, [sp, #20]
    // loop runs an edge-detector on MOSI, and triggers a falling edge on
    // chip-enable on the first bit of our real data.
    //
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    // Switch to Low Freq
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32LowClkCfg;
    12fa:	4ca2      	ldr	r4, [pc, #648]	; (1584 <am_hal_iom_workaround_word_write+0x6e8>)
    ui32Critical = am_hal_interrupt_master_disable();

    //
    // Start the write on the bus.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CMD) = ui32Command;
    12fc:	6018      	str	r0, [r3, #0]
    //
    // Slow down the clock, and run the workaround loop. The workaround
    // loop runs an edge-detector on MOSI, and triggers a falling edge on
    // chip-enable on the first bit of our real data.
    //
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    12fe:	49a2      	ldr	r1, [pc, #648]	; (1588 <am_hal_iom_workaround_word_write+0x6ec>)
    1300:	9807      	ldr	r0, [sp, #28]
    1302:	4788      	blx	r1
    // Switch to Low Freq
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32LowClkCfg;
    1304:	9b03      	ldr	r3, [sp, #12]
    iom_workaround_loop(ui32CSPadregVal, pui32CSPadreg, bRising);
    1306:	9a06      	ldr	r2, [sp, #24]
    1308:	9802      	ldr	r0, [sp, #8]
    // loop runs an edge-detector on MOSI, and triggers a falling edge on
    // chip-enable on the first bit of our real data.
    //
    ((void (*)(uint32_t)) 0x0800009d)(ui32DelayTime);
    // Switch to Low Freq
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32LowClkCfg;
    130a:	6023      	str	r3, [r4, #0]
    iom_workaround_loop(ui32CSPadregVal, pui32CSPadreg, bRising);
    130c:	4659      	mov	r1, fp
    130e:	f7ff fc21 	bl	b54 <iom_workaround_loop>
    //
    // Restore the clock frequency and the normal MOSI pin function.
    //
    AM_REGn(IOMSTR, WORKAROUND_IOM, CLKCFG) = ui32ClkCfg;
    1312:	6025      	str	r5, [r4, #0]
    am_hal_gpio_pin_config(WORKAROUND_IOM_MOSI_PIN, WORKAROUND_IOM_MOSI_CFG);
    1314:	9d04      	ldr	r5, [sp, #16]
    1316:	950b      	str	r5, [sp, #44]	; 0x2c
    1318:	b672      	cpsid	i
    131a:	2473      	movs	r4, #115	; 0x73
    131c:	6034      	str	r4, [r6, #0]
    131e:	f8d9 2000 	ldr.w	r2, [r9]
    1322:	f422 21e0 	bic.w	r1, r2, #458752	; 0x70000
    1326:	f8c9 1000 	str.w	r1, [r9]
    132a:	f8d8 0000 	ldr.w	r0, [r8]
    132e:	f020 03ff 	bic.w	r3, r0, #255	; 0xff
    1332:	f043 0528 	orr.w	r5, r3, #40	; 0x28
    1336:	f8c8 5000 	str.w	r5, [r8]
    133a:	683c      	ldr	r4, [r7, #0]
    133c:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
    1340:	603a      	str	r2, [r7, #0]
    1342:	f8c6 a000 	str.w	sl, [r6]
    1346:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    1348:	f387 8810 	msr	PRIMASK, r7

    //
    // End the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    134c:	9901      	ldr	r1, [sp, #4]
    134e:	4608      	mov	r0, r1
    1350:	f001 fb0a 	bl	2968 <am_hal_interrupt_master_set>
            ui32DelayTime, ui32ClkCfg,
            ui32LowClkCfg, bRising);
    //
    // Re-lock the GPIO PADKEY register
    //
    AM_REGn(GPIO, 0, PADKEY) = 0;
    1354:	f8c6 a000 	str.w	sl, [r6]
    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += (ui32TransferSize - 4) >> 2;
}
    1358:	b00d      	add	sp, #52	; 0x34
    135a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        // Prepare to delay 19 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
    135e:	0402      	lsls	r2, r0, #16
        // The transition we care for is on 25th bit.
        // Prepare to delay 19 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    1360:	eb06 0a46 	add.w	sl, r6, r6, lsl #1
    1364:	4e89      	ldr	r6, [pc, #548]	; (158c <am_hal_iom_workaround_word_write+0x6f0>)
    1366:	fbb6 f3fa 	udiv	r3, r6, sl
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
        if ( ui32FirstWord & 0x80000000 )
    136a:	f012 467f 	ands.w	r6, r2, #4278190080	; 0xff000000
        // The transition we care for is on 25th bit.
        // Prepare to delay 19 bits past the start of the transaction
        // before getting into polling - to leave some
        // margin for compiler related variations
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
    136e:	9307      	str	r3, [sp, #28]
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
        if ( ui32FirstWord & 0x80000000 )
    1370:	f100 813d 	bmi.w	15ee <am_hal_iom_workaround_word_write+0x752>
        {
            bRising = true;
        }
        else
        {
            ui32FirstWord |= 0x00FFFF00;
    1374:	f446 007f 	orr.w	r0, r6, #16711680	; 0xff0000
    1378:	f440 467f 	orr.w	r6, r0, #65280	; 0xff00
            bRising = false;
    137c:	9106      	str	r1, [sp, #24]
    137e:	e6c1      	b.n	1104 <am_hal_iom_workaround_word_write+0x268>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1380:	4e83      	ldr	r6, [pc, #524]	; (1590 <am_hal_iom_workaround_word_write+0x6f4>)
    1382:	6837      	ldr	r7, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    1384:	f3c7 41c2 	ubfx	r1, r7, #19, #3
    1388:	2904      	cmp	r1, #4
    138a:	f000 814a 	beq.w	1622 <am_hal_iom_workaround_word_write+0x786>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    138e:	3614      	adds	r6, #20
    1390:	6832      	ldr	r2, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    1392:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    1396:	2805      	cmp	r0, #5
    1398:	f47f af60 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    139c:	2225      	movs	r2, #37	; 0x25
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    139e:	46b3      	mov	fp, r6
    13a0:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    13a2:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    13a6:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    13aa:	f04f 0824 	mov.w	r8, #36	; 0x24
    13ae:	e027      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    13b0:	4978      	ldr	r1, [pc, #480]	; (1594 <am_hal_iom_workaround_word_write+0x6f8>)
    13b2:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    13b4:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    13b8:	2806      	cmp	r0, #6
    13ba:	f47f af4f 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    13be:	2229      	movs	r2, #41	; 0x29
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    13c0:	468b      	mov	fp, r1
    13c2:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    13c4:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    13c8:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    13cc:	f04f 0828 	mov.w	r8, #40	; 0x28
    13d0:	e016      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    13d2:	496f      	ldr	r1, [pc, #444]	; (1590 <am_hal_iom_workaround_word_write+0x6f4>)
    13d4:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    13d6:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    13da:	2804      	cmp	r0, #4
    13dc:	f000 812a 	beq.w	1634 <am_hal_iom_workaround_word_write+0x798>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    13e0:	311c      	adds	r1, #28
    13e2:	680e      	ldr	r6, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    13e4:	f3c6 27c2 	ubfx	r7, r6, #11, #3
    13e8:	2f04      	cmp	r7, #4
    13ea:	f47f af37 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    13ee:	222d      	movs	r2, #45	; 0x2d
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    13f0:	468b      	mov	fp, r1
    13f2:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    13f4:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    13f8:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    13fc:	f04f 082c 	mov.w	r8, #44	; 0x2c
    ui32CSPadregVal = *pui32CSPadreg;

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    1400:	08d0      	lsrs	r0, r2, #3
    1402:	f00c 071f 	and.w	r7, ip, #31
    1406:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 15b8 <am_hal_iom_workaround_word_write+0x71c>
    //
    // Save the locations and values of the CS pin configuration
    // information.
    //
    pui32CSPadreg = (volatile uint32_t *)AM_HAL_GPIO_PADREG(ui32IOMGPIO);
    ui32CSPadregVal = *pui32CSPadreg;
    140a:	f8db 1000 	ldr.w	r1, [fp]
    140e:	9102      	str	r1, [sp, #8]

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    1410:	f000 0c04 	and.w	ip, r0, #4
    1414:	2601      	movs	r6, #1
    1416:	40be      	lsls	r6, r7
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_GPIO_OUTPUT);
    1418:	f3ef 8010 	mrs	r0, PRIMASK
    ui32CSPadregVal = *pui32CSPadreg;

    //
    // Switch CS to a GPIO.
    //
    am_hal_gpio_out_bit_set(ui32IOMGPIO);
    141c:	f84c 600e 	str.w	r6, [ip, lr]
    am_hal_gpio_pin_config(ui32IOMGPIO, AM_HAL_GPIO_OUTPUT);
    1420:	9009      	str	r0, [sp, #36]	; 0x24
    1422:	b672      	cpsid	i
    1424:	4f54      	ldr	r7, [pc, #336]	; (1578 <am_hal_iom_workaround_word_write+0x6dc>)
    1426:	f8df c194 	ldr.w	ip, [pc, #404]	; 15bc <am_hal_iom_workaround_word_write+0x720>
    142a:	0856      	lsrs	r6, r2, #1
    142c:	f006 067c 	and.w	r6, r6, #124	; 0x7c
    1430:	2173      	movs	r1, #115	; 0x73
    1432:	6039      	str	r1, [r7, #0]
    1434:	0092      	lsls	r2, r2, #2
    1436:	f856 000c 	ldr.w	r0, [r6, ip]
    143a:	f002 021c 	and.w	r2, r2, #28
    143e:	2107      	movs	r1, #7
    1440:	4091      	lsls	r1, r2
    1442:	ea20 0001 	bic.w	r0, r0, r1
    1446:	2102      	movs	r1, #2
    1448:	fa01 f202 	lsl.w	r2, r1, r2
    144c:	4302      	orrs	r2, r0
    144e:	f846 200c 	str.w	r2, [r6, ip]
    1452:	f8db 6000 	ldr.w	r6, [fp]
    1456:	ea6f 0009 	mvn.w	r0, r9
    145a:	f04f 0918 	mov.w	r9, #24
    145e:	fa09 f10a 	lsl.w	r1, r9, sl
    1462:	ea06 0a00 	and.w	sl, r6, r0
    1466:	f10e 0e50 	add.w	lr, lr, #80	; 0x50
    146a:	ea41 020a 	orr.w	r2, r1, sl
    146e:	f8cb 2000 	str.w	r2, [fp]
    1472:	f858 600e 	ldr.w	r6, [r8, lr]
    1476:	2100      	movs	r1, #0
    1478:	4030      	ands	r0, r6
    147a:	f848 000e 	str.w	r0, [r8, lr]
    147e:	6039      	str	r1, [r7, #0]
    1480:	9f09      	ldr	r7, [sp, #36]	; 0x24
    1482:	f387 8810 	msr	PRIMASK, r7
    1486:	e6f9      	b.n	127c <am_hal_iom_workaround_word_write+0x3e0>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1488:	4943      	ldr	r1, [pc, #268]	; (1598 <am_hal_iom_workaround_word_write+0x6fc>)
    148a:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    148c:	f3c2 40c2 	ubfx	r0, r2, #19, #3
    1490:	2806      	cmp	r0, #6
    1492:	f000 80d9 	beq.w	1648 <am_hal_iom_workaround_word_write+0x7ac>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1496:	3124      	adds	r1, #36	; 0x24
    1498:	680e      	ldr	r6, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    149a:	f3c6 47c2 	ubfx	r7, r6, #19, #3
    149e:	2f06      	cmp	r7, #6
    14a0:	f47f aedc 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    14a4:	222e      	movs	r2, #46	; 0x2e
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    14a6:	468b      	mov	fp, r1
    14a8:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    14aa:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    14ae:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    14b2:	f04f 082c 	mov.w	r8, #44	; 0x2c
    14b6:	e7a3      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    14b8:	4937      	ldr	r1, [pc, #220]	; (1598 <am_hal_iom_workaround_word_write+0x6fc>)
    14ba:	680a      	ldr	r2, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    14bc:	f3c2 20c2 	ubfx	r0, r2, #11, #3
    14c0:	2804      	cmp	r0, #4
    14c2:	f000 80cb 	beq.w	165c <am_hal_iom_workaround_word_write+0x7c0>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    14c6:	3124      	adds	r1, #36	; 0x24
    14c8:	680e      	ldr	r6, [r1, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    14ca:	f3c6 67c2 	ubfx	r7, r6, #27, #3
    14ce:	2f06      	cmp	r7, #6
    14d0:	f47f aec4 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    14d4:	222f      	movs	r2, #47	; 0x2f
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    14d6:	468b      	mov	fp, r1
    14d8:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    14da:	f04f 497f 	mov.w	r9, #4278190080	; 0xff000000
    14de:	f04f 0a18 	mov.w	sl, #24
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    14e2:	f04f 082c 	mov.w	r8, #44	; 0x2c
    14e6:	e78b      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    14e8:	482c      	ldr	r0, [pc, #176]	; (159c <am_hal_iom_workaround_word_write+0x700>)
    14ea:	6806      	ldr	r6, [r0, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    14ec:	f3c6 67c2 	ubfx	r7, r6, #27, #3
    14f0:	2f04      	cmp	r7, #4
    14f2:	f47f aeb3 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    14f6:	2223      	movs	r2, #35	; 0x23
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    14f8:	4683      	mov	fp, r0
    14fa:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    14fc:	f04f 497f 	mov.w	r9, #4278190080	; 0xff000000
    1500:	f04f 0a18 	mov.w	sl, #24
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1504:	f04f 0820 	mov.w	r8, #32
    1508:	e77a      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    150a:	4f25      	ldr	r7, [pc, #148]	; (15a0 <am_hal_iom_workaround_word_write+0x704>)
    150c:	683a      	ldr	r2, [r7, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    150e:	f3c2 41c2 	ubfx	r1, r2, #19, #3
    1512:	2906      	cmp	r1, #6
    1514:	f47f aea2 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    1518:	2226      	movs	r2, #38	; 0x26
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    151a:	46bb      	mov	fp, r7
    151c:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    151e:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    1522:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1526:	f04f 0824 	mov.w	r8, #36	; 0x24
    152a:	e769      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    152c:	4a1d      	ldr	r2, [pc, #116]	; (15a4 <am_hal_iom_workaround_word_write+0x708>)
    152e:	4810      	ldr	r0, [pc, #64]	; (1570 <am_hal_iom_workaround_word_write+0x6d4>)
    1530:	9302      	str	r3, [sp, #8]
    1532:	f640 7107 	movw	r1, #3847	; 0xf07
    1536:	f7ff fa05 	bl	944 <am_hal_debug_error>
    153a:	9b02      	ldr	r3, [sp, #8]
    153c:	e60c      	b.n	1158 <am_hal_iom_workaround_word_write+0x2bc>
    153e:	4a19      	ldr	r2, [pc, #100]	; (15a4 <am_hal_iom_workaround_word_write+0x708>)
    1540:	480b      	ldr	r0, [pc, #44]	; (1570 <am_hal_iom_workaround_word_write+0x6d4>)
    1542:	9302      	str	r3, [sp, #8]
    1544:	f640 7107 	movw	r1, #3847	; 0xf07
    1548:	f7ff f9fc 	bl	944 <am_hal_debug_error>
    154c:	9b02      	ldr	r3, [sp, #8]
    154e:	e5ed      	b.n	112c <am_hal_iom_workaround_word_write+0x290>
    ui32HiFreq = am_hal_iom_frequency_get(ui32HiClkCfg);

    //
    // Validate return value to prevent DIVBY0 errors.
    //
    am_hal_debug_assert_msg(ui32HiFreq > 0, "Invalid Hi Frequency for IOM.");
    1550:	4a15      	ldr	r2, [pc, #84]	; (15a8 <am_hal_iom_workaround_word_write+0x70c>)
    1552:	4807      	ldr	r0, [pc, #28]	; (1570 <am_hal_iom_workaround_word_write+0x6d4>)
    1554:	f240 41de 	movw	r1, #1246	; 0x4de
    1558:	f7ff f9f4 	bl	944 <am_hal_debug_error>
    155c:	e538      	b.n	fd0 <am_hal_iom_workaround_word_write+0x134>
    // Make sure the transfer isn't too long for the hardware to support.
    //
    // Note: This is a little shorter than usual, since the workaround
    // consumes an extra byte at the beginning of the transfer.
    //
    am_hal_debug_assert_msg(ui32NumBytes <= 4091, "SPI transfer too big.");
    155e:	4a13      	ldr	r2, [pc, #76]	; (15ac <am_hal_iom_workaround_word_write+0x710>)
    1560:	4803      	ldr	r0, [pc, #12]	; (1570 <am_hal_iom_workaround_word_write+0x6d4>)
    1562:	f240 41b3 	movw	r1, #1203	; 0x4b3
    1566:	f7ff f9ed 	bl	944 <am_hal_debug_error>
    156a:	e4aa      	b.n	ec2 <am_hal_iom_workaround_word_write+0x26>
    156c:	400100ec 	.word	0x400100ec
    1570:	00004648 	.word	0x00004648
    1574:	40010094 	.word	0x40010094
    1578:	40010060 	.word	0x40010060
    157c:	4001010c 	.word	0x4001010c
    1580:	50008110 	.word	0x50008110
    1584:	5000810c 	.word	0x5000810c
    1588:	0800009d 	.word	0x0800009d
    158c:	365c0400 	.word	0x365c0400
    1590:	40010010 	.word	0x40010010
    1594:	40010028 	.word	0x40010028
    1598:	40010008 	.word	0x40010008
    159c:	40010020 	.word	0x40010020
    15a0:	40010024 	.word	0x40010024
    15a4:	00004614 	.word	0x00004614
    15a8:	000046dc 	.word	0x000046dc
    15ac:	000046c4 	.word	0x000046c4
    15b0:	40010054 	.word	0x40010054
    15b4:	4001002c 	.word	0x4001002c
    15b8:	40010090 	.word	0x40010090
    15bc:	40010040 	.word	0x40010040
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    15c0:	4e2b      	ldr	r6, [pc, #172]	; (1670 <am_hal_iom_workaround_word_write+0x7d4>)
    15c2:	6837      	ldr	r7, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    15c4:	f3c7 21c2 	ubfx	r1, r7, #11, #3
    15c8:	2906      	cmp	r1, #6
    15ca:	d020      	beq.n	160e <am_hal_iom_workaround_word_write+0x772>
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    15cc:	3604      	adds	r6, #4
    15ce:	6832      	ldr	r2, [r6, #0]
            ui8FncSelVal = (ui8PadRegVal & 0x38) >> 3;

            //
            // Is the FNCSEL filed for this pad set to the expected value?
            //
            if ( ui8FncSelVal == g_IOMPads[index].funcsel )
    15d0:	f3c2 40c2 	ubfx	r0, r2, #19, #3
    15d4:	2806      	cmp	r0, #6
    15d6:	f47f ae41 	bne.w	125c <am_hal_iom_workaround_word_write+0x3c0>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    15da:	2222      	movs	r2, #34	; 0x22
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    15dc:	46b3      	mov	fp, r6
    15de:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    15e0:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    15e4:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    15e8:	f04f 0820 	mov.w	r8, #32
    15ec:	e708      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
        //
        ui32DelayTime = ((19 * AM_HAL_CLKGEN_FREQ_MAX_HZ) / (ui32HiFreq * 3));
        ui32FirstWord = ((ui32Options & 0xFF00) << 16);
        if ( ui32FirstWord & 0x80000000 )
        {
            bRising = true;
    15ee:	2101      	movs	r1, #1
    15f0:	9106      	str	r1, [sp, #24]
    15f2:	e587      	b.n	1104 <am_hal_iom_workaround_word_write+0x268>

    //
    // Starting with the current clock configuration parameters, find a value
    // of FSEL that will bring our total frequency down to or below maxFreq.
    //
    for ( ui32Fsel = 1; ui32Fsel < 8; ui32Fsel++ )
    15f4:	2101      	movs	r1, #1
    15f6:	e56b      	b.n	10d0 <am_hal_iom_workaround_word_write+0x234>
    15f8:	f04f 0e01 	mov.w	lr, #1
    15fc:	e499      	b.n	f32 <am_hal_iom_workaround_word_write+0x96>
    15fe:	2102      	movs	r1, #2
    1600:	e566      	b.n	10d0 <am_hal_iom_workaround_word_write+0x234>
    1602:	2103      	movs	r1, #3
    1604:	e564      	b.n	10d0 <am_hal_iom_workaround_word_write+0x234>
    1606:	2104      	movs	r1, #4
    1608:	e562      	b.n	10d0 <am_hal_iom_workaround_word_write+0x234>
    160a:	2105      	movs	r1, #5
    160c:	e560      	b.n	10d0 <am_hal_iom_workaround_word_write+0x234>
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    160e:	221d      	movs	r2, #29
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1610:	46b3      	mov	fp, r6
    1612:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    1614:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    1618:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    161c:	f04f 081c 	mov.w	r8, #28
    1620:	e6ee      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    1622:	f04f 0a10 	mov.w	sl, #16
    1626:	2212      	movs	r2, #18
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1628:	46b3      	mov	fp, r6
    162a:	46d0      	mov	r8, sl
    162c:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    162e:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    1632:	e6e5      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    1634:	2211      	movs	r2, #17
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1636:	468b      	mov	fp, r1
    1638:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    163a:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    163e:	f04f 0a08 	mov.w	sl, #8
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1642:	f04f 0810 	mov.w	r8, #16
    1646:	e6db      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    1648:	220a      	movs	r2, #10
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    164a:	468b      	mov	fp, r1
    164c:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    164e:	f44f 097f 	mov.w	r9, #16711680	; 0xff0000
    1652:	f04f 0a10 	mov.w	sl, #16
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1656:	f04f 0808 	mov.w	r8, #8
    165a:	e6d1      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    165c:	f04f 0a08 	mov.w	sl, #8
    1660:	2209      	movs	r2, #9
        if ( g_IOMPads[index].channel == ui32ChipSelect )
        {
            //
            // Get the PAD register value
            //
            ui8PadRegVal = ((AM_REGVAL(AM_HAL_GPIO_PADREG(g_IOMPads[index].pad))) &
    1662:	468b      	mov	fp, r1
    1664:	46d0      	mov	r8, sl
    1666:	4694      	mov	ip, r2
                             AM_HAL_GPIO_PADREG_M(g_IOMPads[index].pad)) >>
    1668:	f44f 497f 	mov.w	r9, #65280	; 0xff00
    166c:	e6c8      	b.n	1400 <am_hal_iom_workaround_word_write+0x564>
    166e:	bf00      	nop
    1670:	4001001c 	.word	0x4001001c

00001674 <am_hal_iom_spi_write_nb.part.6>:
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    1674:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1678:	f500 24a0 	add.w	r4, r0, #327680	; 0x50000
    167c:	3404      	adds	r4, #4
    167e:	0324      	lsls	r4, r4, #12
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    1680:	4607      	mov	r7, r0
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1682:	f8d4 011c 	ldr.w	r0, [r4, #284]	; 0x11c
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    1686:	4e68      	ldr	r6, [pc, #416]	; (1828 <am_hal_iom_spi_write_nb.part.6+0x1b4>)
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    1688:	f3c0 05c0 	ubfx	r5, r0, #3, #1
    168c:	2d00      	cmp	r5, #0
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    168e:	f04f 0e01 	mov.w	lr, #1
    1692:	f806 e007 	strb.w	lr, [r6, r7]
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    1696:	461d      	mov	r5, r3
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1698:	f240 70ff 	movw	r0, #2047	; 0x7ff
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    169c:	bf15      	itete	ne
    169e:	233c      	movne	r3, #60	; 0x3c
    16a0:	237c      	moveq	r3, #124	; 0x7c
    16a2:	2640      	movne	r6, #64	; 0x40
    16a4:	2680      	moveq	r6, #128	; 0x80
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;

    //
    // Check to see if we need to do the workaround.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    16a6:	2f04      	cmp	r7, #4
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    16a8:	4689      	mov	r9, r1
    16aa:	4690      	mov	r8, r2
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    16ac:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208

    //
    // Check to see if we need to do the workaround.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    16b0:	d004      	beq.n	16bc <am_hal_iom_spi_write_nb.part.6+0x48>
    uint32_t ui32Index;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    16b2:	2f05      	cmp	r7, #5
    16b4:	d908      	bls.n	16c8 <am_hal_iom_spi_write_nb.part.6+0x54>
            am_hal_iom_spi_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32ChipSelect,
                                   ui32NumBytes, ui32Options);
        }
    }
    return ui32Status;
}
    16b6:	2000      	movs	r0, #0
    16b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
isRevB0(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B )
    16bc:	4a5b      	ldr	r2, [pc, #364]	; (182c <am_hal_iom_spi_write_nb.part.6+0x1b8>)
    16be:	6811      	ldr	r1, [r2, #0]
    16c0:	b2c8      	uxtb	r0, r1
    16c2:	2820      	cmp	r0, #32
    16c4:	f000 8093 	beq.w	17ee <am_hal_iom_spi_write_nb.part.6+0x17a>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    16c8:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    16cc:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    else
    {
        //
        // Figure out how many bytes we can write to the FIFO immediately.
        //
        ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    16d0:	42ae      	cmp	r6, r5
    16d2:	bf28      	it	cs
    16d4:	462e      	movcs	r6, r5
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    16d6:	f013 0f08 	tst.w	r3, #8
    16da:	bf14      	ite	ne
    16dc:	2340      	movne	r3, #64	; 0x40
    16de:	2380      	moveq	r3, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    16e0:	1a99      	subs	r1, r3, r2
    16e2:	f001 00fc 	and.w	r0, r1, #252	; 0xfc
    16e6:	4286      	cmp	r6, r0
    16e8:	f200 8097 	bhi.w	181a <am_hal_iom_spi_write_nb.part.6+0x1a6>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    16ec:	2e00      	cmp	r6, #0
    16ee:	d0e2      	beq.n	16b6 <am_hal_iom_spi_write_nb.part.6+0x42>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    16f0:	4642      	mov	r2, r8
    16f2:	ea6f 0c08 	mvn.w	ip, r8
    16f6:	f852 3b04 	ldr.w	r3, [r2], #4
    16fa:	6023      	str	r3, [r4, #0]
    16fc:	44c4      	add	ip, r8

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    16fe:	ebc8 0102 	rsb	r1, r8, r2
    1702:	44b4      	add	ip, r6
    1704:	428e      	cmp	r6, r1
    1706:	f3cc 0082 	ubfx	r0, ip, #2, #3
    170a:	d942      	bls.n	1792 <am_hal_iom_spi_write_nb.part.6+0x11e>
    170c:	b320      	cbz	r0, 1758 <am_hal_iom_spi_write_nb.part.6+0xe4>
    170e:	2801      	cmp	r0, #1
    1710:	d01b      	beq.n	174a <am_hal_iom_spi_write_nb.part.6+0xd6>
    1712:	2802      	cmp	r0, #2
    1714:	d016      	beq.n	1744 <am_hal_iom_spi_write_nb.part.6+0xd0>
    1716:	2803      	cmp	r0, #3
    1718:	d011      	beq.n	173e <am_hal_iom_spi_write_nb.part.6+0xca>
    171a:	2804      	cmp	r0, #4
    171c:	d00c      	beq.n	1738 <am_hal_iom_spi_write_nb.part.6+0xc4>
    171e:	2805      	cmp	r0, #5
    1720:	d007      	beq.n	1732 <am_hal_iom_spi_write_nb.part.6+0xbe>
    1722:	2806      	cmp	r0, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1724:	bf1c      	itt	ne
    1726:	f852 0b04 	ldrne.w	r0, [r2], #4
    172a:	6020      	strne	r0, [r4, #0]
    172c:	f852 3b04 	ldr.w	r3, [r2], #4
    1730:	6023      	str	r3, [r4, #0]
    1732:	f852 1b04 	ldr.w	r1, [r2], #4
    1736:	6021      	str	r1, [r4, #0]
    1738:	f852 0b04 	ldr.w	r0, [r2], #4
    173c:	6020      	str	r0, [r4, #0]
    173e:	f852 3b04 	ldr.w	r3, [r2], #4
    1742:	6023      	str	r3, [r4, #0]
    1744:	f852 1b04 	ldr.w	r1, [r2], #4
    1748:	6021      	str	r1, [r4, #0]
    174a:	f852 0b04 	ldr.w	r0, [r2], #4
    174e:	6020      	str	r0, [r4, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1750:	ebc8 0c02 	rsb	ip, r8, r2
    1754:	4566      	cmp	r6, ip
    1756:	d91c      	bls.n	1792 <am_hal_iom_spi_write_nb.part.6+0x11e>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1758:	4611      	mov	r1, r2
    175a:	3220      	adds	r2, #32
    175c:	f851 3b04 	ldr.w	r3, [r1], #4
    1760:	6023      	str	r3, [r4, #0]
    1762:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    1766:	6020      	str	r0, [r4, #0]
    1768:	6849      	ldr	r1, [r1, #4]
    176a:	6021      	str	r1, [r4, #0]
    176c:	f852 3c14 	ldr.w	r3, [r2, #-20]
    1770:	6023      	str	r3, [r4, #0]
    1772:	f852 0c10 	ldr.w	r0, [r2, #-16]
    1776:	6020      	str	r0, [r4, #0]
    1778:	f852 1c0c 	ldr.w	r1, [r2, #-12]
    177c:	6021      	str	r1, [r4, #0]
    177e:	f852 3c08 	ldr.w	r3, [r2, #-8]
    1782:	6023      	str	r3, [r4, #0]
    1784:	f852 0c04 	ldr.w	r0, [r2, #-4]
    1788:	6020      	str	r0, [r4, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    178a:	ebc8 0102 	rsb	r1, r8, r2
    178e:	428e      	cmp	r6, r1
    1790:	d8e2      	bhi.n	1758 <am_hal_iom_spi_write_nb.part.6+0xe4>
        if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
        {
            //
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    1792:	4a27      	ldr	r2, [pc, #156]	; (1830 <am_hal_iom_spi_write_nb.part.6+0x1bc>)
    1794:	eb07 0787 	add.w	r7, r7, r7, lsl #2
    1798:	00b8      	lsls	r0, r7, #2
    179a:	1813      	adds	r3, r2, r0
            //
            // Update the pointer and the byte counter based on the portion of
            // the transfer we just sent to the fifo.
            //
            g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
            g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    179c:	f026 0703 	bic.w	r7, r6, #3
        if ( am_hal_iom_fifo_write(ui32Module, pui32Data, ui32TransferSize) > 0 )
        {
            //
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    17a0:	2101      	movs	r1, #1
    17a2:	5011      	str	r1, [r2, r0]

            //
            // Update the pointer and the byte counter based on the portion of
            // the transfer we just sent to the fifo.
            //
            g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    17a4:	1bae      	subs	r6, r5, r6
            g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    17a6:	4447      	add	r7, r8
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
            g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
            g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
            g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    17a8:	9a09      	ldr	r2, [sp, #36]	; 0x24
            g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    17aa:	9808      	ldr	r0, [sp, #32]
            // Prepare the global IOM buffer structure.
            //
            g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
            g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
            g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
            g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    17ac:	611a      	str	r2, [r3, #16]
            g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    17ae:	60d8      	str	r0, [r3, #12]

            //
            // Update the pointer and the byte counter based on the portion of
            // the transfer we just sent to the fifo.
            //
            g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
    17b0:	609e      	str	r6, [r3, #8]
            g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
    17b2:	605f      	str	r7, [r3, #4]
                       uint32_t ui32ChipSelect, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    uint32_t ui32Command;

    am_hal_debug_assert_msg(ui32NumBytes > 0,
    17b4:	b92d      	cbnz	r5, 17c2 <am_hal_iom_spi_write_nb.part.6+0x14e>
    17b6:	4a1f      	ldr	r2, [pc, #124]	; (1834 <am_hal_iom_spi_write_nb.part.6+0x1c0>)
    17b8:	481f      	ldr	r0, [pc, #124]	; (1838 <am_hal_iom_spi_write_nb.part.6+0x1c4>)
    17ba:	f640 219c 	movw	r1, #2716	; 0xa9c
    17be:	f7ff f8c1 	bl	944 <am_hal_debug_error>
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    17c2:	9b08      	ldr	r3, [sp, #32]
    17c4:	ea4f 4109 	mov.w	r1, r9, lsl #16
    17c8:	f023 4723 	bic.w	r7, r3, #2734686208	; 0xa3000000
    17cc:	f401 26e0 	and.w	r6, r1, #458752	; 0x70000
    17d0:	f007 22ff 	and.w	r2, r7, #4278255360	; 0xff00ff00
    17d4:	b2e9      	uxtb	r1, r5
    17d6:	ea46 0002 	orr.w	r0, r6, r2
    17da:	03ed      	lsls	r5, r5, #15
    17dc:	4308      	orrs	r0, r1
    17de:	f005 63f0 	and.w	r3, r5, #125829120	; 0x7800000
    17e2:	4303      	orrs	r3, r0


    //
    // Write the complete command word to the IOM command register.
    //
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    17e4:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
            am_hal_iom_spi_cmd_run(AM_HAL_IOM_WRITE, ui32Module, ui32ChipSelect,
                                   ui32NumBytes, ui32Options);
        }
    }
    return ui32Status;
}
    17e8:	2000      	movs	r0, #0
    17ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    {
        //
        // Figure out how many bytes we can write to the FIFO immediately,
        // accounting for the extra word from the workaround.
        //
        ui32TransferSize = (ui32NumBytes <= (ui32MaxFifoSize - 4) ?  ui32NumBytes :
    17ee:	42ab      	cmp	r3, r5
    17f0:	bf28      	it	cs
    17f2:	462b      	movcs	r3, r5
                            (ui32MaxFifoSize - 4));

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    17f4:	4e0e      	ldr	r6, [pc, #56]	; (1830 <am_hal_iom_spi_write_nb.part.6+0x1bc>)
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
    17f6:	f023 0703 	bic.w	r7, r3, #3
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
    17fa:	1aec      	subs	r4, r5, r3

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
    17fc:	4447      	add	r7, r8
        //
        // Start the write on the bus using the workaround. This includes both
        // the command write and the first fifo write, so we won't need to do
        // either of those things manually.
        //
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    17fe:	462a      	mov	r2, r5
    1800:	9b08      	ldr	r3, [sp, #32]
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    1802:	9d09      	ldr	r5, [sp, #36]	; 0x24

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
    1804:	6577      	str	r7, [r6, #84]	; 0x54
        //
        // Start the write on the bus using the workaround. This includes both
        // the command write and the first fifo write, so we won't need to do
        // either of those things manually.
        //
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    1806:	4648      	mov	r0, r9
    1808:	4641      	mov	r1, r8
        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
    180a:	65b4      	str	r4, [r6, #88]	; 0x58
                            (ui32MaxFifoSize - 4));

        //
        // Prepare the global IOM buffer structure.
        //
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
    180c:	f8c6 e050 	str.w	lr, [r6, #80]	; 0x50
        g_psIOMBuffers[ui32Module].pui32Data = pui32Data + (ui32TransferSize / 4);
        g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes - ui32TransferSize;
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    1810:	6635      	str	r5, [r6, #96]	; 0x60
        g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    1812:	65f3      	str	r3, [r6, #92]	; 0x5c
        //
        // Start the write on the bus using the workaround. This includes both
        // the command write and the first fifo write, so we won't need to do
        // either of those things manually.
        //
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    1814:	f7ff fb42 	bl	e9c <am_hal_iom_workaround_word_write>
    1818:	e74d      	b.n	16b6 <am_hal_iom_spi_write_nb.part.6+0x42>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    181a:	4a08      	ldr	r2, [pc, #32]	; (183c <am_hal_iom_spi_write_nb.part.6+0x1c8>)
    181c:	4806      	ldr	r0, [pc, #24]	; (1838 <am_hal_iom_spi_write_nb.part.6+0x1c4>)
    181e:	f640 7107 	movw	r1, #3847	; 0xf07
    1822:	f7ff f88f 	bl	944 <am_hal_debug_error>
    1826:	e763      	b.n	16f0 <am_hal_iom_spi_write_nb.part.6+0x7c>
    1828:	1000105c 	.word	0x1000105c
    182c:	4002000c 	.word	0x4002000c
    1830:	10001374 	.word	0x10001374
    1834:	000046fc 	.word	0x000046fc
    1838:	00004648 	.word	0x00004648
    183c:	00004614 	.word	0x00004614

00001840 <am_hal_iom_spi_read_nb.part.7>:
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_read_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    1840:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1844:	f500 26a0 	add.w	r6, r0, #327680	; 0x50000
    1848:	3604      	adds	r6, #4
    184a:	0336      	lsls	r6, r6, #12
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    184c:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 1948 <am_hal_iom_spi_read_nb.part.7+0x108>
    1850:	f04f 0801 	mov.w	r8, #1

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1854:	f240 7bff 	movw	fp, #2047	; 0x7ff
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    1858:	2804      	cmp	r0, #4
    //
    // Need to mark IOM busy to avoid another transaction to be scheduled.
    // This is to take care of a race condition in Queue mode, where the IDLE
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;
    185a:	f80a 8000 	strb.w	r8, [sl, r0]
//! successfully initiated. The status of the transaction is not known till the
//! callback is called on completion
//
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_read_nb(uint32_t ui32Module, uint32_t ui32ChipSelect,
    185e:	b083      	sub	sp, #12
    1860:	4605      	mov	r5, r0
    1862:	460f      	mov	r7, r1
    1864:	4691      	mov	r9, r2
    1866:	461c      	mov	r4, r3
    // set is not a guarantee that the CMDCMP has been received
    //
    g_bIomBusy[ui32Module] = true;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1868:	f8c6 b208 	str.w	fp, [r6, #520]	; 0x208
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    186c:	d02c      	beq.n	18c8 <am_hal_iom_spi_read_nb.part.7+0x88>
    }

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    186e:	482f      	ldr	r0, [pc, #188]	; (192c <am_hal_iom_spi_read_nb.part.7+0xec>)
    1870:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    1874:	00aa      	lsls	r2, r5, #2
    1876:	1883      	adds	r3, r0, r2
    1878:	2102      	movs	r1, #2
    187a:	5081      	str	r1, [r0, r2]
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    187c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    187e:	980c      	ldr	r0, [sp, #48]	; 0x30

    //
    // Prepare the global IOM buffer structure.
    //
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
    1880:	f8c3 9004 	str.w	r9, [r3, #4]
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
    1884:	609c      	str	r4, [r3, #8]
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
    1886:	611d      	str	r5, [r3, #16]
    g_psIOMBuffers[ui32Module].ui32Options = ui32Options;
    1888:	60d8      	str	r0, [r3, #12]
                       uint32_t ui32ChipSelect, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    uint32_t ui32Command;

    am_hal_debug_assert_msg(ui32NumBytes > 0,
    188a:	b92c      	cbnz	r4, 1898 <am_hal_iom_spi_read_nb.part.7+0x58>
    188c:	4a28      	ldr	r2, [pc, #160]	; (1930 <am_hal_iom_spi_read_nb.part.7+0xf0>)
    188e:	4829      	ldr	r0, [pc, #164]	; (1934 <am_hal_iom_spi_read_nb.part.7+0xf4>)
    1890:	f640 219c 	movw	r1, #2716	; 0xa9c
    1894:	f7ff f856 	bl	944 <am_hal_debug_error>
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    1898:	03e2      	lsls	r2, r4, #15
    189a:	fa5f fc84 	uxtb.w	ip, r4
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    189e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    18a0:	f002 61f0 	and.w	r1, r2, #125829120	; 0x7800000
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    18a4:	043f      	lsls	r7, r7, #16
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    18a6:	f04c 4400 	orr.w	r4, ip, #2147483648	; 0x80000000
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    18aa:	f023 4023 	bic.w	r0, r3, #2734686208	; 0xa3000000
    18ae:	f407 25e0 	and.w	r5, r7, #458752	; 0x70000
    //
    // Set the transfer length (the length field is split, so this requires
    // some swizzling).
    //
    ui32Command |= ((ui32NumBytes & 0xF00) << 15);
    ui32Command |= (ui32NumBytes & 0xFF);
    18b2:	430c      	orrs	r4, r1
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    18b4:	f000 22ff 	and.w	r2, r0, #4278255360	; 0xff00ff00
    18b8:	4325      	orrs	r5, r4
    18ba:	4315      	orrs	r5, r2


    //
    // Write the complete command word to the IOM command register.
    //
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    18bc:	f8c6 5110 	str.w	r5, [r6, #272]	; 0x110
    // Start the read transaction on the bus.
    //
    am_hal_iom_spi_cmd_run(AM_HAL_IOM_READ, ui32Module, ui32ChipSelect,
                           ui32NumBytes, ui32Options);

    return ui32Status;
    18c0:	2000      	movs	r0, #0
}
    18c2:	b003      	add	sp, #12
    18c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    18c8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    18ca:	f013 4180 	ands.w	r1, r3, #1073741824	; 0x40000000
    18ce:	d1ce      	bne.n	186e <am_hal_iom_spi_read_nb.part.7+0x2e>
isRevB0(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B )
    18d0:	4819      	ldr	r0, [pc, #100]	; (1938 <am_hal_iom_spi_read_nb.part.7+0xf8>)
    18d2:	6802      	ldr	r2, [r0, #0]
    18d4:	b2d3      	uxtb	r3, r2
    18d6:	2b20      	cmp	r3, #32
    18d8:	d1c9      	bne.n	186e <am_hal_iom_spi_read_nb.part.7+0x2e>
        //
        // We might mess up the interrupt handler behavior if we allow this
        // polled transaction to complete with interrupts enabled. We'll
        // briefly turn them off here.
        //
        ui32IntConfig = AM_REGn(IOMSTR, 4, INTEN);
    18da:	4818      	ldr	r0, [pc, #96]	; (193c <am_hal_iom_spi_read_nb.part.7+0xfc>)
    18dc:	6803      	ldr	r3, [r0, #0]
        AM_REGn(IOMSTR, 4, INTEN) = 0;
    18de:	4817      	ldr	r0, [pc, #92]	; (193c <am_hal_iom_spi_read_nb.part.7+0xfc>)
        //
        // We might mess up the interrupt handler behavior if we allow this
        // polled transaction to complete with interrupts enabled. We'll
        // briefly turn them off here.
        //
        ui32IntConfig = AM_REGn(IOMSTR, 4, INTEN);
    18e0:	9301      	str	r3, [sp, #4]
        AM_REGn(IOMSTR, 4, INTEN) = 0;
    18e2:	6001      	str	r1, [r0, #0]

        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    18e4:	460a      	mov	r2, r1
    18e6:	990c      	ldr	r1, [sp, #48]	; 0x30
    18e8:	4638      	mov	r0, r7
    18ea:	f041 5380 	orr.w	r3, r1, #268435456	; 0x10000000
    18ee:	4649      	mov	r1, r9
    18f0:	f7ff fad4 	bl	e9c <am_hal_iom_workaround_word_write>

        //
        // Wait for the dummy word to go out over the bus.
        //
        // Make sure the command complete has also been raised
        waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    18f4:	4a12      	ldr	r2, [pc, #72]	; (1940 <am_hal_iom_spi_read_nb.part.7+0x100>)
    18f6:	4643      	mov	r3, r8
    18f8:	6910      	ldr	r0, [r2, #16]
    18fa:	f506 7101 	add.w	r1, r6, #516	; 0x204
    18fe:	4642      	mov	r2, r8
    1900:	f7ff f828 	bl	954 <am_hal_flash_delay_status_change>
                     AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                     AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

        if (waitStatus != 1)
    1904:	2801      	cmp	r0, #1
    1906:	d004      	beq.n	1912 <am_hal_iom_spi_read_nb.part.7+0xd2>
        {
            g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    1908:	4e0e      	ldr	r6, [pc, #56]	; (1944 <am_hal_iom_spi_read_nb.part.7+0x104>)
            return ui32Status;
    190a:	4640      	mov	r0, r8
                     AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                     AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

        if (waitStatus != 1)
        {
            g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    190c:	f886 8004 	strb.w	r8, [r6, #4]
    1910:	e7d7      	b.n	18c2 <am_hal_iom_spi_read_nb.part.7+0x82>

        //
        // The workaround will send our offset for us, so we can run a RAW
        // command after.
        //
        ui32Options |= AM_HAL_IOM_RAW;
    1912:	9b0c      	ldr	r3, [sp, #48]	; 0x30

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, 4, INTEN) = ui32IntConfig;
    1914:	4909      	ldr	r1, [pc, #36]	; (193c <am_hal_iom_spi_read_nb.part.7+0xfc>)

        //
        // Re-mark IOM as busy
        //

        g_bIomBusy[ui32Module] = true;
    1916:	f88a 0004 	strb.w	r0, [sl, #4]

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, 4, INTEN) = ui32IntConfig;
    191a:	9a01      	ldr	r2, [sp, #4]
        g_bIomBusy[ui32Module] = true;

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    191c:	f8c6 b208 	str.w	fp, [r6, #520]	; 0x208

        //
        // The workaround will send our offset for us, so we can run a RAW
        // command after.
        //
        ui32Options |= AM_HAL_IOM_RAW;
    1920:	f043 4080 	orr.w	r0, r3, #1073741824	; 0x40000000
    1924:	900c      	str	r0, [sp, #48]	; 0x30

        //
        // Re-enable IOM interrupts. Make sure CMDCMP is cleared
        //
        AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
        AM_REGn(IOMSTR, 4, INTEN) = ui32IntConfig;
    1926:	600a      	str	r2, [r1, #0]
    1928:	e7a1      	b.n	186e <am_hal_iom_spi_read_nb.part.7+0x2e>
    192a:	bf00      	nop
    192c:	10001374 	.word	0x10001374
    1930:	000046fc 	.word	0x000046fc
    1934:	00004648 	.word	0x00004648
    1938:	4002000c 	.word	0x4002000c
    193c:	50008200 	.word	0x50008200
    1940:	1000135c 	.word	0x1000135c
    1944:	10001054 	.word	0x10001054
    1948:	1000105c 	.word	0x1000105c

0000194c <am_hal_iom_spi_write_nq>:
    uint32_t waitStatus;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    194c:	2805      	cmp	r0, #5
    194e:	d901      	bls.n	1954 <am_hal_iom_spi_write_nq+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    1950:	2002      	movs	r0, #2
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;

    return ui32Status;
}
    1952:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write_nq(uint32_t ui32Module, uint32_t ui32ChipSelect,
                        uint32_t *pui32Data, uint32_t ui32NumBytes,
                        uint32_t ui32Options)
{
    1954:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1958:	4cbf      	ldr	r4, [pc, #764]	; (1c58 <am_hal_iom_spi_write_nq+0x30c>)
    195a:	b083      	sub	sp, #12
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    195c:	5c25      	ldrb	r5, [r4, r0]
    195e:	f005 06ff 	and.w	r6, r5, #255	; 0xff
    1962:	2d00      	cmp	r5, #0
    1964:	d1fa      	bne.n	195c <am_hal_iom_spi_write_nq+0x10>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1966:	f8df 9304 	ldr.w	r9, [pc, #772]	; 1c6c <am_hal_iom_spi_write_nq+0x320>
    if (ui32NumBytes == 0)
    196a:	1e5f      	subs	r7, r3, #1
    196c:	f640 78fe 	movw	r8, #4094	; 0xffe
    1970:	4547      	cmp	r7, r8
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1972:	f809 6000 	strb.w	r6, [r9, r0]
    if (ui32NumBytes == 0)
    1976:	d907      	bls.n	1988 <am_hal_iom_spi_write_nq+0x3c>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    1978:	f04f 0b03 	mov.w	fp, #3
    197c:	f809 b000 	strb.w	fp, [r9, r0]
        return ui32Status;
    1980:	4658      	mov	r0, fp
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;

    return ui32Status;
}
    1982:	b003      	add	sp, #12
    1984:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1988:	4604      	mov	r4, r0
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    198a:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    198e:	3004      	adds	r0, #4
    1990:	0307      	lsls	r7, r0, #12
    1992:	461d      	mov	r5, r3
    1994:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
    1998:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    199c:	2800      	cmp	r0, #0
    199e:	4690      	mov	r8, r2
    19a0:	468b      	mov	fp, r1
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    19a2:	f240 72ff 	movw	r2, #2047	; 0x7ff
    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
                       AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    19a6:	f8d7 1200 	ldr.w	r1, [r7, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    19aa:	f8c7 6200 	str.w	r6, [r7, #512]	; 0x200
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    19ae:	bf15      	itete	ne
    19b0:	f04f 0e3c 	movne.w	lr, #60	; 0x3c
    19b4:	f04f 0e7c 	moveq.w	lr, #124	; 0x7c
    19b8:	2640      	movne	r6, #64	; 0x40
    19ba:	2680      	moveq	r6, #128	; 0x80
    // get that first byte out of the way.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    19bc:	2c04      	cmp	r4, #4
    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
                       AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    19be:	9100      	str	r1, [sp, #0]
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    19c0:	f8c7 2208 	str.w	r2, [r7, #520]	; 0x208
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ?
    19c4:	f507 7a8e 	add.w	sl, r7, #284	; 0x11c
    // get that first byte out of the way.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    19c8:	f000 8122 	beq.w	1c10 <am_hal_iom_spi_write_nq+0x2c4>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    19cc:	f8d7 011c 	ldr.w	r0, [r7, #284]	; 0x11c
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    19d0:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    19d4:	f010 0f08 	tst.w	r0, #8
    19d8:	bf14      	ite	ne
    19da:	2040      	movne	r0, #64	; 0x40
    19dc:	2080      	moveq	r0, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    19de:	1a83      	subs	r3, r0, r2
    else
    {
        //
        // Figure out how many bytes we can write to the FIFO immediately.
        //
        ui32TransferSize = (ui32NumBytes <= ui32MaxFifoSize ? ui32NumBytes :
    19e0:	42ae      	cmp	r6, r5
    19e2:	bf28      	it	cs
    19e4:	462e      	movcs	r6, r5
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    19e6:	f003 01fc 	and.w	r1, r3, #252	; 0xfc
    19ea:	428e      	cmp	r6, r1
    19ec:	f200 8140 	bhi.w	1c70 <am_hal_iom_spi_write_nq+0x324>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    19f0:	4640      	mov	r0, r8
    19f2:	ea6f 0c08 	mvn.w	ip, r8
    19f6:	f850 2b04 	ldr.w	r2, [r0], #4
    19fa:	603a      	str	r2, [r7, #0]
    19fc:	44c4      	add	ip, r8

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    19fe:	ebc8 0300 	rsb	r3, r8, r0
    1a02:	44b4      	add	ip, r6
    1a04:	429e      	cmp	r6, r3
    1a06:	f3cc 0182 	ubfx	r1, ip, #2, #3
    1a0a:	d943      	bls.n	1a94 <am_hal_iom_spi_write_nq+0x148>
    1a0c:	b321      	cbz	r1, 1a58 <am_hal_iom_spi_write_nq+0x10c>
    1a0e:	2901      	cmp	r1, #1
    1a10:	d01b      	beq.n	1a4a <am_hal_iom_spi_write_nq+0xfe>
    1a12:	2902      	cmp	r1, #2
    1a14:	d016      	beq.n	1a44 <am_hal_iom_spi_write_nq+0xf8>
    1a16:	2903      	cmp	r1, #3
    1a18:	d011      	beq.n	1a3e <am_hal_iom_spi_write_nq+0xf2>
    1a1a:	2904      	cmp	r1, #4
    1a1c:	d00c      	beq.n	1a38 <am_hal_iom_spi_write_nq+0xec>
    1a1e:	2905      	cmp	r1, #5
    1a20:	d007      	beq.n	1a32 <am_hal_iom_spi_write_nq+0xe6>
    1a22:	2906      	cmp	r1, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1a24:	bf1c      	itt	ne
    1a26:	f850 1b04 	ldrne.w	r1, [r0], #4
    1a2a:	6039      	strne	r1, [r7, #0]
    1a2c:	f850 2b04 	ldr.w	r2, [r0], #4
    1a30:	603a      	str	r2, [r7, #0]
    1a32:	f850 3b04 	ldr.w	r3, [r0], #4
    1a36:	603b      	str	r3, [r7, #0]
    1a38:	f850 1b04 	ldr.w	r1, [r0], #4
    1a3c:	6039      	str	r1, [r7, #0]
    1a3e:	f850 2b04 	ldr.w	r2, [r0], #4
    1a42:	603a      	str	r2, [r7, #0]
    1a44:	f850 3b04 	ldr.w	r3, [r0], #4
    1a48:	603b      	str	r3, [r7, #0]
    1a4a:	f850 1b04 	ldr.w	r1, [r0], #4
    1a4e:	6039      	str	r1, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1a50:	ebc8 0e00 	rsb	lr, r8, r0
    1a54:	4576      	cmp	r6, lr
    1a56:	d91d      	bls.n	1a94 <am_hal_iom_spi_write_nq+0x148>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1a58:	4684      	mov	ip, r0
    1a5a:	3020      	adds	r0, #32
    1a5c:	f85c 2b04 	ldr.w	r2, [ip], #4
    1a60:	603a      	str	r2, [r7, #0]
    1a62:	f850 3c1c 	ldr.w	r3, [r0, #-28]
    1a66:	603b      	str	r3, [r7, #0]
    1a68:	f8dc 1004 	ldr.w	r1, [ip, #4]
    1a6c:	6039      	str	r1, [r7, #0]
    1a6e:	f850 2c14 	ldr.w	r2, [r0, #-20]
    1a72:	603a      	str	r2, [r7, #0]
    1a74:	f850 3c10 	ldr.w	r3, [r0, #-16]
    1a78:	603b      	str	r3, [r7, #0]
    1a7a:	f850 1c0c 	ldr.w	r1, [r0, #-12]
    1a7e:	6039      	str	r1, [r7, #0]
    1a80:	f850 2c08 	ldr.w	r2, [r0, #-8]
    1a84:	603a      	str	r2, [r7, #0]
    1a86:	f850 3c04 	ldr.w	r3, [r0, #-4]
    1a8a:	603b      	str	r3, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1a8c:	ebc8 0100 	rsb	r1, r8, r0
    1a90:	428e      	cmp	r6, r1
    1a92:	d8e1      	bhi.n	1a58 <am_hal_iom_spi_write_nq+0x10c>
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    1a94:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    1a96:	ea4f 400b 	mov.w	r0, fp, lsl #16
    1a9a:	f400 23e0 	and.w	r3, r0, #458752	; 0x70000
    1a9e:	b2e9      	uxtb	r1, r5
    1aa0:	f022 4023 	bic.w	r0, r2, #2734686208	; 0xa3000000
    1aa4:	4319      	orrs	r1, r3
    1aa6:	f000 22ff 	and.w	r2, r0, #4278255360	; 0xff00ff00
    1aaa:	03eb      	lsls	r3, r5, #15
    1aac:	430a      	orrs	r2, r1
    1aae:	f003 61f0 	and.w	r1, r3, #125829120	; 0x7800000
    1ab2:	4311      	orrs	r1, r2


    //
    // Write the complete command word to the IOM command register.
    //
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    1ab4:	f8c7 1110 	str.w	r1, [r7, #272]	; 0x110

    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += ui32TransferSize >> 2;
    1ab8:	f026 0e03 	bic.w	lr, r6, #3

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    1abc:	1bae      	subs	r6, r5, r6

    //
    // Update the pointer and data counter.
    //
    ui32NumBytes -= ui32TransferSize;
    pui32Data += ui32TransferSize >> 2;
    1abe:	44f0      	add	r8, lr

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    1ac0:	f000 80df 	beq.w	1c82 <am_hal_iom_spi_write_nq+0x336>
    1ac4:	f8d7 5204 	ldr.w	r5, [r7, #516]	; 0x204
    1ac8:	07e9      	lsls	r1, r5, #31
    1aca:	f507 7b01 	add.w	fp, r7, #516	; 0x204
    1ace:	f100 8081 	bmi.w	1bd4 <am_hal_iom_spi_write_nq+0x288>
    1ad2:	4620      	mov	r0, r4
    1ad4:	f507 7c80 	add.w	ip, r7, #256	; 0x100
    1ad8:	4664      	mov	r4, ip
    1ada:	4603      	mov	r3, r0
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1adc:	f8da 2000 	ldr.w	r2, [sl]
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    1ae0:	6821      	ldr	r1, [r4, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1ae2:	f8da 0000 	ldr.w	r0, [sl]
    1ae6:	f012 0f08 	tst.w	r2, #8
    1aea:	bf14      	ite	ne
    1aec:	2240      	movne	r2, #64	; 0x40
    1aee:	2280      	moveq	r2, #128	; 0x80
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    {
        //
        // This will always return a multiple of four.
        //
        ui32SpaceInFifo =  am_hal_iom_fifo_empty_slots(ui32Module);
    1af0:	1a55      	subs	r5, r2, r1
    1af2:	f005 05fc 	and.w	r5, r5, #252	; 0xfc

        if ( ui32NumBytes <= ui32SpaceInFifo )
    1af6:	42b5      	cmp	r5, r6
        {
            //
            // If only a portion of the message will fit in the fifo, prepare
            // to copy the largest number of 4-byte blocks possible.
            //
            ui32TransferSize = ui32SpaceInFifo & ~(0x3);
    1af8:	bf35      	itete	cc
    1afa:	f025 0503 	biccc.w	r5, r5, #3
        //
        // This will always return a multiple of four.
        //
        ui32SpaceInFifo =  am_hal_iom_fifo_empty_slots(ui32Module);

        if ( ui32NumBytes <= ui32SpaceInFifo )
    1afe:	4635      	movcs	r5, r6
    1b00:	1b76      	subcc	r6, r6, r5
    1b02:	2600      	movcs	r6, #0
    //
    // Calculate the FIFO Remaining from the FIFO size. This will be different
    // depending on whether the IOM is configured for half-duplex or
    // full-duplex.
    //
    return (ui32MaxFifoSize - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
    1b04:	6822      	ldr	r2, [r4, #0]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    ui32MaxFifoSize = ((0 == AM_BFRn(IOMSTR, ui32Module, CFG, FULLDUP)) ? AM_HAL_IOM_MAX_FIFO_SIZE : AM_HAL_IOM_MAX_FIFO_SIZE / 2);
    1b06:	f010 0f08 	tst.w	r0, #8
    1b0a:	bf14      	ite	ne
    1b0c:	2040      	movne	r0, #64	; 0x40
    1b0e:	2080      	moveq	r0, #128	; 0x80
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1b10:	1a81      	subs	r1, r0, r2
    1b12:	f001 00fc 	and.w	r0, r1, #252	; 0xfc
    1b16:	4285      	cmp	r5, r0
    1b18:	d871      	bhi.n	1bfe <am_hal_iom_spi_write_nq+0x2b2>

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1b1a:	2d00      	cmp	r5, #0
    1b1c:	d051      	beq.n	1bc2 <am_hal_iom_spi_write_nq+0x276>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1b1e:	4642      	mov	r2, r8
    1b20:	ea6f 0e08 	mvn.w	lr, r8
    1b24:	f852 1b04 	ldr.w	r1, [r2], #4
    1b28:	6039      	str	r1, [r7, #0]
    1b2a:	44c6      	add	lr, r8

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1b2c:	ebc8 0c02 	rsb	ip, r8, r2
    1b30:	44ae      	add	lr, r5
    1b32:	4565      	cmp	r5, ip
    1b34:	f3ce 0082 	ubfx	r0, lr, #2, #3
    1b38:	d943      	bls.n	1bc2 <am_hal_iom_spi_write_nq+0x276>
    1b3a:	b320      	cbz	r0, 1b86 <am_hal_iom_spi_write_nq+0x23a>
    1b3c:	2801      	cmp	r0, #1
    1b3e:	d01b      	beq.n	1b78 <am_hal_iom_spi_write_nq+0x22c>
    1b40:	2802      	cmp	r0, #2
    1b42:	d016      	beq.n	1b72 <am_hal_iom_spi_write_nq+0x226>
    1b44:	2803      	cmp	r0, #3
    1b46:	d011      	beq.n	1b6c <am_hal_iom_spi_write_nq+0x220>
    1b48:	2804      	cmp	r0, #4
    1b4a:	d00c      	beq.n	1b66 <am_hal_iom_spi_write_nq+0x21a>
    1b4c:	2805      	cmp	r0, #5
    1b4e:	d007      	beq.n	1b60 <am_hal_iom_spi_write_nq+0x214>
    1b50:	2806      	cmp	r0, #6
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1b52:	bf1c      	itt	ne
    1b54:	f852 0b04 	ldrne.w	r0, [r2], #4
    1b58:	6038      	strne	r0, [r7, #0]
    1b5a:	f852 1b04 	ldr.w	r1, [r2], #4
    1b5e:	6039      	str	r1, [r7, #0]
    1b60:	f852 0b04 	ldr.w	r0, [r2], #4
    1b64:	6038      	str	r0, [r7, #0]
    1b66:	f852 1b04 	ldr.w	r1, [r2], #4
    1b6a:	6039      	str	r1, [r7, #0]
    1b6c:	f852 0b04 	ldr.w	r0, [r2], #4
    1b70:	6038      	str	r0, [r7, #0]
    1b72:	f852 1b04 	ldr.w	r1, [r2], #4
    1b76:	6039      	str	r1, [r7, #0]
    1b78:	f852 0b04 	ldr.w	r0, [r2], #4
    1b7c:	6038      	str	r0, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1b7e:	ebc8 0e02 	rsb	lr, r8, r2
    1b82:	4575      	cmp	r5, lr
    1b84:	d91d      	bls.n	1bc2 <am_hal_iom_spi_write_nq+0x276>
    {
        //
        // Write the word to the FIFO.
        //
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
    1b86:	4694      	mov	ip, r2
    1b88:	3220      	adds	r2, #32
    1b8a:	f85c 1b04 	ldr.w	r1, [ip], #4
    1b8e:	6039      	str	r1, [r7, #0]
    1b90:	f852 0c1c 	ldr.w	r0, [r2, #-28]
    1b94:	6038      	str	r0, [r7, #0]
    1b96:	f8dc 1004 	ldr.w	r1, [ip, #4]
    1b9a:	6039      	str	r1, [r7, #0]
    1b9c:	f852 0c14 	ldr.w	r0, [r2, #-20]
    1ba0:	6038      	str	r0, [r7, #0]
    1ba2:	f852 1c10 	ldr.w	r1, [r2, #-16]
    1ba6:	6039      	str	r1, [r7, #0]
    1ba8:	f852 0c0c 	ldr.w	r0, [r2, #-12]
    1bac:	6038      	str	r0, [r7, #0]
    1bae:	f852 1c08 	ldr.w	r1, [r2, #-8]
    1bb2:	6039      	str	r1, [r7, #0]
    1bb4:	f852 0c04 	ldr.w	r0, [r2, #-4]
    1bb8:	6038      	str	r0, [r7, #0]

    //
    // Loop over the words in the array until we have the correct number of
    // bytes.
    //
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    1bba:	ebc8 0e02 	rsb	lr, r8, r2
    1bbe:	4575      	cmp	r5, lr
    1bc0:	d8e1      	bhi.n	1b86 <am_hal_iom_spi_write_nq+0x23a>

        //
        // Update the data pointer and bytes-left count.
        //
        ui32NumBytes -= ui32TransferSize;
        pui32Data += ui32TransferSize >> 2;
    1bc2:	f025 0203 	bic.w	r2, r5, #3
    1bc6:	4490      	add	r8, r2
    pui32Data += ui32TransferSize >> 2;

    //
    // Keep looping until we're out of bytes to send or command complete (error).
    //
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
    1bc8:	b11e      	cbz	r6, 1bd2 <am_hal_iom_spi_write_nq+0x286>
    1bca:	f8db 5000 	ldr.w	r5, [fp]
    1bce:	07ea      	lsls	r2, r5, #31
    1bd0:	d584      	bpl.n	1adc <am_hal_iom_spi_write_nq+0x190>
    1bd2:	461c      	mov	r4, r3
    }

    //
    // Make sure CMDCMP was raised with standard timeout
    //
    waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    1bd4:	4e21      	ldr	r6, [pc, #132]	; (1c5c <am_hal_iom_spi_write_nq+0x310>)
    1bd6:	2301      	movs	r3, #1
    1bd8:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
    1bdc:	461a      	mov	r2, r3
    1bde:	4659      	mov	r1, fp
    1be0:	f7fe feb8 	bl	954 <am_hal_flash_delay_status_change>
                 AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                 AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

    if (waitStatus != 1)
    1be4:	2801      	cmp	r0, #1
    1be6:	d024      	beq.n	1c32 <am_hal_iom_spi_write_nq+0x2e6>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    1be8:	2001      	movs	r0, #1
    1bea:	f809 0004 	strb.w	r0, [r9, r4]

    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1bee:	f240 71ff 	movw	r1, #2047	; 0x7ff
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1bf2:	9a00      	ldr	r2, [sp, #0]

    //
    // Re-enable IOM interrupts.
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1bf4:	f8c7 1208 	str.w	r1, [r7, #520]	; 0x208
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1bf8:	f8c7 2200 	str.w	r2, [r7, #512]	; 0x200
    1bfc:	e6c1      	b.n	1982 <am_hal_iom_spi_write_nq+0x36>
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1bfe:	4a18      	ldr	r2, [pc, #96]	; (1c60 <am_hal_iom_spi_write_nq+0x314>)
    1c00:	4818      	ldr	r0, [pc, #96]	; (1c64 <am_hal_iom_spi_write_nq+0x318>)
    1c02:	9301      	str	r3, [sp, #4]
    1c04:	f640 7107 	movw	r1, #3847	; 0xf07
    1c08:	f7fe fe9c 	bl	944 <am_hal_debug_error>
    1c0c:	9b01      	ldr	r3, [sp, #4]
    1c0e:	e786      	b.n	1b1e <am_hal_iom_spi_write_nq+0x1d2>
isRevB0(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B )
    1c10:	4a15      	ldr	r2, [pc, #84]	; (1c68 <am_hal_iom_spi_write_nq+0x31c>)
    1c12:	6813      	ldr	r3, [r2, #0]
    1c14:	b2d9      	uxtb	r1, r3
    1c16:	2920      	cmp	r1, #32
    1c18:	f47f aed8 	bne.w	19cc <am_hal_iom_spi_write_nq+0x80>
        // The workaround function is going to a partial transfer for us, but
        // we have to keep our own data-tracking variables updated. Here, we're
        // subtracting 4 bytes from the effective transfer size to account for
        // the 4 bytes of "dummy" word that we sent instead of the actual data.
        //
        ui32TransferSize = (ui32NumBytes <= (ui32MaxFifoSize - 4) ? ui32NumBytes :
    1c1c:	45ae      	cmp	lr, r5
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    {
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    1c1e:	4658      	mov	r0, fp
    1c20:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1c22:	462a      	mov	r2, r5
    1c24:	4641      	mov	r1, r8
        // The workaround function is going to a partial transfer for us, but
        // we have to keep our own data-tracking variables updated. Here, we're
        // subtracting 4 bytes from the effective transfer size to account for
        // the 4 bytes of "dummy" word that we sent instead of the actual data.
        //
        ui32TransferSize = (ui32NumBytes <= (ui32MaxFifoSize - 4) ? ui32NumBytes :
    1c26:	4676      	mov	r6, lr
    1c28:	bf28      	it	cs
    1c2a:	462e      	movcs	r6, r5
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( WORKAROUND_IOM == ui32Module && isRevB0() )
    {
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data,
    1c2c:	f7ff f936 	bl	e9c <am_hal_iom_workaround_word_write>
    1c30:	e742      	b.n	1ab8 <am_hal_iom_spi_write_nq+0x16c>
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    1c32:	f8db 3000 	ldr.w	r3, [fp]
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    1c36:	f013 0fcc 	tst.w	r3, #204	; 0xcc
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    1c3a:	bf18      	it	ne
    1c3c:	2005      	movne	r0, #5
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    1c3e:	d002      	beq.n	1c46 <am_hal_iom_spi_write_nq+0x2fa>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    }
    else
    {
        g_iom_error_status[ui32Module] = ui32Status = internal_iom_get_int_err(ui32Module, 0);
    1c40:	f809 0004 	strb.w	r0, [r9, r4]
    1c44:	e7d3      	b.n	1bee <am_hal_iom_spi_write_nq+0x2a2>
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    1c46:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    1c4a:	d118      	bne.n	1c7e <am_hal_iom_spi_write_nq+0x332>
//!
//*****************************************************************************
static am_hal_iom_status_e
internal_iom_get_int_err(uint32_t ui32Module, uint32_t ui32IntStatus)
{
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;
    1c4c:	f013 0f10 	tst.w	r3, #16
    1c50:	bf14      	ite	ne
    1c52:	2006      	movne	r0, #6
    1c54:	2000      	moveq	r0, #0
    1c56:	e7f3      	b.n	1c40 <am_hal_iom_spi_write_nq+0x2f4>
    1c58:	1000105c 	.word	0x1000105c
    1c5c:	1000135c 	.word	0x1000135c
    1c60:	00004614 	.word	0x00004614
    1c64:	00004648 	.word	0x00004648
    1c68:	4002000c 	.word	0x4002000c
    1c6c:	10001054 	.word	0x10001054
    }

    //
    // Make sure we check the number of bytes we're writing to the FIFO.
    //
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
    1c70:	4a05      	ldr	r2, [pc, #20]	; (1c88 <am_hal_iom_spi_write_nq+0x33c>)
    1c72:	4806      	ldr	r0, [pc, #24]	; (1c8c <am_hal_iom_spi_write_nq+0x340>)
    1c74:	f640 7107 	movw	r1, #3847	; 0xf07
    1c78:	f7fe fe64 	bl	944 <am_hal_debug_error>
    1c7c:	e6b8      	b.n	19f0 <am_hal_iom_spi_write_nq+0xa4>
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    {
        // Loss of I2C multi-master arbitration
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    1c7e:	2007      	movs	r0, #7
    1c80:	e7de      	b.n	1c40 <am_hal_iom_spi_write_nq+0x2f4>
    1c82:	f507 7b01 	add.w	fp, r7, #516	; 0x204
    1c86:	e7a5      	b.n	1bd4 <am_hal_iom_spi_write_nq+0x288>
    1c88:	00004614 	.word	0x00004614
    1c8c:	00004648 	.word	0x00004648

00001c90 <am_hal_iom_spi_write>:
{
    am_hal_iom_status_e ui32Status;
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1c90:	2805      	cmp	r0, #5
    1c92:	d901      	bls.n	1c98 <am_hal_iom_spi_write+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    1c94:	2002      	movs	r0, #2
        //
        ui32Status = am_hal_iom_spi_write_nq(ui32Module, ui32ChipSelect, pui32Data,
                                ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    1c96:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write(uint32_t ui32Module, uint32_t ui32ChipSelect,
                     uint32_t *pui32Data, uint32_t ui32NumBytes,
                     uint32_t ui32Options)
{
    1c98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1c9c:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 1d78 <am_hal_iom_spi_write+0xe8>
    1ca0:	f04f 0e00 	mov.w	lr, #0
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_write(uint32_t ui32Module, uint32_t ui32ChipSelect,
                     uint32_t *pui32Data, uint32_t ui32NumBytes,
                     uint32_t ui32Options)
{
    1ca4:	b08d      	sub	sp, #52	; 0x34
    1ca6:	4604      	mov	r4, r0
    1ca8:	461d      	mov	r5, r3
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1caa:	f808 e000 	strb.w	lr, [r8, r0]
    if (ui32NumBytes == 0)
    1cae:	b92b      	cbnz	r3, 1cbc <am_hal_iom_spi_write+0x2c>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    1cb0:	2003      	movs	r0, #3
    1cb2:	f808 0004 	strb.w	r0, [r8, r4]
        //
        ui32Status = am_hal_iom_spi_write_nq(ui32Module, ui32ChipSelect, pui32Data,
                                ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    1cb6:	b00d      	add	sp, #52	; 0x34
    1cb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    //
    // Check to see if queues have been enabled. If they are, we'll actually
    // switch to the queued interface.
    //
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    1cbc:	ea4f 0a40 	mov.w	sl, r0, lsl #1
    1cc0:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 1d7c <am_hal_iom_spi_write+0xec>
    1cc4:	9103      	str	r1, [sp, #12]
    1cc6:	eb0a 0700 	add.w	r7, sl, r0
    1cca:	eb0b 09c7 	add.w	r9, fp, r7, lsl #3
    1cce:	f8d9 6014 	ldr.w	r6, [r9, #20]
    1cd2:	2e00      	cmp	r6, #0
    1cd4:	d046      	beq.n	1d64 <am_hal_iom_spi_write+0xd4>
    1cd6:	4617      	mov	r7, r2
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    1cd8:	f000 fe42 	bl	2960 <am_hal_interrupt_master_disable>
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    1cdc:	4b24      	ldr	r3, [pc, #144]	; (1d70 <am_hal_iom_spi_write+0xe0>)
    1cde:	5d1a      	ldrb	r2, [r3, r4]
    }

    //
    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    1ce0:	4606      	mov	r6, r0
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    1ce2:	b912      	cbnz	r2, 1cea <am_hal_iom_spi_write+0x5a>
    1ce4:	f8d9 0008 	ldr.w	r0, [r9, #8]
    1ce8:	b1d0      	cbz	r0, 1d20 <am_hal_iom_spi_write+0x90>
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1cea:	eb0a 0104 	add.w	r1, sl, r4
    1cee:	eb0b 00c1 	add.w	r0, fp, r1, lsl #3
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
    1cf2:	9903      	ldr	r1, [sp, #12]
    1cf4:	9107      	str	r1, [sp, #28]
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_WRITE;
    1cf6:	2300      	movs	r3, #0
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
    1cf8:	9509      	str	r5, [sp, #36]	; 0x24
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1cfa:	2201      	movs	r2, #1
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    1cfc:	9d16      	ldr	r5, [sp, #88]	; 0x58
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
    1cfe:	9406      	str	r4, [sp, #24]
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1d00:	a905      	add	r1, sp, #20
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_WRITE;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
    1d02:	9708      	str	r7, [sp, #32]
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    1d04:	950a      	str	r5, [sp, #40]	; 0x28
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_WRITE;
    1d06:	9305      	str	r3, [sp, #20]
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    1d08:	930b      	str	r3, [sp, #44]	; 0x2c

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1d0a:	f000 fc73 	bl	25f4 <am_hal_queue_item_add>
    1d0e:	b9f8      	cbnz	r0, 1d50 <am_hal_iom_spi_write+0xc0>
        {
            //
            // Didn't have enough memory.
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
    1d10:	2508      	movs	r5, #8
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1d12:	4630      	mov	r0, r6
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    1d14:	f808 5004 	strb.w	r5, [r8, r4]
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1d18:	f000 fe26 	bl	2968 <am_hal_interrupt_master_set>
    1d1c:	4628      	mov	r0, r5
    1d1e:	e7ca      	b.n	1cb6 <am_hal_iom_spi_write+0x26>
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    1d20:	5d1a      	ldrb	r2, [r3, r4]
    1d22:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    1d26:	2a00      	cmp	r2, #0
    1d28:	d1fa      	bne.n	1d20 <am_hal_iom_spi_write+0x90>
        return ui32Status;
    }
    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 4096)
    1d2a:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status for non-blocking transfer
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1d2e:	f808 0004 	strb.w	r0, [r8, r4]
        return ui32Status;
    }
    //
    // Make sure the transfer isn't too long for the hardware to support.
    //
    if (ui32NumBytes >= 4096)
    1d32:	d301      	bcc.n	1d38 <am_hal_iom_spi_write+0xa8>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
        return ui32Status;
    1d34:	2503      	movs	r5, #3
    1d36:	e7ec      	b.n	1d12 <am_hal_iom_spi_write+0x82>
    1d38:	9b16      	ldr	r3, [sp, #88]	; 0x58
    1d3a:	9001      	str	r0, [sp, #4]
    1d3c:	9300      	str	r3, [sp, #0]
    1d3e:	463a      	mov	r2, r7
    1d40:	462b      	mov	r3, r5
    1d42:	9903      	ldr	r1, [sp, #12]
    1d44:	4620      	mov	r0, r4
    1d46:	f7ff fc95 	bl	1674 <am_hal_iom_spi_write_nb.part.6>
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    1d4a:	4605      	mov	r5, r0
    1d4c:	2800      	cmp	r0, #0
    1d4e:	d1e0      	bne.n	1d12 <am_hal_iom_spi_write+0x82>
        if (ui32Status == AM_HAL_IOM_SUCCESS)
        {
            //
            // Wait until the transaction actually clears.
            //
            am_hal_iom_queue_flush(ui32Module);
    1d50:	4f08      	ldr	r7, [pc, #32]	; (1d74 <am_hal_iom_spi_write+0xe4>)
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    1d52:	4630      	mov	r0, r6
    1d54:	f000 fe08 	bl	2968 <am_hal_interrupt_master_set>
        if (ui32Status == AM_HAL_IOM_SUCCESS)
        {
            //
            // Wait until the transaction actually clears.
            //
            am_hal_iom_queue_flush(ui32Module);
    1d58:	4620      	mov	r0, r4
    1d5a:	683e      	ldr	r6, [r7, #0]
    1d5c:	47b0      	blx	r6
            // g_iom_error_status gets set in the isr handling
            ui32Status = g_iom_error_status[ui32Module];
    1d5e:	f818 0004 	ldrb.w	r0, [r8, r4]
    1d62:	e7a8      	b.n	1cb6 <am_hal_iom_spi_write+0x26>
    else
    {
        //
        // Otherwise, we'll just do a polled transaction.
        //
        ui32Status = am_hal_iom_spi_write_nq(ui32Module, ui32ChipSelect, pui32Data,
    1d64:	9c16      	ldr	r4, [sp, #88]	; 0x58
    1d66:	9400      	str	r4, [sp, #0]
    1d68:	f7ff fdf0 	bl	194c <am_hal_iom_spi_write_nq>
    1d6c:	e7a3      	b.n	1cb6 <am_hal_iom_spi_write+0x26>
    1d6e:	bf00      	nop
    1d70:	1000105c 	.word	0x1000105c
    1d74:	10001050 	.word	0x10001050
    1d78:	10001054 	.word	0x10001054
    1d7c:	100013ec 	.word	0x100013ec

00001d80 <am_hal_iom_spi_read_nq>:
    uint32_t waitStatus;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    1d80:	2805      	cmp	r0, #5
    1d82:	d901      	bls.n	1d88 <am_hal_iom_spi_read_nq+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    1d84:	2002      	movs	r0, #2
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;

    return ui32Status;

}
    1d86:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_read_nq(uint32_t ui32Module, uint32_t ui32ChipSelect,
                       uint32_t *pui32Data, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    1d88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d8c:	4688      	mov	r8, r1
    1d8e:	49b9      	ldr	r1, [pc, #740]	; (2074 <am_hal_iom_spi_read_nq+0x2f4>)
    1d90:	b085      	sub	sp, #20
    1d92:	4604      	mov	r4, r0
    1d94:	4617      	mov	r7, r2
    1d96:	461d      	mov	r5, r3
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    1d98:	5d0b      	ldrb	r3, [r1, r4]
    1d9a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1d9e:	2b00      	cmp	r3, #0
    1da0:	d1fa      	bne.n	1d98 <am_hal_iom_spi_read_nq+0x18>
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1da2:	f8df a2e0 	ldr.w	sl, [pc, #736]	; 2084 <am_hal_iom_spi_read_nq+0x304>
    if (ui32NumBytes == 0)
    1da6:	1e68      	subs	r0, r5, #1
    1da8:	f640 76fe 	movw	r6, #4094	; 0xffe
    1dac:	42b0      	cmp	r0, r6
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);

    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    1dae:	f80a 2004 	strb.w	r2, [sl, r4]
    if (ui32NumBytes == 0)
    1db2:	d905      	bls.n	1dc0 <am_hal_iom_spi_read_nq+0x40>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    1db4:	2003      	movs	r0, #3
    1db6:	f80a 0004 	strb.w	r0, [sl, r4]
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;

    return ui32Status;

}
    1dba:	b005      	add	sp, #20
    1dbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    1dc0:	f504 21a0 	add.w	r1, r4, #327680	; 0x50000
    1dc4:	3104      	adds	r1, #4
    1dc6:	030b      	lsls	r3, r1, #12
    // Disable IOM interrupts as we'll be polling
    //
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1dc8:	f240 79ff 	movw	r9, #2047	; 0x7ff
    }

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    1dcc:	f8d3 6200 	ldr.w	r6, [r3, #512]	; 0x200
    1dd0:	9300      	str	r3, [sp, #0]
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    1dd2:	2c04      	cmp	r4, #4
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);

    //
    // Disable IOM interrupts as we'll be polling
    //
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    1dd4:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    }

    //
    // Disable interrupts so that we don't get any undesired interrupts.
    //
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    1dd8:	4618      	mov	r0, r3
    1dda:	9602      	str	r6, [sp, #8]
    // Disable IOM interrupts as we'll be polling
    //
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;

    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1ddc:	f8c3 9208 	str.w	r9, [r3, #520]	; 0x208
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    1de0:	f000 8152 	beq.w	2088 <am_hal_iom_spi_read_nq+0x308>
    1de4:	4aa4      	ldr	r2, [pc, #656]	; (2078 <am_hal_iom_spi_read_nq+0x2f8>)
    1de6:	9203      	str	r2, [sp, #12]
    1de8:	f503 7b01 	add.w	fp, r3, #516	; 0x204
    1dec:	461e      	mov	r6, r3
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    1dee:	ea4f 4108 	mov.w	r1, r8, lsl #16
    1df2:	f401 20e0 	and.w	r0, r1, #458752	; 0x70000
    1df6:	f040 4100 	orr.w	r1, r0, #2147483648	; 0x80000000
    1dfa:	b2eb      	uxtb	r3, r5
    1dfc:	430b      	orrs	r3, r1
    1dfe:	990e      	ldr	r1, [sp, #56]	; 0x38
                       uint32_t *pui32Data, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    uint32_t ui32BytesInFifo;
    uint32_t ui32IntConfig;
    uint32_t bCmdCmp = false;
    1e00:	9401      	str	r4, [sp, #4]
    //
    // Finally, OR in the rest of the options. This mask should make sure that
    // erroneous option values won't interfere with the other transfer
    // parameters.
    //
    ui32Command |= ui32Options & 0x5C00FF00;
    1e02:	03ea      	lsls	r2, r5, #15
    1e04:	f002 60f0 	and.w	r0, r2, #125829120	; 0x7800000
    1e08:	f021 4223 	bic.w	r2, r1, #2734686208	; 0xa3000000
    1e0c:	4303      	orrs	r3, r0
    1e0e:	f002 20ff 	and.w	r0, r2, #4278255360	; 0xff00ff00
    1e12:	4303      	orrs	r3, r0


    //
    // Write the complete command word to the IOM command register.
    //
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    1e14:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
    1e18:	f506 7980 	add.w	r9, r6, #256	; 0x100
                       uint32_t *pui32Data, uint32_t ui32NumBytes,
                       uint32_t ui32Options)
{
    uint32_t ui32BytesInFifo;
    uint32_t ui32IntConfig;
    uint32_t bCmdCmp = false;
    1e1c:	2300      	movs	r3, #0
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    1e1e:	f8d9 2000 	ldr.w	r2, [r9]
    1e22:	b2d4      	uxtb	r4, r2
    //
    while ( ui32NumBytes )
    {
        ui32BytesInFifo =  am_hal_iom_fifo_full_slots(ui32Module);

        if ( ui32BytesInFifo >= ui32NumBytes )
    1e24:	42ac      	cmp	r4, r5
    1e26:	f080 8096 	bcs.w	1f56 <am_hal_iom_spi_read_nq+0x1d6>
            // thing out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32NumBytes);
            ui32NumBytes = 0;
        }
        else if ( ui32BytesInFifo >= 4 )
    1e2a:	2c03      	cmp	r4, #3
    1e2c:	d972      	bls.n	1f14 <am_hal_iom_spi_read_nq+0x194>

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    1e2e:	f8d6 111c 	ldr.w	r1, [r6, #284]	; 0x11c
        {
            //
            // If the fifo has at least one 32-bit word in it, copy whole
            // words out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);
    1e32:	f002 08fc 	and.w	r8, r2, #252	; 0xfc

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    1e36:	070a      	lsls	r2, r1, #28
    1e38:	d406      	bmi.n	1e48 <am_hal_iom_spi_read_nq+0xc8>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    1e3a:	f8d9 0000 	ldr.w	r0, [r9]
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    1e3e:	fa5f fc80 	uxtb.w	ip, r0
    1e42:	45e0      	cmp	r8, ip
    1e44:	f200 8142 	bhi.w	20cc <am_hal_iom_spi_read_nq+0x34c>

    //
    // Figure out how many whole words we're reading from the fifo, and how
    // many bytes will be left over when we're done.
    //
    ui32NumWords = ui32NumBytes / 4;
    1e48:	ea4f 0298 	mov.w	r2, r8, lsr #2
    1e4c:	9200      	str	r2, [sp, #0]
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    1e4e:	0091      	lsls	r1, r2, #2

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1e50:	2a00      	cmp	r2, #0
    1e52:	d049      	beq.n	1ee8 <am_hal_iom_spi_read_nq+0x168>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1e54:	463a      	mov	r2, r7
    1e56:	6830      	ldr	r0, [r6, #0]
    1e58:	f842 0b04 	str.w	r0, [r2], #4
    1e5c:	eb07 0e01 	add.w	lr, r7, r1
    1e60:	f1a1 0c04 	sub.w	ip, r1, #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1e64:	4596      	cmp	lr, r2
    1e66:	f3cc 0082 	ubfx	r0, ip, #2, #3
    1e6a:	d03d      	beq.n	1ee8 <am_hal_iom_spi_read_nq+0x168>
    1e6c:	b310      	cbz	r0, 1eb4 <am_hal_iom_spi_read_nq+0x134>
    1e6e:	2801      	cmp	r0, #1
    1e70:	d01b      	beq.n	1eaa <am_hal_iom_spi_read_nq+0x12a>
    1e72:	2802      	cmp	r0, #2
    1e74:	d016      	beq.n	1ea4 <am_hal_iom_spi_read_nq+0x124>
    1e76:	2803      	cmp	r0, #3
    1e78:	d011      	beq.n	1e9e <am_hal_iom_spi_read_nq+0x11e>
    1e7a:	2804      	cmp	r0, #4
    1e7c:	d00c      	beq.n	1e98 <am_hal_iom_spi_read_nq+0x118>
    1e7e:	2805      	cmp	r0, #5
    1e80:	d007      	beq.n	1e92 <am_hal_iom_spi_read_nq+0x112>
    1e82:	2806      	cmp	r0, #6
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1e84:	bf1c      	itt	ne
    1e86:	6830      	ldrne	r0, [r6, #0]
    1e88:	f842 0b04 	strne.w	r0, [r2], #4
    1e8c:	6830      	ldr	r0, [r6, #0]
    1e8e:	f842 0b04 	str.w	r0, [r2], #4
    1e92:	6830      	ldr	r0, [r6, #0]
    1e94:	f842 0b04 	str.w	r0, [r2], #4
    1e98:	6830      	ldr	r0, [r6, #0]
    1e9a:	f842 0b04 	str.w	r0, [r2], #4
    1e9e:	6830      	ldr	r0, [r6, #0]
    1ea0:	f842 0b04 	str.w	r0, [r2], #4
    1ea4:	6830      	ldr	r0, [r6, #0]
    1ea6:	f842 0b04 	str.w	r0, [r2], #4
    1eaa:	6830      	ldr	r0, [r6, #0]
    1eac:	f842 0b04 	str.w	r0, [r2], #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1eb0:	4596      	cmp	lr, r2
    1eb2:	d019      	beq.n	1ee8 <am_hal_iom_spi_read_nq+0x168>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1eb4:	4610      	mov	r0, r2
    1eb6:	f8d6 c000 	ldr.w	ip, [r6]
    1eba:	f840 cb04 	str.w	ip, [r0], #4
    1ebe:	f8d6 c000 	ldr.w	ip, [r6]
    1ec2:	f8c2 c004 	str.w	ip, [r2, #4]
    1ec6:	f8d6 c000 	ldr.w	ip, [r6]
    1eca:	f8c0 c004 	str.w	ip, [r0, #4]
    1ece:	6830      	ldr	r0, [r6, #0]
    1ed0:	60d0      	str	r0, [r2, #12]
    1ed2:	6830      	ldr	r0, [r6, #0]
    1ed4:	6110      	str	r0, [r2, #16]
    1ed6:	6830      	ldr	r0, [r6, #0]
    1ed8:	6150      	str	r0, [r2, #20]
    1eda:	6830      	ldr	r0, [r6, #0]
    1edc:	6190      	str	r0, [r2, #24]
    1ede:	6830      	ldr	r0, [r6, #0]
    1ee0:	61d0      	str	r0, [r2, #28]
    1ee2:	3220      	adds	r2, #32
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1ee4:	4596      	cmp	lr, r2
    1ee6:	d1e5      	bne.n	1eb4 <am_hal_iom_spi_read_nq+0x134>
    // definition requests, we wouldn't need to do this. It's possible to call
    // this function with a re-cast or packed pointer instead though. If that
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    1ee8:	4588      	cmp	r8, r1
    1eea:	d00e      	beq.n	1f0a <am_hal_iom_spi_read_nq+0x18a>
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1eec:	6832      	ldr	r2, [r6, #0]
        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    1eee:	9800      	ldr	r0, [sp, #0]
    1ef0:	4439      	add	r1, r7
    1ef2:	f807 2020 	strb.w	r2, [r7, r0, lsl #2]
    1ef6:	f3c2 2e07 	ubfx	lr, r2, #8, #8
    1efa:	f3c2 4007 	ubfx	r0, r2, #16, #8
    1efe:	f3c2 6207 	ubfx	r2, r2, #24, #8
    1f02:	f881 e001 	strb.w	lr, [r1, #1]
    1f06:	7088      	strb	r0, [r1, #2]
    1f08:	70ca      	strb	r2, [r1, #3]
            // If the fifo has at least one 32-bit word in it, copy whole
            // words out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);
            ui32NumBytes -= ui32BytesInFifo & ~0x3;
            pui32Data += ui32BytesInFifo >> 2;
    1f0a:	f004 01fc 	and.w	r1, r4, #252	; 0xfc
    1f0e:	440f      	add	r7, r1
            //
            // If the fifo has at least one 32-bit word in it, copy whole
            // words out.
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);
            ui32NumBytes -= ui32BytesInFifo & ~0x3;
    1f10:	ebc8 0505 	rsb	r5, r8, r5
            pui32Data += ui32BytesInFifo >> 2;
        }
        if ( bCmdCmp == true )
    1f14:	b933      	cbnz	r3, 1f24 <am_hal_iom_spi_read_nq+0x1a4>
            // No more data expected. Get out of the loop
            //
            break;
        }

        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
    1f16:	f8db 3000 	ldr.w	r3, [fp]
    1f1a:	f003 0301 	and.w	r3, r3, #1
                           ui32NumBytes, ui32Options);

    //
    // Start a loop to catch the Rx data.
    //
    while ( ui32NumBytes )
    1f1e:	2d00      	cmp	r5, #0
    1f20:	f47f af7d 	bne.w	1e1e <am_hal_iom_spi_read_nq+0x9e>
    1f24:	9c01      	ldr	r4, [sp, #4]
    1f26:	9600      	str	r6, [sp, #0]
    }

    //
    // Make sure CMDCMP was raised,
    //
    waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    1f28:	9f03      	ldr	r7, [sp, #12]
    1f2a:	2301      	movs	r3, #1
    1f2c:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
    1f30:	461a      	mov	r2, r3
    1f32:	4659      	mov	r1, fp
    1f34:	f7fe fd0e 	bl	954 <am_hal_flash_delay_status_change>
                 AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                 AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

    if (waitStatus != 1)
    1f38:	2801      	cmp	r0, #1
    1f3a:	f000 80b4 	beq.w	20a6 <am_hal_iom_spi_read_nq+0x326>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    1f3e:	2001      	movs	r0, #1
    1f40:	f80a 0004 	strb.w	r0, [sl, r4]

    //
    // Re-enable IOM interrupts. Make sure CMDCMP is cleared
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1f44:	9d00      	ldr	r5, [sp, #0]
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1f46:	9a02      	ldr	r2, [sp, #8]

    //
    // Re-enable IOM interrupts. Make sure CMDCMP is cleared
    //
    // Clear interrupts
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    1f48:	f240 74ff 	movw	r4, #2047	; 0x7ff
    1f4c:	f8c5 4208 	str.w	r4, [r5, #520]	; 0x208
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1f50:	f8c5 2200 	str.w	r2, [r5, #512]	; 0x200
    1f54:	e731      	b.n	1dba <am_hal_iom_spi_read_nq+0x3a>

    //
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    1f56:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    1f5a:	9600      	str	r6, [sp, #0]
    1f5c:	0700      	lsls	r0, r0, #28
    1f5e:	9c01      	ldr	r4, [sp, #4]
    1f60:	d40c      	bmi.n	1f7c <am_hal_iom_spi_read_nq+0x1fc>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return 0;
    }

    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    1f62:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    1f66:	b2d1      	uxtb	r1, r2
    1f68:	42a9      	cmp	r1, r5
    1f6a:	d207      	bcs.n	1f7c <am_hal_iom_spi_read_nq+0x1fc>
    1f6c:	4a43      	ldr	r2, [pc, #268]	; (207c <am_hal_iom_spi_read_nq+0x2fc>)
    1f6e:	4844      	ldr	r0, [pc, #272]	; (2080 <am_hal_iom_spi_read_nq+0x300>)
    1f70:	9301      	str	r3, [sp, #4]
    1f72:	f640 7142 	movw	r1, #3906	; 0xf42
    1f76:	f7fe fce5 	bl	944 <am_hal_debug_error>
    1f7a:	9b01      	ldr	r3, [sp, #4]

    //
    // Figure out how many whole words we're reading from the fifo, and how
    // many bytes will be left over when we're done.
    //
    ui32NumWords = ui32NumBytes / 4;
    1f7c:	ea4f 0c95 	mov.w	ip, r5, lsr #2
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    1f80:	ea4f 018c 	mov.w	r1, ip, lsl #2
    1f84:	1a6d      	subs	r5, r5, r1

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1f86:	f1bc 0f00 	cmp.w	ip, #0
    1f8a:	d057      	beq.n	203c <am_hal_iom_spi_read_nq+0x2bc>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1f8c:	9e00      	ldr	r6, [sp, #0]
    1f8e:	463a      	mov	r2, r7
    1f90:	6830      	ldr	r0, [r6, #0]
    1f92:	f842 0b04 	str.w	r0, [r2], #4
    1f96:	eb07 0e01 	add.w	lr, r7, r1
    1f9a:	1f0e      	subs	r6, r1, #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1f9c:	4596      	cmp	lr, r2
    1f9e:	f3c6 0082 	ubfx	r0, r6, #2, #3
    1fa2:	d04b      	beq.n	203c <am_hal_iom_spi_read_nq+0x2bc>
    1fa4:	b348      	cbz	r0, 1ffa <am_hal_iom_spi_read_nq+0x27a>
    1fa6:	2801      	cmp	r0, #1
    1fa8:	d021      	beq.n	1fee <am_hal_iom_spi_read_nq+0x26e>
    1faa:	2802      	cmp	r0, #2
    1fac:	d01b      	beq.n	1fe6 <am_hal_iom_spi_read_nq+0x266>
    1fae:	2803      	cmp	r0, #3
    1fb0:	d015      	beq.n	1fde <am_hal_iom_spi_read_nq+0x25e>
    1fb2:	2804      	cmp	r0, #4
    1fb4:	d00f      	beq.n	1fd6 <am_hal_iom_spi_read_nq+0x256>
    1fb6:	2805      	cmp	r0, #5
    1fb8:	d009      	beq.n	1fce <am_hal_iom_spi_read_nq+0x24e>
    1fba:	2806      	cmp	r0, #6
    1fbc:	d003      	beq.n	1fc6 <am_hal_iom_spi_read_nq+0x246>
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1fbe:	9e00      	ldr	r6, [sp, #0]
    1fc0:	6830      	ldr	r0, [r6, #0]
    1fc2:	f842 0b04 	str.w	r0, [r2], #4
    1fc6:	9e00      	ldr	r6, [sp, #0]
    1fc8:	6830      	ldr	r0, [r6, #0]
    1fca:	f842 0b04 	str.w	r0, [r2], #4
    1fce:	9e00      	ldr	r6, [sp, #0]
    1fd0:	6830      	ldr	r0, [r6, #0]
    1fd2:	f842 0b04 	str.w	r0, [r2], #4
    1fd6:	9e00      	ldr	r6, [sp, #0]
    1fd8:	6830      	ldr	r0, [r6, #0]
    1fda:	f842 0b04 	str.w	r0, [r2], #4
    1fde:	9e00      	ldr	r6, [sp, #0]
    1fe0:	6830      	ldr	r0, [r6, #0]
    1fe2:	f842 0b04 	str.w	r0, [r2], #4
    1fe6:	9e00      	ldr	r6, [sp, #0]
    1fe8:	6830      	ldr	r0, [r6, #0]
    1fea:	f842 0b04 	str.w	r0, [r2], #4
    1fee:	9e00      	ldr	r6, [sp, #0]
    1ff0:	6830      	ldr	r0, [r6, #0]
    1ff2:	f842 0b04 	str.w	r0, [r2], #4
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    1ff6:	4596      	cmp	lr, r2
    1ff8:	d020      	beq.n	203c <am_hal_iom_spi_read_nq+0x2bc>
    1ffa:	9e00      	ldr	r6, [sp, #0]
    {
        //
        // Copy data out of the FIFO, one word at a time.
        //
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1ffc:	f8d6 8000 	ldr.w	r8, [r6]
    2000:	4691      	mov	r9, r2
    2002:	3220      	adds	r2, #32
    2004:	f849 8b04 	str.w	r8, [r9], #4
    2008:	f8d6 8000 	ldr.w	r8, [r6]
    200c:	f842 8c1c 	str.w	r8, [r2, #-28]
    2010:	f8d6 8000 	ldr.w	r8, [r6]
    2014:	f8c9 8004 	str.w	r8, [r9, #4]
    2018:	6830      	ldr	r0, [r6, #0]
    201a:	f842 0c14 	str.w	r0, [r2, #-20]
    201e:	6830      	ldr	r0, [r6, #0]
    2020:	f842 0c10 	str.w	r0, [r2, #-16]
    2024:	6830      	ldr	r0, [r6, #0]
    2026:	f842 0c0c 	str.w	r0, [r2, #-12]
    202a:	6830      	ldr	r0, [r6, #0]
    202c:	f842 0c08 	str.w	r0, [r2, #-8]
    2030:	6830      	ldr	r0, [r6, #0]
    2032:	f842 0c04 	str.w	r0, [r2, #-4]
    ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);

    //
    // Copy out as many full words as we can.
    //
    for ( i = 0; i < ui32NumWords; i++ )
    2036:	4596      	cmp	lr, r2
    2038:	d1e0      	bne.n	1ffc <am_hal_iom_spi_read_nq+0x27c>
    203a:	9600      	str	r6, [sp, #0]
    // definition requests, we wouldn't need to do this. It's possible to call
    // this function with a re-cast or packed pointer instead though. If that
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    203c:	b1a5      	cbz	r5, 2068 <am_hal_iom_spi_read_nq+0x2e8>
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    203e:	9a00      	ldr	r2, [sp, #0]
        pui8Data = (uint8_t *) (&pui32Data[i]);

        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
    2040:	2d01      	cmp	r5, #1
    // happens, we want to be careful not to overwrite any data that might be
    // sitting just past the end of the destination array.
    //
    if ( ui32Leftovers )
    {
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    2042:	6816      	ldr	r6, [r2, #0]
        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    2044:	f807 602c 	strb.w	r6, [r7, ip, lsl #2]
        pui8Data = (uint8_t *) (&pui32Data[i]);

        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
    2048:	d00e      	beq.n	2068 <am_hal_iom_spi_read_nq+0x2e8>
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    204a:	440f      	add	r7, r1
        pui8Data = (uint8_t *) (&pui32Data[i]);

        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
    204c:	2d02      	cmp	r5, #2
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    204e:	f3c6 2107 	ubfx	r1, r6, #8, #8
    2052:	7079      	strb	r1, [r7, #1]
        pui8Data = (uint8_t *) (&pui32Data[i]);

        //
        // If we had leftover bytes, copy them out one byte at a time.
        //
        for ( j = 0; j < ui32Leftovers; j++ )
    2054:	d008      	beq.n	2068 <am_hal_iom_spi_read_nq+0x2e8>
    2056:	2d03      	cmp	r5, #3
        {
            pui8Data[j] = sTempBuffer.bytes[j];
    2058:	f3c6 4007 	ubfx	r0, r6, #16, #8
    205c:	bf18      	it	ne
    205e:	f3c6 6607 	ubfxne	r6, r6, #24, #8
    2062:	70b8      	strb	r0, [r7, #2]
    2064:	bf18      	it	ne
    2066:	70fe      	strbne	r6, [r7, #3]
            //
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);
            ui32NumBytes -= ui32BytesInFifo & ~0x3;
            pui32Data += ui32BytesInFifo >> 2;
        }
        if ( bCmdCmp == true )
    2068:	2b00      	cmp	r3, #0
    206a:	f47f af5d 	bne.w	1f28 <am_hal_iom_spi_read_nq+0x1a8>
            // No more data expected. Get out of the loop
            //
            break;
        }

        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
    206e:	f8db 3000 	ldr.w	r3, [fp]
    2072:	e759      	b.n	1f28 <am_hal_iom_spi_read_nq+0x1a8>
    2074:	1000105c 	.word	0x1000105c
    2078:	1000135c 	.word	0x1000135c
    207c:	00004720 	.word	0x00004720
    2080:	00004648 	.word	0x00004648
    2084:	10001054 	.word	0x10001054
    // OFFSET values.
    //
    // That operation is tricky and detailed, so we'll call a function to do it
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
    2088:	990e      	ldr	r1, [sp, #56]	; 0x38
    208a:	f011 4280 	ands.w	r2, r1, #1073741824	; 0x40000000
    208e:	d104      	bne.n	209a <am_hal_iom_spi_read_nq+0x31a>
isRevB0(void)
{
    //
    // Check to make sure the major rev is B and the minor rev is zero.
    //
    if ( (AM_REG(MCUCTRL, CHIPREV) & 0xFF) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B )
    2090:	4b2a      	ldr	r3, [pc, #168]	; (213c <am_hal_iom_spi_read_nq+0x3bc>)
    2092:	681e      	ldr	r6, [r3, #0]
    2094:	b2f1      	uxtb	r1, r6
    2096:	2920      	cmp	r1, #32
    2098:	d021      	beq.n	20de <am_hal_iom_spi_read_nq+0x35e>
    209a:	f500 7b01 	add.w	fp, r0, #516	; 0x204
    209e:	4828      	ldr	r0, [pc, #160]	; (2140 <am_hal_iom_spi_read_nq+0x3c0>)
    20a0:	9003      	str	r0, [sp, #12]
    20a2:	9e00      	ldr	r6, [sp, #0]
    20a4:	e6a3      	b.n	1dee <am_hal_iom_spi_read_nq+0x6e>
        uint32_t u32RetVal = AM_REGn(IOMSTR, ui32Module, INTSTAT);
        return u32RetVal & AM_REGn(IOMSTR, ui32Module, INTEN);
    }
    else
    {
        return AM_REGn(IOMSTR, ui32Module, INTSTAT);
    20a6:	f8db 3000 	ldr.w	r3, [fp]
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    20aa:	f013 0fcc 	tst.w	r3, #204	; 0xcc
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    20ae:	bf18      	it	ne
    20b0:	2005      	movne	r0, #5
    //
    // Let's accumulate the errors
    //
    ui32IntStatus |= am_hal_iom_int_status_get(ui32Module, false);

    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    20b2:	d002      	beq.n	20ba <am_hal_iom_spi_read_nq+0x33a>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    }
    else
    {
        g_iom_error_status[ui32Module] = ui32Status = internal_iom_get_int_err(ui32Module, 0);
    20b4:	f80a 0004 	strb.w	r0, [sl, r4]
    20b8:	e744      	b.n	1f44 <am_hal_iom_spi_read_nq+0x1c4>
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    {
        // Error in hardware command issued or illegal access by SW
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    20ba:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    20be:	d12d      	bne.n	211c <am_hal_iom_spi_read_nq+0x39c>
//!
//*****************************************************************************
static am_hal_iom_status_e
internal_iom_get_int_err(uint32_t ui32Module, uint32_t ui32IntStatus)
{
    am_hal_iom_status_e ui32Status = AM_HAL_IOM_SUCCESS;
    20c0:	f013 0f10 	tst.w	r3, #16
    20c4:	bf14      	ite	ne
    20c6:	2006      	movne	r0, #6
    20c8:	2000      	moveq	r0, #0
    20ca:	e7f3      	b.n	20b4 <am_hal_iom_spi_read_nq+0x334>
    // Make sure we check the number of bytes we're reading from the FIFO.
    // This doesn't make sense for Full-Duplex operations.
    //
    if ( AM_REG_IOMSTR_CFG_FULLDUP_NORMAL == (AM_REGn(IOMSTR, ui32Module, CFG) & AM_REG_IOMSTR_CFG_FULLDUP_M) )
    {
        am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    20cc:	4a1d      	ldr	r2, [pc, #116]	; (2144 <am_hal_iom_spi_read_nq+0x3c4>)
    20ce:	481e      	ldr	r0, [pc, #120]	; (2148 <am_hal_iom_spi_read_nq+0x3c8>)
    20d0:	9300      	str	r3, [sp, #0]
    20d2:	f640 7142 	movw	r1, #3906	; 0xf42
    20d6:	f7fe fc35 	bl	944 <am_hal_debug_error>
    20da:	9b00      	ldr	r3, [sp, #0]
    20dc:	e6b4      	b.n	1e48 <am_hal_iom_spi_read_nq+0xc8>
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
        isRevB0() )
    {
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data, 0,
    20de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        ui32Options |= AM_HAL_IOM_RAW;
        //
        // Wait for the dummy word to go out over the bus.
        //
        // Make sure the command complete has also been raised
        waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    20e0:	4e17      	ldr	r6, [pc, #92]	; (2140 <am_hal_iom_spi_read_nq+0x3c0>)
    20e2:	9603      	str	r6, [sp, #12]
    // for us.
    //
    if ( (WORKAROUND_IOM == ui32Module) && !(ui32Options & AM_HAL_IOM_RAW) &&
        isRevB0() )
    {
        am_hal_iom_workaround_word_write(ui32ChipSelect, pui32Data, 0,
    20e4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    20e8:	4639      	mov	r1, r7
    20ea:	4640      	mov	r0, r8
    20ec:	f7fe fed6 	bl	e9c <am_hal_iom_workaround_word_write>
        ui32Options |= AM_HAL_IOM_RAW;
        //
        // Wait for the dummy word to go out over the bus.
        //
        // Make sure the command complete has also been raised
        waitStatus = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    20f0:	9a00      	ldr	r2, [sp, #0]
    20f2:	6930      	ldr	r0, [r6, #16]
    20f4:	f502 7b01 	add.w	fp, r2, #516	; 0x204
    20f8:	2301      	movs	r3, #1
    20fa:	4659      	mov	r1, fp
    20fc:	461a      	mov	r2, r3
    20fe:	f7fe fc29 	bl	954 <am_hal_flash_delay_status_change>
                     AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                     AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

        if (waitStatus != 1)
    2102:	2801      	cmp	r0, #1
    2104:	d00c      	beq.n	2120 <am_hal_iom_spi_read_nq+0x3a0>
            g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
            //
            // Re-enable IOM interrupts.
            //
            // Clear interrupts
            AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2106:	9e00      	ldr	r6, [sp, #0]
            AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    2108:	9902      	ldr	r1, [sp, #8]
            g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
            //
            // Re-enable IOM interrupts.
            //
            // Clear interrupts
            AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    210a:	f8c6 9208 	str.w	r9, [r6, #520]	; 0x208
                     AM_REG_IOMSTRn(ui32Module) + AM_REG_IOMSTR_INTSTAT_O,
                     AM_REG_IOMSTR_INTEN_CMDCMP_M, AM_REG_IOMSTR_INTEN_CMDCMP_M);

        if (waitStatus != 1)
        {
            g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_TIMEOUT;
    210e:	2001      	movs	r0, #1
    2110:	f88a 0004 	strb.w	r0, [sl, #4]
            //
            // Re-enable IOM interrupts.
            //
            // Clear interrupts
            AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2114:	46b6      	mov	lr, r6
            AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    2116:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
    211a:	e64e      	b.n	1dba <am_hal_iom_spi_read_nq+0x3a>
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    }
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    {
        // Loss of I2C multi-master arbitration
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    211c:	2007      	movs	r0, #7
    211e:	e7c9      	b.n	20b4 <am_hal_iom_spi_read_nq+0x334>
            AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
            return ui32Status;
        }

        // Clear CMDCMP status
        AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
    2120:	9900      	ldr	r1, [sp, #0]

        //
        // The workaround will send our offset for us, so we can run a RAW
        // command after.
        //
        ui32Options |= AM_HAL_IOM_RAW;
    2122:	9e0e      	ldr	r6, [sp, #56]	; 0x38
            AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
            return ui32Status;
        }

        // Clear CMDCMP status
        AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
    2124:	f8d1 0208 	ldr.w	r0, [r1, #520]	; 0x208

        //
        // The workaround will send our offset for us, so we can run a RAW
        // command after.
        //
        ui32Options |= AM_HAL_IOM_RAW;
    2128:	f046 4280 	orr.w	r2, r6, #1073741824	; 0x40000000
            AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
            return ui32Status;
        }

        // Clear CMDCMP status
        AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
    212c:	f040 0301 	orr.w	r3, r0, #1

        //
        // The workaround will send our offset for us, so we can run a RAW
        // command after.
        //
        ui32Options |= AM_HAL_IOM_RAW;
    2130:	920e      	str	r2, [sp, #56]	; 0x38
            AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
            return ui32Status;
        }

        // Clear CMDCMP status
        AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
    2132:	f8c1 3208 	str.w	r3, [r1, #520]	; 0x208
    2136:	460e      	mov	r6, r1
    2138:	e659      	b.n	1dee <am_hal_iom_spi_read_nq+0x6e>
    213a:	bf00      	nop
    213c:	4002000c 	.word	0x4002000c
    2140:	1000135c 	.word	0x1000135c
    2144:	00004720 	.word	0x00004720
    2148:	00004648 	.word	0x00004648

0000214c <am_hal_iom_spi_read>:
{
    am_hal_iom_status_e ui32Status;
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    214c:	2805      	cmp	r0, #5
    214e:	d901      	bls.n	2154 <am_hal_iom_spi_read+0x8>
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    2150:	2002      	movs	r0, #2
        //
        ui32Status = am_hal_iom_spi_read_nq(ui32Module, ui32ChipSelect, pui32Data,
                               ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    2152:	4770      	bx	lr
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_read(uint32_t ui32Module, uint32_t ui32ChipSelect,
                    uint32_t *pui32Data, uint32_t ui32NumBytes,
                    uint32_t ui32Options)
{
    2154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    // Reset the error status
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2158:	f500 27a0 	add.w	r7, r0, #327680	; 0x50000
    215c:	3704      	adds	r7, #4
    215e:	033d      	lsls	r5, r7, #12
    2160:	f240 7cff 	movw	ip, #2047	; 0x7ff
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2164:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 2244 <am_hal_iom_spi_read+0xf8>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    // Reset the error status
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    2168:	f8c5 c208 	str.w	ip, [r5, #520]	; 0x208
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    if (ui32NumBytes == 0)
    216c:	f640 79fe 	movw	r9, #4094	; 0xffe
    2170:	1e5d      	subs	r5, r3, #1
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    // Reset the error status
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    2172:	2600      	movs	r6, #0
    if (ui32NumBytes == 0)
    2174:	454d      	cmp	r5, r9
//*****************************************************************************
am_hal_iom_status_e
am_hal_iom_spi_read(uint32_t ui32Module, uint32_t ui32ChipSelect,
                    uint32_t *pui32Data, uint32_t ui32NumBytes,
                    uint32_t ui32Options)
{
    2176:	b08d      	sub	sp, #52	; 0x34
    2178:	4604      	mov	r4, r0
    217a:	469e      	mov	lr, r3
    {
        return AM_HAL_IOM_ERR_INVALID_MODULE;
    }
    // Reset the error status
    AM_REGn(IOMSTR, ui32Module, INTCLR) = AM_HAL_IOM_INT_ALL;
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    217c:	f808 6000 	strb.w	r6, [r8, r0]
    if (ui32NumBytes == 0)
    2180:	d905      	bls.n	218e <am_hal_iom_spi_read+0x42>
    {
        g_iom_error_status[ui32Module] = ui32Status = AM_HAL_IOM_ERR_INVALID_PARAM;
    2182:	2003      	movs	r0, #3
    2184:	f808 0004 	strb.w	r0, [r8, r4]
        //
        ui32Status = am_hal_iom_spi_read_nq(ui32Module, ui32ChipSelect, pui32Data,
                               ui32NumBytes, ui32Options);
    }
    return ui32Status;
}
    2188:	b00d      	add	sp, #52	; 0x34
    218a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    //
    // Check to see if queues have been enabled. If they are, we'll actually
    // switch to the queued interface.
    //
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    218e:	ea4f 0a40 	mov.w	sl, r0, lsl #1
    2192:	f8df b0b4 	ldr.w	fp, [pc, #180]	; 2248 <am_hal_iom_spi_read+0xfc>
    2196:	9202      	str	r2, [sp, #8]
    2198:	eb0a 0500 	add.w	r5, sl, r0
    219c:	eb0b 09c5 	add.w	r9, fp, r5, lsl #3
    21a0:	461f      	mov	r7, r3
    21a2:	f8d9 6014 	ldr.w	r6, [r9, #20]
    21a6:	2e00      	cmp	r6, #0
    21a8:	d043      	beq.n	2232 <am_hal_iom_spi_read+0xe6>
    21aa:	460d      	mov	r5, r1
        return ui32Status;
    }

    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    21ac:	f000 fbd8 	bl	2960 <am_hal_interrupt_master_disable>
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    21b0:	4b22      	ldr	r3, [pc, #136]	; (223c <am_hal_iom_spi_read+0xf0>)
        return ui32Status;
    }

    // Start a critical section.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    21b2:	9003      	str	r0, [sp, #12]
    // there's nothing in the queue already, we can go ahead and start the
    // transaction in the physical IOM. Need to check for the g_bIomBusy to
    // avoid a race condition where IDLE is set - but the command complete
    // for previous transaction has not been processed yet
    //
    if ( (g_bIomBusy[ui32Module] == false) &&
    21b4:	5d1a      	ldrb	r2, [r3, r4]
    21b6:	b912      	cbnz	r2, 21be <am_hal_iom_spi_read+0x72>
    21b8:	f8d9 0008 	ldr.w	r0, [r9, #8]
    21bc:	b1d8      	cbz	r0, 21f6 <am_hal_iom_spi_read+0xaa>
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    21be:	eb0a 0104 	add.w	r1, sl, r4
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_READ;
    21c2:	2301      	movs	r3, #1
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    21c4:	eb0b 00c1 	add.w	r0, fp, r1, lsl #3
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_READ;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
    21c8:	9507      	str	r5, [sp, #28]
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    21ca:	2600      	movs	r6, #0
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_READ;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
    21cc:	9d02      	ldr	r5, [sp, #8]
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
    21ce:	9709      	str	r7, [sp, #36]	; 0x24
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    21d0:	461a      	mov	r2, r3
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_READ;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    21d2:	9f16      	ldr	r7, [sp, #88]	; 0x58
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_READ;
        sIOMTransaction.ui32Module = ui32Module;
    21d4:	9406      	str	r4, [sp, #24]
        sIOMTransaction.pfnCallback = pfnCallback;

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    21d6:	a905      	add	r1, sp, #20
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_READ;
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
    21d8:	9508      	str	r5, [sp, #32]
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
    21da:	970a      	str	r7, [sp, #40]	; 0x28
        //
        // Otherwise, we'll build a transaction structure and add it to the queue.
        //
        am_hal_iom_queue_entry_t sIOMTransaction;

        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_SPI_READ;
    21dc:	9305      	str	r3, [sp, #20]
        sIOMTransaction.ui32Module = ui32Module;
        sIOMTransaction.ui32ChipSelect = ui32ChipSelect;
        sIOMTransaction.pui32Data = pui32Data;
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
        sIOMTransaction.ui32Options = ui32Options;
        sIOMTransaction.pfnCallback = pfnCallback;
    21de:	960b      	str	r6, [sp, #44]	; 0x2c

        //
        // Make sure the item actually makes it into the queue
        //
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    21e0:	f000 fa08 	bl	25f4 <am_hal_queue_item_add>
    21e4:	b9d8      	cbnz	r0, 221e <am_hal_iom_spi_read+0xd2>
        {
            //
            // Didn't have enough memory.
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
    21e6:	2608      	movs	r6, #8
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    21e8:	9803      	ldr	r0, [sp, #12]
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    {
        g_iom_error_status[ui32Module] = ui32Status;
    21ea:	f808 6004 	strb.w	r6, [r8, r4]
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    21ee:	f000 fbbb 	bl	2968 <am_hal_interrupt_master_set>
    21f2:	4630      	mov	r0, r6
    21f4:	e7c8      	b.n	2188 <am_hal_iom_spi_read+0x3c>
    }

    //
    // Poll on the IDLE bit in the status register.
    //
    while ( g_bIomBusy[ui32Module] );
    21f6:	5d1a      	ldrb	r2, [r3, r4]
    21f8:	f002 0eff 	and.w	lr, r2, #255	; 0xff
    21fc:	2a00      	cmp	r2, #0
    21fe:	d1fa      	bne.n	21f6 <am_hal_iom_spi_read+0xaa>
    2200:	9816      	ldr	r0, [sp, #88]	; 0x58
    2202:	9000      	str	r0, [sp, #0]
    2204:	f8cd e004 	str.w	lr, [sp, #4]
    2208:	463b      	mov	r3, r7
    220a:	9a02      	ldr	r2, [sp, #8]
    //
    // Wait until the bus is idle
    //
    am_hal_iom_poll_complete(ui32Module);
    // Reset the error status
    ui32Status = g_iom_error_status[ui32Module] = AM_HAL_IOM_SUCCESS;
    220c:	f808 e004 	strb.w	lr, [r8, r4]
    2210:	4629      	mov	r1, r5
    2212:	4620      	mov	r0, r4
    2214:	f7ff fb14 	bl	1840 <am_hal_iom_spi_read_nb.part.7>
            //
            ui32Status = AM_HAL_IOM_ERR_RESOURCE_ERR;
        }
    }

    if (ui32Status != AM_HAL_IOM_SUCCESS)
    2218:	4606      	mov	r6, r0
    221a:	2800      	cmp	r0, #0
    221c:	d1e4      	bne.n	21e8 <am_hal_iom_spi_read+0x9c>
        g_iom_error_status[ui32Module] = ui32Status;
    }
    //
    // Exit the critical section.
    //
    am_hal_interrupt_master_set(ui32Critical);
    221e:	9803      	ldr	r0, [sp, #12]
    2220:	f000 fba2 	bl	2968 <am_hal_interrupt_master_set>
        if (ui32Status == AM_HAL_IOM_SUCCESS)
        {
            //
            // Wait until the transaction actually clears.
            //
            am_hal_iom_queue_flush(ui32Module);
    2224:	4906      	ldr	r1, [pc, #24]	; (2240 <am_hal_iom_spi_read+0xf4>)
    2226:	4620      	mov	r0, r4
    2228:	680b      	ldr	r3, [r1, #0]
    222a:	4798      	blx	r3
            // g_iom_error_status gets set in the isr handling
            ui32Status = g_iom_error_status[ui32Module];
    222c:	f818 0004 	ldrb.w	r0, [r8, r4]
    2230:	e7aa      	b.n	2188 <am_hal_iom_spi_read+0x3c>
    else
    {
        //
        // Otherwise, just perform a polled transaction.
        //
        ui32Status = am_hal_iom_spi_read_nq(ui32Module, ui32ChipSelect, pui32Data,
    2232:	9c16      	ldr	r4, [sp, #88]	; 0x58
    2234:	9400      	str	r4, [sp, #0]
    2236:	f7ff fda3 	bl	1d80 <am_hal_iom_spi_read_nq>
    223a:	e7a5      	b.n	2188 <am_hal_iom_spi_read+0x3c>
    223c:	1000105c 	.word	0x1000105c
    2240:	10001050 	.word	0x10001050
    2244:	10001054 	.word	0x10001054
    2248:	100013ec 	.word	0x100013ec

0000224c <am_hal_iom_int_clear>:
am_hal_iom_int_clear(uint32_t ui32Module, uint32_t ui32Interrupt)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    224c:	2805      	cmp	r0, #5
    224e:	d805      	bhi.n	225c <am_hal_iom_int_clear+0x10>
    {
        return;
    }

    AM_REGn(IOMSTR, ui32Module, INTCLR) = ui32Interrupt;
    2250:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    2254:	3004      	adds	r0, #4
    2256:	0302      	lsls	r2, r0, #12
    2258:	f8c2 1208 	str.w	r1, [r2, #520]	; 0x208
    225c:	4770      	bx	lr
    225e:	bf00      	nop

00002260 <am_hal_pwrctrl_periph_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{
    2260:	b510      	push	{r4, lr}

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    2262:	4604      	mov	r4, r0
//! @return None.
//
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{
    2264:	b082      	sub	sp, #8

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    2266:	b1c0      	cbz	r0, 229a <am_hal_pwrctrl_periph_enable+0x3a>
    2268:	1e43      	subs	r3, r0, #1
    226a:	4203      	tst	r3, r0
    226c:	d115      	bne.n	229a <am_hal_pwrctrl_periph_enable+0x3a>
                        "Cannot enable more than one peripheral at a time.");

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    226e:	f3ef 8010 	mrs	r0, PRIMASK
    2272:	9001      	str	r0, [sp, #4]
    2274:	b672      	cpsid	i

    //
    // Enable power control for the given device.
    //
    AM_REG(PWRCTRL, DEVICEEN) |= ui32Peripheral;
    2276:	4a18      	ldr	r2, [pc, #96]	; (22d8 <am_hal_pwrctrl_periph_enable+0x78>)
    2278:	6811      	ldr	r1, [r2, #0]
    227a:	4321      	orrs	r1, r4
    227c:	6011      	str	r1, [r2, #0]

    //
    // End Critical Section.
    //
    AM_CRITICAL_END_ASM
    227e:	9b01      	ldr	r3, [sp, #4]
    2280:	f383 8810 	msr	PRIMASK, r3

    //
    // Wait for the power to stablize.  Using a simple delay loop is more
    // power efficient than a polling loop.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);
    2284:	200e      	movs	r0, #14
    2286:	f7fe fb5f 	bl	948 <am_hal_flash_delay>

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    228a:	f014 0f0e 	tst.w	r4, #14
    228e:	d10a      	bne.n	22a6 <am_hal_pwrctrl_periph_enable+0x46>
    2290:	f014 0f70 	tst.w	r4, #112	; 0x70
    2294:	d00e      	beq.n	22b4 <am_hal_pwrctrl_periph_enable+0x54>
    2296:	2408      	movs	r4, #8
    2298:	e006      	b.n	22a8 <am_hal_pwrctrl_periph_enable+0x48>
//*****************************************************************************
void
am_hal_pwrctrl_periph_enable(uint32_t ui32Peripheral)
{

    am_hal_debug_assert_msg(ONE_BIT(ui32Peripheral),
    229a:	4a10      	ldr	r2, [pc, #64]	; (22dc <am_hal_pwrctrl_periph_enable+0x7c>)
    229c:	4810      	ldr	r0, [pc, #64]	; (22e0 <am_hal_pwrctrl_periph_enable+0x80>)
    229e:	215d      	movs	r1, #93	; 0x5d
    22a0:	f7fe fb50 	bl	944 <am_hal_debug_error>
    22a4:	e7e3      	b.n	226e <am_hal_pwrctrl_periph_enable+0xe>
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    22a6:	2404      	movs	r4, #4
    22a8:	4a0e      	ldr	r2, [pc, #56]	; (22e4 <am_hal_pwrctrl_periph_enable+0x84>)
    22aa:	6811      	ldr	r1, [r2, #0]
    22ac:	420c      	tst	r4, r1
    22ae:	d0fc      	beq.n	22aa <am_hal_pwrctrl_periph_enable+0x4a>
}
    22b0:	b002      	add	sp, #8
    22b2:	bd10      	pop	{r4, pc}
    am_hal_flash_delay(AM_HAL_PWRCTRL_DEVICEEN_DELAYCYCLES / 3);

    //
    // Quick check to guarantee we're good (should never be more than 1 read).
    //
    POLL_PWRSTATUS(ui32Peripheral);
    22b4:	f240 1081 	movw	r0, #385	; 0x181
    22b8:	4020      	ands	r0, r4
    22ba:	b940      	cbnz	r0, 22ce <am_hal_pwrctrl_periph_enable+0x6e>
    22bc:	05a3      	lsls	r3, r4, #22
    22be:	d408      	bmi.n	22d2 <am_hal_pwrctrl_periph_enable+0x72>
    22c0:	f414 6f80 	tst.w	r4, #1024	; 0x400
    22c4:	bf14      	ite	ne
    22c6:	2410      	movne	r4, #16
    22c8:	f04f 34ff 	moveq.w	r4, #4294967295
    22cc:	e7ec      	b.n	22a8 <am_hal_pwrctrl_periph_enable+0x48>
    22ce:	2402      	movs	r4, #2
    22d0:	e7ea      	b.n	22a8 <am_hal_pwrctrl_periph_enable+0x48>
    22d2:	2480      	movs	r4, #128	; 0x80
    22d4:	e7e8      	b.n	22a8 <am_hal_pwrctrl_periph_enable+0x48>
    22d6:	bf00      	nop
    22d8:	40021008 	.word	0x40021008
    22dc:	00004758 	.word	0x00004758
    22e0:	0000478c 	.word	0x0000478c
    22e4:	40021014 	.word	0x40021014

000022e8 <am_hal_pwrctrl_memory_enable>:
{
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    22e8:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    22ec:	b430      	push	{r4, r5}
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    22ee:	d03a      	beq.n	2366 <am_hal_pwrctrl_memory_enable+0x7e>
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    22f0:	f5b0 5fc0 	cmp.w	r0, #6144	; 0x1800
    22f4:	f000 809d 	beq.w	2432 <am_hal_pwrctrl_memory_enable+0x14a>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    22f8:	2801      	cmp	r0, #1
    22fa:	f000 809d 	beq.w	2438 <am_hal_pwrctrl_memory_enable+0x150>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    22fe:	2803      	cmp	r0, #3
    2300:	f000 80a6 	beq.w	2450 <am_hal_pwrctrl_memory_enable+0x168>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM24K )
    2304:	2807      	cmp	r0, #7
    2306:	f000 809c 	beq.w	2442 <am_hal_pwrctrl_memory_enable+0x15a>
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    230a:	280f      	cmp	r0, #15
    230c:	f000 80a5 	beq.w	245a <am_hal_pwrctrl_memory_enable+0x172>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    2310:	281f      	cmp	r0, #31
    2312:	f000 80b1 	beq.w	2478 <am_hal_pwrctrl_memory_enable+0x190>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    2316:	283f      	cmp	r0, #63	; 0x3f
    2318:	f000 80b5 	beq.w	2486 <am_hal_pwrctrl_memory_enable+0x19e>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    231c:	287f      	cmp	r0, #127	; 0x7f
    231e:	f000 80b9 	beq.w	2494 <am_hal_pwrctrl_memory_enable+0x1ac>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    2322:	28ff      	cmp	r0, #255	; 0xff
    2324:	f000 80a0 	beq.w	2468 <am_hal_pwrctrl_memory_enable+0x180>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    2328:	f240 13ff 	movw	r3, #511	; 0x1ff
    232c:	4298      	cmp	r0, r3
    232e:	f000 80b8 	beq.w	24a2 <am_hal_pwrctrl_memory_enable+0x1ba>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    2332:	f240 31ff 	movw	r1, #1023	; 0x3ff
    2336:	4288      	cmp	r0, r1
    2338:	f000 80b9 	beq.w	24ae <am_hal_pwrctrl_memory_enable+0x1c6>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM256K )
    233c:	f240 72ff 	movw	r2, #2047	; 0x7ff
    2340:	4290      	cmp	r0, r2
    2342:	d00e      	beq.n	2362 <am_hal_pwrctrl_memory_enable+0x7a>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM256K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    2344:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
    2348:	f000 80b7 	beq.w	24ba <am_hal_pwrctrl_memory_enable+0x1d2>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    234c:	f06f 4420 	mvn.w	r4, #2684354560	; 0xa0000000
    2350:	42a0      	cmp	r0, r4
    2352:	f000 80b5 	beq.w	24c0 <am_hal_pwrctrl_memory_enable+0x1d8>
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_ALL )
    2356:	f104 4580 	add.w	r5, r4, #1073741824	; 0x40000000
    235a:	f505 5c00 	add.w	ip, r5, #8192	; 0x2000
    235e:	4560      	cmp	r0, ip
    2360:	d132      	bne.n	23c8 <am_hal_pwrctrl_memory_enable+0xe0>
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_ALL;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
    2362:	495c      	ldr	r1, [pc, #368]	; (24d4 <am_hal_pwrctrl_memory_enable+0x1ec>)
    2364:	e066      	b.n	2434 <am_hal_pwrctrl_memory_enable+0x14c>
    2366:	f46f 5580 	mvn.w	r5, #4096	; 0x1000
    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    236a:	2340      	movs	r3, #64	; 0x40

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
    236c:	2120      	movs	r1, #32
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    236e:	4c5a      	ldr	r4, [pc, #360]	; (24d8 <am_hal_pwrctrl_memory_enable+0x1f0>)
    2370:	6822      	ldr	r2, [r4, #0]
    2372:	402a      	ands	r2, r5
    2374:	6022      	str	r2, [r4, #0]
    //
    // Enable the required memory.
    //
    if ( ui32MemEnMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) |= ui32MemEnMask;
    2376:	4d58      	ldr	r5, [pc, #352]	; (24d8 <am_hal_pwrctrl_memory_enable+0x1f0>)
    2378:	682c      	ldr	r4, [r5, #0]
    237a:	4320      	orrs	r0, r4
    237c:	6028      	str	r0, [r5, #0]
    //
    // Wait for the power to be turned on.
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    237e:	2b00      	cmp	r3, #0
    2380:	d029      	beq.n	23d6 <am_hal_pwrctrl_memory_enable+0xee>
    {
        while ( --i32TOcnt              &&
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    2382:	4a56      	ldr	r2, [pc, #344]	; (24dc <am_hal_pwrctrl_memory_enable+0x1f4>)
    2384:	6810      	ldr	r0, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    2386:	4203      	tst	r3, r0
    2388:	bf18      	it	ne
    238a:	20c6      	movne	r0, #198	; 0xc6
    238c:	d01f      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    238e:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    2390:	422b      	tst	r3, r5
    2392:	d01c      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    2394:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    2396:	4223      	tst	r3, r4
    2398:	d019      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    239a:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    239c:	422b      	tst	r3, r5
    239e:	d016      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    23a0:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    23a2:	4223      	tst	r3, r4
    23a4:	d013      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    23a6:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    23a8:	422b      	tst	r3, r5
    23aa:	d010      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    23ac:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    23ae:	4223      	tst	r3, r4
    23b0:	d00d      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    23b2:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    23b4:	422b      	tst	r3, r5
    23b6:	d00a      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    23b8:	6814      	ldr	r4, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    23ba:	4223      	tst	r3, r4
    23bc:	d007      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    23be:	6815      	ldr	r5, [r2, #0]
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    {
        while ( --i32TOcnt              &&
    23c0:	422b      	tst	r3, r5
    23c2:	d004      	beq.n	23ce <am_hal_pwrctrl_memory_enable+0xe6>
    23c4:	3809      	subs	r0, #9
    23c6:	d1e2      	bne.n	238e <am_hal_pwrctrl_memory_enable+0xa6>
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
        ui32PwrStatDisMask = 0;
    }
    else
    {
        return false;
    23c8:	2000      	movs	r0, #0
    {
        return false;
    }

    return true;
}
    23ca:	bc30      	pop	{r4, r5}
    23cc:	4770      	bx	lr
    {
        return false;
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    23ce:	b911      	cbnz	r1, 23d6 <am_hal_pwrctrl_memory_enable+0xee>
    if ( i32TOcnt <= 0 )
    {
        return false;
    }

    return true;
    23d0:	2001      	movs	r0, #1
}
    23d2:	bc30      	pop	{r4, r5}
    23d4:	4770      	bx	lr

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    23d6:	4b41      	ldr	r3, [pc, #260]	; (24dc <am_hal_pwrctrl_memory_enable+0x1f4>)
    23d8:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    23da:	ea31 0402 	bics.w	r4, r1, r2
    23de:	bf18      	it	ne
    23e0:	24c6      	movne	r4, #198	; 0xc6
    23e2:	d0f5      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    23e4:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    23e6:	ea31 0000 	bics.w	r0, r1, r0
    23ea:	d0f1      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    23ec:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    23ee:	ea31 0005 	bics.w	r0, r1, r5
    23f2:	d0ed      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    23f4:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    23f6:	ea31 0002 	bics.w	r0, r1, r2
    23fa:	d0e9      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    23fc:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    23fe:	ea31 0000 	bics.w	r0, r1, r0
    2402:	d0e5      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    2404:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    2406:	ea31 0005 	bics.w	r0, r1, r5
    240a:	d0e1      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    240c:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    240e:	ea31 0002 	bics.w	r0, r1, r2
    2412:	d0dd      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    2414:	6818      	ldr	r0, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    2416:	ea31 0000 	bics.w	r0, r1, r0
    241a:	d0d9      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    241c:	681d      	ldr	r5, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    241e:	ea31 0005 	bics.w	r0, r1, r5
    2422:	d0d5      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    2424:	681a      	ldr	r2, [r3, #0]
    }

    i32TOcnt = 200;
    if ( ui32PwrStatEnMask )
    {
        while ( --i32TOcnt              &&
    2426:	ea31 0002 	bics.w	r0, r1, r2
    242a:	d0d1      	beq.n	23d0 <am_hal_pwrctrl_memory_enable+0xe8>
    242c:	3c09      	subs	r4, #9
    242e:	d1d9      	bne.n	23e4 <am_hal_pwrctrl_memory_enable+0xfc>
    2430:	e7ca      	b.n	23c8 <am_hal_pwrctrl_memory_enable+0xe0>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN |
                         AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
    2432:	2160      	movs	r1, #96	; 0x60
//! @return None.
//
//*****************************************************************************
bool
am_hal_pwrctrl_memory_enable(uint32_t ui32MemEn)
{
    2434:	2300      	movs	r3, #0
    2436:	e79e      	b.n	2376 <am_hal_pwrctrl_memory_enable+0x8e>
    2438:	4d29      	ldr	r5, [pc, #164]	; (24e0 <am_hal_pwrctrl_memory_enable+0x1f8>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    243a:	4b2a      	ldr	r3, [pc, #168]	; (24e4 <am_hal_pwrctrl_memory_enable+0x1fc>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    243c:	f44f 7180 	mov.w	r1, #256	; 0x100
    2440:	e795      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    2442:	f46f 65ff 	mvn.w	r5, #2040	; 0x7f8
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    2446:	f44f 23ff 	mov.w	r3, #522240	; 0x7f800
                         AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~(AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM0     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM1     |
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    244a:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    244e:	e78e      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    2450:	4d25      	ldr	r5, [pc, #148]	; (24e8 <am_hal_pwrctrl_memory_enable+0x200>)
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    2452:	4b26      	ldr	r3, [pc, #152]	; (24ec <am_hal_pwrctrl_memory_enable+0x204>)
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    2454:	f44f 7140 	mov.w	r1, #768	; 0x300
    2458:	e789      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    245a:	f46f 65fe 	mvn.w	r5, #2032	; 0x7f0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    245e:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    2462:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    2466:	e782      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    2468:	f46f 65e0 	mvn.w	r5, #1792	; 0x700
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    246c:	f44f 23e0 	mov.w	r3, #458752	; 0x70000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    2470:	f44f 417f 	mov.w	r1, #65280	; 0xff00
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM160K;
    2474:	20ff      	movs	r0, #255	; 0xff
    2476:	e77a      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    2478:	f46f 65fc 	mvn.w	r5, #2016	; 0x7e0
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    247c:	f44f 23fc 	mov.w	r3, #516096	; 0x7e000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    2480:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
    2484:	e773      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    2486:	f46f 65f8 	mvn.w	r5, #1984	; 0x7c0
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    248a:	f44f 23f8 	mov.w	r3, #507904	; 0x7c000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    248e:	f44f 517c 	mov.w	r1, #16128	; 0x3f00
    2492:	e76c      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    2494:	f46f 65f0 	mvn.w	r5, #1920	; 0x780
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    2498:	f44f 23f0 	mov.w	r3, #491520	; 0x78000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    249c:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
    24a0:	e765      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    24a2:	f46f 65c0 	mvn.w	r5, #1536	; 0x600
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    24a6:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    24aa:	4911      	ldr	r1, [pc, #68]	; (24f0 <am_hal_pwrctrl_memory_enable+0x208>)
    24ac:	e75f      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_SRAMEN_ALL    &
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    24ae:	4911      	ldr	r1, [pc, #68]	; (24f4 <am_hal_pwrctrl_memory_enable+0x20c>)
    24b0:	f46f 6580 	mvn.w	r5, #1024	; 0x400
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    24b4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    24b8:	e759      	b.n	236e <am_hal_pwrctrl_memory_enable+0x86>
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    {
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN    |
                         AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    24ba:	f44f 1120 	mov.w	r1, #2621440	; 0x280000
    24be:	e7b9      	b.n	2434 <am_hal_pwrctrl_memory_enable+0x14c>
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    24c0:	4805      	ldr	r0, [pc, #20]	; (24d8 <am_hal_pwrctrl_memory_enable+0x1f0>)
    24c2:	6803      	ldr	r3, [r0, #0]
    24c4:	f023 4120 	bic.w	r1, r3, #2684354560	; 0xa0000000
    24c8:	6001      	str	r1, [r0, #0]
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    24ca:	f44f 1320 	mov.w	r3, #2621440	; 0x280000
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    {
        ui32MemEnMask = 0;
        ui32MemDisMask  = AM_REG_PWRCTRL_MEMEN_CACHEB0_EN   |
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
    24ce:	2100      	movs	r1, #0
    24d0:	e757      	b.n	2382 <am_hal_pwrctrl_memory_enable+0x9a>
    24d2:	bf00      	nop
    24d4:	0007ff00 	.word	0x0007ff00
    24d8:	40021010 	.word	0x40021010
    24dc:	40021014 	.word	0x40021014
    24e0:	fffff801 	.word	0xfffff801
    24e4:	0007fe00 	.word	0x0007fe00
    24e8:	fffff803 	.word	0xfffff803
    24ec:	0007fc00 	.word	0x0007fc00
    24f0:	0001ff00 	.word	0x0001ff00
    24f4:	0003ff00 	.word	0x0003ff00

000024f8 <am_hal_pwrctrl_bucks_init>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    24f8:	4b0f      	ldr	r3, [pc, #60]	; (2538 <am_hal_pwrctrl_bucks_init+0x40>)
    24fa:	681a      	ldr	r2, [r3, #0]
    24fc:	0792      	lsls	r2, r2, #30
    24fe:	d502      	bpl.n	2506 <am_hal_pwrctrl_bucks_init+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    2500:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    2502:	07c3      	lsls	r3, r0, #31
    2504:	d40e      	bmi.n	2524 <am_hal_pwrctrl_bucks_init+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    2506:	4b0d      	ldr	r3, [pc, #52]	; (253c <am_hal_pwrctrl_bucks_init+0x44>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    2508:	4a0b      	ldr	r2, [pc, #44]	; (2538 <am_hal_pwrctrl_bucks_init+0x40>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    250a:	6819      	ldr	r1, [r3, #0]
    250c:	f041 0002 	orr.w	r0, r1, #2
    2510:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    2512:	6819      	ldr	r1, [r3, #0]
    2514:	f041 0001 	orr.w	r0, r1, #1
    2518:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    251a:	6813      	ldr	r3, [r2, #0]
    251c:	f003 0103 	and.w	r1, r3, #3
    2520:	2903      	cmp	r1, #3
    2522:	d1fa      	bne.n	251a <am_hal_pwrctrl_bucks_init+0x22>
void
am_hal_pwrctrl_bucks_init(void)
{
    am_hal_pwrctrl_bucks_enable();

    while ( ( AM_REG(PWRCTRL, POWERSTATUS) &
    2524:	4a04      	ldr	r2, [pc, #16]	; (2538 <am_hal_pwrctrl_bucks_init+0x40>)
    2526:	6810      	ldr	r0, [r2, #0]
    2528:	f000 0303 	and.w	r3, r0, #3
    252c:	2b03      	cmp	r3, #3
    252e:	d1fa      	bne.n	2526 <am_hal_pwrctrl_bucks_init+0x2e>
                AM_REG_PWRCTRL_POWERSTATUS_MEMBUCKON_M ) );

    //
    // Additional delay to make sure BUCKs are initialized.
    //
    am_hal_flash_delay(200 / 3);
    2530:	2042      	movs	r0, #66	; 0x42
    2532:	f7fe ba09 	b.w	948 <am_hal_flash_delay>
    2536:	bf00      	nop
    2538:	40021004 	.word	0x40021004
    253c:	40021000 	.word	0x40021000

00002540 <am_hal_pwrctrl_bucks_enable>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    2540:	4b0b      	ldr	r3, [pc, #44]	; (2570 <am_hal_pwrctrl_bucks_enable+0x30>)
    2542:	681a      	ldr	r2, [r3, #0]
    2544:	0792      	lsls	r2, r2, #30
    2546:	d502      	bpl.n	254e <am_hal_pwrctrl_bucks_enable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    2548:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    254a:	07c3      	lsls	r3, r0, #31
    254c:	d40e      	bmi.n	256c <am_hal_pwrctrl_bucks_enable+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    254e:	4b09      	ldr	r3, [pc, #36]	; (2574 <am_hal_pwrctrl_bucks_enable+0x34>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    2550:	4a07      	ldr	r2, [pc, #28]	; (2570 <am_hal_pwrctrl_bucks_enable+0x30>)
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    2552:	6819      	ldr	r1, [r3, #0]
    2554:	f041 0002 	orr.w	r0, r1, #2
    2558:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    255a:	6819      	ldr	r1, [r3, #0]
    255c:	f041 0001 	orr.w	r0, r1, #1
    2560:	6018      	str	r0, [r3, #0]

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    2562:	6813      	ldr	r3, [r2, #0]
    2564:	f003 0103 	and.w	r1, r3, #3
    2568:	2903      	cmp	r1, #3
    256a:	d1fa      	bne.n	2562 <am_hal_pwrctrl_bucks_enable+0x22>
    256c:	4770      	bx	lr
    256e:	bf00      	nop
    2570:	40021004 	.word	0x40021004
    2574:	40021000 	.word	0x40021000

00002578 <am_hal_pwrctrl_bucks_disable>:
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    2578:	4b12      	ldr	r3, [pc, #72]	; (25c4 <am_hal_pwrctrl_bucks_disable+0x4c>)
    257a:	681a      	ldr	r2, [r3, #0]
    257c:	0792      	lsls	r2, r2, #30
    257e:	d402      	bmi.n	2586 <am_hal_pwrctrl_bucks_disable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) == 0)
    2580:	6818      	ldr	r0, [r3, #0]
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    2582:	07c3      	lsls	r3, r0, #31
    2584:	d51c      	bpl.n	25c0 <am_hal_pwrctrl_bucks_disable+0x48>
//
//*****************************************************************************
static bool
isRev_ADC(void)
{
    return AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    2586:	4910      	ldr	r1, [pc, #64]	; (25c8 <am_hal_pwrctrl_bucks_disable+0x50>)
    2588:	680b      	ldr	r3, [r1, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    258a:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    258e:	2a20      	cmp	r2, #32
    2590:	d00b      	beq.n	25aa <am_hal_pwrctrl_bucks_disable+0x32>
    else
    {
        //
        // Power them down
        //
        AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 0);
    2592:	4b0e      	ldr	r3, [pc, #56]	; (25cc <am_hal_pwrctrl_bucks_disable+0x54>)
    2594:	681a      	ldr	r2, [r3, #0]
    2596:	f022 0002 	bic.w	r0, r2, #2
    259a:	6018      	str	r0, [r3, #0]
        AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 0);
    259c:	6819      	ldr	r1, [r3, #0]
    259e:	f021 0201 	bic.w	r2, r1, #1
    25a2:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait until BUCKs are disabled.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_BUCKDIS_DELAYCYCLES / 3);
    25a4:	200a      	movs	r0, #10
    25a6:	f7fe b9cf 	b.w	948 <am_hal_flash_delay>

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    25aa:	4809      	ldr	r0, [pc, #36]	; (25d0 <am_hal_pwrctrl_bucks_disable+0x58>)
    25ac:	6801      	ldr	r1, [r0, #0]
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    25ae:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    25b2:	d1ee      	bne.n	2592 <am_hal_pwrctrl_bucks_disable+0x1a>
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_ADC_EN) )
    {
            //
            // Set SUPPLYSRC to handle this case
            //
            AM_REG(PWRCTRL, SUPPLYSRC) &=
    25b4:	4805      	ldr	r0, [pc, #20]	; (25cc <am_hal_pwrctrl_bucks_disable+0x54>)
    25b6:	6803      	ldr	r3, [r0, #0]
    25b8:	f003 0105 	and.w	r1, r3, #5
    25bc:	6001      	str	r1, [r0, #0]
    25be:	e7f1      	b.n	25a4 <am_hal_pwrctrl_bucks_disable+0x2c>
    25c0:	4770      	bx	lr
    25c2:	bf00      	nop
    25c4:	40021004 	.word	0x40021004
    25c8:	4002000c 	.word	0x4002000c
    25cc:	40021000 	.word	0x40021000
    25d0:	40021008 	.word	0x40021008

000025d4 <am_hal_pwrctrl_low_power_init>:
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    25d4:	4905      	ldr	r1, [pc, #20]	; (25ec <am_hal_pwrctrl_low_power_init+0x18>)
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    25d6:	4a06      	ldr	r2, [pc, #24]	; (25f0 <am_hal_pwrctrl_low_power_init+0x1c>)
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    25d8:	680b      	ldr	r3, [r1, #0]
    25da:	f043 0006 	orr.w	r0, r3, #6
    25de:	6008      	str	r0, [r1, #0]
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    25e0:	6811      	ldr	r1, [r2, #0]
    25e2:	f021 0304 	bic.w	r3, r1, #4
    25e6:	6013      	str	r3, [r2, #0]
    25e8:	4770      	bx	lr
    25ea:	bf00      	nop
    25ec:	40021018 	.word	0x40021018
    25f0:	40021000 	.word	0x40021000

000025f4 <am_hal_queue_item_add>:
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
    25f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    25f6:	4604      	mov	r4, r0
    uint32_t i;
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    25f8:	6907      	ldr	r7, [r0, #16]
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
    25fa:	460e      	mov	r6, r1
    uint32_t i;
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    25fc:	fb07 f702 	mul.w	r7, r7, r2
    bool bSuccess = false;
    uint32_t ui32Primask;

    pui8Source = (uint8_t *) pvSource;

    ui32Primask = am_hal_interrupt_master_disable();
    2600:	f000 f9ae 	bl	2960 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't already full
    //
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    2604:	68a5      	ldr	r5, [r4, #8]
    2606:	68e3      	ldr	r3, [r4, #12]
    2608:	1b59      	subs	r1, r3, r5
    260a:	428f      	cmp	r7, r1
    260c:	d87a      	bhi.n	2704 <am_hal_queue_item_add+0x110>
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    260e:	2f00      	cmp	r7, #0
    2610:	d071      	beq.n	26f6 <am_hal_queue_item_add+0x102>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    2612:	4635      	mov	r5, r6
    2614:	6823      	ldr	r3, [r4, #0]
    2616:	6962      	ldr	r2, [r4, #20]
    2618:	f815 1b01 	ldrb.w	r1, [r5], #1
    261c:	54d1      	strb	r1, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    261e:	6822      	ldr	r2, [r4, #0]
    2620:	68e3      	ldr	r3, [r4, #12]
    2622:	3201      	adds	r2, #1
    2624:	19f1      	adds	r1, r6, r7
    2626:	fbb2 fcf3 	udiv	ip, r2, r3
    262a:	1e7e      	subs	r6, r7, #1
    262c:	fb03 231c 	mls	r3, r3, ip, r2
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    2630:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    2632:	6023      	str	r3, [r4, #0]
    2634:	f006 0203 	and.w	r2, r6, #3
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    2638:	d05c      	beq.n	26f4 <am_hal_queue_item_add+0x100>
    263a:	b34a      	cbz	r2, 2690 <am_hal_queue_item_add+0x9c>
    263c:	2a01      	cmp	r2, #1
    263e:	d019      	beq.n	2674 <am_hal_queue_item_add+0x80>
    2640:	2a02      	cmp	r2, #2
    2642:	d00b      	beq.n	265c <am_hal_queue_item_add+0x68>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    2644:	6962      	ldr	r2, [r4, #20]
    2646:	f815 6b01 	ldrb.w	r6, [r5], #1
    264a:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    264c:	6822      	ldr	r2, [r4, #0]
    264e:	68e3      	ldr	r3, [r4, #12]
    2650:	3201      	adds	r2, #1
    2652:	fbb2 fef3 	udiv	lr, r2, r3
    2656:	fb03 231e 	mls	r3, r3, lr, r2
    265a:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    265c:	6962      	ldr	r2, [r4, #20]
    265e:	f815 6b01 	ldrb.w	r6, [r5], #1
    2662:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    2664:	6822      	ldr	r2, [r4, #0]
    2666:	68e3      	ldr	r3, [r4, #12]
    2668:	3201      	adds	r2, #1
    266a:	fbb2 fcf3 	udiv	ip, r2, r3
    266e:	fb03 231c 	mls	r3, r3, ip, r2
    2672:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    2674:	6962      	ldr	r2, [r4, #20]
    2676:	f815 6b01 	ldrb.w	r6, [r5], #1
    267a:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    267c:	6822      	ldr	r2, [r4, #0]
    267e:	68e3      	ldr	r3, [r4, #12]
    2680:	3201      	adds	r2, #1
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    2682:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    2684:	fbb2 fef3 	udiv	lr, r2, r3
    2688:	fb03 231e 	mls	r3, r3, lr, r2
    268c:	6023      	str	r3, [r4, #0]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    268e:	d031      	beq.n	26f4 <am_hal_queue_item_add+0x100>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    2690:	46ac      	mov	ip, r5
    2692:	6962      	ldr	r2, [r4, #20]
    2694:	f81c 6b01 	ldrb.w	r6, [ip], #1
    2698:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    269a:	6823      	ldr	r3, [r4, #0]
    269c:	68e2      	ldr	r2, [r4, #12]
    269e:	3301      	adds	r3, #1
    26a0:	fbb3 fef2 	udiv	lr, r3, r2
    26a4:	fb02 331e 	mls	r3, r2, lr, r3
    26a8:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    26aa:	6962      	ldr	r2, [r4, #20]
    26ac:	786e      	ldrb	r6, [r5, #1]
    26ae:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    26b0:	6823      	ldr	r3, [r4, #0]
    26b2:	68e6      	ldr	r6, [r4, #12]
    26b4:	3301      	adds	r3, #1
    26b6:	fbb3 fef6 	udiv	lr, r3, r6
    26ba:	fb06 331e 	mls	r3, r6, lr, r3
    26be:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    26c0:	6966      	ldr	r6, [r4, #20]
    26c2:	f89c 2001 	ldrb.w	r2, [ip, #1]
    26c6:	54f2      	strb	r2, [r6, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    26c8:	6823      	ldr	r3, [r4, #0]
    26ca:	68e2      	ldr	r2, [r4, #12]
    26cc:	3301      	adds	r3, #1
    26ce:	fbb3 fcf2 	udiv	ip, r3, r2
    26d2:	fb02 331c 	mls	r3, r2, ip, r3
    26d6:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    26d8:	6962      	ldr	r2, [r4, #20]
    26da:	78ee      	ldrb	r6, [r5, #3]
    26dc:	54d6      	strb	r6, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    26de:	6826      	ldr	r6, [r4, #0]
    26e0:	68e3      	ldr	r3, [r4, #12]
    26e2:	3601      	adds	r6, #1
    26e4:	3504      	adds	r5, #4
    26e6:	fbb6 fef3 	udiv	lr, r6, r3
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    26ea:	42a9      	cmp	r1, r5
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    26ec:	fb03 631e 	mls	r3, r3, lr, r6
    26f0:	6023      	str	r3, [r4, #0]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    26f2:	d1cd      	bne.n	2690 <am_hal_queue_item_add+0x9c>
    26f4:	68a5      	ldr	r5, [r4, #8]
        }

        //
        // Update the length value appropriately.
        //
        psQueue->ui32Length += ui32Bytes;
    26f6:	443d      	add	r5, r7
    26f8:	60a5      	str	r5, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
    26fa:	2401      	movs	r4, #1
        // failure.
        //
        bSuccess = false;
    }

    am_hal_interrupt_master_set(ui32Primask);
    26fc:	f000 f934 	bl	2968 <am_hal_interrupt_master_set>

    return bSuccess;
}
    2700:	4620      	mov	r0, r4
    2702:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    {
        //
        // The buffer can't fit the amount of data requested. Return a
        // failure.
        //
        bSuccess = false;
    2704:	2400      	movs	r4, #0
    }

    am_hal_interrupt_master_set(ui32Primask);
    2706:	f000 f92f 	bl	2968 <am_hal_interrupt_master_set>

    return bSuccess;
}
    270a:	4620      	mov	r0, r4
    270c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    270e:	bf00      	nop

00002710 <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    2710:	4a05      	ldr	r2, [pc, #20]	; (2728 <am_hal_rtc_osc_select+0x18>)
    2712:	6813      	ldr	r3, [r2, #0]
{
    //
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    2714:	b918      	cbnz	r0, 271e <am_hal_rtc_osc_select+0xe>
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    2716:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    271a:	6010      	str	r0, [r2, #0]
    271c:	4770      	bx	lr
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    271e:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    2722:	6011      	str	r1, [r2, #0]
    2724:	4770      	bx	lr
    2726:	bf00      	nop
    2728:	4000400c 	.word	0x4000400c

0000272c <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_REG(RTC, RTCCTL) |= AM_REG_RTC_RTCCTL_RSTOP(1);
    272c:	4a02      	ldr	r2, [pc, #8]	; (2738 <am_hal_rtc_osc_disable+0xc>)
    272e:	6813      	ldr	r3, [r2, #0]
    2730:	f043 0010 	orr.w	r0, r3, #16
    2734:	6010      	str	r0, [r2, #0]
    2736:	4770      	bx	lr
    2738:	40004050 	.word	0x40004050

0000273c <am_hal_sysctrl_sleep>:
//! @return None.
//
//*****************************************************************************
void
am_hal_sysctrl_sleep(bool bSleepDeep)
{
    273c:	b5f0      	push	{r4, r5, r6, r7, lr}
    273e:	b083      	sub	sp, #12
    2740:	4605      	mov	r5, r0
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    2742:	f000 f90d 	bl	2960 <am_hal_interrupt_master_disable>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    2746:	4a41      	ldr	r2, [pc, #260]	; (284c <am_hal_sysctrl_sleep+0x110>)
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    2748:	4604      	mov	r4, r0

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    274a:	b11d      	cbz	r5, 2754 <am_hal_sysctrl_sleep+0x18>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    274c:	4b40      	ldr	r3, [pc, #256]	; (2850 <am_hal_sysctrl_sleep+0x114>)
    274e:	6818      	ldr	r0, [r3, #0]

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    2750:	07c3      	lsls	r3, r0, #31
    2752:	d509      	bpl.n	2768 <am_hal_sysctrl_sleep+0x2c>
    else
    {
        //
        // Prepare the core for normal sleep (write 0 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 0);
    2754:	6811      	ldr	r1, [r2, #0]
    2756:	f021 0604 	bic.w	r6, r1, #4
    275a:	6016      	str	r6, [r2, #0]

        //
        // Go to sleep.
        //
        AM_ASM_WFI;
    275c:	bf30      	wfi
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    275e:	4620      	mov	r0, r4
    2760:	f000 f902 	bl	2968 <am_hal_interrupt_master_set>
}
    2764:	b003      	add	sp, #12
    2766:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    2768:	6813      	ldr	r3, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    276a:	493a      	ldr	r1, [pc, #232]	; (2854 <am_hal_sysctrl_sleep+0x118>)
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    276c:	4f3a      	ldr	r7, [pc, #232]	; (2858 <am_hal_sysctrl_sleep+0x11c>)
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    276e:	4d3b      	ldr	r5, [pc, #236]	; (285c <am_hal_sysctrl_sleep+0x120>)

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    2770:	483b      	ldr	r0, [pc, #236]	; (2860 <am_hal_sysctrl_sleep+0x124>)
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    2772:	f043 0604 	orr.w	r6, r3, #4
    2776:	6016      	str	r6, [r2, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    2778:	6809      	ldr	r1, [r1, #0]
                   CHKBUCKZX_REV : 0x0;

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    277a:	683b      	ldr	r3, [r7, #0]
                    CHKBUCKZX_TIMER : 0x0;

    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    277c:	682a      	ldr	r2, [r5, #0]

    //
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    277e:	6800      	ldr	r0, [r0, #0]
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    2780:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
    2784:	2920      	cmp	r1, #32

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    2786:	f103 36ff 	add.w	r6, r3, #4294967295
    uint32_t ui32SupplySrc;

    //
    // Is this chip rev appropriate to do the workaround?
    //
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    278a:	bf14      	ite	ne
    278c:	2500      	movne	r5, #0
    278e:	2502      	moveq	r5, #2

    //
    // Has a timer been configured to handle the workaround?
    //
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
                    CHKBUCKZX_TIMER : 0x0;
    2790:	2e03      	cmp	r6, #3
    2792:	bf8c      	ite	hi
    2794:	2100      	movhi	r1, #0
    2796:	2104      	movls	r1, #4
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    2798:	f012 0303 	ands.w	r3, r2, #3
    279c:	bf18      	it	ne
    279e:	2301      	movne	r3, #1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    27a0:	f240 56ff 	movw	r6, #1535	; 0x5ff
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    27a4:	432b      	orrs	r3, r5
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    27a6:	4006      	ands	r6, r0
    //
    // Are either or both of the bucks actually enabled?
    //
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);

    g_buckZX_chk |= (ui32SupplySrc &
    27a8:	ea43 0501 	orr.w	r5, r3, r1
    // Finally, if any peripheral is already powered up, we don't need to do the
    //  ZX workaround because in this case the bucks remain in active mode.
    //
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);

    g_buckZX_chk |= ( ui32SupplySrc &
    27ac:	b91e      	cbnz	r6, 27b6 <am_hal_sysctrl_sleep+0x7a>
    27ae:	f045 0508 	orr.w	r5, r5, #8
        //
        // Check if special buck handling is needed
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
    27b2:	2d0f      	cmp	r5, #15
    27b4:	d00a      	beq.n	27cc <am_hal_sysctrl_sleep+0x90>
        }

        //
        // Execute the sleep instruction.
        //
        AM_ASM_WFI;
    27b6:	bf30      	wfi

        //
        // Return from sleep
        //
        if ( bBuckZX_chk )
    27b8:	2d0f      	cmp	r5, #15
    27ba:	d01a      	beq.n	27f2 <am_hal_sysctrl_sleep+0xb6>
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    27bc:	4f29      	ldr	r7, [pc, #164]	; (2864 <am_hal_sysctrl_sleep+0x128>)
    27be:	2101      	movs	r1, #1
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    27c0:	4620      	mov	r0, r4
        else
        {
            //
            // Since we're not doing anything, we're done, so set the done flag.
            //
            g_bBuckRestoreComplete = true;
    27c2:	7039      	strb	r1, [r7, #0]
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    27c4:	f000 f8d0 	bl	2968 <am_hal_interrupt_master_set>
}
    27c8:	b003      	add	sp, #12
    27ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
        //
        bBuckZX_chk = buckZX_chk();

        if ( bBuckZX_chk )
        {
            ui32BuckTimer = g_ui32BuckTimer - 1;
    27cc:	683a      	ldr	r2, [r7, #0]
    27ce:	1e50      	subs	r0, r2, #1
    27d0:	9000      	str	r0, [sp, #0]
            //
            // Before going to sleep, clear the buck timers.
            // This will also handle the case where we're going back to
            // sleep before the buck sequence has even completed.
            //
            am_hal_ctimer_clear(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    27d2:	9800      	ldr	r0, [sp, #0]
    27d4:	f04f 31ff 	mov.w	r1, #4294967295
    27d8:	f000 f86a 	bl	28b0 <am_hal_ctimer_clear>

            //
            // Set CMPR0 of both timerA and timerB to the period value
            //
            #define     TIMER_PERIOD_BUCKS  1
            am_hal_ctimer_period_set(ui32BuckTimer,
    27dc:	9800      	ldr	r0, [sp, #0]
    27de:	4633      	mov	r3, r6
    27e0:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    27e4:	f04f 31ff 	mov.w	r1, #4294967295
    27e8:	f000 f876 	bl	28d8 <am_hal_ctimer_period_set>
                                     0);

            //
            // Disable bucks before going to sleep.
            //
            am_hal_pwrctrl_bucks_disable();
    27ec:	f7ff fec4 	bl	2578 <am_hal_pwrctrl_bucks_disable>
    27f0:	e7e1      	b.n	27b6 <am_hal_sysctrl_sleep+0x7a>
    bool bDoRestore = false;

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    27f2:	f3ef 8310 	mrs	r3, PRIMASK
    27f6:	9301      	str	r3, [sp, #4]
    27f8:	b672      	cpsid	i

    //
    // Get the current zero cross trim values.
    //
    ui32SaveCore = AM_BFR(MCUCTRL, BUCK3, COREBUCKZXTRIM);
    27fa:	4e1b      	ldr	r6, [pc, #108]	; (2868 <am_hal_sysctrl_sleep+0x12c>)
    27fc:	6832      	ldr	r2, [r6, #0]
    ui32SaveMem  = AM_BFR(MCUCTRL, BUCK3, MEMBUCKZXTRIM);
    27fe:	6832      	ldr	r2, [r6, #0]
    //
    if ( bDoRestore )
    {
        if ( ui32Flags & SETBUCKZX_RESTORE_CORE_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, COREBUCKZXTRIM, ui32NewCore);
    2800:	6835      	ldr	r5, [r6, #0]
    2802:	f025 0c3c 	bic.w	ip, r5, #60	; 0x3c
    2806:	f04c 021c 	orr.w	r2, ip, #28
    280a:	6032      	str	r2, [r6, #0]
        }

        if ( ui32Flags & SETBUCKZX_RESTORE_MEM_ONLY )
        {
            AM_BFW(MCUCTRL, BUCK3, MEMBUCKZXTRIM,  ui32NewMem);
    280c:	6830      	ldr	r0, [r6, #0]
    280e:	f420 31f0 	bic.w	r1, r0, #122880	; 0x1e000
    2812:	f441 4360 	orr.w	r3, r1, #57344	; 0xe000
    2816:	6033      	str	r3, [r6, #0]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    2818:	9e01      	ldr	r6, [sp, #4]
    281a:	f386 8810 	msr	PRIMASK, r6
                      SETBUCKZX_RESTORE_BOTH );

            //
            // Delay for 2us before enabling bucks.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(2) );
    281e:	201c      	movs	r0, #28
    2820:	f7fe f892 	bl	948 <am_hal_flash_delay>

            //
            // Turn on the bucks
            //
            am_hal_pwrctrl_bucks_enable();
    2824:	f7ff fe8c 	bl	2540 <am_hal_pwrctrl_bucks_enable>

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    2828:	683f      	ldr	r7, [r7, #0]
            g_bBuckRestoreComplete = false;

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    282a:	4910      	ldr	r1, [pc, #64]	; (286c <am_hal_sysctrl_sleep+0x130>)
            ui32BuckTimer = g_ui32BuckTimer - 1;

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    282c:	4d0d      	ldr	r5, [pc, #52]	; (2864 <am_hal_sysctrl_sleep+0x128>)
    282e:	2200      	movs	r2, #0
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    2830:	1e7b      	subs	r3, r7, #1
            g_ui32BuckInputs = 0;

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    2832:	204c      	movs	r0, #76	; 0x4c
            am_hal_pwrctrl_bucks_enable();

            //
            // Get the actual timer number
            //
            ui32BuckTimer = g_ui32BuckTimer - 1;
    2834:	9300      	str	r3, [sp, #0]

            //
            // Initialize the complete flag
            //
            g_bBuckRestoreComplete = false;
    2836:	702a      	strb	r2, [r5, #0]

            //
            // Initialize the input flags
            //
            g_ui32BuckInputs = 0;
    2838:	600a      	str	r2, [r1, #0]

            //
            // Delay for 5us to make sure we're receiving clean buck signals.
            //
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    283a:	f7fe f885 	bl	948 <am_hal_flash_delay>

            //
            // Start timers (set the enable bit, clear the clear bit)
            //
            am_hal_ctimer_start(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    283e:	9800      	ldr	r0, [sp, #0]
    2840:	f04f 31ff 	mov.w	r1, #4294967295
    2844:	f000 f81a 	bl	287c <am_hal_ctimer_start>
    2848:	e789      	b.n	275e <am_hal_sysctrl_sleep+0x22>
    284a:	bf00      	nop
    284c:	e000ed10 	.word	0xe000ed10
    2850:	40020250 	.word	0x40020250
    2854:	4002000c 	.word	0x4002000c
    2858:	10001068 	.word	0x10001068
    285c:	40021000 	.word	0x40021000
    2860:	40021008 	.word	0x40021008
    2864:	10001063 	.word	0x10001063
    2868:	40020068 	.word	0x40020068
    286c:	10001064 	.word	0x10001064

00002870 <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    2870:	4b01      	ldr	r3, [pc, #4]	; (2878 <am_hal_vcomp_disable+0x8>)
    2872:	2237      	movs	r2, #55	; 0x37
    2874:	601a      	str	r2, [r3, #0]
    2876:	4770      	bx	lr
    2878:	4000c008 	.word	0x4000c008

0000287c <am_hal_ctimer_start>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    287c:	b410      	push	{r4}
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    287e:	f3ef 8310 	mrs	r3, PRIMASK
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    2882:	b083      	sub	sp, #12
    uint32_t ui32ConfigVal;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    2884:	0100      	lsls	r0, r0, #4
    2886:	4a09      	ldr	r2, [pc, #36]	; (28ac <am_hal_ctimer_start+0x30>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    2888:	9301      	str	r3, [sp, #4]
    288a:	b672      	cpsid	i

    //
    // Read the current value.
    //
    ui32ConfigVal = *pui32ConfigReg;
    288c:	5883      	ldr	r3, [r0, r2]

    //
    // Clear out the "clear" bit.
    //
    ui32ConfigVal &= ~(ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0CLR_M |
    288e:	f001 2408 	and.w	r4, r1, #134219776	; 0x8000800
    2892:	ea23 0304 	bic.w	r3, r3, r4
                                           AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Set the "enable bit"
    //
    ui32ConfigVal |= (ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0EN_M |
    2896:	f001 1101 	and.w	r1, r1, #65537	; 0x10001
    289a:	4319      	orrs	r1, r3
                                          AM_REG_CTIMER_CTRL0_TMRB0EN_M));

    //
    // Write the value back to the register.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    289c:	5081      	str	r1, [r0, r2]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    289e:	9801      	ldr	r0, [sp, #4]
    28a0:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_start()
    28a4:	b003      	add	sp, #12
    28a6:	f85d 4b04 	ldr.w	r4, [sp], #4
    28aa:	4770      	bx	lr
    28ac:	4000800c 	.word	0x4000800c

000028b0 <am_hal_ctimer_clear>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_clear(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    28b0:	b082      	sub	sp, #8
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    28b2:	f3ef 8310 	mrs	r3, PRIMASK
    volatile uint32_t *pui32ConfigReg;

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    28b6:	0100      	lsls	r0, r0, #4
    28b8:	4a06      	ldr	r2, [pc, #24]	; (28d4 <am_hal_ctimer_clear+0x24>)
                                  (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    28ba:	9301      	str	r3, [sp, #4]
    28bc:	b672      	cpsid	i

    //
    // Set the "clear" bit
    //
    AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
    28be:	5883      	ldr	r3, [r0, r2]
    28c0:	f001 2108 	and.w	r1, r1, #134219776	; 0x8000800
    28c4:	4319      	orrs	r1, r3
    28c6:	5081      	str	r1, [r0, r2]
                                   AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    28c8:	9801      	ldr	r0, [sp, #4]
    28ca:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_clear()
    28ce:	b002      	add	sp, #8
    28d0:	4770      	bx	lr
    28d2:	bf00      	nop
    28d4:	4000800c 	.word	0x4000800c

000028d8 <am_hal_ctimer_period_set>:
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    28d8:	b4f0      	push	{r4, r5, r6, r7}
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    28da:	f3ef 8410 	mrs	r4, PRIMASK
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    28de:	b082      	sub	sp, #8
    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                   (ui32TimerNumber * TIMER_OFFSET));
    28e0:	0100      	lsls	r0, r0, #4

    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    28e2:	4d1c      	ldr	r5, [pc, #112]	; (2954 <am_hal_ctimer_period_set+0x7c>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    28e4:	9401      	str	r4, [sp, #4]
                                   (ui32TimerNumber * TIMER_OFFSET));

    //
    // Find the correct compare registers to write.
    //
    pui32CompareRegA = (uint32_t *)(AM_REG_CTIMERn(0) +
    28e6:	4e1c      	ldr	r6, [pc, #112]	; (2958 <am_hal_ctimer_period_set+0x80>)
                                    AM_REG_CTIMER_CMPRA0_O +
                                    (ui32TimerNumber * TIMER_OFFSET));

    pui32CompareRegB = (uint32_t *)(AM_REG_CTIMERn(0) +
    28e8:	4f1c      	ldr	r7, [pc, #112]	; (295c <am_hal_ctimer_period_set+0x84>)
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    28ea:	b672      	cpsid	i
    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    28ec:	f511 3f80 	cmn.w	r1, #65536	; 0x10000

    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    28f0:	5944      	ldr	r4, [r0, r5]
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    28f2:	d01a      	beq.n	292a <am_hal_ctimer_period_set+0x52>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    28f4:	f404 75c0 	and.w	r5, r4, #384	; 0x180
    28f8:	2d80      	cmp	r5, #128	; 0x80
    28fa:	d01b      	beq.n	2934 <am_hal_ctimer_period_set+0x5c>

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    28fc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    2900:	2500      	movs	r5, #0
    2902:	4299      	cmp	r1, r3
        ui32Comp1 = ui32Period;
    }
    else
    {
        ui32Comp0 = ui32Period;
        ui32Comp1 = 0;
    2904:	462c      	mov	r4, r5

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    2906:	d01c      	beq.n	2942 <am_hal_ctimer_period_set+0x6a>
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));
    }
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    2908:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    290c:	d01e      	beq.n	294c <am_hal_ctimer_period_set+0x74>
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    290e:	0c21      	lsrs	r1, r4, #16
    2910:	040c      	lsls	r4, r1, #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    2912:	b291      	uxth	r1, r2
    2914:	430d      	orrs	r5, r1
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    2916:	ea44 4212 	orr.w	r2, r4, r2, lsr #16
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    291a:	5185      	str	r5, [r0, r6]
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    291c:	51c2      	str	r2, [r0, r7]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    291e:	9801      	ldr	r0, [sp, #4]
    2920:	f380 8810 	msr	PRIMASK, r0
} // am_hal_ctimer_period_set()
    2924:	b002      	add	sp, #8
    2926:	bcf0      	pop	{r4, r5, r6, r7}
    2928:	4770      	bx	lr

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    292a:	0c25      	lsrs	r5, r4, #16
    292c:	f405 74c0 	and.w	r4, r5, #384	; 0x180
    2930:	2c80      	cmp	r4, #128	; 0x80
    2932:	d10a      	bne.n	294a <am_hal_ctimer_period_set+0x72>
    2934:	0415      	lsls	r5, r2, #16
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
        ui32Comp1 = ui32Period;
    2936:	4614      	mov	r4, r2
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
        ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
    {
        ui32Comp0 = ui32Period - ui32OnTime;
    2938:	1ad2      	subs	r2, r2, r3

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    293a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    293e:	4299      	cmp	r1, r3
    2940:	d1e2      	bne.n	2908 <am_hal_ctimer_period_set+0x30>
    {
        //
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    2942:	b297      	uxth	r7, r2
    2944:	433d      	orrs	r5, r7
    2946:	5185      	str	r5, [r0, r6]
    2948:	e7e9      	b.n	291e <am_hal_ctimer_period_set+0x46>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    294a:	2500      	movs	r5, #0
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    {
        //
        // For timer B, write the values to the TIMERA compare register.
        //
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    294c:	b296      	uxth	r6, r2
    294e:	4335      	orrs	r5, r6
    2950:	51c5      	str	r5, [r0, r7]
    2952:	e7e4      	b.n	291e <am_hal_ctimer_period_set+0x46>
    2954:	4000800c 	.word	0x4000800c
    2958:	40008004 	.word	0x40008004
    295c:	40008008 	.word	0x40008008

00002960 <am_hal_interrupt_master_disable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
    2960:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
    2964:	b672      	cpsid	i
    __asm("    bx lr");
    2966:	4770      	bx	lr

00002968 <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
    2968:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
    296c:	4770      	bx	lr
    296e:	bf00      	nop

00002970 <g_pui8Apollo2BootDemo>:
    2970:	1000 1000 9c01 0000 9c09 0000 98dd 0000     ................
    2980:	98dd 0000 98dd 0000 98dd 0000 0000 0000     ................
	...
    299c:	9c07 0000 9c07 0000 0000 0000 9c07 0000     ................
    29ac:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    29bc:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    29cc:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    29dc:	9c07 0000 9c07 0000 93a7 0000 9c07 0000     ................
    29ec:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    29fc:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    2a0c:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    2a1c:	9c07 0000 9c07 0000 9c07 0000 9c07 0000     ................
    2a2c:	9c07 0000 f8df 18a0 6008 4770 e92d 0ff0     .........`pG-...
    2a3c:	0004 000d 2d00 d04d 0020 0029 0849 ea5f     .....-M. .).I._.
    2a4c:	0030 4680 4689 0020 0029 0880 ea40 7081     0..F.F .)...@..p
    2a5c:	0889 eb18 0000 eb59 0101 0006 000f 0030     ......Y.......0.
    2a6c:	0039 0900 ea40 7001 0909 1836 414f 0030     9...@..p..6.OA0.
    2a7c:	0039 0a00 ea40 6001 0a09 1836 414f 0030     9...@..`..6.OA0.
    2a8c:	0039 0c00 ea40 4001 0c09 1836 414f 0030     9...@..@..6.OA0.
    2a9c:	0039 0008 2100 1836 414f 08f6 ea46 7647     9....!6.OA..F.Gv
    2aac:	08ff 200a 2100 fba0 8906 fb00 9907 fb01     ... .!..........
    2abc:	9906 ebb4 0008 eb75 0109 4682 468b f11a     ......u....F.F..
    2acc:	0006 f15b 0100 0900 ea40 7001 0909 1830     ..[.....@..p..0.
    2adc:	4179 e015 46a4 4660 0880 eb10 005c 0002     yA...F`F....\...
    2aec:	eb12 1212 eb12 2212 eb12 4212 08d2 200a     ......."...B... 
    2afc:	fb00 c012 0003 1d9b eb12 1213 0010 2100     ...............!
    2b0c:	e8bd 0ff0 4770 b510 0002 000b 2000 2100     ....pG....... .!
    2b1c:	428b d101 4282 d001 2400 e000 2401 2000     .B...B...$...$. 
    2b2c:	2100 428b d101 4282 d007 0010 0019 f7ff     .!.B...B........
    2b3c:	ff7d 0002 000b 1c64 e7f1 0020 bd10 b580     }.....d... .....
    2b4c:	2200 2300 4299 dc05 db01 4290 d202 4240     .".#.B.....B..@B
    2b5c:	eb71 0141 f7ff ffd7 bd02 b430 0002 000b     q.A.......0.....
    2b6c:	2000 2100 428b d101 4282 d001 2000 e000     . .!.B...B... ..
    2b7c:	2001 2400 2500 42ab d101 42a2 d005 0912     . .$.%.B...B....
    2b8c:	ea42 7203 091b 1c40 e7f3 bc30 4770 b430     B..r..@...0.pG0.
    2b9c:	0003 2200 2000 2500 781c 2c2d d103 2401     ...". .%.x-,...$
    2bac:	0022 1c5b 1c6d 781c 2c30 db0a 781c 2c3a     ".[.m..x0,...x:,
    2bbc:	da07 1c6d 240a 4360 781c 3c30 1820 1c5b     ..m..$`C.x0< .[.
    2bcc:	e7f1 2900 d000 600d b2d2 2a00 d001 4240     ...)...`...*..@B
    2bdc:	e7ff bc30 4770 e92d 4ff0 b087 0006 000f     ..0.pG-..O......
    2bec:	4690 f05f 0900 f05f 0a00 0030 0039 f7ff     .F_..._...0.9...
    2bfc:	ff1d 0004 000d 200a 2100 fba0 2304 fb00     ....... .!...#..
    2c0c:	3305 fb01 3304 1ab0 eb77 0103 4683 f11b     .3...3..w....F..
    2c1c:	0030 4669 f801 0009 f119 0901 0026 002f     0.iF........&./.
    2c2c:	2000 2100 428f d1e0 4286 d1de 46ca f1b8     . .!.B...B...F..
    2c3c:	0f00 d00f 4648 f1b0 0901 2800 d007 4668     ....HF.....(..hF
    2c4c:	f810 0009 f888 0000 f118 0801 e7f2 2000     ............... 
    2c5c:	f888 0000 4650 b007 e8bd 8ff0 b5f0 b085     ....PF..........
    2c6c:	0004 000d f05f 0c00 2600 2700 42bd d107     ...._....&.'.B..
    2c7c:	42b4 d105 2030 466e f806 000c f11c 0c01     .B..0 nF........
    2c8c:	2600 2700 42bd d101 42b4 d01c 0020 f010     .&.'.B...B.. ...
    2c9c:	000f 4686 fa5f fe8e f1be 0f0a db07 b2db     ...F_...........
    2cac:	2b00 d001 2027 e000 2007 eb10 0e0e f11e     .+..' ... ......
    2cbc:	0030 466e f806 000c f11c 0c01 0924 ea44     0.nF........$.D.
    2ccc:	7405 092d e7dc 4661 2a00 d00c 4660 f1b0     .t-...aF.*..`F..
    2cdc:	0c01 2800 d005 4668 f810 000c 7010 1c52     ...(..hF.....pR.
    2cec:	e7f4 2000 7010 0008 b005 bdf0 0002 2000     ... .p......... 
    2cfc:	2a00 d006 0011 1c4a 7809 2900 d001 1c40     .*....J..x.)..@.
    2d0c:	e7f8 4770 b410 0004 2000 2a01 db09 0013     ..pG..... .*....
    2d1c:	1e5a 2b00 d005 2c00 d001 7021 1c64 1c40     Z..+...,..!pd.@.
    2d2c:	e7f5 bc10 4770 e92d 4ff8 ed2d 8b02 b082     ....pG-..O-.....
    2d3c:	eeb0 8a40 0006 000f 6830 4683 f1bb 0f04     ..@.....0h.F....
    2d4c:	da02 f07f 0002 e09a eeb5 8a40 eef1 fa10     ..........@.....
    2d5c:	d104 f8df 057c 6030 2003 e090 46b1 ed8d     ....|.0`. ...F..
    2d6c:	8a00 9800 f3c0 50c7 387f 4680 9800 f020     .......P.8.F.. .
    2d7c:	407f f450 0000 4682 2000 0005 2000 0004     .@P....F. ... ..
    2d8c:	f1b8 0f1f db02 f07f 0001 e078 f118 0f17     ..........x.....
    2d9c:	da02 f05f 30ff e072 f1b8 0f17 db05 4640     .._..0r.......@F
    2dac:	3817 fa1a f000 0004 e016 f1b8 0f00 d40c     .8..............
    2dbc:	f1d8 0017 4651 4101 000c f118 0001 fa1a     ....QF.A........
    2dcc:	f000 f020 407f 0005 e006 f02a 407f f118     .. ..@....*..@..
    2ddc:	0101 4249 4108 0005 9800 2800 d502 202d     ..IB.A.....(..- 
    2dec:	7030 1c76 2c00 d103 2030 7030 1c76 e014     0pv..,..0 0pv...
    2dfc:	2c01 db05 0032 0020 17e1 f7ff feec e007     .,..2. .........
    2e0c:	202d 7030 1c76 0032 4260 17c1 f7ff fee3     - 0pv.2.`B......
    2e1c:	7830 2800 d001 1c76 e7fa 202e 7030 1c76     0x.(..v.... 0pv.
    2e2c:	2d00 d103 2030 7030 1c76 e023 ebb6 0009     .-..0 0pv.#.....
    2e3c:	ebbb 0000 1e40 0001 428f da01 0039 e7ff     ....@....B..9...
    2e4c:	2000 0002 428a da0a 200a 4345 0028 1600     . ...B... EC(...
    2e5c:	3030 7030 1c76 f025 457f 1c52 e7f2 1e76     000pv.%..ER...v.
    2e6c:	7830 2830 d105 f816 0c01 282e d001 1e76     0x0(.......(..v.
    2e7c:	e7f6 1c76 2000 7030 ebb6 0609 0030 b002     ..v.. 0p....0...
    2e8c:	ecbd 8b02 e8bd 8ff2 e92d 4ff8 ed2d 8b02     ........-..O-...
    2e9c:	b088 0004 4688 0017 2600 2000 9002 f898     .....F...&. ....
    2eac:	0000 2800 f000 81ed 2006 9005 f898 0000     ...(..... ......
    2ebc:	2825 d016 2c00 d010 f898 0000 280a d108     %(...,.......(..
    2ecc:	f8df 0408 7800 2800 d003 200d 7020 1c64     .....x.(...  pd.
    2edc:	1c76 f898 0000 7020 1c64 f118 0801 1c76     v..... pd.....v.
    2eec:	e7dd f118 0801 2000 f88d 0001 f89d 0001     ....... ........
    2efc:	f88d 0003 2020 f88d 0000 f898 0000 2830     ....  ........0(
    2f0c:	d104 2030 f88d 0000 f118 0801 a904 4640     ..0 ..........@F
    2f1c:	f7ff fe3d 0005 9804 4480 f898 0000 2873     ..=......D....s(
    2f2c:	d002 2d00 d500 426d f898 0000 282e d108     ...-..mB.....(..
    2f3c:	f118 0801 a904 4640 f7ff fe29 9005 9804     ......@F..).....
    2f4c:	4480 f898 0000 286c d10a f118 0801 f898     .D....l(........
    2f5c:	0000 286c d104 f118 0801 2001 f88d 0001     ..l(....... ....
    2f6c:	f898 0000 2846 f000 8153 2858 d067 2863     ....F(..S.X(g.c(
    2f7c:	d010 2864 f000 80d1 2866 f000 8149 2869     ..d(....f(..I.i(
    2f8c:	f000 80cb 2873 d011 2875 f000 8090 2878     ....s(..u(....x(
    2f9c:	d052 e16c 6838 1d3f f88d 0004 2c00 d003     R.l.8h?......,..
    2fac:	f89d 0004 7020 1c64 1c76 e167 6838 1d3f     .... pd.v.g.8h?.
    2fbc:	9003 9803 f7ff fe9a 9002 2d01 db14 9802     ...........-....
    2fcc:	42a8 d211 9802 1a2d 002a f89d 1000 0020     .B....-.*..... .
    2fdc:	f7ff fe98 0005 2c00 d001 0028 e000 2000     .......,..(.... 
    2fec:	4404 19ae 2000 0005 9803 7800 2800 d00a     .D... .....x.(..
    2ffc:	2c00 d003 9803 7800 7020 1c64 9803 1c40     .,.....x pd...@.
    300c:	9003 1c76 e7f0 2d00 d015 426d 9802 42a8     ..v....-..mB...B
    301c:	d211 9802 1a2d 002a f89d 1000 0020 f7ff     ....-.*..... ...
    302c:	fe71 0005 2c00 d001 0028 e000 2000 4404     q....,..(.... .D
    303c:	19ae 2000 0005 e121 2001 f88d 0003 f89d     ... ..!.. ......
    304c:	0001 2800 d008 1dff f037 0707 e9d7 0100     ...(....7.......
    305c:	3708 4682 468b e004 6838 1d3f 2100 4682     .7.F.F..8h?..!.F
    306c:	468b 2d00 d015 4650 4659 f7ff fd76 1a28     .F.-..PFYF..v.(.
    307c:	0005 002a f89d 1000 0020 f7ff fe43 0005     ..*..... ...C...
    308c:	2c00 d001 0028 e000 2000 4404 19ae 2000     .,..(.... .D... 
    309c:	0005 f89d 3003 0022 4650 4659 f7ff fdde     .....0".PFYF....
    30ac:	4681 2c00 d000 444c eb19 0606 e0e6 f89d     .F.,..LD........
    30bc:	0001 2800 d008 1dff f037 0707 e9d7 0100     ...(....7.......
    30cc:	3708 4682 468b e004 6838 1d3f 2100 4682     .7.F.F..8h?..!.F
    30dc:	468b 2d00 d015 4650 4659 f7ff fd14 1a28     .F.-..PFYF....(.
    30ec:	0005 002a f89d 1000 0020 f7ff fe0b 0005     ..*..... .......
    30fc:	2c00 d001 0028 e000 2000 4404 19ae 2000     .,..(.... .D... 
    310c:	0005 0022 4650 4659 f7ff fd65 4681 2c00     ..".PFYF..e..F.,
    311c:	d000 444c eb19 0606 e0b0 f89d 0001 2800     ..LD...........(
    312c:	d008 1dff f037 0707 e9d7 0100 3708 e9cd     ....7........7..
    313c:	0106 e004 6838 1d3f 17c1 e9cd 0106 e9dd     ....8h?.........
    314c:	0106 0002 000b 2000 2100 428b dc0d db01     ....... .!.B....
    315c:	4282 d20a e9dd 0106 4240 eb71 0141 4682     .B......@Bq.A..F
    316c:	468b 2001 f88d 0002 e006 e9dd 0106 4682     .F. ...........F
    317c:	468b 2000 f88d 0002 2d00 d033 4650 4659     .F. .....-3.PFYF
    318c:	f7ff fcdd 1a28 0005 f89d 0002 2800 d00a     ....(........(..
    319c:	1e6d f89d 0000 2830 d105 2c00 d002 202d     m.....0(...,..- 
    31ac:	7020 1c64 1c76 002a f89d 1000 0020 f7ff      pd.v.*..... ...
    31bc:	fda9 0005 2c00 d001 0028 e000 2000 4404     .....,..(.... .D
    31cc:	19ae 2000 0005 f89d 0002 2800 d014 f89d     ... .......(....
    31dc:	0000 2820 d110 2c00 d002 202d 7020 1c64     .. (...,..-  pd.
    31ec:	1c76 e009 f89d 0002 2800 d005 2c00 d002     v........(...,..
    31fc:	202d 7020 1c64 1c76 0022 4650 4659 f7ff     -  pd.v.".PFYF..
    320c:	fcea 4681 2c00 d000 444c eb19 0606 e035     ...F.,..LD....5.
    321c:	2c00 d02b 1dff f037 0707 ed97 0b00 3708     .,+...7........7
    322c:	ec51 0b10 f000 f85e ee08 0a10 2014 6020     Q.....^......  `
    323c:	9905 0020 eeb0 0a48 f7ff fd75 4681 f1b9     .. ...H...u..F..
    324c:	0f00 d510 f119 0f01 d102 4921 0008 e007     ..........!I....
    325c:	f119 0f02 d102 491f 0008 e001 491e 0008     .......I.....I..
    326c:	6020 2103 4689 eb19 0606 444c e006 2c00      `.!.F....LD...,
    327c:	d003 f898 0000 7020 1c64 1c76 f118 0801     ...... pd.v.....
    328c:	e60d 2c00 d001 2000 7020 0030 b008 ecbd     ...,...  p0.....
    329c:	8b02 e8bd 8ff2 b40e b578 0004 a805 0006     ........x.......
    32ac:	0032 0021 480d f7ff fdef 0005 480b 4906     2.!..H.......H.I
    32bc:	6809 4788 0028 bc72 f85d fb10 b580 4808     .h.G(.r.]......H
    32cc:	f7ff ffe9 bd01 0000 119c 1000 11a8 1000     ................
    32dc:	2e30 0030 2e23 0023 2e3f 003f 1084 1000     0.0.#.#.?.?.....
    32ec:	9bd4 0000 f001 4200 1a8b f1a3 5160 f5b1     .......B....`Q..
    32fc:	1f80 db0a f1b1 6f7f d21f ea42 02c1 00c1     .......o..B.....
    330c:	f171 4100 eb42 7050 4770 150b f1c3 0309     q..AB.PppG......
    331c:	2b21 d210 0289 ea41 5190 0280 2801 4149     !+....A..Q...(IA
    332c:	f041 4100 fa21 f003 f1c3 0320 4099 f171     A..A!..... ..@q.
    333c:	4100 4150 4770 0010 4770 f06f 0000 eb13     .APApG..pGo.....
    334c:	3f10 bf5c 0e00 ea42 50c0 4770 b418 7901     .?\...B..PpG...y
    335c:	0789 f140 808d 6801 2932 d25d f3ef 8110     ..@....h2)].....
    336c:	9100 b672 2173 f8df 2314 6011 2202 6801     ..r.s!...#.`.".h
    337c:	0089 f011 011c 408a 6803 085b f013 037c     .......@.h[...|.
    338c:	f8df 12fc 18cb 6819 2307 6804 00a4 f014     .......h.#.h....
    339c:	041c 40a3 4399 430a 6803 085b f013 037c     ...@.C.C.h[...|.
    33ac:	f8df 12dc 18cb 601a 2218 6801 00c9 f011     .......`.".h....
    33bc:	0118 408a 7803 f013 03fc f8df 12c8 18cb     ...@.x..........
    33cc:	6819 23ff 6804 00e4 f014 0418 40a3 4399     .h.#.h.......@.C
    33dc:	430a 7803 f013 03fc f8df 12a8 18cb 601a     .C.x...........`
    33ec:	7802 f012 02fc f8df 12a0 188a 6812 21ff     .x...........h.!
    33fc:	6803 00db f013 0318 4099 438a 7803 f013     .h.......@.C.x..
    340c:	03fc f8df 1284 18cb 601a 2100 f8df 226c     .........`.!..l"
    341c:	6011 9900 f381 8810 2201 7801 f011 011f     .`.......".x....
    342c:	408a 6803 08db f013 0304 f8df 1260 18cb     .@.h........`...
    343c:	601a 7901 07c9 d50d 2201 7801 f011 011f     .`.y.....".x....
    344c:	408a 6803 08db f013 0304 f8df 1244 18cb     .@.h........D...
    345c:	601a e08e 2201 7801 f011 011f 408a 6803     .`...".x.....@.h
    346c:	08db f013 0304 f8df 122c 18cb 601a e080     ........,....`..
    347c:	6801 2932 d255 f3ef 8110 9100 b672 2173     .h2)U.......r.s!
    348c:	4a7e 6011 2206 6801 0089 f011 011c 408a     ~J.`.".h.......@
    349c:	6803 085b f013 037c 4979 18cb 6819 2307     .h[...|.yI...h.#
    34ac:	6804 00a4 f014 041c 40a3 4399 430a 6803     .h.......@.C.C.h
    34bc:	085b f013 037c 4972 18cb 601a 2218 6801     [...|.rI...`.".h
    34cc:	00c9 f011 0118 408a 7803 f013 03fc 496d     .......@.x....mI
    34dc:	18cb 6819 23ff 6804 00e4 f014 0418 40a3     ...h.#.h.......@
    34ec:	4399 430a 7803 f013 03fc 4966 18cb 601a     .C.C.x....fI...`
    34fc:	7802 f012 02fc 4964 188a 6812 21ff 6803     .x....dI...h.!.h
    350c:	00db f013 0318 4099 438a 7803 f013 03fc     .......@.C.x....
    351c:	495d 18cb 601a 2100 4a58 6011 9900 f381     ]I...`.!XJ.`....
    352c:	8810 2201 7801 f011 011f 408a 6803 08db     ...".x.....@.h..
    353c:	f013 0304 4958 18cb 601a 7901 07c9 d50c     ....XI...`.y....
    354c:	2201 7801 f011 011f 408a 6803 08db f013     .".x.....@.h....
    355c:	0304 494f 18cb 601a e00b 2201 7801 f011     ..OI...`...".x..
    356c:	011f 408a 6803 08db f013 0304 4949 18cb     ...@.h......II..
    357c:	601a bc11 4770 0000 b570 0004 000d 2000     .`..pG..p...... 
    358c:	0006 42ae d205 eb04 00c6 f7ff fedf 1c76     ...B..........v.
    359c:	e7f7 bd70 b410 eb00 02c1 7912 0792 d522     ..p........y..".
    35ac:	eb00 02c1 7912 07d2 d50e f850 3031 08db     .....y....P.10..
    35bc:	f013 0304 4a36 18d3 2201 f810 4031 f014     ....6J..."..1@..
    35cc:	041f 40a2 601a e01c f850 3031 08db f013     ...@.`..P.10....
    35dc:	0304 4a30 18d3 2201 f810 4031 f014 041f     ..0J..."..1@....
    35ec:	40a2 601a e00d f850 3031 08db f013 0304     .@.`..P.10......
    35fc:	4a26 18d3 2201 f810 4031 f014 041f 40a2     &J..."..1@.....@
    360c:	601a bc10 4770 b410 eb00 02c1 7912 0792     .`..pG.......y..
    361c:	d522 eb00 02c1 7912 07d2 d40e f850 3031     "......y....P.10
    362c:	08db f013 0304 4a1a 18d3 2201 f810 4031     .......J..."..1@
    363c:	f014 041f 40a2 601a e01c f850 3031 08db     .....@.`..P.10..
    364c:	f013 0304 4a13 18d3 2201 f810 4031 f014     .....J..."..1@..
    365c:	041f 40a2 601a e00d f850 3031 08db f013     ...@.`..P.10....
    366c:	0304 4a0d 18d3 2201 f810 4031 f014 041f     ...J..."..1@....
    367c:	40a2 601a bc10 4770 0000 0000 0060 4001     .@.`..pG....`..@
    368c:	0040 4001 0000 4001 00e0 4001 00a8 4001     @..@...@...@...@
    369c:	0090 4001 0098 4001 00b4 4001 b5f8 0004     ...@...@...@....
    36ac:	000d 0016 2000 0007 42af d20e 0030 40f8     ..... ...B..0..@
    36bc:	07c0 d504 0039 0020 f7ff ff6c e003 0039     ....9. ...l...9.
    36cc:	0020 f7ff ffa0 1c7f e7ee bdf1 b430 f5b0      ...........0...
    36dc:	6f00 d127 f44f 6300 f44f 5080 2220 2140     .o'.O..cO..P "@!
    36ec:	4c8d 6825 ea25 0000 2b00 6020 f040 80a0     .L%h%....+ `@...
    36fc:	20c8 1e40 d013 4b88 685c 420c d1f9 2800     . @....K\h.B...(
    370c:	dd0d 20c8 2a00 f000 809c 1e40 d007 4982     ... .*....@....I
    371c:	684b 4013 4293 d1f8 2800 f300 8092 bc30     Kh.@.B...(....0.
    372c:	2000 4770 f5b0 5fc0 d103 f44f 53c0 2260     . pG..._..O..S`"
    373c:	e07d 2801 d106 2301 f240 70fe f44f 7280     }..(...#@..pO..r
    374c:	4976 e7cd 2803 d106 2303 f240 70fc f44f     vI...(...#@..pO.
    375c:	7240 4973 e7c4 2807 d107 2307 f44f 60ff     @rsI...(...#O..`
    376c:	f44f 62e0 f44f 21ff e7ba 280f d107 230f     O..bO..!...(...#
    377c:	f44f 60fe f44f 6270 f44f 21fe e7b0 281f     O..`O.pbO..!...(
    378c:	d107 231f f44f 60fc f44f 52f8 f44f 21fc     ...#O..`O..RO..!
    379c:	e7a6 283f d107 233f f44f 60f8 f44f 527c     ..?(..?#O..`O.|R
    37ac:	f44f 21f8 e79c 287f d107 237f f44f 60f0     O..!...(...#O..`
    37bc:	f44f 42fe f44f 21f0 e792 28ff d107 23ff     O..BO..!...(...#
    37cc:	f44f 60e0 f44f 427f f44f 21e0 e788 f240     O..`O..BO..!..@.
    37dc:	13ff 4298 d105 f44f 60c0 4a52 f44f 21c0     ...B..O..`RJO..!
    37ec:	e77e f240 33ff 4298 d105 f44f 6080 4a4e     ~.@..3.B..O..`NJ
    37fc:	f44f 2180 e774 f240 73ff 4298 d016 f1b0     O..!t.@..s.B....
    380c:	4f20 d104 f04f 4320 f44f 1220 e00f f06f      O..O. CO. ...o.
    381c:	4120 4288 d106 2300 f04f 4020 2200 f44f      A.B...#O. @."O.
    382c:	1120 e75d 4b41 4298 f47f af79 4a40 2100      .].AK.B..y.@J.!
    383c:	4c39 6820 4303 20c8 2900 6023 f43f af61     9L h.C. .)#`?.a.
    384c:	e757 bc30 2001 4770 493a 6848 f3c0 0040     W.0.. pG:IHh..@.
    385c:	b110 6848 07c2 d40c 680a f042 0202 600a     ..Hh.....hB....`
    386c:	6808 f040 0001 6008 684a f002 0203 2a03     .h@....`Jh.....*
    387c:	d1fa 6848 f000 0003 2803 d1fa 2042 f000     ..Hh.....(..B ..
    388c:	b85d 492c 6848 f3c0 0040 b110 6848 07c2     ].,IHh..@...Hh..
    389c:	d40c 680a f042 0202 600a 6808 f040 0001     ...hB....`.h@...
    38ac:	6008 684a f002 0203 2a03 d1fa 4770 4922     .`Jh.....*..pG"I
    38bc:	f8d1 0ff8 f3c0 0040 b918 f8d1 0ff8 07c2     ......@.........
    38cc:	d51f 680a f002 02f0 2a20 bf04 f8d1 0ffc     ...h.... *......
    38dc:	f5b0 7f00 d106 f8d1 2ff4 f002 0205 f8c1     ........./......
    38ec:	2ff4 e00b f8d1 0ff4 f020 0002 f8c1 0ff4     ./...... .......
    38fc:	f8d1 0ff4 0840 0040 f8c1 0ff4 200a f000     ....@.@...... ..
    390c:	b81d 4770 480b 6981 f041 0106 6181 6802     ..pG.H.iA....a.h
    391c:	f022 0204 6002 4770 1010 4002 fe00 0007     "....`pG...@....
    392c:	fc00 0007 ff00 0001 ff00 0003 1fff a000     ................
    393c:	ff00 0007 1000 4002 000c 4002 f8df 1004     .......@...@....
    394c:	6b4a 4710 100c 1000 b081 684a 688b 6809     Jk.G......Jh.h.h
    395c:	ea42 4203 2900 bf18 f052 4200 f3ef 8110     B..B.)..R..B....
    396c:	9100 b672 f8df 117c eb01 1100 f8df 0174     ..r...|.......t.
    397c:	600a f8d0 10f4 f001 010f 2901 bf18 2902     .`.........)...)
    398c:	d036 6801 f3c1 0244 1e52 2a04 bf82 f3c1     6..h..D.R..*....
    399c:	4144 1e49 2904 d92b 6901 f3c1 0244 1e52     DAI..)+..i..D.R.
    39ac:	2a04 bf82 f3c1 4144 1e49 2904 d920 6a01     .*....DAI..) ..j
    39bc:	f3c1 0244 1e52 2a04 bf82 f3c1 4144 1e49     ..D.R..*....DAI.
    39cc:	2904 d915 6b00 f3c0 0144 1e49 2904 bf82     .)...k..D.I..)..
    39dc:	f3c0 4044 1e40 2804 d90a f8df 010c 6801     ..D@@..(.......h
    39ec:	f041 0104 6001 9800 f380 8810 b001 4770     A....`........pG
    39fc:	f8df 00f4 6802 f022 0204 6002 9800 f380     .....h"....`....
    3a0c:	8810 b001 4770 0000 4a36 b081 eb12 1200     ....pG..6J......
    3a1c:	f3ef 8010 9000 b672 6813 f001 2008 4383     ......r..h... .C
    3a2c:	f001 1101 4319 6011 9800 f380 8810 b001     .....C.`........
    3a3c:	4770 0000 4a2b b081 eb12 1200 f3ef 8010     pG..+J..........
    3a4c:	9000 b672 6810 f001 2108 4301 6011 9800     ..r..h...!.C.`..
    3a5c:	f380 8810 b001 4770 b4f0 b081 4d24 4e25     ......pG....$M%N
    3a6c:	eb05 1500 f3ef 8410 eb16 1600 9400 b672     ..............r.
    3a7c:	4c1c eb04 1000 4c1d 6800 42a1 bf08 0c00     .L.....L.h.B....
    3a8c:	f400 70e0 2880 bf17 28c0 1ad3 4613 2200     ...p.(...(...F."
    3a9c:	f64f 77ff eac3 4002 42b9 bf08 6028 d009     O..w...@.B..(`..
    3aac:	42a1 bf08 6030 d005 0c12 0412 6028 ea42     .B..0`......(`B.
    3abc:	4213 6032 9800 f380 8810 b001 bcf0 4770     .B2`..........pG
    3acc:	b081 f3ef 8110 9100 b672 490b 680a 4310     ........r..I.h.C
    3adc:	6008 9800 f380 8810 b001 4770 4907 6008     .`........pG.I.`
    3aec:	4770 0000 800c 4000 1020 4002 0000 ffff     pG.....@ ..@....
    3afc:	8004 4000 8008 4000 8200 4000 8208 4000     ...@...@...@...@
    3b0c:	b470 b081 f3ef 8310 9300 b672 4b51 681c     p.........r.QK.h
    3b1c:	681d 0796 f3c4 0483 f3c5 3543 d503 494e     .h........C5..NI
    3b2c:	6808 6849 e001 07d6 d513 06d6 d507 681e     .hIh...........h
    3b3c:	0080 f000 003c f026 063c 4330 6018 0690     ....<.&.<.0C.`..
    3b4c:	d507 6818 0349 f401 31f0 f420 30f0 4301     ...hI....1 ..0.C
    3b5c:	6019 0751 d507 06d0 bf44 483f 6004 0690     .`Q.....D.?H.`..
    3b6c:	bf44 483d 6045 9800 f380 8810 b001 bc70     D.=HE`........p.
    3b7c:	4770 0000 b570 b082 4604 f000 f8a1 2c01     pG..p....F.....,
    3b8c:	4605 d15a 4835 f8d0 1244 07ca d455 4934     .FZ.5H..D...U.4I
    3b9c:	4e34 680a f042 0204 600a 6801 6872 f001     4N.hB....`.hrh..
    3bac:	01f0 2920 bf0c 2102 2100 1e52 2a04 f8d0     .. )...!.!R..*..
    3bbc:	2ff4 f8d0 0ffc bf38 f041 0104 f012 0f03     ./....8.A.......
    3bcc:	bf18 f041 0101 f240 52ff 4210 bf08 f041     ..A...@..R.B..A.
    3bdc:	0108 290f d112 6870 1e40 9000 f04f 31ff     ...)..ph@...O..1
    3bec:	9800 f7ff ff27 9800 2300 f04f 1201 f04f     ....'....#O...O.
    3bfc:	31ff f7ff ff31 f7ff fe5a e000 2400 bf30     .1..1...Z....$0.
    3c0c:	b1c4 2231 2107 2007 f7ff ff7a 201c f7ff     ..1".!. ..z.. ..
    3c1c:	fe95 f7ff fe36 6870 1e40 9000 2100 7031     ....6.ph@....!1p
    3c2c:	60b1 204c f7ff fe8a 9800 f04f 31ff f7ff     .`L ......O..1..
    3c3c:	feeb e008 2001 7030 e005 4909 6808 f030     ..... 0p...I.h0.
    3c4c:	0004 6008 bf30 4628 b002 e8bd 4070 f000     ...`0.(F....p@..
    3c5c:	b83d 0000 0068 4002 1194 1000 000c 4002     =...h..@.......@
    3c6c:	ed10 e000 1184 1000 2810 d307 3810 2101     .........(...8.!
    3c7c:	f000 001f 4a0e 4081 6011 4770 2804 d00f     .....J.@.`pG.(..
    3c8c:	d315 2806 d006 d212 4809 f8d0 1c24 f441     ...(.....H..$.A.
    3c9c:	3100 e00a 4806 f8d0 1c24 f441 2180 e004     .1...H..$.A..!..
    3cac:	4803 f8d0 1c24 f441 3180 f8c0 1c24 4770     .H..$.A..1..$.pG
    3cbc:	e100 e000 f3ef 8010 b662 4770 4770 0000     ........b.pGpG..
    3ccc:	f3ef 8010 b672 4770 4770 0000 f380 8810     ....r.pGpG......
    3cdc:	4770 4770 b510 2002 f000 f8af f64f 71ff     pGpG... ....O..q
    3cec:	2000 f7ff fea7 493b 2000 f7ff fe2d 2008     . ....;I. ..-.. 
    3cfc:	0004 0023 085b 0022 f64f 71ff 2000 f7ff     ..#.[.".O..q. ..
    3d0c:	feab 2001 f7ff feea bd10 b580 2001 f7ff     ... ......... ..
    3d1c:	fee5 4831 6800 1c40 492f 6008 2820 d302     ..1H.h@./I.` (..
    3d2c:	2000 492d 6008 bd01 b580 2000 f000 f866     . -I.`..... ..f.
    3d3c:	482a f000 f8db f000 f937 4829 f7fe fe72     *H......7.)H..r.
    3d4c:	f3ef 8010 9000 b672 2073 4926 6008 4826     ......r.s &I.`&H
    3d5c:	6800 f030 0070 4924 6008 4824 6800 f430     .h0.p.$I.`$H.h0.
    3d6c:	407f f450 5080 4921 6008 4821 6800 f430     .@P..P!I.`!H.h0.
    3d7c:	407f 491f 6008 2000 491a 6008 9800 f380     .@.I.`. .I.`....
    3d8c:	8810 2105 481b f7ff fbf7 f000 f996 f000     ...!.H..........
    3d9c:	f91f f7ff fa93 4818 f7ff fa7d f7ff ff9a     .......H..}.....
    3dac:	2001 f7ff fe8d 201d f7ff ff5e f7ff ff82     . ..... ..^.....
    3dbc:	f64f 71ff 2000 f7ff fe27 f000 f937 2001     O..q. ..'...7.. 
    3dcc:	f7ff fed8 4804 6802 2105 480a f7ff fc66     .....H.h.!.H..f.
    3ddc:	e7f5 0000 1000 1000 11a0 1000 9be8 0000     ................
    3dec:	9739 0000 0060 4001 0054 4001 0028 4001     9...`..@T..@(..@
    3dfc:	0108 4001 105c 1000 9bbc 0000 b510 0004     ...@\...........
    3e0c:	d006 f20f 02b0 f20f 005c 2150 f000 f9af     ........\.P!....
    3e1c:	480f 2147 6001 6044 2100 6001 bd10 480d     .HG!.`D`.!.`...H
    3e2c:	6800 f010 0001 d004 2801 d004 f04f 30ff     .h.......(..O..0
    3e3c:	4770 4809 4770 4809 4770 4909 680a ea22     pG.HpG.HpG.I.h".
    3e4c:	0000 6008 4770 4906 680a 4310 6008 4770     ...`pG.I.h.C.`pG
    3e5c:	4014 4000 4018 4000 6c00 02dc 3600 016e     .@.@.@.@.l...6n.
    3e6c:	400c 4000 3a43 6a5c 7376 615c 626d 7169     .@.@C:\jvs\ambiq
    3e7c:	775c 726f 5c6b 6574 7473 6e69 5c67 6552     \work\testing\Re
    3e8c:	2d6c 2e31 2e32 5c39 6d41 6962 5371 6975     l-1.2.9\AmbiqSui
    3e9c:	6574 6d5c 7563 615c 6f70 6c6c 326f 685c     te\mcu\apollo2\h
    3eac:	6c61 615c 5f6d 6168 5f6c 6c63 676b 6e65     al\am_hal_clkgen
    3ebc:	632e 0000 6d61 685f 6c61 635f 6b6c 6567     .c..am_hal_clkge
    3ecc:	5f6e 7973 6373 6b6c 735f 6c65 6365 2874     n_sysclk_select(
    3edc:	3a29 6920 766e 6c61 6469 6320 6f6c 6b63     ): invalid clock
    3eec:	7320 7465 6974 676e 002e 0000 b530 4605      setting....0..F
    3efc:	b081 78ac 7868 0040 00a1 0864 f000 0002     ...xhx@...d.....
    3f0c:	f001 0104 00e4 4308 f004 0408 4304 78e8     .......C.....C.x
    3f1c:	4304 7928 01c0 f000 0080 4304 79a8 0280     .C(y.......C.y..
    3f2c:	f400 6080 4304 79e8 02c0 f400 6000 4304     ...`.C.y.....`.C
    3f3c:	7a28 0300 f400 4070 4304 7a68 0400 f400     (z....p@.Chz....
    3f4c:	2070 4304 7aa8 0500 f400 1080 4304 7ae8     p .C.z.......C.z
    3f5c:	0600 f000 7080 4304 f04f 4020 f7ff fbb6     .....p.CO. @....
    3f6c:	4910 f044 0401 600c 2032 688a 0753 d401     .ID....`2 .hS...
    3f7c:	1e40 d1fa 6888 f040 0001 6088 2032 688a     @....h@....`2 .h
    3f8c:	0753 d401 1e40 d1fa 7968 0202 0840 f402     S...@...hy..@...
    3f9c:	7280 0240 4314 f400 7000 4304 600c b001     .r@..C...p.C.`..
    3fac:	bd30 0000 8000 4001 b500 b081 f7ff fc4c     0......@......L.
    3fbc:	f7ff fca8 f000 f8dc 2001 f000 f8df 2001     ......... ..... 
    3fcc:	f7ff ff41 b001 f85d eb04 f000 b8e4 0000     ..A...].........
    3fdc:	482d 6801 07ca d500 4770 b500 492b 482c     -H.h....pG..+I,H
    3fec:	b087 6008 a801 492b 9101 f000 f8df f3ef     ...`..+I........
    3ffc:	8010 9000 b672 4828 2173 6381 6ac1 f021     ....r.(Hs!.c.j!.
    400c:	0170 62c1 6802 f422 427f f442 5280 6002     p..b.h"..BB..R.`
    401c:	2200 f8d0 10e0 f421 417f f8c0 10e0 6382     ."....!..A.....c
    402c:	9800 f380 8810 b007 bd00 0000 b500 4816     ...............H
    403c:	b081 6801 07ca d424 f000 f858 f3ef 8010     ...h..$...X.....
    404c:	9000 b672 4814 2173 6381 2200 6ac1 f021     ..r..Hs!.c.".j!.
    405c:	0170 f041 0120 62c1 6801 f421 417f f441     p.A. ..b.h!..AA.
    406c:	51c0 6001 f8d0 10e0 f421 417f f8c0 10e0     .Q.`....!..A....
    407c:	6382 9800 f380 8810 b001 f85d eb04 f000     .c........].....
    408c:	b8d2 b001 bd00 0000 11a4 1000 0e80 e000     ................
    409c:	0511 0015 4240 000f 0028 4001 f000 b848     ....@B..(..@..H.
    40ac:	b510 4604 f7ff febb 4a1a fba0 2102 0d48     ...F.....J...!H.
    40bc:	4360 e8bd 4010 f7ff bc41 4817 6801 07ca     `C...@..A..H.h..
    40cc:	d413 4816 6801 f041 7180 6001 6802 01d1     ...H.hA..q.`.h..
    40dc:	d5fc 4813 4913 f8c0 11b0 210f 6401 f04f     ...H.I.....!.dO.
    40ec:	31ff 6001 4910 f8c0 1080 4770 b500 b081     .1.`.I....pG....
    40fc:	480e 6801 020a d4fc f7ff fe91 4b05 fba0     .H.h.........K..
    410c:	3203 b001 0d50 2132 f85d eb04 fb11 f000     .2..P.2!].......
    411c:	f7ff bc14 fc08 b2f4 11a4 1000 edfc e000     ................
    412c:	0e00 e000 ce55 c5ac 0511 0015 0e80 e000     ....U...........
    413c:	7801 2200 b1d1 1c52 5c83 b153 1c52 5c81     .x."..R..\S.R..\
    414c:	b139 1c52 5c83 2b00 d003 1c52 5c81 2900     9.R..\.+..R..\.)
    415c:	d1f1 b15a f04f 4360 f890 c000 6819 2900     ..Z.O.`C.....h.)
    416c:	d0fc 1c40 1e52 f883 c000 d1f5 4770 e7fe     ..@.R.......pG..
    417c:	4901 2037 6008 4770 c008 4000 f8df 1024     .I7 .`pG...@..$.
    418c:	b120 6808 f040 0080 6008 4770 680a f022      ..h@....`pG.h".
    419c:	0280 600a 4770 f8df 0010 6801 f041 0110     ...`pG.....hA...
    41ac:	6001 4770 400c 4000 4050 4000 b530 b081     .`pG.@.@P@.@0...
    41bc:	6804 4d20 2100 f8c5 1300 b1fc 2001 6028     .h M.!....... (`
    41cc:	f5a4 4061 491c 4288 bf28 4c1c f7ff fe27     ..a@.I.B(..L..'.
    41dc:	f110 0f01 d005 08c0 fbb0 f0f4 1e40 b280     ............@...
    41ec:	e000 2005 60e8 2002 f8c5 00ec 2000 f8c5     ... .`. ..... ..
    41fc:	0efc f240 2001 490e 6008 e00e 6901 60e9     ..@.. .I.`...i.`
    420c:	2201 6881 f8c5 10ec 68c3 1e59 408a 602a     .".h.....hY..@*`
    421c:	4907 680a 6840 4302 600a b001 e8bd 4030     .I.h@h.C.`....0@
    422c:	2032 f7ff bf3d 4902 2000 6008 4770 0000     2 ..=..I. .`pG..
    423c:	0250 4002 0004 e004 a381 001d 4240 000f     P..@........@B..
    424c:	b580 4668 3008 f000 f808 bd01 4770 0000     ..hF.0......pG..
    425c:	0080 1840 6800 4770 4770 b530 b093 0004     ..@..hpGpG0.....
    426c:	a80c 2118 f000 f852 2500 950a 4825 6800     ...!..R..%..%H.h
    427c:	900a 980a f88d 002c 980a 0a00 f88d 002d     ......,.......-.
    428c:	980a 0c00 f8ad 002e 481f 6800 9009 f89d     .........H.h....
    429c:	002d 0780 d504 0021 2006 f7ff ffd9 e001     -.....!.. ......
    42ac:	f05f 30ff 9008 0021 2000 f7ff ffd1 9000     _..0..!.. ......
    42bc:	0021 2001 f7ff ffcc 9001 0021 2002 f7ff     !.. ......!.. ..
    42cc:	ffc7 9002 0021 2003 f7ff ffc2 9003 0021     ....!.. ......!.
    42dc:	2004 f7ff ffbd 9004 0021 2005 f7ff ffb8     . ......!.. ....
    42ec:	9005 0021 2006 f7ff ffb3 9006 0021 2007     ..!.. ......!.. 
    42fc:	f7ff ffae 9007 a80c f000 f80c 2000 0005     ............. ..
    430c:	e7fe 0000 ed28 e000 ed38 e000 2200 f000     ....(...8...."..
    431c:	b81b 0000 4a0b 68d1 f001 0301 7003 084b     .....J.h.....pK.
    432c:	0889 f001 0101 f003 0301 7401 7203 6851     ...........t.rQh
    433c:	6843 60c1 6811 430b 6043 6943 6891 430b     Ch.`.h.CC`Ci.h.C
    434c:	6143 4770 01c0 4002 b500 bf00 0013 4696     CapG...@.......F
    435c:	4694 3910 bf28 e8a0 500c d8fa ea5f 7c41     .F.9(....P.._.A|
    436c:	bf28 c00c bf48 f840 2b04 07c9 bf28 f820     (...H.@..+..(. .
    437c:	2b02 bf48 f800 2b01 bd00 0000 0000 0000     .+H....+........
    438c:	0256 0000 0000 0000 004d 0800 0051 0800     V.......M...Q...
    439c:	0055 0800 0059 0800 006d 0800 0071 0800     U...Y...m...q...
    43ac:	007d 0800 0081 0800 0089 0800 0091 0800     }...............
    43bc:	0099 0800 0075 0800 0079 0800 009d 0800     ....u...y.......
    43cc:	005d 0800 0061 0800 0065 0800 0069 0800     ]...a...e...i...
    43dc:	0085 0800 008d 0800 0011 0000 0003 0000     ................
    43ec:	000e 0000 0003 0000 000f 0000 0003 0000     ................
    43fc:	001e 0000 0003 0000 000a 0000 0003 0000     ................
    440c:	e019 f850 2b04 07d3 bf44 f1a9 0301 189a     ..P..+..D.......
    441c:	1f09 2300 2904 f842 3b04 d2f9 ea5f 7c81     ...#.)B..;.._..|
    442c:	4613 d504 f04f 0c00 f8a2 c000 1c9b 07c9     .F..O...........
    443c:	bf44 2100 7019 f850 1b04 2900 d1e1 4770     D..!.pP....)..pG
    444c:	b410 f850 1b04 b179 6802 6843 4402 3008     ..P...y..hCh.D.0
    445c:	07dc bf44 f1a9 0401 18e3 f852 4b04 f843     ..D.......R..KC.
    446c:	4b04 1f09 d1f9 e7ec bc10 4770 b510 4907     .K........pG...I
    447c:	4479 3118 4c06 447c 3416 e004 680a 1d08     yD.1.L|D.4...h..
    448c:	4411 4788 4601 42a1 d1f8 bd10 002c 0000     .D.G.F.B....,...
    449c:	004c 0000 f64e 5188 f2ce 0100 6808 f440     L...N..Q.....h@.
    44ac:	0070 6008 f3bf 8f4f f3bf 8f6f f04f 7000     p..`..O...o.O..p
    44bc:	eee1 0a10 4770 0000 ff49 ffff 0128 0000     ....pG..I...(...
    44cc:	1084 1000 0000 0000 ff79 ffff 0084 0000     ........y.......
    44dc:	feac ffff 1000 1000 0000 0000 f000 f80b     ................
    44ec:	2800 d001 f7ff ffc2 2000 f3af 8000 f7ff     .(....... ......
    44fc:	fc1b f000 f802 2001 4770 f000 b801 0000     ....... pG......
    450c:	4607 4638 f000 f802 e7fb 0000 b580 f3af     .F8F............
    451c:	8000 4a02 0011 2018 beab e7fb 0026 0002     ...J... ....&...
    452c:	6942 616e 7972 4320 756f 746e 7265 4520     Binary Counter E
    453c:	6178 706d 656c 000a 0a0a 0a0a 0a0a 0a0a     xample..........
    454c:	0a0a 0a0a 0a0a 0a0a 0a0a 0000 0001 5000     ...............P
    455c:	0300 0001 0101 0001 f3af 8000 f7ff ff9a     ................
    456c:	f7ff ffbc f7ff fff8 4770 e7fe e7fe 0000     ........pG......

0000457c <g_sIOMConfig>:
    457c:	0001 0000 86a0 0001 0000 3c04               ...........<

00004588 <g_SPIpins>:
    4588:	0006 0000 000a 0000 0009 0000 000a 0000     ................
    4598:	0019 0000 002a 0000 002b 0000 002a 0000     ....*...+...*...
    45a8:	0028 0000 002a 0000 0031 0000 002a 0000     (...*...1...*...

000045b8 <am_hal_cachectrl_defaults>:
    45b8:	0001 5000 0300 0001 0101 0001 6d61 685f     ...P........am_h
    45c8:	6c61 635f 6b6c 6567 5f6e 7973 6373 6b6c     al_clkgen_sysclk
    45d8:	735f 6c65 6365 2874 3a29 6920 766e 6c61     _select(): inval
    45e8:	6469 6320 6f6c 6b63 7320 7465 6974 676e     id clock setting
    45f8:	002e 0000 2e2e 2e5c 5c2e 6d61 685f 6c61     ......\..\am_hal
    4608:	635f 6b6c 6567 2e6e 0063 0000 6854 2065     _clkgen.c...The 
    4618:	6966 6f66 6320 756f 646c 276e 2074 6966     fifo couldn't fi
    4628:	2074 6874 2065 6572 7571 7365 6574 2064     t the requested 
    4638:	756e 626d 7265 6f20 2066 7962 6574 0073     number of bytes.
    4648:	2e2e 2e5c 5c2e 6d61 685f 6c61 695f 6d6f     ..\..\am_hal_iom
    4658:	632e 0000 7254 6979 676e 7420 206f 6e65     .c..Trying to en
    4668:	6261 656c 6120 206e 4f49 204d 6f6d 7564     able an IOM modu
    4678:	656c 7420 6168 2074 6f64 7365 276e 2074     le that doesn't 
    4688:	7865 7369 2e74 0000 7254 6979 676e 7420     exist...Trying t
    4698:	206f 6964 6173 6c62 2065 6e61 4920 4d4f     o disable an IOM
    46a8:	6d20 646f 6c75 2065 6874 7461 6420 656f      module that doe
    46b8:	6e73 7427 6520 6978 7473 002e 5053 2049     sn't exist..SPI 
    46c8:	7274 6e61 6673 7265 7420 6f6f 6220 6769     transfer too big
    46d8:	002e 0000 6e49 6176 696c 2064 6948 4620     ....Invalid Hi F
    46e8:	6572 7571 6e65 7963 6620 726f 4920 4d4f     requency for IOM
    46f8:	002e 0000 7254 6979 676e 7420 206f 6f64     ....Trying to do
    4708:	6120 3020 6220 7479 2065 7274 6e61 6173      a 0 byte transa
    4718:	7463 6f69 006e 0000 6854 2065 6966 6f66     ction...The fifo
    4728:	6420 656f 6e73 7427 6320 6e6f 6174 6e69      doesn't contain
    4738:	7420 6568 7220 7165 6575 7473 6465 6e20      the requested n
    4748:	6d75 6562 2072 666f 6220 7479 7365 002e     umber of bytes..
    4758:	6143 6e6e 746f 6520 616e 6c62 2065 6f6d     Cannot enable mo
    4768:	6572 7420 6168 206e 6e6f 2065 6570 6972     re than one peri
    4778:	6870 7265 6c61 6120 2074 2061 6974 656d     pheral at a time
    4788:	002e 0000 2e2e 2e5c 5c2e 6d61 685f 6c61     ......\..\am_hal
    4798:	705f 7277 7463 6c72 632e 0000               _pwrctrl.c..
